
target/vmlinux.img：     文件格式 elf64-littleriscv


Disassembly of section .text:

0000000080200000 <_start>:
    80200000:	00050293          	mv	t0,a0
    80200004:	00128293          	addi	t0,t0,1
    80200008:	01029293          	slli	t0,t0,0x10
    8020000c:	001af117          	auipc	sp,0x1af
    80200010:	ff410113          	addi	sp,sp,-12 # 803af000 <_stack>
    80200014:	00510133          	add	sp,sp,t0
    80200018:	008000ef          	jal	ra,80200020 <main>

000000008020001c <loop>:
    8020001c:	0000006f          	j	8020001c <loop>

0000000080200020 <main>:
    asm volatile("mv tp, %0" : : "r" (hartId & 0x7));
}

extern struct superblock *fat;

void main(u64 hartId) {
    80200020:	fd010113          	addi	sp,sp,-48
    80200024:	02113423          	sd	ra,40(sp)
    80200028:	02813023          	sd	s0,32(sp)
    8020002c:	00913c23          	sd	s1,24(sp)
    80200030:	03010413          	addi	s0,sp,48
    80200034:	00050493          	mv	s1,a0
    asm volatile("mv tp, %0" : : "r" (hartId & 0x7));
    80200038:	00757793          	andi	a5,a0,7
    8020003c:	00078213          	mv	tp,a5
    initHartId(hartId);

    if (mainCount == 1000) {
    80200040:	001ff697          	auipc	a3,0x1ff
    80200044:	fc06a683          	lw	a3,-64(a3) # 803ff000 <mainCount>
    80200048:	3e800793          	li	a5,1000
        // PROCESS_CREATE_PRIORITY(WaitTest, 1);
        // PROCESS_CREATE_PRIORITY(MuslLibcTest, 1);
        PROCESS_CREATE_PRIORITY(BusyboxTest, 1);

    } else {
        while (initFinish == 0);
    8020004c:	00200717          	auipc	a4,0x200
    80200050:	fb470713          	addi	a4,a4,-76 # 80400000 <initFinish>
    if (mainCount == 1000) {
    80200054:	02f68e63          	beq	a3,a5,80200090 <main+0x70>
        while (initFinish == 0);
    80200058:	00072783          	lw	a5,0(a4)
    8020005c:	0007879b          	sext.w	a5,a5
    80200060:	fe078ce3          	beqz	a5,80200058 <main+0x38>
        __sync_synchronize();
    80200064:	0ff0000f          	fence

        printf("Hello, risc-v!\nCurrent hartId: %ld \n\n", hartId);
    80200068:	00048593          	mv	a1,s1
    8020006c:	00015517          	auipc	a0,0x15
    80200070:	fbc50513          	addi	a0,a0,-68 # 80215028 <textEnd+0x28>
    80200074:	00001097          	auipc	ra,0x1
    80200078:	ddc080e7          	jalr	-548(ra) # 80200e50 <printf>

        startPage();
    8020007c:	00009097          	auipc	ra,0x9
    80200080:	810080e7          	jalr	-2032(ra) # 8020888c <startPage>
        trapInit();
    80200084:	0000e097          	auipc	ra,0xe
    80200088:	3ec080e7          	jalr	1004(ra) # 8020e470 <trapInit>

        
        //PROCESS_CREATE_PRIORITY(ForkTest, 1);
        //PROCESS_CREATE_PRIORITY(ProcessB, 3);
        //printf("Reach this place\n");
        for(;;);
    8020008c:	0000006f          	j	8020008c <main+0x6c>
        for (u64 *i = bssStart; i < bssEnd; i++) {
    80200090:	00200717          	auipc	a4,0x200
    80200094:	f7070713          	addi	a4,a4,-144 # 80400000 <initFinish>
    80200098:	02170797          	auipc	a5,0x2170
    8020009c:	f6878793          	addi	a5,a5,-152 # 82370000 <bssEnd>
    802000a0:	02f77663          	bgeu	a4,a5,802000cc <main+0xac>
    802000a4:	00070793          	mv	a5,a4
    802000a8:	02170717          	auipc	a4,0x2170
    802000ac:	f5770713          	addi	a4,a4,-169 # 8236ffff <_pgdir+0xfff>
    802000b0:	40f70733          	sub	a4,a4,a5
    802000b4:	ff877713          	andi	a4,a4,-8
    802000b8:	00870713          	addi	a4,a4,8
    802000bc:	00f70733          	add	a4,a4,a5
            *i = 0;
    802000c0:	0007b023          	sd	zero,0(a5)
        for (u64 *i = bssStart; i < bssEnd; i++) {
    802000c4:	00878793          	addi	a5,a5,8
    802000c8:	fee79ce3          	bne	a5,a4,802000c0 <main+0xa0>
        mainCount = mainCount + 1;
    802000cc:	001ff797          	auipc	a5,0x1ff
    802000d0:	f347a783          	lw	a5,-204(a5) # 803ff000 <mainCount>
    802000d4:	0017879b          	addiw	a5,a5,1
    802000d8:	001ff717          	auipc	a4,0x1ff
    802000dc:	f2f72423          	sw	a5,-216(a4) # 803ff000 <mainCount>
        consoleInit();
    802000e0:	00000097          	auipc	ra,0x0
    802000e4:	3bc080e7          	jalr	956(ra) # 8020049c <consoleInit>
        printLockInit();
    802000e8:	00000097          	auipc	ra,0x0
    802000ec:	40c080e7          	jalr	1036(ra) # 802004f4 <printLockInit>
        pageLockInit();
    802000f0:	00009097          	auipc	ra,0x9
    802000f4:	d40080e7          	jalr	-704(ra) # 80208e30 <pageLockInit>
        printf("Hello, risc-v!\nBoot hartId: %ld \n\n", hartId);
    802000f8:	00048593          	mv	a1,s1
    802000fc:	00015517          	auipc	a0,0x15
    80200100:	f0450513          	addi	a0,a0,-252 # 80215000 <textEnd>
    80200104:	00001097          	auipc	ra,0x1
    80200108:	d4c080e7          	jalr	-692(ra) # 80200e50 <printf>
        memoryInit();
    8020010c:	00008097          	auipc	ra,0x8
    80200110:	7b8080e7          	jalr	1976(ra) # 802088c4 <memoryInit>
        processInit();
    80200114:	00010097          	auipc	ra,0x10
    80200118:	94c080e7          	jalr	-1716(ra) # 8020fa60 <processInit>
        sdInit();
    8020011c:	00001097          	auipc	ra,0x1
    80200120:	5fc080e7          	jalr	1532(ra) # 80201718 <sdInit>
        binit();
    80200124:	00002097          	auipc	ra,0x2
    80200128:	aa0080e7          	jalr	-1376(ra) # 80201bc4 <binit>
        fileinit();
    8020012c:	00004097          	auipc	ra,0x4
    80200130:	d0c080e7          	jalr	-756(ra) # 80203e38 <fileinit>
        signalInit();
    80200134:	0000a097          	auipc	ra,0xa
    80200138:	110080e7          	jalr	272(ra) # 8020a244 <signalInit>
    8020013c:	00100793          	li	a5,1
                unsigned long mask = 1 << i;
    80200140:	00100f93          	li	t6,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    return a0;
}

inline void setMode(int hartId) {
	register u64 a7 asm ("a7") = 0x48534D;
    80200144:	00485eb7          	lui	t4,0x485
    80200148:	34de8e93          	addi	t4,t4,845 # 48534d <_start-0x7fd7acb3>
	register u64 a0 asm ("a0") = hartId;
	register u64 a1 asm ("a1") = 0x80200000;
    8020014c:	40100e13          	li	t3,1025
    80200150:	015e1e13          	slli	t3,t3,0x15
	register u64 a2 asm ("a2") = 19260817; // priv
    80200154:	0125e337          	lui	t1,0x125e
    80200158:	59130313          	addi	t1,t1,1425 # 125e591 <_start-0x7efa1a6f>
        for (int i = 1; i < 5; ++ i) {
    8020015c:	00500f13          	li	t5,5
    80200160:	00c0006f          	j	8020016c <main+0x14c>
    80200164:	00178793          	addi	a5,a5,1
    80200168:	05e78463          	beq	a5,t5,802001b0 <main+0x190>
    8020016c:	0007871b          	sext.w	a4,a5
            if (i != hartId) {
    80200170:	fe978ae3          	beq	a5,s1,80200164 <main+0x144>
                unsigned long mask = 1 << i;
    80200174:	00ef973b          	sllw	a4,t6,a4
    80200178:	fce43c23          	sd	a4,-40(s0)
	register u64 a7 asm ("a7") = 0x48534D;
    8020017c:	000e8893          	mv	a7,t4
	register u64 a0 asm ("a0") = hartId;
    80200180:	00078513          	mv	a0,a5
	register u64 a1 asm ("a1") = 0x80200000;
    80200184:	000e0593          	mv	a1,t3
	register u64 a2 asm ("a2") = 19260817; // priv
    80200188:	00030613          	mv	a2,t1
	register u64 a6 asm ("a6") = 0; // funcid
    8020018c:	00000813          	li	a6,0
	asm volatile ("ecall" : "+r" (a0) : "r"(a0), "r"(a1), "r"(a2), "r"(a6), "r" (a7) : "memory");
    80200190:	00000073          	ecall
		SBI_CALL(which, arg0, arg1, arg2, 0)
#define SBI_CALL_4(which, arg0, arg1, arg2, arg3) \
		SBI_CALL(which, arg0, arg1, arg2, arg3)

static inline void sbi_send_ipi(const unsigned long* hart_mask) {
    SBI_CALL_1(SBI_SEND_IPI, hart_mask);
    80200194:	fd840513          	addi	a0,s0,-40
    80200198:	00000593          	li	a1,0
    8020019c:	00000613          	li	a2,0
    802001a0:	00000693          	li	a3,0
    802001a4:	00400893          	li	a7,4
    802001a8:	00000073          	ecall
    802001ac:	fb9ff06f          	j	80200164 <main+0x144>
        trapInit();
    802001b0:	0000e097          	auipc	ra,0xe
    802001b4:	2c0080e7          	jalr	704(ra) # 8020e470 <trapInit>
        __sync_synchronize();     
    802001b8:	0ff0000f          	fence
        initFinish = 0;
    802001bc:	00200797          	auipc	a5,0x200
    802001c0:	e407a223          	sw	zero,-444(a5) # 80400000 <initFinish>
        PROCESS_CREATE_PRIORITY(BusyboxTest, 1);
    802001c4:	00100613          	li	a2,1
    802001c8:	001ff597          	auipc	a1,0x1ff
    802001cc:	e405a583          	lw	a1,-448(a1) # 803ff008 <binaryBusyboxTestSize>
    802001d0:	00019517          	auipc	a0,0x19
    802001d4:	e6850513          	addi	a0,a0,-408 # 80219038 <binaryBusyboxTestStart>
    802001d8:	00010097          	auipc	ra,0x10
    802001dc:	e3c080e7          	jalr	-452(ra) # 80210014 <processCreatePriority>
    }

    yield();
    802001e0:	00012097          	auipc	ra,0x12
    802001e4:	b58080e7          	jalr	-1192(ra) # 80211d38 <yield>
    802001e8:	02813083          	ld	ra,40(sp)
    802001ec:	02013403          	ld	s0,32(sp)
    802001f0:	01813483          	ld	s1,24(sp)
    802001f4:	03010113          	addi	sp,sp,48
    802001f8:	00008067          	ret

00000000802001fc <consoleWrite>:
    // if ((ret & UART_RXFIFO_DATA) == '\r')
    //     return '\n';
    return ret & UART_RXFIFO_DATA;
}

int consoleWrite(int user_src, u64 src, u64 start, u64 n) {
    802001fc:	fa010113          	addi	sp,sp,-96
    80200200:	04113c23          	sd	ra,88(sp)
    80200204:	04813823          	sd	s0,80(sp)
    80200208:	04913423          	sd	s1,72(sp)
    8020020c:	05213023          	sd	s2,64(sp)
    80200210:	03313c23          	sd	s3,56(sp)
    80200214:	03413823          	sd	s4,48(sp)
    80200218:	03513423          	sd	s5,40(sp)
    8020021c:	03613023          	sd	s6,32(sp)
    80200220:	01713c23          	sd	s7,24(sp)
    80200224:	01813823          	sd	s8,16(sp)
    80200228:	06010413          	addi	s0,sp,96
    int i;
    for (i = 0; i < n; i++) {
    8020022c:	08068863          	beqz	a3,802002bc <consoleWrite+0xc0>
    80200230:	00050a93          	mv	s5,a0
    80200234:	00058913          	mv	s2,a1
    80200238:	00b68a33          	add	s4,a3,a1
    8020023c:	00000993          	li	s3,0
        char c;
        if(either_copyin(&c, user_src, src+i, 1) == -1)
    80200240:	fff00b13          	li	s6,-1
            break;
        if (c == '\n')
    80200244:	00a00b93          	li	s7,10
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200248:	100104b7          	lui	s1,0x10010
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    8020024c:	00d00c13          	li	s8,13
    80200250:	02c0006f          	j	8020027c <consoleWrite+0x80>
            putchar('\r');
        putchar(c);
    80200254:	faf44703          	lbu	a4,-81(s0)
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200258:	0004a783          	lw	a5,0(s1) # 10010000 <_start-0x701f0000>
	while (readl(uartRegTXFIFO) & UART_TXFIFO_FULL);
    8020025c:	0820000f          	fence	i,r
    80200260:	0007879b          	sext.w	a5,a5
    80200264:	fe07cae3          	bltz	a5,80200258 <consoleWrite+0x5c>
    writel(ch, uartRegTXFIFO);
    80200268:	0140000f          	fence	w,o
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    8020026c:	00e4a023          	sw	a4,0(s1)
    for (i = 0; i < n; i++) {
    80200270:	0019899b          	addiw	s3,s3,1
    80200274:	00190913          	addi	s2,s2,1
    80200278:	05490463          	beq	s2,s4,802002c0 <consoleWrite+0xc4>
        if(either_copyin(&c, user_src, src+i, 1) == -1)
    8020027c:	00100693          	li	a3,1
    80200280:	00090613          	mv	a2,s2
    80200284:	000a8593          	mv	a1,s5
    80200288:	faf40513          	addi	a0,s0,-81
    8020028c:	00010097          	auipc	ra,0x10
    80200290:	1f8080e7          	jalr	504(ra) # 80210484 <either_copyin>
    80200294:	03650663          	beq	a0,s6,802002c0 <consoleWrite+0xc4>
        if (c == '\n')
    80200298:	faf44783          	lbu	a5,-81(s0)
    8020029c:	fb779ce3          	bne	a5,s7,80200254 <consoleWrite+0x58>
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    802002a0:	0004a783          	lw	a5,0(s1)
	while (readl(uartRegTXFIFO) & UART_TXFIFO_FULL);
    802002a4:	0820000f          	fence	i,r
    802002a8:	0007879b          	sext.w	a5,a5
    802002ac:	fe07cae3          	bltz	a5,802002a0 <consoleWrite+0xa4>
    writel(ch, uartRegTXFIFO);
    802002b0:	0140000f          	fence	w,o
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    802002b4:	0184a023          	sw	s8,0(s1)
}
    802002b8:	f9dff06f          	j	80200254 <consoleWrite+0x58>
    for (i = 0; i < n; i++) {
    802002bc:	00000993          	li	s3,0
    }
    return i;
}
    802002c0:	00098513          	mv	a0,s3
    802002c4:	05813083          	ld	ra,88(sp)
    802002c8:	05013403          	ld	s0,80(sp)
    802002cc:	04813483          	ld	s1,72(sp)
    802002d0:	04013903          	ld	s2,64(sp)
    802002d4:	03813983          	ld	s3,56(sp)
    802002d8:	03013a03          	ld	s4,48(sp)
    802002dc:	02813a83          	ld	s5,40(sp)
    802002e0:	02013b03          	ld	s6,32(sp)
    802002e4:	01813b83          	ld	s7,24(sp)
    802002e8:	01013c03          	ld	s8,16(sp)
    802002ec:	06010113          	addi	sp,sp,96
    802002f0:	00008067          	ret

00000000802002f4 <consoleRead>:

//TODO, 未考虑多进程
//没有回显
#define GET_BUF_LEN 64
char buf[GET_BUF_LEN];
int consoleRead(int isUser, u64 dst, u64 start, u64 n) {
    802002f4:	f9010113          	addi	sp,sp,-112
    802002f8:	06113423          	sd	ra,104(sp)
    802002fc:	06813023          	sd	s0,96(sp)
    80200300:	04913c23          	sd	s1,88(sp)
    80200304:	05213823          	sd	s2,80(sp)
    80200308:	05313423          	sd	s3,72(sp)
    8020030c:	05413023          	sd	s4,64(sp)
    80200310:	03513c23          	sd	s5,56(sp)
    80200314:	03613823          	sd	s6,48(sp)
    80200318:	03713423          	sd	s7,40(sp)
    8020031c:	03813023          	sd	s8,32(sp)
    80200320:	01913c23          	sd	s9,24(sp)
    80200324:	07010413          	addi	s0,sp,112
    int i;
    for (i = 0; i < n; i++) {
    80200328:	08068e63          	beqz	a3,802003c4 <consoleRead+0xd0>
    8020032c:	00050b13          	mv	s6,a0
    80200330:	00058913          	mv	s2,a1
    80200334:	00b68ab3          	add	s5,a3,a1
    80200338:	00000993          	li	s3,0
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    8020033c:	10010a37          	lui	s4,0x10010
    80200340:	004a0493          	addi	s1,s4,4 # 10010004 <_start-0x701efffc>
        char c = getchar();
        if (c == '\n')
    80200344:	00a00c13          	li	s8,10
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    80200348:	00d00c93          	li	s9,13
            putchar('\r');
        if (either_copyout(isUser, dst + i, &c, 1) == -1)
    8020034c:	fff00b93          	li	s7,-1
    80200350:	0340006f          	j	80200384 <consoleRead+0x90>
    writel(ch, uartRegTXFIFO);
    80200354:	0140000f          	fence	w,o
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    80200358:	019a2023          	sw	s9,0(s4)
        if (either_copyout(isUser, dst + i, &c, 1) == -1)
    8020035c:	00100693          	li	a3,1
    80200360:	f9f40613          	addi	a2,s0,-97
    80200364:	00090593          	mv	a1,s2
    80200368:	000b0513          	mv	a0,s6
    8020036c:	00010097          	auipc	ra,0x10
    80200370:	004080e7          	jalr	4(ra) # 80210370 <either_copyout>
    80200374:	05750a63          	beq	a0,s7,802003c8 <consoleRead+0xd4>
    for (i = 0; i < n; i++) {
    80200378:	0019899b          	addiw	s3,s3,1
    8020037c:	00190913          	addi	s2,s2,1
    80200380:	052a8463          	beq	s5,s2,802003c8 <consoleRead+0xd4>
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200384:	0004a783          	lw	a5,0(s1)
    80200388:	0007871b          	sext.w	a4,a5
	u32 ret = readl(uartRegRXFIFO);
    8020038c:	0820000f          	fence	i,r
    while (ret & UART_RXFIFO_EMPTY) {
    80200390:	00075a63          	bgez	a4,802003a4 <consoleRead+0xb0>
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200394:	0004a783          	lw	a5,0(s1)
    80200398:	0007871b          	sext.w	a4,a5
        ret = readl(uartRegRXFIFO);
    8020039c:	0820000f          	fence	i,r
    while (ret & UART_RXFIFO_EMPTY) {
    802003a0:	fe074ae3          	bltz	a4,80200394 <consoleRead+0xa0>
        char c = getchar();
    802003a4:	0ff77713          	zext.b	a4,a4
    802003a8:	f8e40fa3          	sb	a4,-97(s0)
        if (c == '\n')
    802003ac:	fb8718e3          	bne	a4,s8,8020035c <consoleRead+0x68>
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    802003b0:	000a2783          	lw	a5,0(s4)
	while (readl(uartRegTXFIFO) & UART_TXFIFO_FULL);
    802003b4:	0820000f          	fence	i,r
    802003b8:	0007879b          	sext.w	a5,a5
    802003bc:	fe07cae3          	bltz	a5,802003b0 <consoleRead+0xbc>
    802003c0:	f95ff06f          	j	80200354 <consoleRead+0x60>
    for (i = 0; i < n; i++) {
    802003c4:	00000993          	li	s3,0
            break;
    }
    return i;
}
    802003c8:	00098513          	mv	a0,s3
    802003cc:	06813083          	ld	ra,104(sp)
    802003d0:	06013403          	ld	s0,96(sp)
    802003d4:	05813483          	ld	s1,88(sp)
    802003d8:	05013903          	ld	s2,80(sp)
    802003dc:	04813983          	ld	s3,72(sp)
    802003e0:	04013a03          	ld	s4,64(sp)
    802003e4:	03813a83          	ld	s5,56(sp)
    802003e8:	03013b03          	ld	s6,48(sp)
    802003ec:	02813b83          	ld	s7,40(sp)
    802003f0:	02013c03          	ld	s8,32(sp)
    802003f4:	01813c83          	ld	s9,24(sp)
    802003f8:	07010113          	addi	sp,sp,112
    802003fc:	00008067          	ret

0000000080200400 <consoleInterrupt>:
void consoleInterrupt(int c) {
    80200400:	ff010113          	addi	sp,sp,-16
    80200404:	00813423          	sd	s0,8(sp)
    80200408:	01010413          	addi	s0,sp,16
}
    8020040c:	00813403          	ld	s0,8(sp)
    80200410:	01010113          	addi	sp,sp,16
    80200414:	00008067          	ret

0000000080200418 <putchar>:
{
    80200418:	ff010113          	addi	sp,sp,-16
    8020041c:	00813423          	sd	s0,8(sp)
    80200420:	01010413          	addi	s0,sp,16
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200424:	10010737          	lui	a4,0x10010
    80200428:	00072783          	lw	a5,0(a4) # 10010000 <_start-0x701f0000>
	while (readl(uartRegTXFIFO) & UART_TXFIFO_FULL);
    8020042c:	0820000f          	fence	i,r
    80200430:	0007879b          	sext.w	a5,a5
    80200434:	fe07cae3          	bltz	a5,80200428 <putchar+0x10>
    writel(ch, uartRegTXFIFO);
    80200438:	0140000f          	fence	w,o
	asm volatile("sw %0, 0(%1)" : : "r"(val), "r"(addr));
    8020043c:	100107b7          	lui	a5,0x10010
    80200440:	00a7a023          	sw	a0,0(a5) # 10010000 <_start-0x701f0000>
}
    80200444:	00813403          	ld	s0,8(sp)
    80200448:	01010113          	addi	sp,sp,16
    8020044c:	00008067          	ret

0000000080200450 <getchar>:
{
    80200450:	ff010113          	addi	sp,sp,-16
    80200454:	00813423          	sd	s0,8(sp)
    80200458:	01010413          	addi	s0,sp,16
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    8020045c:	10010537          	lui	a0,0x10010
    80200460:	00450513          	addi	a0,a0,4 # 10010004 <_start-0x701efffc>
    80200464:	00052503          	lw	a0,0(a0)
	u32 ret = readl(uartRegRXFIFO);
    80200468:	0820000f          	fence	i,r
    while (ret & UART_RXFIFO_EMPTY) {
    8020046c:	0005051b          	sext.w	a0,a0
    80200470:	00055e63          	bgez	a0,8020048c <getchar+0x3c>
	asm volatile("lw %0, 0(%1)" : "=r"(val) : "r"(addr));
    80200474:	100107b7          	lui	a5,0x10010
    80200478:	00478793          	addi	a5,a5,4 # 10010004 <_start-0x701efffc>
    8020047c:	0007a503          	lw	a0,0(a5)
        ret = readl(uartRegRXFIFO);
    80200480:	0820000f          	fence	i,r
    while (ret & UART_RXFIFO_EMPTY) {
    80200484:	0005051b          	sext.w	a0,a0
    80200488:	fe054ae3          	bltz	a0,8020047c <getchar+0x2c>
}
    8020048c:	0ff57513          	zext.b	a0,a0
    80200490:	00813403          	ld	s0,8(sp)
    80200494:	01010113          	addi	sp,sp,16
    80200498:	00008067          	ret

000000008020049c <consoleInit>:

void consoleInit() {
    8020049c:	ff010113          	addi	sp,sp,-16
    802004a0:	00113423          	sd	ra,8(sp)
    802004a4:	00813023          	sd	s0,0(sp)
    802004a8:	01010413          	addi	s0,sp,16
    initLock(&consoleLock, "console");
    802004ac:	00015597          	auipc	a1,0x15
    802004b0:	ba458593          	addi	a1,a1,-1116 # 80215050 <textEnd+0x50>
    802004b4:	00200517          	auipc	a0,0x200
    802004b8:	b5450513          	addi	a0,a0,-1196 # 80400008 <consoleLock>
    802004bc:	00008097          	auipc	ra,0x8
    802004c0:	32c080e7          	jalr	812(ra) # 802087e8 <initLock>

    devsw[DEV_CONSOLE].read = consoleRead;
    802004c4:	010ac797          	auipc	a5,0x10ac
    802004c8:	fbc78793          	addi	a5,a5,-68 # 812ac480 <devsw>
    802004cc:	00000717          	auipc	a4,0x0
    802004d0:	e2870713          	addi	a4,a4,-472 # 802002f4 <consoleRead>
    802004d4:	00e7b823          	sd	a4,16(a5)
    devsw[DEV_CONSOLE].write = consoleWrite;
    802004d8:	00000717          	auipc	a4,0x0
    802004dc:	d2470713          	addi	a4,a4,-732 # 802001fc <consoleWrite>
    802004e0:	00e7bc23          	sd	a4,24(a5)
    802004e4:	00813083          	ld	ra,8(sp)
    802004e8:	00013403          	ld	s0,0(sp)
    802004ec:	01010113          	addi	sp,sp,16
    802004f0:	00008067          	ret

00000000802004f4 <printLockInit>:

struct Spinlock printLock;

#define IsDigit(x)  (((x) >= '0') && ((x) <= '9'))

inline void printLockInit(void) {
    802004f4:	ff010113          	addi	sp,sp,-16
    802004f8:	00113423          	sd	ra,8(sp)
    802004fc:	00813023          	sd	s0,0(sp)
    80200500:	01010413          	addi	s0,sp,16
    initLock(&printLock, "printLock");
    80200504:	00015597          	auipc	a1,0x15
    80200508:	b5458593          	addi	a1,a1,-1196 # 80215058 <textEnd+0x58>
    8020050c:	00200517          	auipc	a0,0x200
    80200510:	b5450513          	addi	a0,a0,-1196 # 80400060 <printLock>
    80200514:	00008097          	auipc	ra,0x8
    80200518:	2d4080e7          	jalr	724(ra) # 802087e8 <initLock>
}
    8020051c:	00813083          	ld	ra,8(sp)
    80200520:	00013403          	ld	s0,0(sp)
    80200524:	01010113          	addi	sp,sp,16
    80200528:	00008067          	ret

000000008020052c <printChar>:
    print(fmt, ap);
    va_end(ap);
    // releaseLock(&printLock);
}

void printChar(char *buf, char c, int length, int ladjust) {
    8020052c:	ff010113          	addi	sp,sp,-16
    80200530:	00813423          	sd	s0,8(sp)
    80200534:	01010413          	addi	s0,sp,16
    int i;

    if (length < 1)
    80200538:	00060713          	mv	a4,a2
    8020053c:	04c05c63          	blez	a2,80200594 <printChar+0x68>
    80200540:	0007071b          	sext.w	a4,a4
        length = 1;
    if (ladjust)
    80200544:	04069c63          	bnez	a3,8020059c <printChar+0x70>
        for (i = 1; i < length; i++)
            buf[i] = ' ';
    }
    else
    {
        for (i = 0; i < length - 1; i++)
    80200548:	00100793          	li	a5,1
    8020054c:	02c7d663          	bge	a5,a2,80200578 <printChar+0x4c>
    80200550:	00050793          	mv	a5,a0
    80200554:	00150693          	addi	a3,a0,1
    80200558:	ffe7061b          	addiw	a2,a4,-2
    8020055c:	02061613          	slli	a2,a2,0x20
    80200560:	02065613          	srli	a2,a2,0x20
    80200564:	00c686b3          	add	a3,a3,a2
            buf[i] = ' ';
    80200568:	02000613          	li	a2,32
    8020056c:	00c78023          	sb	a2,0(a5)
        for (i = 0; i < length - 1; i++)
    80200570:	00178793          	addi	a5,a5,1
    80200574:	fed79ce3          	bne	a5,a3,8020056c <printChar+0x40>
        buf[length - 1] = c;
    80200578:	00e507b3          	add	a5,a0,a4
    8020057c:	feb78fa3          	sb	a1,-1(a5)
    }
    buf[length] = '\0';
    80200580:	00e50533          	add	a0,a0,a4
    80200584:	00050023          	sb	zero,0(a0)
}
    80200588:	00813403          	ld	s0,8(sp)
    8020058c:	01010113          	addi	sp,sp,16
    80200590:	00008067          	ret
    80200594:	00100713          	li	a4,1
    80200598:	fa9ff06f          	j	80200540 <printChar+0x14>
        *buf = c;
    8020059c:	00b50023          	sb	a1,0(a0)
        for (i = 1; i < length; i++)
    802005a0:	00100793          	li	a5,1
    802005a4:	fcc7dee3          	bge	a5,a2,80200580 <printChar+0x54>
            buf[i] = ' ';
    802005a8:	02000613          	li	a2,32
    802005ac:	00f506b3          	add	a3,a0,a5
    802005b0:	00c68023          	sb	a2,0(a3)
        for (i = 1; i < length; i++)
    802005b4:	00178793          	addi	a5,a5,1
    802005b8:	0007869b          	sext.w	a3,a5
    802005bc:	fee6c8e3          	blt	a3,a4,802005ac <printChar+0x80>
    802005c0:	fc1ff06f          	j	80200580 <printChar+0x54>

00000000802005c4 <printString>:

void printString(char * buf, char* s, int length, int ladjust) {
    802005c4:	ff010113          	addi	sp,sp,-16
    802005c8:	00813423          	sd	s0,8(sp)
    802005cc:	01010413          	addi	s0,sp,16
    int i;
    int len = 0;
    char *s1 = s;
    while (*s1++)
    802005d0:	0005c783          	lbu	a5,0(a1)
    802005d4:	10078463          	beqz	a5,802006dc <printString+0x118>
    802005d8:	00158713          	addi	a4,a1,1
    int len = 0;
    802005dc:	00000793          	li	a5,0
        len++;
    802005e0:	00078893          	mv	a7,a5
    802005e4:	0017879b          	addiw	a5,a5,1
    while (*s1++)
    802005e8:	00170713          	addi	a4,a4,1
    802005ec:	fff74803          	lbu	a6,-1(a4)
    802005f0:	fe0818e3          	bnez	a6,802005e0 <printString+0x1c>
    if (length < len)
    802005f4:	00060713          	mv	a4,a2
    802005f8:	00f65463          	bge	a2,a5,80200600 <printString+0x3c>
    802005fc:	00078713          	mv	a4,a5
    80200600:	0007081b          	sext.w	a6,a4
        length = len;

    if (ladjust)
    80200604:	06069063          	bnez	a3,80200664 <printString+0xa0>
        for (i = len; i < length; i++)
            buf[i] = ' ';
    }
    else
    {
        for (i = 0; i < length - len; i++)
    80200608:	40f7073b          	subw	a4,a4,a5
    8020060c:	02e05663          	blez	a4,80200638 <printString+0x74>
    80200610:	00050693          	mv	a3,a0
    80200614:	00150613          	addi	a2,a0,1
    80200618:	fff7089b          	addiw	a7,a4,-1
    8020061c:	02089893          	slli	a7,a7,0x20
    80200620:	0208d893          	srli	a7,a7,0x20
    80200624:	01160633          	add	a2,a2,a7
            buf[i] = ' ';
    80200628:	02000893          	li	a7,32
    8020062c:	01168023          	sb	a7,0(a3)
        for (i = 0; i < length - len; i++)
    80200630:	00168693          	addi	a3,a3,1
    80200634:	fec69ce3          	bne	a3,a2,8020062c <printString+0x68>
        for (i = length - len; i < length; i++)
    80200638:	09075463          	bge	a4,a6,802006c0 <printString+0xfc>
            buf[i] = s[i - length + len];
    8020063c:	410787b3          	sub	a5,a5,a6
    80200640:	00e786b3          	add	a3,a5,a4
    80200644:	00d586b3          	add	a3,a1,a3
    80200648:	0006c603          	lbu	a2,0(a3)
    8020064c:	00e506b3          	add	a3,a0,a4
    80200650:	00c68023          	sb	a2,0(a3)
        for (i = length - len; i < length; i++)
    80200654:	00170713          	addi	a4,a4,1
    80200658:	0007069b          	sext.w	a3,a4
    8020065c:	ff06c2e3          	blt	a3,a6,80200640 <printString+0x7c>
    80200660:	0600006f          	j	802006c0 <printString+0xfc>
        for (i = 0; i < len; i++)
    80200664:	02f05463          	blez	a5,8020068c <printString+0xc8>
    80200668:	00050613          	mv	a2,a0
    8020066c:	00058713          	mv	a4,a1
            buf[i] = s[i];
    80200670:	00074683          	lbu	a3,0(a4)
    80200674:	00d60023          	sb	a3,0(a2)
        for (i = 0; i < len; i++)
    80200678:	00170713          	addi	a4,a4,1
    8020067c:	00160613          	addi	a2,a2,1
    80200680:	40b706bb          	subw	a3,a4,a1
    80200684:	fff6869b          	addiw	a3,a3,-1
    80200688:	ff16c4e3          	blt	a3,a7,80200670 <printString+0xac>
        for (i = len; i < length; i++)
    8020068c:	0307da63          	bge	a5,a6,802006c0 <printString+0xfc>
    80200690:	00f50733          	add	a4,a0,a5
    80200694:	fff8069b          	addiw	a3,a6,-1
    80200698:	40f686bb          	subw	a3,a3,a5
    8020069c:	02069693          	slli	a3,a3,0x20
    802006a0:	0206d693          	srli	a3,a3,0x20
    802006a4:	00150613          	addi	a2,a0,1
    802006a8:	00f607b3          	add	a5,a2,a5
    802006ac:	00f687b3          	add	a5,a3,a5
            buf[i] = ' ';
    802006b0:	02000693          	li	a3,32
    802006b4:	00d70023          	sb	a3,0(a4)
        for (i = len; i < length; i++)
    802006b8:	00170713          	addi	a4,a4,1
    802006bc:	fef71ce3          	bne	a4,a5,802006b4 <printString+0xf0>
    }
    buf[length] = '\0';
    802006c0:	01050833          	add	a6,a0,a6
    802006c4:	00080023          	sb	zero,0(a6)
}
    802006c8:	00813403          	ld	s0,8(sp)
    802006cc:	01010113          	addi	sp,sp,16
    802006d0:	00008067          	ret
    int len = 0;
    802006d4:	00000793          	li	a5,0
    802006d8:	fb5ff06f          	j	8020068c <printString+0xc8>
    if (length < len)
    802006dc:	fff64813          	not	a6,a2
    802006e0:	43f85813          	srai	a6,a6,0x3f
    802006e4:	00c87833          	and	a6,a6,a2
    if (ladjust)
    802006e8:	fe0696e3          	bnez	a3,802006d4 <printString+0x110>
        for (i = 0; i < length - len; i++)
    802006ec:	00080713          	mv	a4,a6
    int len = 0;
    802006f0:	00068793          	mv	a5,a3
        for (i = 0; i < length - len; i++)
    802006f4:	f0c04ee3          	bgtz	a2,80200610 <printString+0x4c>
    802006f8:	fc9ff06f          	j	802006c0 <printString+0xfc>

00000000802006fc <printNum>:

void printNum(char * buf, unsigned long u, int base, int negFlag, 
	 int length, int ladjust, char padc, int upcase)
{
    802006fc:	ff010113          	addi	sp,sp,-16
    80200700:	00813423          	sd	s0,8(sp)
    80200704:	01010413          	addi	s0,sp,16
    int actualLength = 0;
    char *p = buf;
    80200708:	00150e13          	addi	t3,a0,1
    int i;

    do
    {
        int tmp = u % base;
    8020070c:	00060f93          	mv	t6,a2
        if (tmp <= 9)
    80200710:	00900f13          	li	t5,9
    80200714:	0280006f          	j	8020073c <printNum+0x40>
        {
            *p++ = '0' + tmp;
        }
        else if (upcase)
    80200718:	04088063          	beqz	a7,80200758 <printNum+0x5c>
        {
            *p++ = 'A' + tmp - 10;
    8020071c:	000e0e93          	mv	t4,t3
    80200720:	0373031b          	addiw	t1,t1,55
    80200724:	0ff37313          	zext.b	t1,t1
            *p++ = '0' + tmp;
    80200728:	fe6e0fa3          	sb	t1,-1(t3)
        }
        else
        {
            *p++ = 'a' + tmp - 10;
        }
        u /= base;
    8020072c:	02c5d333          	divu	t1,a1,a2
    } while (u != 0);
    80200730:	001e0e13          	addi	t3,t3,1
    80200734:	03f5ea63          	bltu	a1,t6,80200768 <printNum+0x6c>
        u /= base;
    80200738:	00030593          	mv	a1,t1
        int tmp = u % base;
    8020073c:	02c5f333          	remu	t1,a1,a2
        if (tmp <= 9)
    80200740:	00030e9b          	sext.w	t4,t1
    80200744:	fddf4ae3          	blt	t5,t4,80200718 <printNum+0x1c>
            *p++ = '0' + tmp;
    80200748:	000e0e93          	mv	t4,t3
    8020074c:	0303031b          	addiw	t1,t1,48
    80200750:	0ff37313          	zext.b	t1,t1
    80200754:	fd5ff06f          	j	80200728 <printNum+0x2c>
            *p++ = 'a' + tmp - 10;
    80200758:	000e0e93          	mv	t4,t3
    8020075c:	0573031b          	addiw	t1,t1,87
    80200760:	0ff37313          	zext.b	t1,t1
    80200764:	fc5ff06f          	j	80200728 <printNum+0x2c>

    if (negFlag)
    80200768:	02068c63          	beqz	a3,802007a0 <printNum+0xa4>
    {
        *p++ = '-';
    8020076c:	02d00613          	li	a2,45
    80200770:	00ce8023          	sb	a2,0(t4)
    80200774:	001e8e93          	addi	t4,t4,1
    }

    /* figure out actual length and adjust the maximum length */
    actualLength = p - buf;
    80200778:	40ae8eb3          	sub	t4,t4,a0
    8020077c:	000e859b          	sext.w	a1,t4
    if (length < actualLength)
    80200780:	00058893          	mv	a7,a1
    80200784:	00e5d463          	bge	a1,a4,8020078c <printNum+0x90>
    80200788:	00070893          	mv	a7,a4
    8020078c:	0008889b          	sext.w	a7,a7
        length = actualLength;

    /* add padding */
    if (ladjust)
    80200790:	02079e63          	bnez	a5,802007cc <printNum+0xd0>
    {
        padc = ' ';
    }
    if (negFlag && !ladjust && (padc == '0'))
    80200794:	0a069663          	bnez	a3,80200840 <printNum+0x144>
            buf[i] = padc;
        buf[length - 1] = '-';
    }
    else
    {
        for (i = actualLength; i < length; i++)
    80200798:	0315ce63          	blt	a1,a7,802007d4 <printNum+0xd8>
    8020079c:	0f40006f          	j	80200890 <printNum+0x194>
    actualLength = p - buf;
    802007a0:	40ae8eb3          	sub	t4,t4,a0
    802007a4:	000e859b          	sext.w	a1,t4
    if (length < actualLength)
    802007a8:	00058893          	mv	a7,a1
    802007ac:	00e5d463          	bge	a1,a4,802007b4 <printNum+0xb8>
    802007b0:	00070893          	mv	a7,a4
    802007b4:	0008889b          	sext.w	a7,a7
    if (ladjust)
    802007b8:	fc078ee3          	beqz	a5,80200794 <printNum+0x98>
    if (negFlag && !ladjust && (padc == '0'))
    802007bc:	00069863          	bnez	a3,802007cc <printNum+0xd0>
        padc = ' ';
    802007c0:	02000813          	li	a6,32
        for (i = actualLength; i < length; i++)
    802007c4:	0115c863          	blt	a1,a7,802007d4 <printNum+0xd8>
    802007c8:	0280006f          	j	802007f0 <printNum+0xf4>
        padc = ' ';
    802007cc:	02000813          	li	a6,32
        for (i = actualLength; i < length; i++)
    802007d0:	0315d063          	bge	a1,a7,802007f0 <printNum+0xf4>
    802007d4:	00058713          	mv	a4,a1
            buf[i] = padc;
    802007d8:	00e506b3          	add	a3,a0,a4
    802007dc:	01068023          	sb	a6,0(a3)
        for (i = actualLength; i < length; i++)
    802007e0:	00170713          	addi	a4,a4,1
    802007e4:	0007069b          	sext.w	a3,a4
    802007e8:	ff16c8e3          	blt	a3,a7,802007d8 <printNum+0xdc>

    /* prepare to reverse the string */
    {
        int begin = 0;
        int end;
        if (ladjust)
    802007ec:	0a078263          	beqz	a5,80200890 <printNum+0x194>
        {
            end = actualLength - 1;
    802007f0:	fff5859b          	addiw	a1,a1,-1
        else
        {
            end = length - 1;
        }

        while (end > begin)
    802007f4:	02b05c63          	blez	a1,8020082c <printNum+0x130>
    802007f8:	00050693          	mv	a3,a0
    802007fc:	00b50733          	add	a4,a0,a1
    80200800:	00000613          	li	a2,0
        {
            char tmp = buf[begin];
    80200804:	0006c783          	lbu	a5,0(a3)
            buf[begin] = buf[end];
    80200808:	00074803          	lbu	a6,0(a4)
    8020080c:	01068023          	sb	a6,0(a3)
            buf[end] = tmp;
    80200810:	00f70023          	sb	a5,0(a4)
            begin++;
    80200814:	0016079b          	addiw	a5,a2,1
    80200818:	0007861b          	sext.w	a2,a5
        while (end > begin)
    8020081c:	00168693          	addi	a3,a3,1
    80200820:	fff70713          	addi	a4,a4,-1
    80200824:	40f587bb          	subw	a5,a1,a5
    80200828:	fcf64ee3          	blt	a2,a5,80200804 <printNum+0x108>
            end--;
        }
    }

    /* adjust the string pointer */
    buf[length] = '\0';
    8020082c:	011508b3          	add	a7,a0,a7
    80200830:	00088023          	sb	zero,0(a7)
}
    80200834:	00813403          	ld	s0,8(sp)
    80200838:	01010113          	addi	sp,sp,16
    8020083c:	00008067          	ret
    if (negFlag && !ladjust && (padc == '0'))
    80200840:	03000713          	li	a4,48
    80200844:	00e80663          	beq	a6,a4,80200850 <printNum+0x154>
        for (i = actualLength; i < length; i++)
    80200848:	f915c6e3          	blt	a1,a7,802007d4 <printNum+0xd8>
    8020084c:	0440006f          	j	80200890 <printNum+0x194>
        for (i = actualLength - 1; i < length - 1; i++)
    80200850:	fff5871b          	addiw	a4,a1,-1
    80200854:	0315d863          	bge	a1,a7,80200884 <printNum+0x188>
    80200858:	00e50733          	add	a4,a0,a4
    8020085c:	41d887bb          	subw	a5,a7,t4
    80200860:	fff7879b          	addiw	a5,a5,-1
    80200864:	02079793          	slli	a5,a5,0x20
    80200868:	0207d793          	srli	a5,a5,0x20
    8020086c:	00b505b3          	add	a1,a0,a1
    80200870:	00b787b3          	add	a5,a5,a1
            buf[i] = padc;
    80200874:	03000693          	li	a3,48
    80200878:	00d70023          	sb	a3,0(a4)
        for (i = actualLength - 1; i < length - 1; i++)
    8020087c:	00170713          	addi	a4,a4,1
    80200880:	fef71ce3          	bne	a4,a5,80200878 <printNum+0x17c>
        buf[length - 1] = '-';
    80200884:	011507b3          	add	a5,a0,a7
    80200888:	02d00713          	li	a4,45
    8020088c:	fee78fa3          	sb	a4,-1(a5)
            end = length - 1;
    80200890:	fff8859b          	addiw	a1,a7,-1
    80200894:	f61ff06f          	j	802007f4 <printNum+0xf8>

0000000080200898 <print>:
    for (i = 0; fmt[i]; i++) {
    80200898:	00054783          	lbu	a5,0(a0)
    8020089c:	5a078863          	beqz	a5,80200e4c <print+0x5b4>
static void print(const char *fmt, va_list ap) {
    802008a0:	f1010113          	addi	sp,sp,-240
    802008a4:	0e113423          	sd	ra,232(sp)
    802008a8:	0e813023          	sd	s0,224(sp)
    802008ac:	0c913c23          	sd	s1,216(sp)
    802008b0:	0d213823          	sd	s2,208(sp)
    802008b4:	0d313423          	sd	s3,200(sp)
    802008b8:	0d413023          	sd	s4,192(sp)
    802008bc:	0b513c23          	sd	s5,184(sp)
    802008c0:	0b613823          	sd	s6,176(sp)
    802008c4:	0b713423          	sd	s7,168(sp)
    802008c8:	0b813023          	sd	s8,160(sp)
    802008cc:	09913c23          	sd	s9,152(sp)
    802008d0:	09a13823          	sd	s10,144(sp)
    802008d4:	09b13423          	sd	s11,136(sp)
    802008d8:	0f010413          	addi	s0,sp,240
    802008dc:	00050493          	mv	s1,a0
    802008e0:	00058a93          	mv	s5,a1
    for (i = 0; fmt[i]; i++) {
    802008e4:	00050a13          	mv	s4,a0
    802008e8:	00000913          	li	s2,0
        if (fmt[i] != '%'){
    802008ec:	02500993          	li	s3,37
        if (c == '-') {
    802008f0:	02d00c13          	li	s8,45
            ladjust = 0;
    802008f4:	00000b13          	li	s6,0
        if (c == '0') {
    802008f8:	03000b93          	li	s7,48
        switch (c) {
    802008fc:	00014c97          	auipc	s9,0x14
    80200900:	7acc8c93          	addi	s9,s9,1964 # 802150a8 <textEnd+0xa8>
    80200904:	00015d17          	auipc	s10,0x15
    80200908:	878d0d13          	addi	s10,s10,-1928 # 8021517c <textEnd+0x17c>
    8020090c:	0200006f          	j	8020092c <print+0x94>
            putchar(fmt[i]);
    80200910:	000a4503          	lbu	a0,0(s4)
    80200914:	00000097          	auipc	ra,0x0
    80200918:	b04080e7          	jalr	-1276(ra) # 80200418 <putchar>
    for (i = 0; fmt[i]; i++) {
    8020091c:	0019091b          	addiw	s2,s2,1
    80200920:	01248a33          	add	s4,s1,s2
    80200924:	000a4783          	lbu	a5,0(s4)
    80200928:	4e078463          	beqz	a5,80200e10 <print+0x578>
        if (fmt[i] != '%'){
    8020092c:	01378e63          	beq	a5,s3,80200948 <print+0xb0>
            if (fmt[i] == '\n') {
    80200930:	00a00713          	li	a4,10
    80200934:	fce79ee3          	bne	a5,a4,80200910 <print+0x78>
                putchar('\r');
    80200938:	00d00513          	li	a0,13
    8020093c:	00000097          	auipc	ra,0x0
    80200940:	adc080e7          	jalr	-1316(ra) # 80200418 <putchar>
    80200944:	fcdff06f          	j	80200910 <print+0x78>
        c = fmt[++i];
    80200948:	00190a1b          	addiw	s4,s2,1
    8020094c:	014487b3          	add	a5,s1,s4
    80200950:	0007c503          	lbu	a0,0(a5)
            ladjust = 0;
    80200954:	000b0793          	mv	a5,s6
        if (c == '-') {
    80200958:	09850c63          	beq	a0,s8,802009f0 <print+0x158>
            padc = ' ';
    8020095c:	02000813          	li	a6,32
        if (c == '0') {
    80200960:	0b750263          	beq	a0,s7,80200a04 <print+0x16c>
        while (IsDigit(c)) {
    80200964:	fd05071b          	addiw	a4,a0,-48
    80200968:	00900693          	li	a3,9
    8020096c:	0ae6e663          	bltu	a3,a4,80200a18 <print+0x180>
    80200970:	001a089b          	addiw	a7,s4,1
        width = 0;
    80200974:	000b0713          	mv	a4,s6
        while (IsDigit(c)) {
    80200978:	00900313          	li	t1,9
            width = (width << 3) + (width << 1) + c - '0';
    8020097c:	0027159b          	slliw	a1,a4,0x2
    80200980:	00e585bb          	addw	a1,a1,a4
    80200984:	0015959b          	slliw	a1,a1,0x1
    80200988:	00a585bb          	addw	a1,a1,a0
    8020098c:	fd05871b          	addiw	a4,a1,-48
            c = fmt[++i];
    80200990:	00088a1b          	sext.w	s4,a7
    80200994:	01148633          	add	a2,s1,a7
    80200998:	00064583          	lbu	a1,0(a2)
    8020099c:	0005851b          	sext.w	a0,a1
        while (IsDigit(c)) {
    802009a0:	00188893          	addi	a7,a7,1
    802009a4:	fd05859b          	addiw	a1,a1,-48
    802009a8:	fcb37ae3          	bgeu	t1,a1,8020097c <print+0xe4>
        if (c == '.') {
    802009ac:	02e00693          	li	a3,46
    802009b0:	06d50863          	beq	a0,a3,80200a20 <print+0x188>
        if (c == 'l') {
    802009b4:	06c00693          	li	a3,108
    802009b8:	0ad50863          	beq	a0,a3,80200a68 <print+0x1d0>
        switch (c) {
    802009bc:	42050863          	beqz	a0,80200dec <print+0x554>
    802009c0:	fbc5069b          	addiw	a3,a0,-68
    802009c4:	03400613          	li	a2,52
    802009c8:	42d66863          	bltu	a2,a3,80200df8 <print+0x560>
    802009cc:	fbc5069b          	addiw	a3,a0,-68
    802009d0:	0006859b          	sext.w	a1,a3
    802009d4:	42b66263          	bltu	a2,a1,80200df8 <print+0x560>
    802009d8:	02069613          	slli	a2,a3,0x20
    802009dc:	01e65693          	srli	a3,a2,0x1e
    802009e0:	019686b3          	add	a3,a3,s9
    802009e4:	0006a683          	lw	a3,0(a3)
    802009e8:	019686b3          	add	a3,a3,s9
    802009ec:	00068067          	jr	a3
            c = fmt[++i];
    802009f0:	00290a1b          	addiw	s4,s2,2
    802009f4:	014487b3          	add	a5,s1,s4
    802009f8:	0007c503          	lbu	a0,0(a5)
            ladjust = 1;
    802009fc:	00100793          	li	a5,1
    80200a00:	f5dff06f          	j	8020095c <print+0xc4>
            c = fmt[++i];
    80200a04:	001a0a1b          	addiw	s4,s4,1
    80200a08:	01448733          	add	a4,s1,s4
    80200a0c:	00074503          	lbu	a0,0(a4)
            padc = '0';
    80200a10:	000b8813          	mv	a6,s7
    80200a14:	f51ff06f          	j	80200964 <print+0xcc>
        width = 0;
    80200a18:	000b0713          	mv	a4,s6
    80200a1c:	f91ff06f          	j	802009ac <print+0x114>
            c = fmt[++i];
    80200a20:	001a069b          	addiw	a3,s4,1
    80200a24:	00d48633          	add	a2,s1,a3
    80200a28:	00064503          	lbu	a0,0(a2)
            while (IsDigit(c)) {
    80200a2c:	fd05031b          	addiw	t1,a0,-48
    80200a30:	00900893          	li	a7,9
    80200a34:	002a061b          	addiw	a2,s4,2
    80200a38:	00900593          	li	a1,9
            c = fmt[++i];
    80200a3c:	0005051b          	sext.w	a0,a0
    80200a40:	00068a13          	mv	s4,a3
            while (IsDigit(c)) {
    80200a44:	f668e8e3          	bltu	a7,t1,802009b4 <print+0x11c>
                c = fmt[++i];
    80200a48:	00060a1b          	sext.w	s4,a2
    80200a4c:	00c486b3          	add	a3,s1,a2
    80200a50:	0006c503          	lbu	a0,0(a3)
            while (IsDigit(c)) {
    80200a54:	00160613          	addi	a2,a2,1
    80200a58:	fd05069b          	addiw	a3,a0,-48
    80200a5c:	fed5f6e3          	bgeu	a1,a3,80200a48 <print+0x1b0>
                c = fmt[++i];
    80200a60:	0005051b          	sext.w	a0,a0
    80200a64:	f51ff06f          	j	802009b4 <print+0x11c>
            c = fmt[++i];
    80200a68:	001a0a1b          	addiw	s4,s4,1
    80200a6c:	014486b3          	add	a3,s1,s4
    80200a70:	0006c503          	lbu	a0,0(a3)
        switch (c) {
    80200a74:	36050c63          	beqz	a0,80200dec <print+0x554>
    80200a78:	fbc5069b          	addiw	a3,a0,-68
    80200a7c:	0ff6f693          	zext.b	a3,a3
    80200a80:	03400613          	li	a2,52
    80200a84:	36d66863          	bltu	a2,a3,80200df4 <print+0x55c>
    80200a88:	fbc5069b          	addiw	a3,a0,-68
    80200a8c:	0ff6f593          	zext.b	a1,a3
    80200a90:	36b66263          	bltu	a2,a1,80200df4 <print+0x55c>
    80200a94:	00259693          	slli	a3,a1,0x2
    80200a98:	01a686b3          	add	a3,a3,s10
    80200a9c:	0006a683          	lw	a3,0(a3)
    80200aa0:	01a686b3          	add	a3,a3,s10
    80200aa4:	00068067          	jr	a3
    80200aa8:	000a0913          	mv	s2,s4
    80200aac:	0080006f          	j	80200ab4 <print+0x21c>
    80200ab0:	000a0913          	mv	s2,s4
                c = (char)va_arg(ap, u32);
    80200ab4:	008a8a13          	addi	s4,s5,8
    80200ab8:	000aca83          	lbu	s5,0(s5)
            	printChar(buf, c, width, ladjust);
    80200abc:	00078693          	mv	a3,a5
    80200ac0:	00070613          	mv	a2,a4
    80200ac4:	000a8593          	mv	a1,s5
    80200ac8:	f1040513          	addi	a0,s0,-240
    80200acc:	00000097          	auipc	ra,0x0
    80200ad0:	a60080e7          	jalr	-1440(ra) # 8020052c <printChar>
                putchar(c);
    80200ad4:	000a8513          	mv	a0,s5
    80200ad8:	00000097          	auipc	ra,0x0
    80200adc:	940080e7          	jalr	-1728(ra) # 80200418 <putchar>
                c = (char)va_arg(ap, u32);
    80200ae0:	000a0a93          	mv	s5,s4
                break;
    80200ae4:	e39ff06f          	j	8020091c <print+0x84>
                    num = va_arg(ap, i64);
    80200ae8:	000ab583          	ld	a1,0(s5)
    80200aec:	000a0913          	mv	s2,s4
    80200af0:	008a8a93          	addi	s5,s5,8
        negFlag = 0;
    80200af4:	000b0693          	mv	a3,s6
                if (num < 0) {
    80200af8:	0205ce63          	bltz	a1,80200b34 <print+0x29c>
	            printNum(buf, num, 10, negFlag, width, ladjust, padc, 0);
    80200afc:	000b0893          	mv	a7,s6
    80200b00:	00a00613          	li	a2,10
    80200b04:	f1040513          	addi	a0,s0,-240
    80200b08:	00000097          	auipc	ra,0x0
    80200b0c:	bf4080e7          	jalr	-1036(ra) # 802006fc <printNum>
    while (*s) {
    80200b10:	f1044783          	lbu	a5,-240(s0)
    80200b14:	e00784e3          	beqz	a5,8020091c <print+0x84>
    80200b18:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200b1c:	00a00d93          	li	s11,10
    80200b20:	0380006f          	j	80200b58 <print+0x2c0>
                    num = va_arg(ap, i32);
    80200b24:	000aa583          	lw	a1,0(s5)
    80200b28:	000a0913          	mv	s2,s4
    80200b2c:	008a8a93          	addi	s5,s5,8
    80200b30:	fc5ff06f          	j	80200af4 <print+0x25c>
                    num = -num;
    80200b34:	40b005b3          	neg	a1,a1
                    negFlag = 1;
    80200b38:	00100693          	li	a3,1
    80200b3c:	fc1ff06f          	j	80200afc <print+0x264>
        putchar(*s++);
    80200b40:	001a0a13          	addi	s4,s4,1
    80200b44:	fffa4503          	lbu	a0,-1(s4)
    80200b48:	00000097          	auipc	ra,0x0
    80200b4c:	8d0080e7          	jalr	-1840(ra) # 80200418 <putchar>
    while (*s) {
    80200b50:	000a4783          	lbu	a5,0(s4)
    80200b54:	dc0784e3          	beqz	a5,8020091c <print+0x84>
        if (*s == '\n') {
    80200b58:	ffb794e3          	bne	a5,s11,80200b40 <print+0x2a8>
            putchar('\r');
    80200b5c:	00d00513          	li	a0,13
    80200b60:	00000097          	auipc	ra,0x0
    80200b64:	8b8080e7          	jalr	-1864(ra) # 80200418 <putchar>
    80200b68:	fd9ff06f          	j	80200b40 <print+0x2a8>
        switch (c) {
    80200b6c:	000a0913          	mv	s2,s4
    80200b70:	00100693          	li	a3,1
    80200b74:	00c0006f          	j	80200b80 <print+0x2e8>
    80200b78:	000a0913          	mv	s2,s4
    80200b7c:	000b0693          	mv	a3,s6
                if (longFlag) {
    80200b80:	02068c63          	beqz	a3,80200bb8 <print+0x320>
                    num = va_arg(ap, i64);
    80200b84:	000ab583          	ld	a1,0(s5)
    80200b88:	008a8a93          	addi	s5,s5,8
                printNum(buf, num, 8, 0, width, ladjust, padc, 0);
    80200b8c:	000b0893          	mv	a7,s6
    80200b90:	000b0693          	mv	a3,s6
    80200b94:	00800613          	li	a2,8
    80200b98:	f1040513          	addi	a0,s0,-240
    80200b9c:	00000097          	auipc	ra,0x0
    80200ba0:	b60080e7          	jalr	-1184(ra) # 802006fc <printNum>
    while (*s) {
    80200ba4:	f1044783          	lbu	a5,-240(s0)
    80200ba8:	d6078ae3          	beqz	a5,8020091c <print+0x84>
    80200bac:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200bb0:	00a00d93          	li	s11,10
    80200bb4:	0280006f          	j	80200bdc <print+0x344>
                    num = va_arg(ap, i32);
    80200bb8:	000aa583          	lw	a1,0(s5)
    80200bbc:	008a8a93          	addi	s5,s5,8
    80200bc0:	fcdff06f          	j	80200b8c <print+0x2f4>
        putchar(*s++);
    80200bc4:	001a0a13          	addi	s4,s4,1
    80200bc8:	fffa4503          	lbu	a0,-1(s4)
    80200bcc:	00000097          	auipc	ra,0x0
    80200bd0:	84c080e7          	jalr	-1972(ra) # 80200418 <putchar>
    while (*s) {
    80200bd4:	000a4783          	lbu	a5,0(s4)
    80200bd8:	d40782e3          	beqz	a5,8020091c <print+0x84>
        if (*s == '\n') {
    80200bdc:	ffb794e3          	bne	a5,s11,80200bc4 <print+0x32c>
            putchar('\r');
    80200be0:	00d00513          	li	a0,13
    80200be4:	00000097          	auipc	ra,0x0
    80200be8:	834080e7          	jalr	-1996(ra) # 80200418 <putchar>
    80200bec:	fd9ff06f          	j	80200bc4 <print+0x32c>
        switch (c) {
    80200bf0:	000a0913          	mv	s2,s4
    80200bf4:	00100693          	li	a3,1
    80200bf8:	00c0006f          	j	80200c04 <print+0x36c>
    80200bfc:	000a0913          	mv	s2,s4
    80200c00:	000b0693          	mv	a3,s6
                if (longFlag) {
    80200c04:	02068c63          	beqz	a3,80200c3c <print+0x3a4>
                    num = va_arg(ap, i64);
    80200c08:	000ab583          	ld	a1,0(s5)
    80200c0c:	008a8a93          	addi	s5,s5,8
	            printNum(buf, num, 10, 0, width, ladjust, padc, 0);
    80200c10:	000b0893          	mv	a7,s6
    80200c14:	000b0693          	mv	a3,s6
    80200c18:	00a00613          	li	a2,10
    80200c1c:	f1040513          	addi	a0,s0,-240
    80200c20:	00000097          	auipc	ra,0x0
    80200c24:	adc080e7          	jalr	-1316(ra) # 802006fc <printNum>
    while (*s) {
    80200c28:	f1044783          	lbu	a5,-240(s0)
    80200c2c:	ce0788e3          	beqz	a5,8020091c <print+0x84>
    80200c30:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200c34:	00a00d93          	li	s11,10
    80200c38:	0280006f          	j	80200c60 <print+0x3c8>
                    num = va_arg(ap, i32);
    80200c3c:	000aa583          	lw	a1,0(s5)
    80200c40:	008a8a93          	addi	s5,s5,8
    80200c44:	fcdff06f          	j	80200c10 <print+0x378>
        putchar(*s++);
    80200c48:	001a0a13          	addi	s4,s4,1
    80200c4c:	fffa4503          	lbu	a0,-1(s4)
    80200c50:	fffff097          	auipc	ra,0xfffff
    80200c54:	7c8080e7          	jalr	1992(ra) # 80200418 <putchar>
    while (*s) {
    80200c58:	000a4783          	lbu	a5,0(s4)
    80200c5c:	cc0780e3          	beqz	a5,8020091c <print+0x84>
        if (*s == '\n') {
    80200c60:	ffb794e3          	bne	a5,s11,80200c48 <print+0x3b0>
            putchar('\r');
    80200c64:	00d00513          	li	a0,13
    80200c68:	fffff097          	auipc	ra,0xfffff
    80200c6c:	7b0080e7          	jalr	1968(ra) # 80200418 <putchar>
    80200c70:	fd9ff06f          	j	80200c48 <print+0x3b0>
        switch (c) {
    80200c74:	000a0913          	mv	s2,s4
    80200c78:	00100693          	li	a3,1
    80200c7c:	00c0006f          	j	80200c88 <print+0x3f0>
    80200c80:	000a0913          	mv	s2,s4
    80200c84:	000b0693          	mv	a3,s6
                if (longFlag) {
    80200c88:	02068c63          	beqz	a3,80200cc0 <print+0x428>
                    num = va_arg(ap, i64);
    80200c8c:	000ab583          	ld	a1,0(s5)
    80200c90:	008a8a93          	addi	s5,s5,8
                printNum(buf, num, 16, 0, width, ladjust, padc, 0);
    80200c94:	000b0893          	mv	a7,s6
    80200c98:	000b0693          	mv	a3,s6
    80200c9c:	01000613          	li	a2,16
    80200ca0:	f1040513          	addi	a0,s0,-240
    80200ca4:	00000097          	auipc	ra,0x0
    80200ca8:	a58080e7          	jalr	-1448(ra) # 802006fc <printNum>
    while (*s) {
    80200cac:	f1044783          	lbu	a5,-240(s0)
    80200cb0:	c60786e3          	beqz	a5,8020091c <print+0x84>
    80200cb4:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200cb8:	00a00d93          	li	s11,10
    80200cbc:	0280006f          	j	80200ce4 <print+0x44c>
                    num = va_arg(ap, i32);
    80200cc0:	000aa583          	lw	a1,0(s5)
    80200cc4:	008a8a93          	addi	s5,s5,8
    80200cc8:	fcdff06f          	j	80200c94 <print+0x3fc>
        putchar(*s++);
    80200ccc:	001a0a13          	addi	s4,s4,1
    80200cd0:	fffa4503          	lbu	a0,-1(s4)
    80200cd4:	fffff097          	auipc	ra,0xfffff
    80200cd8:	744080e7          	jalr	1860(ra) # 80200418 <putchar>
    while (*s) {
    80200cdc:	000a4783          	lbu	a5,0(s4)
    80200ce0:	c2078ee3          	beqz	a5,8020091c <print+0x84>
        if (*s == '\n') {
    80200ce4:	ffb794e3          	bne	a5,s11,80200ccc <print+0x434>
            putchar('\r');
    80200ce8:	00d00513          	li	a0,13
    80200cec:	fffff097          	auipc	ra,0xfffff
    80200cf0:	72c080e7          	jalr	1836(ra) # 80200418 <putchar>
    80200cf4:	fd9ff06f          	j	80200ccc <print+0x434>
                    num = va_arg(ap, i64);
    80200cf8:	000ab583          	ld	a1,0(s5)
            c = fmt[++i];
    80200cfc:	000a0913          	mv	s2,s4
                    num = va_arg(ap, i64);
    80200d00:	008a8a93          	addi	s5,s5,8
                printNum(buf, num, 16, 0, width, ladjust, padc, 1);
    80200d04:	00100893          	li	a7,1
    80200d08:	000b0693          	mv	a3,s6
    80200d0c:	01000613          	li	a2,16
    80200d10:	f1040513          	addi	a0,s0,-240
    80200d14:	00000097          	auipc	ra,0x0
    80200d18:	9e8080e7          	jalr	-1560(ra) # 802006fc <printNum>
    while (*s) {
    80200d1c:	f1044783          	lbu	a5,-240(s0)
    80200d20:	be078ee3          	beqz	a5,8020091c <print+0x84>
    80200d24:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200d28:	00a00d93          	li	s11,10
    80200d2c:	02c0006f          	j	80200d58 <print+0x4c0>
                    num = va_arg(ap, i32);
    80200d30:	000aa583          	lw	a1,0(s5)
    80200d34:	000a0913          	mv	s2,s4
    80200d38:	008a8a93          	addi	s5,s5,8
    80200d3c:	fc9ff06f          	j	80200d04 <print+0x46c>
        putchar(*s++);
    80200d40:	001a0a13          	addi	s4,s4,1
    80200d44:	fffa4503          	lbu	a0,-1(s4)
    80200d48:	fffff097          	auipc	ra,0xfffff
    80200d4c:	6d0080e7          	jalr	1744(ra) # 80200418 <putchar>
    while (*s) {
    80200d50:	000a4783          	lbu	a5,0(s4)
    80200d54:	bc0784e3          	beqz	a5,8020091c <print+0x84>
        if (*s == '\n') {
    80200d58:	ffb794e3          	bne	a5,s11,80200d40 <print+0x4a8>
            putchar('\r');
    80200d5c:	00d00513          	li	a0,13
    80200d60:	fffff097          	auipc	ra,0xfffff
    80200d64:	6b8080e7          	jalr	1720(ra) # 80200418 <putchar>
    80200d68:	fd9ff06f          	j	80200d40 <print+0x4a8>
        switch (c) {
    80200d6c:	000a0913          	mv	s2,s4
    80200d70:	0080006f          	j	80200d78 <print+0x4e0>
    80200d74:	000a0913          	mv	s2,s4
                if ((s = va_arg(ap, char*)) == 0) {
    80200d78:	008a8d93          	addi	s11,s5,8
    80200d7c:	000ab583          	ld	a1,0(s5)
    80200d80:	02058663          	beqz	a1,80200dac <print+0x514>
                printString(buf, s, width, ladjust);
    80200d84:	00078693          	mv	a3,a5
    80200d88:	00070613          	mv	a2,a4
    80200d8c:	f1040513          	addi	a0,s0,-240
    80200d90:	00000097          	auipc	ra,0x0
    80200d94:	834080e7          	jalr	-1996(ra) # 802005c4 <printString>
    while (*s) {
    80200d98:	f1044783          	lbu	a5,-240(s0)
    80200d9c:	06078663          	beqz	a5,80200e08 <print+0x570>
    80200da0:	f1040a13          	addi	s4,s0,-240
        if (*s == '\n') {
    80200da4:	00a00a93          	li	s5,10
    80200da8:	0280006f          	j	80200dd0 <print+0x538>
                    s = "(null)";
    80200dac:	00014597          	auipc	a1,0x14
    80200db0:	2bc58593          	addi	a1,a1,700 # 80215068 <textEnd+0x68>
    80200db4:	fd1ff06f          	j	80200d84 <print+0x4ec>
        putchar(*s++);
    80200db8:	001a0a13          	addi	s4,s4,1
    80200dbc:	fffa4503          	lbu	a0,-1(s4)
    80200dc0:	fffff097          	auipc	ra,0xfffff
    80200dc4:	658080e7          	jalr	1624(ra) # 80200418 <putchar>
    while (*s) {
    80200dc8:	000a4783          	lbu	a5,0(s4)
    80200dcc:	00078c63          	beqz	a5,80200de4 <print+0x54c>
        if (*s == '\n') {
    80200dd0:	ff5794e3          	bne	a5,s5,80200db8 <print+0x520>
            putchar('\r');
    80200dd4:	00d00513          	li	a0,13
    80200dd8:	fffff097          	auipc	ra,0xfffff
    80200ddc:	640080e7          	jalr	1600(ra) # 80200418 <putchar>
    80200de0:	fd9ff06f          	j	80200db8 <print+0x520>
                if ((s = va_arg(ap, char*)) == 0) {
    80200de4:	000d8a93          	mv	s5,s11
    80200de8:	b35ff06f          	j	8020091c <print+0x84>
                i--;
    80200dec:	fffa091b          	addiw	s2,s4,-1
                break;
    80200df0:	b2dff06f          	j	8020091c <print+0x84>
            c = fmt[++i];
    80200df4:	0005051b          	sext.w	a0,a0
                putchar(c);
    80200df8:	fffff097          	auipc	ra,0xfffff
    80200dfc:	620080e7          	jalr	1568(ra) # 80200418 <putchar>
                break;
    80200e00:	000a0913          	mv	s2,s4
    80200e04:	b19ff06f          	j	8020091c <print+0x84>
                if ((s = va_arg(ap, char*)) == 0) {
    80200e08:	000d8a93          	mv	s5,s11
    80200e0c:	b11ff06f          	j	8020091c <print+0x84>
}
    80200e10:	0e813083          	ld	ra,232(sp)
    80200e14:	0e013403          	ld	s0,224(sp)
    80200e18:	0d813483          	ld	s1,216(sp)
    80200e1c:	0d013903          	ld	s2,208(sp)
    80200e20:	0c813983          	ld	s3,200(sp)
    80200e24:	0c013a03          	ld	s4,192(sp)
    80200e28:	0b813a83          	ld	s5,184(sp)
    80200e2c:	0b013b03          	ld	s6,176(sp)
    80200e30:	0a813b83          	ld	s7,168(sp)
    80200e34:	0a013c03          	ld	s8,160(sp)
    80200e38:	09813c83          	ld	s9,152(sp)
    80200e3c:	09013d03          	ld	s10,144(sp)
    80200e40:	08813d83          	ld	s11,136(sp)
    80200e44:	0f010113          	addi	sp,sp,240
    80200e48:	00008067          	ret
    80200e4c:	00008067          	ret

0000000080200e50 <printf>:
void printf(const char *fmt, ...) {
    80200e50:	fa010113          	addi	sp,sp,-96
    80200e54:	00113c23          	sd	ra,24(sp)
    80200e58:	00813823          	sd	s0,16(sp)
    80200e5c:	02010413          	addi	s0,sp,32
    80200e60:	00b43423          	sd	a1,8(s0)
    80200e64:	00c43823          	sd	a2,16(s0)
    80200e68:	00d43c23          	sd	a3,24(s0)
    80200e6c:	02e43023          	sd	a4,32(s0)
    80200e70:	02f43423          	sd	a5,40(s0)
    80200e74:	03043823          	sd	a6,48(s0)
    80200e78:	03143c23          	sd	a7,56(s0)
    va_start(ap, fmt);
    80200e7c:	00840593          	addi	a1,s0,8
    80200e80:	feb43423          	sd	a1,-24(s0)
    print(fmt, ap);
    80200e84:	00000097          	auipc	ra,0x0
    80200e88:	a14080e7          	jalr	-1516(ra) # 80200898 <print>
}
    80200e8c:	01813083          	ld	ra,24(sp)
    80200e90:	01013403          	ld	s0,16(sp)
    80200e94:	06010113          	addi	sp,sp,96
    80200e98:	00008067          	ret

0000000080200e9c <panicPrintf>:

void panicPrintf(const char *fmt, ...) {
    80200e9c:	fa010113          	addi	sp,sp,-96
    80200ea0:	00113c23          	sd	ra,24(sp)
    80200ea4:	00813823          	sd	s0,16(sp)
    80200ea8:	02010413          	addi	s0,sp,32
    80200eac:	00b43423          	sd	a1,8(s0)
    80200eb0:	00c43823          	sd	a2,16(s0)
    80200eb4:	00d43c23          	sd	a3,24(s0)
    80200eb8:	02e43023          	sd	a4,32(s0)
    80200ebc:	02f43423          	sd	a5,40(s0)
    80200ec0:	03043823          	sd	a6,48(s0)
    80200ec4:	03143c23          	sd	a7,56(s0)
    va_list ap;
    va_start(ap, fmt);
    80200ec8:	00840593          	addi	a1,s0,8
    80200ecc:	feb43423          	sd	a1,-24(s0)
    print(fmt, ap);
    80200ed0:	00000097          	auipc	ra,0x0
    80200ed4:	9c8080e7          	jalr	-1592(ra) # 80200898 <print>
    va_end(ap);
}
    80200ed8:	01813083          	ld	ra,24(sp)
    80200edc:	01013403          	ld	s0,16(sp)
    80200ee0:	06010113          	addi	sp,sp,96
    80200ee4:	00008067          	ret

0000000080200ee8 <_panic_>:

void _panic_(const char *file, int line, const char *func,const char *fmt, ...) {
    80200ee8:	fb010113          	addi	sp,sp,-80
    80200eec:	02113423          	sd	ra,40(sp)
    80200ef0:	02813023          	sd	s0,32(sp)
    80200ef4:	00913c23          	sd	s1,24(sp)
    80200ef8:	03010413          	addi	s0,sp,48
    80200efc:	00058313          	mv	t1,a1
    80200f00:	00068493          	mv	s1,a3
    80200f04:	00e43023          	sd	a4,0(s0)
    80200f08:	00f43423          	sd	a5,8(s0)
    80200f0c:	01043823          	sd	a6,16(s0)
    80200f10:	01143c23          	sd	a7,24(s0)
#define HART_TOTAL_NUMBER 5

// which hart (core) is this?
static inline u64 r_hartid() {
    u64 x;
    asm volatile("mv %0, tp" : "=r" (x) );
    80200f14:	00020593          	mv	a1,tp
    // acquireLock(&printLock);
    panicPrintf("hartId %d panic at %s: %d in %s(): ", r_hartid(), file, line, func);
    80200f18:	00060713          	mv	a4,a2
    80200f1c:	00030693          	mv	a3,t1
    80200f20:	00050613          	mv	a2,a0
    80200f24:	00014517          	auipc	a0,0x14
    80200f28:	14c50513          	addi	a0,a0,332 # 80215070 <textEnd+0x70>
    80200f2c:	00000097          	auipc	ra,0x0
    80200f30:	f70080e7          	jalr	-144(ra) # 80200e9c <panicPrintf>
    va_list ap;
    va_start(ap, fmt);
    80200f34:	fc843c23          	sd	s0,-40(s0)
    print(fmt, ap);
    80200f38:	00040593          	mv	a1,s0
    80200f3c:	00048513          	mv	a0,s1
    80200f40:	00000097          	auipc	ra,0x0
    80200f44:	958080e7          	jalr	-1704(ra) # 80200898 <print>
    va_end(ap);
    putchar('\n');
    80200f48:	00a00513          	li	a0,10
    80200f4c:	fffff097          	auipc	ra,0xfffff
    80200f50:	4cc080e7          	jalr	1228(ra) # 80200418 <putchar>
    // releaseLock(&printLock);
    //timerTick();
    //w_sstatus(r_sstatus() | SSTATUS_SIE);
    while (true);
    80200f54:	0000006f          	j	80200f54 <_panic_+0x6c>

0000000080200f58 <_assert_>:
}

void _assert_(const char* file, int line, const char *func, u64 statement) {
    if (!statement) {
    80200f58:	00068463          	beqz	a3,80200f60 <_assert_+0x8>
    80200f5c:	00008067          	ret
void _assert_(const char* file, int line, const char *func, u64 statement) {
    80200f60:	ff010113          	addi	sp,sp,-16
    80200f64:	00113423          	sd	ra,8(sp)
    80200f68:	00813023          	sd	s0,0(sp)
    80200f6c:	01010413          	addi	s0,sp,16
        _panic_(file, line, func, "assert failed\n");
    80200f70:	00014697          	auipc	a3,0x14
    80200f74:	12868693          	addi	a3,a3,296 # 80215098 <textEnd+0x98>
    80200f78:	00000097          	auipc	ra,0x0
    80200f7c:	f70080e7          	jalr	-144(ra) # 80200ee8 <_panic_>

0000000080200f80 <sd_cmd>:
{
	return spi_xfer(0xFF);
}

static u8 sd_cmd(u8 cmd, u32 arg, u8 crc)
{
    80200f80:	fe010113          	addi	sp,sp,-32
    80200f84:	00113c23          	sd	ra,24(sp)
    80200f88:	00813823          	sd	s0,16(sp)
    80200f8c:	00913423          	sd	s1,8(sp)
    80200f90:	02010413          	addi	s0,sp,32
	unsigned long n;
	u8 r;

	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_HOLD;
    80200f94:	100507b7          	lui	a5,0x10050
    80200f98:	00200713          	li	a4,2
    80200f9c:	00e7ac23          	sw	a4,24(a5) # 10050018 <_start-0x701affe8>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200fa0:	0ff00713          	li	a4,255
    80200fa4:	04e7a423          	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200fa8:	10050737          	lui	a4,0x10050
    80200fac:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    80200fb0:	fe07cee3          	bltz	a5,80200fac <sd_cmd+0x2c>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200fb4:	0005051b          	sext.w	a0,a0
    80200fb8:	100507b7          	lui	a5,0x10050
    80200fbc:	04a7a423          	sw	a0,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80200fc0:	10050737          	lui	a4,0x10050
    80200fc4:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    80200fc8:	fe07cee3          	bltz	a5,80200fc4 <sd_cmd+0x44>
	sd_dummy();
	spi_xfer(cmd);
	spi_xfer(arg >> 24);
    80200fcc:	0185d79b          	srliw	a5,a1,0x18
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200fd0:	10050737          	lui	a4,0x10050
    80200fd4:	04f72423          	sw	a5,72(a4) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80200fd8:	04c72783          	lw	a5,76(a4)
	} while (r < 0);
    80200fdc:	fe07cee3          	bltz	a5,80200fd8 <sd_cmd+0x58>
	spi_xfer(arg >> 16);
    80200fe0:	0105d79b          	srliw	a5,a1,0x10
    80200fe4:	0ff7f793          	zext.b	a5,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200fe8:	10050737          	lui	a4,0x10050
    80200fec:	04f72423          	sw	a5,72(a4) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80200ff0:	04c72783          	lw	a5,76(a4)
	} while (r < 0);
    80200ff4:	fe07cee3          	bltz	a5,80200ff0 <sd_cmd+0x70>
	spi_xfer(arg >> 8);
    80200ff8:	0085d79b          	srliw	a5,a1,0x8
    80200ffc:	0ff7f793          	zext.b	a5,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201000:	10050737          	lui	a4,0x10050
    80201004:	04f72423          	sw	a5,72(a4) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201008:	04c72783          	lw	a5,76(a4)
	} while (r < 0);
    8020100c:	fe07cee3          	bltz	a5,80201008 <sd_cmd+0x88>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201010:	0ff5f593          	zext.b	a1,a1
    80201014:	100507b7          	lui	a5,0x10050
    80201018:	04b7a423          	sw	a1,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020101c:	10050737          	lui	a4,0x10050
    80201020:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    80201024:	fe07cee3          	bltz	a5,80201020 <sd_cmd+0xa0>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201028:	0006079b          	sext.w	a5,a2
    8020102c:	10050737          	lui	a4,0x10050
    80201030:	04f72423          	sw	a5,72(a4) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201034:	04c72783          	lw	a5,76(a4)
	} while (r < 0);
    80201038:	fe07cee3          	bltz	a5,80201034 <sd_cmd+0xb4>
    8020103c:	3e800693          	li	a3,1000
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201040:	10050737          	lui	a4,0x10050
    80201044:	04870593          	addi	a1,a4,72 # 10050048 <_start-0x701affb8>
    80201048:	0ff00613          	li	a2,255
    8020104c:	00c5a023          	sw	a2,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201050:	04c72783          	lw	a5,76(a4)
    80201054:	0007849b          	sext.w	s1,a5
	} while (r < 0);
    80201058:	fe07cce3          	bltz	a5,80201050 <sd_cmd+0xd0>
	spi_xfer(crc);

	n = 1000;
	do {
		r = sd_dummy();
		if (!(r & 0x80)) {
    8020105c:	0184979b          	slliw	a5,s1,0x18
    80201060:	4187d79b          	sraiw	a5,a5,0x18
    80201064:	0007de63          	bgez	a5,80201080 <sd_cmd+0x100>
			//printf("sd:cmd: %x\r\n", r);
			goto done;
		}
	} while (--n > 0);
    80201068:	fff68693          	addi	a3,a3,-1
    8020106c:	fe0690e3          	bnez	a3,8020104c <sd_cmd+0xcc>
	printf("sd_cmd: timeout\n");
    80201070:	00014517          	auipc	a0,0x14
    80201074:	1e050513          	addi	a0,a0,480 # 80215250 <textEnd+0x250>
    80201078:	00000097          	auipc	ra,0x0
    8020107c:	dd8080e7          	jalr	-552(ra) # 80200e50 <printf>
done:
	return (r & 0xFF);
}
    80201080:	0ff4f513          	zext.b	a0,s1
    80201084:	01813083          	ld	ra,24(sp)
    80201088:	01013403          	ld	s0,16(sp)
    8020108c:	00813483          	ld	s1,8(sp)
    80201090:	02010113          	addi	sp,sp,32
    80201094:	00008067          	ret

0000000080201098 <sdRead>:
#define SPIN_INDEX(i)	(((i) >> SPIN_SHIFT) & 0x3)

//static const char spinner[] = { '-', '/', '|', '\\' };


int sdRead(u8 *buf, u64 startSector, u32 sectorNumber) {
    80201098:	fb010113          	addi	sp,sp,-80
    8020109c:	04113423          	sd	ra,72(sp)
    802010a0:	04813023          	sd	s0,64(sp)
    802010a4:	02913c23          	sd	s1,56(sp)
    802010a8:	03213823          	sd	s2,48(sp)
    802010ac:	03313423          	sd	s3,40(sp)
    802010b0:	03413023          	sd	s4,32(sp)
    802010b4:	01513c23          	sd	s5,24(sp)
    802010b8:	01613823          	sd	s6,16(sp)
    802010bc:	01713423          	sd	s7,8(sp)
    802010c0:	01813023          	sd	s8,0(sp)
    802010c4:	05010413          	addi	s0,sp,80
    802010c8:	00050c13          	mv	s8,a0
	// printf("[SD Read]Read: %x\n", startSector);
	int readTimes = 0;
    802010cc:	00000993          	li	s3,0
	int tot = 0;

start: 
	tot = sectorNumber;
    802010d0:	00060b93          	mv	s7,a2
	int timeout;
	u8 x;
	#ifdef QEMU
	if (sd_cmd(0x52, startSector * 512, 0xE1) != 0x00) {
	#else
	if (sd_cmd(0x52, startSector, 0xE1) != 0x00) {
    802010d4:	00058b1b          	sext.w	s6,a1
	int readTimes = 0;
    802010d8:	0000c7b7          	lui	a5,0xc
    802010dc:	34f78a93          	addi	s5,a5,847 # c34f <_start-0x801f3cb1>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802010e0:	0ff00913          	li	s2,255
    802010e4:	00090493          	mv	s1,s2
    802010e8:	0e80006f          	j	802011d0 <sdRead+0x138>
    802010ec:	100507b7          	lui	a5,0x10050
    802010f0:	0ff00713          	li	a4,255
    802010f4:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802010f8:	04c7a703          	lw	a4,76(a5)
	} while (r < 0);
    802010fc:	fe074ee3          	bltz	a4,802010f8 <sdRead+0x60>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201100:	100507b7          	lui	a5,0x10050
    80201104:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	#endif
		sd_cmd_end();
		panic("[SD Read]Read Error, retry times %x\n", readTimes);
    80201108:	00098713          	mv	a4,s3
    8020110c:	00014697          	auipc	a3,0x14
    80201110:	15c68693          	addi	a3,a3,348 # 80215268 <textEnd+0x268>
    80201114:	00015617          	auipc	a2,0x15
    80201118:	62c60613          	addi	a2,a2,1580 # 80216740 <__func__.2>
    8020111c:	0bc00593          	li	a1,188
    80201120:	00014517          	auipc	a0,0x14
    80201124:	17050513          	addi	a0,a0,368 # 80215290 <textEnd+0x290>
    80201128:	00000097          	auipc	ra,0x0
    8020112c:	dc0080e7          	jalr	-576(ra) # 80200ee8 <_panic_>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201130:	04868513          	addi	a0,a3,72
    80201134:	0080006f          	j	8020113c <sdRead+0xa4>
			goto retry;
		}

		do {
			u8 x = sd_dummy();
			*p++ = x;
    80201138:	00078613          	mv	a2,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020113c:	00952023          	sw	s1,0(a0)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201140:	04c6a783          	lw	a5,76(a3)
    80201144:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80201148:	fe07cce3          	bltz	a5,80201140 <sdRead+0xa8>
	return (r & 0xFF);
    8020114c:	0ff77713          	zext.b	a4,a4
			*p++ = x;
    80201150:	00160793          	addi	a5,a2,1
    80201154:	00e60023          	sb	a4,0(a2)
		} while (--n > 0);
    80201158:	feb790e3          	bne	a5,a1,80201138 <sdRead+0xa0>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020115c:	0526a423          	sw	s2,72(a3)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201160:	04c6a783          	lw	a5,76(a3)
	} while (r < 0);
    80201164:	fe07cee3          	bltz	a5,80201160 <sdRead+0xc8>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201168:	0526a423          	sw	s2,72(a3)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020116c:	04c6a783          	lw	a5,76(a3)
	} while (r < 0);
    80201170:	fe07cee3          	bltz	a5,8020116c <sdRead+0xd4>

		sd_dummy();
		sd_dummy();
	} while (--tot > 0);
    80201174:	fffa0a1b          	addiw	s4,s4,-1
    80201178:	20058593          	addi	a1,a1,512
    8020117c:	09405063          	blez	s4,802011fc <sdRead+0x164>
    80201180:	e0058613          	addi	a2,a1,-512
	int readTimes = 0;
    80201184:	000a8513          	mv	a0,s5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201188:	04868893          	addi	a7,a3,72
    8020118c:	0098a023          	sw	s1,0(a7)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201190:	04c6a783          	lw	a5,76(a3)
    80201194:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80201198:	fe07cce3          	bltz	a5,80201190 <sdRead+0xf8>
			if (x == 0xFE)
    8020119c:	0ff77713          	zext.b	a4,a4
    802011a0:	f90708e3          	beq	a4,a6,80201130 <sdRead+0x98>
		while (--timeout) {
    802011a4:	fff5051b          	addiw	a0,a0,-1
    802011a8:	fe0512e3          	bnez	a0,8020118c <sdRead+0xf4>
	// printf("\nread end\n");
	// printf("[SD Read]Finish\n");
	return rc;

retry:
	readTimes++;
    802011ac:	0019899b          	addiw	s3,s3,1
	if (readTimes > 10) {
    802011b0:	00b00793          	li	a5,11
    802011b4:	08f98663          	beq	s3,a5,80201240 <sdRead+0x1a8>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802011b8:	100507b7          	lui	a5,0x10050
    802011bc:	0527a423          	sw	s2,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802011c0:	04c7a703          	lw	a4,76(a5)
	} while (r < 0);
    802011c4:	fe074ee3          	bltz	a4,802011c0 <sdRead+0x128>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802011c8:	100507b7          	lui	a5,0x10050
    802011cc:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	tot = sectorNumber;
    802011d0:	000b8a13          	mv	s4,s7
	if (sd_cmd(0x52, startSector, 0xE1) != 0x00) {
    802011d4:	0e100613          	li	a2,225
    802011d8:	000b0593          	mv	a1,s6
    802011dc:	05200513          	li	a0,82
    802011e0:	00000097          	auipc	ra,0x0
    802011e4:	da0080e7          	jalr	-608(ra) # 80200f80 <sd_cmd>
    802011e8:	f00512e3          	bnez	a0,802010ec <sdRead+0x54>
    802011ec:	200c0593          	addi	a1,s8,512
	REG32(spi, SPI_REG_TXFIFO) = d;
    802011f0:	100506b7          	lui	a3,0x10050
			if (x == 0xFE)
    802011f4:	0fe00813          	li	a6,254
    802011f8:	f89ff06f          	j	80201180 <sdRead+0xe8>
	sd_cmd(0x4C, 0, 0x01);
    802011fc:	00100613          	li	a2,1
    80201200:	00000593          	li	a1,0
    80201204:	04c00513          	li	a0,76
    80201208:	00000097          	auipc	ra,0x0
    8020120c:	d78080e7          	jalr	-648(ra) # 80200f80 <sd_cmd>
    80201210:	000a8613          	mv	a2,s5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201214:	100506b7          	lui	a3,0x10050
    80201218:	04868593          	addi	a1,a3,72 # 10050048 <_start-0x701affb8>
    8020121c:	0095a023          	sw	s1,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201220:	04c6a783          	lw	a5,76(a3)
    80201224:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80201228:	fe07cce3          	bltz	a5,80201220 <sdRead+0x188>
		if (x == 0xFF) {
    8020122c:	0ff77713          	zext.b	a4,a4
    80201230:	03270a63          	beq	a4,s2,80201264 <sdRead+0x1cc>
	while (--timeout) {
    80201234:	fff6061b          	addiw	a2,a2,-1
    80201238:	fe0612e3          	bnez	a2,8020121c <sdRead+0x184>
    8020123c:	f71ff06f          	j	802011ac <sdRead+0x114>
		panic("[SD Read]There must be some error in sd read");
    80201240:	00014697          	auipc	a3,0x14
    80201244:	05868693          	addi	a3,a3,88 # 80215298 <textEnd+0x298>
    80201248:	00015617          	auipc	a2,0x15
    8020124c:	4f860613          	addi	a2,a2,1272 # 80216740 <__func__.2>
    80201250:	0ee00593          	li	a1,238
    80201254:	00014517          	auipc	a0,0x14
    80201258:	03c50513          	addi	a0,a0,60 # 80215290 <textEnd+0x290>
    8020125c:	00000097          	auipc	ra,0x0
    80201260:	c8c080e7          	jalr	-884(ra) # 80200ee8 <_panic_>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201264:	100507b7          	lui	a5,0x10050
    80201268:	0ff00713          	li	a4,255
    8020126c:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201270:	04c7a703          	lw	a4,76(a5)
	} while (r < 0);
    80201274:	fe074ee3          	bltz	a4,80201270 <sdRead+0x1d8>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201278:	100507b7          	lui	a5,0x10050
    8020127c:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	}
	sd_cmd_end();
	goto start;
}
    80201280:	00000513          	li	a0,0
    80201284:	04813083          	ld	ra,72(sp)
    80201288:	04013403          	ld	s0,64(sp)
    8020128c:	03813483          	ld	s1,56(sp)
    80201290:	03013903          	ld	s2,48(sp)
    80201294:	02813983          	ld	s3,40(sp)
    80201298:	02013a03          	ld	s4,32(sp)
    8020129c:	01813a83          	ld	s5,24(sp)
    802012a0:	01013b03          	ld	s6,16(sp)
    802012a4:	00813b83          	ld	s7,8(sp)
    802012a8:	00013c03          	ld	s8,0(sp)
    802012ac:	05010113          	addi	sp,sp,80
    802012b0:	00008067          	ret

00000000802012b4 <sdCardRead>:
	}
	sd_cmd_end();
	goto start;
}

int sdCardRead(int isUser, u64 dst, u64 startAddr, u64 n) {
    802012b4:	dd010113          	addi	sp,sp,-560
    802012b8:	22113423          	sd	ra,552(sp)
    802012bc:	22813023          	sd	s0,544(sp)
    802012c0:	20913c23          	sd	s1,536(sp)
    802012c4:	21213823          	sd	s2,528(sp)
    802012c8:	21313423          	sd	s3,520(sp)
    802012cc:	21413023          	sd	s4,512(sp)
    802012d0:	23010413          	addi	s0,sp,560
	if (n & ((1 << 9) - 1)) {
    802012d4:	1ff6f793          	andi	a5,a3,511
    802012d8:	06079863          	bnez	a5,80201348 <sdCardRead+0x94>
    802012dc:	00050a13          	mv	s4,a0
    802012e0:	00058493          	mv	s1,a1
		printf("[SD] Card Read error\n");
		return -1;
	}
	if (startAddr & ((1 << 9) - 1)) {
    802012e4:	1ff67793          	andi	a5,a2,511
    802012e8:	06079c63          	bnez	a5,80201360 <sdCardRead+0xac>
		printf("[SD] Card Read error\n");
		return -1;	
	}

	if (isUser) {
    802012ec:	08051663          	bnez	a0,80201378 <sdCardRead+0xc4>
			dst += 512;
			st++;
		}
		return 0;
	}
	int st = (startAddr) >> 9;
    802012f0:	00965993          	srli	s3,a2,0x9
    802012f4:	0009899b          	sext.w	s3,s3
	for (int i = 0; i < n; i++) {
    802012f8:	02068663          	beqz	a3,80201324 <sdCardRead+0x70>
    802012fc:	00098913          	mv	s2,s3
    80201300:	00d989b3          	add	s3,s3,a3
		sdRead((u8*)dst, st, 1);
    80201304:	00100613          	li	a2,1
    80201308:	00090593          	mv	a1,s2
    8020130c:	00048513          	mv	a0,s1
    80201310:	00000097          	auipc	ra,0x0
    80201314:	d88080e7          	jalr	-632(ra) # 80201098 <sdRead>
		dst += 512;
    80201318:	20048493          	addi	s1,s1,512
	for (int i = 0; i < n; i++) {
    8020131c:	00190913          	addi	s2,s2,1
    80201320:	ff3912e3          	bne	s2,s3,80201304 <sdCardRead+0x50>
		st++;
	}
	return 0;
}
    80201324:	000a0513          	mv	a0,s4
    80201328:	22813083          	ld	ra,552(sp)
    8020132c:	22013403          	ld	s0,544(sp)
    80201330:	21813483          	ld	s1,536(sp)
    80201334:	21013903          	ld	s2,528(sp)
    80201338:	20813983          	ld	s3,520(sp)
    8020133c:	20013a03          	ld	s4,512(sp)
    80201340:	23010113          	addi	sp,sp,560
    80201344:	00008067          	ret
		printf("[SD] Card Read error\n");
    80201348:	00014517          	auipc	a0,0x14
    8020134c:	f8050513          	addi	a0,a0,-128 # 802152c8 <textEnd+0x2c8>
    80201350:	00000097          	auipc	ra,0x0
    80201354:	b00080e7          	jalr	-1280(ra) # 80200e50 <printf>
		return -1;
    80201358:	fff00a13          	li	s4,-1
    8020135c:	fc9ff06f          	j	80201324 <sdCardRead+0x70>
		printf("[SD] Card Read error\n");
    80201360:	00014517          	auipc	a0,0x14
    80201364:	f6850513          	addi	a0,a0,-152 # 802152c8 <textEnd+0x2c8>
    80201368:	00000097          	auipc	ra,0x0
    8020136c:	ae8080e7          	jalr	-1304(ra) # 80200e50 <printf>
		return -1;	
    80201370:	fff00a13          	li	s4,-1
    80201374:	fb1ff06f          	j	80201324 <sdCardRead+0x70>
		int st = (startAddr) >> 9;
    80201378:	00965913          	srli	s2,a2,0x9
    8020137c:	0009091b          	sext.w	s2,s2
		for (int i = 0; i < n; i++) {
    80201380:	04068663          	beqz	a3,802013cc <sdCardRead+0x118>
    80201384:	00090993          	mv	s3,s2
    80201388:	00d90933          	add	s2,s2,a3
			sdRead((u8*)buf, st, 1);
    8020138c:	00100613          	li	a2,1
    80201390:	00098593          	mv	a1,s3
    80201394:	dd040513          	addi	a0,s0,-560
    80201398:	00000097          	auipc	ra,0x0
    8020139c:	d00080e7          	jalr	-768(ra) # 80201098 <sdRead>
			copyout(myProcess()->pgdir, dst, buf, 512);
    802013a0:	0000e097          	auipc	ra,0xe
    802013a4:	648080e7          	jalr	1608(ra) # 8020f9e8 <myProcess>
    802013a8:	20000693          	li	a3,512
    802013ac:	dd040613          	addi	a2,s0,-560
    802013b0:	00048593          	mv	a1,s1
    802013b4:	04053503          	ld	a0,64(a0)
    802013b8:	00008097          	auipc	ra,0x8
    802013bc:	780080e7          	jalr	1920(ra) # 80209b38 <copyout>
			dst += 512;
    802013c0:	20048493          	addi	s1,s1,512
		for (int i = 0; i < n; i++) {
    802013c4:	00198993          	addi	s3,s3,1
    802013c8:	fd2992e3          	bne	s3,s2,8020138c <sdCardRead+0xd8>
		return 0;
    802013cc:	00000a13          	li	s4,0
    802013d0:	f55ff06f          	j	80201324 <sdCardRead+0x70>

00000000802013d4 <sdWrite>:
	for (int i = 0; i < sectorNumber; i++) {
    802013d4:	20060e63          	beqz	a2,802015f0 <sdWrite+0x21c>
int sdWrite(u8 *buf, u64 startSector, u32 sectorNumber) {
    802013d8:	f8010113          	addi	sp,sp,-128
    802013dc:	06113c23          	sd	ra,120(sp)
    802013e0:	06813823          	sd	s0,112(sp)
    802013e4:	06913423          	sd	s1,104(sp)
    802013e8:	07213023          	sd	s2,96(sp)
    802013ec:	05313c23          	sd	s3,88(sp)
    802013f0:	05413823          	sd	s4,80(sp)
    802013f4:	05513423          	sd	s5,72(sp)
    802013f8:	05613023          	sd	s6,64(sp)
    802013fc:	03713c23          	sd	s7,56(sp)
    80201400:	03813823          	sd	s8,48(sp)
    80201404:	03913423          	sd	s9,40(sp)
    80201408:	03a13023          	sd	s10,32(sp)
    8020140c:	01b13c23          	sd	s11,24(sp)
    80201410:	08010413          	addi	s0,sp,128
    80201414:	00058d13          	mv	s10,a1
    80201418:	20050913          	addi	s2,a0,512
    8020141c:	00060a9b          	sext.w	s5,a2
	for (int i = 0; i < sectorNumber; i++) {
    80201420:	00000b93          	li	s7,0
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201424:	100504b7          	lui	s1,0x10050
    80201428:	0ff00993          	li	s3,255
    8020142c:	0000cc37          	lui	s8,0xc
    80201430:	34fc0793          	addi	a5,s8,847 # c34f <_start-0x801f3cb1>
    80201434:	f8f43023          	sd	a5,-128(s0)
    80201438:	00098a13          	mv	s4,s3
    8020143c:	e0090793          	addi	a5,s2,-512
    80201440:	f8f43423          	sd	a5,-120(s0)
		writeTimes = 0;
    80201444:	00000b13          	li	s6,0
		if (sd_cmd(24 | 0x40, now, 0) != 0) {
    80201448:	017d0cbb          	addw	s9,s10,s7
    8020144c:	350c0d93          	addi	s11,s8,848
    80201450:	0e40006f          	j	80201534 <sdWrite+0x160>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201454:	100507b7          	lui	a5,0x10050
    80201458:	0ff00713          	li	a4,255
    8020145c:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201460:	04c7a703          	lw	a4,76(a5)
	} while (r < 0);
    80201464:	fe074ee3          	bltz	a4,80201460 <sdWrite+0x8c>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201468:	100507b7          	lui	a5,0x10050
    8020146c:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
			panic("[SD Write]Write Error, can't use cmd24, retry times %x\n", writeTimes);
    80201470:	000b0713          	mv	a4,s6
    80201474:	00014697          	auipc	a3,0x14
    80201478:	e6c68693          	addi	a3,a3,-404 # 802152e0 <textEnd+0x2e0>
    8020147c:	00015617          	auipc	a2,0x15
    80201480:	2bc60613          	addi	a2,a2,700 # 80216738 <__func__.1>
    80201484:	19300593          	li	a1,403
    80201488:	00014517          	auipc	a0,0x14
    8020148c:	e0850513          	addi	a0,a0,-504 # 80215290 <textEnd+0x290>
    80201490:	00000097          	auipc	ra,0x0
    80201494:	a58080e7          	jalr	-1448(ra) # 80200ee8 <_panic_>
    80201498:	000d8693          	mv	a3,s11
		while (--timeout) {
    8020149c:	fff6869b          	addiw	a3,a3,-1
    802014a0:	06068c63          	beqz	a3,80201518 <sdWrite+0x144>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802014a4:	0534a423          	sw	s3,72(s1) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802014a8:	04c4a783          	lw	a5,76(s1)
    802014ac:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    802014b0:	fe07cce3          	bltz	a5,802014a8 <sdWrite+0xd4>
			if (x == 0xFF) {
    802014b4:	0ff77713          	zext.b	a4,a4
    802014b8:	ff3712e3          	bne	a4,s3,8020149c <sdWrite+0xc8>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802014bc:	0534a423          	sw	s3,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    802014c0:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    802014c4:	fe07cee3          	bltz	a5,802014c0 <sdWrite+0xec>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802014c8:	0004ac23          	sw	zero,24(s1)
	for (int i = 0; i < sectorNumber; i++) {
    802014cc:	001b8b9b          	addiw	s7,s7,1
    802014d0:	20090913          	addi	s2,s2,512
    802014d4:	f75b94e3          	bne	s7,s5,8020143c <sdWrite+0x68>
}
    802014d8:	00000513          	li	a0,0
    802014dc:	07813083          	ld	ra,120(sp)
    802014e0:	07013403          	ld	s0,112(sp)
    802014e4:	06813483          	ld	s1,104(sp)
    802014e8:	06013903          	ld	s2,96(sp)
    802014ec:	05813983          	ld	s3,88(sp)
    802014f0:	05013a03          	ld	s4,80(sp)
    802014f4:	04813a83          	ld	s5,72(sp)
    802014f8:	04013b03          	ld	s6,64(sp)
    802014fc:	03813b83          	ld	s7,56(sp)
    80201500:	03013c03          	ld	s8,48(sp)
    80201504:	02813c83          	ld	s9,40(sp)
    80201508:	02013d03          	ld	s10,32(sp)
    8020150c:	01813d83          	ld	s11,24(sp)
    80201510:	08010113          	addi	sp,sp,128
    80201514:	00008067          	ret
	writeTimes++;
    80201518:	001b0b1b          	addiw	s6,s6,1
	if (writeTimes > 10) {
    8020151c:	00b00793          	li	a5,11
    80201520:	0afb0663          	beq	s6,a5,802015cc <sdWrite+0x1f8>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201524:	0534a423          	sw	s3,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201528:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    8020152c:	fe07cee3          	bltz	a5,80201528 <sdWrite+0x154>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201530:	0004ac23          	sw	zero,24(s1)
		if (sd_cmd(24 | 0x40, now, 0) != 0) {
    80201534:	00000613          	li	a2,0
    80201538:	000c8593          	mv	a1,s9
    8020153c:	05800513          	li	a0,88
    80201540:	00000097          	auipc	ra,0x0
    80201544:	a40080e7          	jalr	-1472(ra) # 80200f80 <sd_cmd>
    80201548:	f00516e3          	bnez	a0,80201454 <sdWrite+0x80>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020154c:	0534a423          	sw	s3,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201550:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    80201554:	fe07cee3          	bltz	a5,80201550 <sdWrite+0x17c>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201558:	0534a423          	sw	s3,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020155c:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    80201560:	fe07cee3          	bltz	a5,8020155c <sdWrite+0x188>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201564:	0534a423          	sw	s3,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201568:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    8020156c:	fe07cee3          	bltz	a5,80201568 <sdWrite+0x194>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201570:	0fe00793          	li	a5,254
    80201574:	04f4a423          	sw	a5,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201578:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    8020157c:	fe07cee3          	bltz	a5,80201578 <sdWrite+0x1a4>
    80201580:	f8843703          	ld	a4,-120(s0)
			spi_xfer(*p++);
    80201584:	00170713          	addi	a4,a4,1
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201588:	fff74783          	lbu	a5,-1(a4)
    8020158c:	04f4a423          	sw	a5,72(s1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201590:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    80201594:	fe07cee3          	bltz	a5,80201590 <sdWrite+0x1bc>
		} while (--n > 0);
    80201598:	ff2716e3          	bne	a4,s2,80201584 <sdWrite+0x1b0>
    8020159c:	f8043683          	ld	a3,-128(s0)
	REG32(spi, SPI_REG_TXFIFO) = d;
    802015a0:	04848593          	addi	a1,s1,72
			if (5 == (x & 0x1f)) {
    802015a4:	00500613          	li	a2,5
	REG32(spi, SPI_REG_TXFIFO) = d;
    802015a8:	0145a023          	sw	s4,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    802015ac:	04c4a783          	lw	a5,76(s1)
    802015b0:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    802015b4:	fe07cce3          	bltz	a5,802015ac <sdWrite+0x1d8>
			if (5 == (x & 0x1f)) {
    802015b8:	01f77713          	andi	a4,a4,31
    802015bc:	ecc70ee3          	beq	a4,a2,80201498 <sdWrite+0xc4>
		while (--timeout) {
    802015c0:	fff6869b          	addiw	a3,a3,-1
    802015c4:	fe0692e3          	bnez	a3,802015a8 <sdWrite+0x1d4>
    802015c8:	f51ff06f          	j	80201518 <sdWrite+0x144>
		panic("[SD Write]There must be some error in sd write");
    802015cc:	00014697          	auipc	a3,0x14
    802015d0:	d4c68693          	addi	a3,a3,-692 # 80215318 <textEnd+0x318>
    802015d4:	00015617          	auipc	a2,0x15
    802015d8:	16460613          	addi	a2,a2,356 # 80216738 <__func__.1>
    802015dc:	1be00593          	li	a1,446
    802015e0:	00014517          	auipc	a0,0x14
    802015e4:	cb050513          	addi	a0,a0,-848 # 80215290 <textEnd+0x290>
    802015e8:	00000097          	auipc	ra,0x0
    802015ec:	900080e7          	jalr	-1792(ra) # 80200ee8 <_panic_>
}
    802015f0:	00000513          	li	a0,0
    802015f4:	00008067          	ret

00000000802015f8 <sdCardWrite>:

int sdCardWrite(int isUser, u64 src, u64 startAddr, u64 n) {
    802015f8:	dd010113          	addi	sp,sp,-560
    802015fc:	22113423          	sd	ra,552(sp)
    80201600:	22813023          	sd	s0,544(sp)
    80201604:	20913c23          	sd	s1,536(sp)
    80201608:	21213823          	sd	s2,528(sp)
    8020160c:	21313423          	sd	s3,520(sp)
    80201610:	21413023          	sd	s4,512(sp)
    80201614:	23010413          	addi	s0,sp,560
	if (n & ((1 << 9) - 1)) {
    80201618:	1ff6f793          	andi	a5,a3,511
    8020161c:	06079863          	bnez	a5,8020168c <sdCardWrite+0x94>
    80201620:	00050a13          	mv	s4,a0
    80201624:	00058493          	mv	s1,a1
		printf("[SD] Card Write error\n");
		return -1;
	}
	if (startAddr & ((1 << 9) - 1)) {
    80201628:	1ff67793          	andi	a5,a2,511
    8020162c:	06079c63          	bnez	a5,802016a4 <sdCardWrite+0xac>
		printf("[SD] Card Write error\n");
		return -1;	
	}

	if (isUser) {
    80201630:	08051663          	bnez	a0,802016bc <sdCardWrite+0xc4>
			src += 512;
			st++;
		}
		return 0;
	}
	int st = (startAddr) >> 9;
    80201634:	00965993          	srli	s3,a2,0x9
    80201638:	0009899b          	sext.w	s3,s3
	for (int i = 0; i < n; i++) {
    8020163c:	02068663          	beqz	a3,80201668 <sdCardWrite+0x70>
    80201640:	00098913          	mv	s2,s3
    80201644:	00d989b3          	add	s3,s3,a3
		sdWrite((u8*)src, st, 1);
    80201648:	00100613          	li	a2,1
    8020164c:	00090593          	mv	a1,s2
    80201650:	00048513          	mv	a0,s1
    80201654:	00000097          	auipc	ra,0x0
    80201658:	d80080e7          	jalr	-640(ra) # 802013d4 <sdWrite>
		src += 512;
    8020165c:	20048493          	addi	s1,s1,512
	for (int i = 0; i < n; i++) {
    80201660:	00190913          	addi	s2,s2,1
    80201664:	ff3912e3          	bne	s2,s3,80201648 <sdCardWrite+0x50>
		st++;
	}
	return 0;
}
    80201668:	000a0513          	mv	a0,s4
    8020166c:	22813083          	ld	ra,552(sp)
    80201670:	22013403          	ld	s0,544(sp)
    80201674:	21813483          	ld	s1,536(sp)
    80201678:	21013903          	ld	s2,528(sp)
    8020167c:	20813983          	ld	s3,520(sp)
    80201680:	20013a03          	ld	s4,512(sp)
    80201684:	23010113          	addi	sp,sp,560
    80201688:	00008067          	ret
		printf("[SD] Card Write error\n");
    8020168c:	00014517          	auipc	a0,0x14
    80201690:	cbc50513          	addi	a0,a0,-836 # 80215348 <textEnd+0x348>
    80201694:	fffff097          	auipc	ra,0xfffff
    80201698:	7bc080e7          	jalr	1980(ra) # 80200e50 <printf>
		return -1;
    8020169c:	fff00a13          	li	s4,-1
    802016a0:	fc9ff06f          	j	80201668 <sdCardWrite+0x70>
		printf("[SD] Card Write error\n");
    802016a4:	00014517          	auipc	a0,0x14
    802016a8:	ca450513          	addi	a0,a0,-860 # 80215348 <textEnd+0x348>
    802016ac:	fffff097          	auipc	ra,0xfffff
    802016b0:	7a4080e7          	jalr	1956(ra) # 80200e50 <printf>
		return -1;	
    802016b4:	fff00a13          	li	s4,-1
    802016b8:	fb1ff06f          	j	80201668 <sdCardWrite+0x70>
		int st = (startAddr) >> 9;
    802016bc:	00965913          	srli	s2,a2,0x9
    802016c0:	0009091b          	sext.w	s2,s2
		for (int i = 0; i < n; i++) {
    802016c4:	04068663          	beqz	a3,80201710 <sdCardWrite+0x118>
    802016c8:	00090993          	mv	s3,s2
    802016cc:	00d90933          	add	s2,s2,a3
        	copyin(myProcess()->pgdir, buf, src, 512);
    802016d0:	0000e097          	auipc	ra,0xe
    802016d4:	318080e7          	jalr	792(ra) # 8020f9e8 <myProcess>
    802016d8:	20000693          	li	a3,512
    802016dc:	00048613          	mv	a2,s1
    802016e0:	dd040593          	addi	a1,s0,-560
    802016e4:	04053503          	ld	a0,64(a0)
    802016e8:	00008097          	auipc	ra,0x8
    802016ec:	360080e7          	jalr	864(ra) # 80209a48 <copyin>
			sdWrite((u8*)buf, st, 1);
    802016f0:	00100613          	li	a2,1
    802016f4:	00098593          	mv	a1,s3
    802016f8:	dd040513          	addi	a0,s0,-560
    802016fc:	00000097          	auipc	ra,0x0
    80201700:	cd8080e7          	jalr	-808(ra) # 802013d4 <sdWrite>
			src += 512;
    80201704:	20048493          	addi	s1,s1,512
		for (int i = 0; i < n; i++) {
    80201708:	00198993          	addi	s3,s3,1
    8020170c:	fd2992e3          	bne	s3,s2,802016d0 <sdCardWrite+0xd8>
		return 0;
    80201710:	00000a13          	li	s4,0
    80201714:	f55ff06f          	j	80201668 <sdCardWrite+0x70>

0000000080201718 <sdInit>:


int sdInit(void) {
    80201718:	fd010113          	addi	sp,sp,-48
    8020171c:	02113423          	sd	ra,40(sp)
    80201720:	02813023          	sd	s0,32(sp)
    80201724:	00913c23          	sd	s1,24(sp)
    80201728:	01213823          	sd	s2,16(sp)
    8020172c:	01313423          	sd	s3,8(sp)
    80201730:	01413023          	sd	s4,0(sp)
    80201734:	03010413          	addi	s0,sp,48
	REG32(uart, UART_REG_TXCTRL) = UART_TXEN;
    80201738:	100107b7          	lui	a5,0x10010
    8020173c:	00100713          	li	a4,1
    80201740:	00e7a423          	sw	a4,8(a5) # 10010008 <_start-0x701efff8>
	REG32(spi, SPI_REG_FMT) = 0x80000;
    80201744:	100507b7          	lui	a5,0x10050
    80201748:	00080737          	lui	a4,0x80
    8020174c:	04e7a023          	sw	a4,64(a5) # 10050040 <_start-0x701affc0>
	REG32(spi, SPI_REG_CSDEF) |= 1;
    80201750:	0147a703          	lw	a4,20(a5)
    80201754:	00176713          	ori	a4,a4,1
    80201758:	00e7aa23          	sw	a4,20(a5)
	REG32(spi, SPI_REG_CSID) = 0;
    8020175c:	0007a823          	sw	zero,16(a5)
	REG32(spi, SPI_REG_SCKDIV) = f;
    80201760:	00001737          	lui	a4,0x1
    80201764:	bb870713          	addi	a4,a4,-1096 # bb8 <_start-0x801ff448>
    80201768:	00e7a023          	sw	a4,0(a5)
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_OFF;
    8020176c:	00300713          	li	a4,3
    80201770:	00e7ac23          	sw	a4,24(a5)
    80201774:	00a00693          	li	a3,10
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201778:	10050737          	lui	a4,0x10050
    8020177c:	04870593          	addi	a1,a4,72 # 10050048 <_start-0x701affb8>
    80201780:	0ff00613          	li	a2,255
    80201784:	00c5a023          	sw	a2,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80201788:	04c72783          	lw	a5,76(a4)
	} while (r < 0);
    8020178c:	fe07cee3          	bltz	a5,80201788 <sdInit+0x70>
	for (i = 10; i > 0; i--) {
    80201790:	fff68693          	addi	a3,a3,-1
    80201794:	fe0698e3          	bnez	a3,80201784 <sdInit+0x6c>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201798:	100507b7          	lui	a5,0x10050
    8020179c:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>

	sd_poweron(3000);

	int initTimes = 10;
    802017a0:	00a00913          	li	s2,10
	REG32(spi, SPI_REG_TXFIFO) = d;
    802017a4:	100504b7          	lui	s1,0x10050
    802017a8:	0ff00a13          	li	s4,255
	while (initTimes > 0 && sd_cmd0()) {
    802017ac:	00100993          	li	s3,1
	rc = (sd_cmd(0x40, 0, 0x95) != 0x01);
    802017b0:	09500613          	li	a2,149
    802017b4:	00000593          	li	a1,0
    802017b8:	04000513          	li	a0,64
    802017bc:	fffff097          	auipc	ra,0xfffff
    802017c0:	7c4080e7          	jalr	1988(ra) # 80200f80 <sd_cmd>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802017c4:	0544a423          	sw	s4,72(s1) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802017c8:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    802017cc:	fe07cee3          	bltz	a5,802017c8 <sdInit+0xb0>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802017d0:	0004ac23          	sw	zero,24(s1)
	while (initTimes > 0 && sd_cmd0()) {
    802017d4:	03350863          	beq	a0,s3,80201804 <sdInit+0xec>
		initTimes--;
    802017d8:	fff9091b          	addiw	s2,s2,-1
	while (initTimes > 0 && sd_cmd0()) {
    802017dc:	fc091ae3          	bnez	s2,802017b0 <sdInit+0x98>
	}

	if (!initTimes) {
		panic("[SD card]CMD0 error!\n");
    802017e0:	00014697          	auipc	a3,0x14
    802017e4:	b8068693          	addi	a3,a3,-1152 # 80215360 <textEnd+0x360>
    802017e8:	00015617          	auipc	a2,0x15
    802017ec:	f4860613          	addi	a2,a2,-184 # 80216730 <__func__.0>
    802017f0:	20c00593          	li	a1,524
    802017f4:	00014517          	auipc	a0,0x14
    802017f8:	a9c50513          	addi	a0,a0,-1380 # 80215290 <textEnd+0x290>
    802017fc:	fffff097          	auipc	ra,0xfffff
    80201800:	6ec080e7          	jalr	1772(ra) # 80200ee8 <_panic_>
	if (!initTimes) {
    80201804:	fc090ee3          	beqz	s2,802017e0 <sdInit+0xc8>
	rc = (sd_cmd(0x48, 0x000001AA, 0x87) != 0x01);
    80201808:	08700613          	li	a2,135
    8020180c:	1aa00593          	li	a1,426
    80201810:	04800513          	li	a0,72
    80201814:	fffff097          	auipc	ra,0xfffff
    80201818:	76c080e7          	jalr	1900(ra) # 80200f80 <sd_cmd>
    8020181c:	0005071b          	sext.w	a4,a0
    80201820:	fff70713          	addi	a4,a4,-1
    80201824:	00e03633          	snez	a2,a4
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201828:	100507b7          	lui	a5,0x10050
    8020182c:	0ff00713          	li	a4,255
    80201830:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201834:	10050737          	lui	a4,0x10050
    80201838:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    8020183c:	fe07cee3          	bltz	a5,80201838 <sdInit+0x120>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201840:	100507b7          	lui	a5,0x10050
    80201844:	0ff00713          	li	a4,255
    80201848:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020184c:	10050737          	lui	a4,0x10050
    80201850:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    80201854:	fe07cee3          	bltz	a5,80201850 <sdInit+0x138>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201858:	100507b7          	lui	a5,0x10050
    8020185c:	0ff00713          	li	a4,255
    80201860:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201864:	100506b7          	lui	a3,0x10050
    80201868:	04c6a783          	lw	a5,76(a3) # 1005004c <_start-0x701affb4>
    8020186c:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80201870:	fe07cce3          	bltz	a5,80201868 <sdInit+0x150>
	rc |= ((sd_dummy() & 0xF) != 0x1); /* voltage */
    80201874:	00f77713          	andi	a4,a4,15
    80201878:	fff70793          	addi	a5,a4,-1
    8020187c:	00f03733          	snez	a4,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201880:	100507b7          	lui	a5,0x10050
    80201884:	0ff00693          	li	a3,255
    80201888:	04d7a423          	sw	a3,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020188c:	100505b7          	lui	a1,0x10050
    80201890:	04c5a783          	lw	a5,76(a1) # 1005004c <_start-0x701affb4>
    80201894:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    80201898:	fe07cce3          	bltz	a5,80201890 <sdInit+0x178>
	rc |= (sd_dummy() != 0xAA); /* check pattern */
    8020189c:	0ff6f793          	zext.b	a5,a3
    802018a0:	f5678793          	addi	a5,a5,-170
    802018a4:	00f037b3          	snez	a5,a5
    802018a8:	00f767b3          	or	a5,a4,a5
    802018ac:	00f66733          	or	a4,a2,a5
    802018b0:	0ff77713          	zext.b	a4,a4
	REG32(spi, SPI_REG_TXFIFO) = d;
    802018b4:	100507b7          	lui	a5,0x10050
    802018b8:	0ff00693          	li	a3,255
    802018bc:	04d7a423          	sw	a3,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802018c0:	100506b7          	lui	a3,0x10050
    802018c4:	04c6a783          	lw	a5,76(a3) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    802018c8:	fe07cee3          	bltz	a5,802018c4 <sdInit+0x1ac>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802018cc:	100507b7          	lui	a5,0x10050
    802018d0:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	}

	if (sd_cmd8()) {
    802018d4:	1c071863          	bnez	a4,80201aa4 <sdInit+0x38c>
	printf("ACMD41");
    802018d8:	00014517          	auipc	a0,0x14
    802018dc:	ab850513          	addi	a0,a0,-1352 # 80215390 <textEnd+0x390>
    802018e0:	fffff097          	auipc	ra,0xfffff
    802018e4:	570080e7          	jalr	1392(ra) # 80200e50 <printf>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802018e8:	100504b7          	lui	s1,0x10050
    802018ec:	0ff00993          	li	s3,255
	} while (r == 0x01);
    802018f0:	00100913          	li	s2,1
	sd_cmd(0x77, 0, 0x65);
    802018f4:	06500613          	li	a2,101
    802018f8:	00000593          	li	a1,0
    802018fc:	07700513          	li	a0,119
    80201900:	fffff097          	auipc	ra,0xfffff
    80201904:	680080e7          	jalr	1664(ra) # 80200f80 <sd_cmd>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201908:	0534a423          	sw	s3,72(s1) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020190c:	04c4a783          	lw	a5,76(s1)
	} while (r < 0);
    80201910:	fe07cee3          	bltz	a5,8020190c <sdInit+0x1f4>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201914:	0004ac23          	sw	zero,24(s1)
		r = sd_cmd(0x69, 0x40000000, 0x77); /* HCS = 1 */
    80201918:	07700613          	li	a2,119
    8020191c:	400005b7          	lui	a1,0x40000
    80201920:	06900513          	li	a0,105
    80201924:	fffff097          	auipc	ra,0xfffff
    80201928:	65c080e7          	jalr	1628(ra) # 80200f80 <sd_cmd>
	} while (r == 0x01);
    8020192c:	fd2504e3          	beq	a0,s2,802018f4 <sdInit+0x1dc>
		panic("[SD card]CMD8 error!\n");
	}

	if (sd_acmd41()) {
    80201930:	18051c63          	bnez	a0,80201ac8 <sdInit+0x3b0>
	printf("CMD58");
    80201934:	00014517          	auipc	a0,0x14
    80201938:	a7c50513          	addi	a0,a0,-1412 # 802153b0 <textEnd+0x3b0>
    8020193c:	fffff097          	auipc	ra,0xfffff
    80201940:	514080e7          	jalr	1300(ra) # 80200e50 <printf>
	rc = (sd_cmd(0x7A, 0, 0xFD) != 0x00);
    80201944:	0fd00613          	li	a2,253
    80201948:	00000593          	li	a1,0
    8020194c:	07a00513          	li	a0,122
    80201950:	fffff097          	auipc	ra,0xfffff
    80201954:	630080e7          	jalr	1584(ra) # 80200f80 <sd_cmd>
    80201958:	0005069b          	sext.w	a3,a0
    8020195c:	00d03633          	snez	a2,a3
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201960:	100507b7          	lui	a5,0x10050
    80201964:	0ff00713          	li	a4,255
    80201968:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020196c:	100506b7          	lui	a3,0x10050
    80201970:	04c6a783          	lw	a5,76(a3) # 1005004c <_start-0x701affb4>
    80201974:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80201978:	fe07cce3          	bltz	a5,80201970 <sdInit+0x258>
	rc |= ((sd_dummy() & 0x80) != 0x80); /* Power up status */
    8020197c:	0ff77793          	zext.b	a5,a4
    80201980:	0807c793          	xori	a5,a5,128
    80201984:	0077d793          	srli	a5,a5,0x7
    80201988:	00f666b3          	or	a3,a2,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020198c:	100507b7          	lui	a5,0x10050
    80201990:	0ff00713          	li	a4,255
    80201994:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201998:	10050737          	lui	a4,0x10050
    8020199c:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    802019a0:	fe07cee3          	bltz	a5,8020199c <sdInit+0x284>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802019a4:	100507b7          	lui	a5,0x10050
    802019a8:	0ff00713          	li	a4,255
    802019ac:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802019b0:	10050737          	lui	a4,0x10050
    802019b4:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    802019b8:	fe07cee3          	bltz	a5,802019b4 <sdInit+0x29c>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802019bc:	100507b7          	lui	a5,0x10050
    802019c0:	0ff00713          	li	a4,255
    802019c4:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802019c8:	10050737          	lui	a4,0x10050
    802019cc:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    802019d0:	fe07cee3          	bltz	a5,802019cc <sdInit+0x2b4>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802019d4:	100507b7          	lui	a5,0x10050
    802019d8:	0ff00713          	li	a4,255
    802019dc:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802019e0:	10050737          	lui	a4,0x10050
    802019e4:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    802019e8:	fe07cee3          	bltz	a5,802019e4 <sdInit+0x2cc>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802019ec:	100507b7          	lui	a5,0x10050
    802019f0:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
		panic("[SD card]ACMD41 error!\n");
	}

	if (sd_cmd58()) {
    802019f4:	0e069c63          	bnez	a3,80201aec <sdInit+0x3d4>
	printf("CMD16");
    802019f8:	00014517          	auipc	a0,0x14
    802019fc:	9d850513          	addi	a0,a0,-1576 # 802153d0 <textEnd+0x3d0>
    80201a00:	fffff097          	auipc	ra,0xfffff
    80201a04:	450080e7          	jalr	1104(ra) # 80200e50 <printf>
	rc = (sd_cmd(0x50, 0x200, 0x15) != 0x00);
    80201a08:	01500613          	li	a2,21
    80201a0c:	20000593          	li	a1,512
    80201a10:	05000513          	li	a0,80
    80201a14:	fffff097          	auipc	ra,0xfffff
    80201a18:	56c080e7          	jalr	1388(ra) # 80200f80 <sd_cmd>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80201a1c:	100507b7          	lui	a5,0x10050
    80201a20:	0ff00713          	li	a4,255
    80201a24:	04e7a423          	sw	a4,72(a5) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80201a28:	10050737          	lui	a4,0x10050
    80201a2c:	04c72783          	lw	a5,76(a4) # 1005004c <_start-0x701affb4>
	} while (r < 0);
    80201a30:	fe07cee3          	bltz	a5,80201a2c <sdInit+0x314>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80201a34:	100507b7          	lui	a5,0x10050
    80201a38:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
		panic("[SD card]CMD58 error!\n");
	}

	if (sd_cmd16()) {
    80201a3c:	0c051a63          	bnez	a0,80201b10 <sdInit+0x3f8>
		panic("[SD card]CMD16 error!\n");
	}

	printf("[SD card]SD card init finish!\n");
    80201a40:	00014517          	auipc	a0,0x14
    80201a44:	9b050513          	addi	a0,a0,-1616 # 802153f0 <textEnd+0x3f0>
    80201a48:	fffff097          	auipc	ra,0xfffff
    80201a4c:	408080e7          	jalr	1032(ra) # 80200e50 <printf>

	REG32(spi, SPI_REG_SCKDIV) = (F_CLK / 16666666UL);
    80201a50:	100507b7          	lui	a5,0x10050
    80201a54:	03c00713          	li	a4,60
    80201a58:	00e7a023          	sw	a4,0(a5) # 10050000 <_start-0x701b0000>
	__asm__ __volatile__ ("fence.i" : : : "memory");
    80201a5c:	0000100f          	fence.i
	
	devsw[DEV_SD].read = sdCardRead;
    80201a60:	010ab797          	auipc	a5,0x10ab
    80201a64:	a2078793          	addi	a5,a5,-1504 # 812ac480 <devsw>
    80201a68:	00000717          	auipc	a4,0x0
    80201a6c:	84c70713          	addi	a4,a4,-1972 # 802012b4 <sdCardRead>
    80201a70:	00e7b023          	sd	a4,0(a5)
	devsw[DEV_SD].write = sdCardWrite;
    80201a74:	00000717          	auipc	a4,0x0
    80201a78:	b8470713          	addi	a4,a4,-1148 # 802015f8 <sdCardWrite>
    80201a7c:	00e7b423          	sd	a4,8(a5)
	return 0;
}
    80201a80:	00000513          	li	a0,0
    80201a84:	02813083          	ld	ra,40(sp)
    80201a88:	02013403          	ld	s0,32(sp)
    80201a8c:	01813483          	ld	s1,24(sp)
    80201a90:	01013903          	ld	s2,16(sp)
    80201a94:	00813983          	ld	s3,8(sp)
    80201a98:	00013a03          	ld	s4,0(sp)
    80201a9c:	03010113          	addi	sp,sp,48
    80201aa0:	00008067          	ret
		panic("[SD card]CMD8 error!\n");
    80201aa4:	00014697          	auipc	a3,0x14
    80201aa8:	8d468693          	addi	a3,a3,-1836 # 80215378 <textEnd+0x378>
    80201aac:	00015617          	auipc	a2,0x15
    80201ab0:	c8460613          	addi	a2,a2,-892 # 80216730 <__func__.0>
    80201ab4:	21000593          	li	a1,528
    80201ab8:	00013517          	auipc	a0,0x13
    80201abc:	7d850513          	addi	a0,a0,2008 # 80215290 <textEnd+0x290>
    80201ac0:	fffff097          	auipc	ra,0xfffff
    80201ac4:	428080e7          	jalr	1064(ra) # 80200ee8 <_panic_>
		panic("[SD card]ACMD41 error!\n");
    80201ac8:	00014697          	auipc	a3,0x14
    80201acc:	8d068693          	addi	a3,a3,-1840 # 80215398 <textEnd+0x398>
    80201ad0:	00015617          	auipc	a2,0x15
    80201ad4:	c6060613          	addi	a2,a2,-928 # 80216730 <__func__.0>
    80201ad8:	21400593          	li	a1,532
    80201adc:	00013517          	auipc	a0,0x13
    80201ae0:	7b450513          	addi	a0,a0,1972 # 80215290 <textEnd+0x290>
    80201ae4:	fffff097          	auipc	ra,0xfffff
    80201ae8:	404080e7          	jalr	1028(ra) # 80200ee8 <_panic_>
		panic("[SD card]CMD58 error!\n");
    80201aec:	00014697          	auipc	a3,0x14
    80201af0:	8cc68693          	addi	a3,a3,-1844 # 802153b8 <textEnd+0x3b8>
    80201af4:	00015617          	auipc	a2,0x15
    80201af8:	c3c60613          	addi	a2,a2,-964 # 80216730 <__func__.0>
    80201afc:	21800593          	li	a1,536
    80201b00:	00013517          	auipc	a0,0x13
    80201b04:	79050513          	addi	a0,a0,1936 # 80215290 <textEnd+0x290>
    80201b08:	fffff097          	auipc	ra,0xfffff
    80201b0c:	3e0080e7          	jalr	992(ra) # 80200ee8 <_panic_>
		panic("[SD card]CMD16 error!\n");
    80201b10:	00014697          	auipc	a3,0x14
    80201b14:	8c868693          	addi	a3,a3,-1848 # 802153d8 <textEnd+0x3d8>
    80201b18:	00015617          	auipc	a2,0x15
    80201b1c:	c1860613          	addi	a2,a2,-1000 # 80216730 <__func__.0>
    80201b20:	21c00593          	li	a1,540
    80201b24:	00013517          	auipc	a0,0x13
    80201b28:	76c50513          	addi	a0,a0,1900 # 80215290 <textEnd+0x290>
    80201b2c:	fffff097          	auipc	ra,0xfffff
    80201b30:	3bc080e7          	jalr	956(ra) # 80200ee8 <_panic_>

0000000080201b34 <sdTest>:

u8 binary[1024];
int sdTest(void) {
    80201b34:	fd010113          	addi	sp,sp,-48
    80201b38:	02113423          	sd	ra,40(sp)
    80201b3c:	02813023          	sd	s0,32(sp)
    80201b40:	00913c23          	sd	s1,24(sp)
    80201b44:	01213823          	sd	s2,16(sp)
    80201b48:	01313423          	sd	s3,8(sp)
    80201b4c:	01413023          	sd	s4,0(sp)
    80201b50:	03010413          	addi	s0,sp,48
	sdInit();
    80201b54:	00000097          	auipc	ra,0x0
    80201b58:	bc4080e7          	jalr	-1084(ra) # 80201718 <sdInit>
    80201b5c:	00000493          	li	s1,0
        // }
        // sdWrite(binary, j, 2);
        // for (int i = 0; i < 1024; i++) {
        //     binary[i] = 0;
        // }
        sdRead(binary, j, 2);
    80201b60:	001fea17          	auipc	s4,0x1fe
    80201b64:	518a0a13          	addi	s4,s4,1304 # 80400078 <binary>
        //     if (binary[i] != (i & 7)) {
        //         panic("gg: %d ", j);
        //         break;
        //     }
        // }
        printf("finish %d\n", j);
    80201b68:	00014997          	auipc	s3,0x14
    80201b6c:	8a898993          	addi	s3,s3,-1880 # 80215410 <textEnd+0x410>
    for (int j = 0; j < 20; j += 2) {
    80201b70:	01400913          	li	s2,20
        sdRead(binary, j, 2);
    80201b74:	00200613          	li	a2,2
    80201b78:	00048593          	mv	a1,s1
    80201b7c:	000a0513          	mv	a0,s4
    80201b80:	fffff097          	auipc	ra,0xfffff
    80201b84:	518080e7          	jalr	1304(ra) # 80201098 <sdRead>
        printf("finish %d\n", j);
    80201b88:	0004859b          	sext.w	a1,s1
    80201b8c:	00098513          	mv	a0,s3
    80201b90:	fffff097          	auipc	ra,0xfffff
    80201b94:	2c0080e7          	jalr	704(ra) # 80200e50 <printf>
    for (int j = 0; j < 20; j += 2) {
    80201b98:	00248493          	addi	s1,s1,2
    80201b9c:	fd249ce3          	bne	s1,s2,80201b74 <sdTest+0x40>
    }
	return 0;
    80201ba0:	00000513          	li	a0,0
    80201ba4:	02813083          	ld	ra,40(sp)
    80201ba8:	02013403          	ld	s0,32(sp)
    80201bac:	01813483          	ld	s1,24(sp)
    80201bb0:	01013903          	ld	s2,16(sp)
    80201bb4:	00813983          	ld	s3,8(sp)
    80201bb8:	00013a03          	ld	s4,0(sp)
    80201bbc:	03010113          	addi	sp,sp,48
    80201bc0:	00008067          	ret

0000000080201bc4 <binit>:
    // Sorted by how recently the buffer was used.
    // head.next is most recent, head.prev is least.
    struct buf head;
} bcache[BCACHE_GROUP_NUM];

void binit(void) {
    80201bc4:	fa010113          	addi	sp,sp,-96
    80201bc8:	04113c23          	sd	ra,88(sp)
    80201bcc:	04813823          	sd	s0,80(sp)
    80201bd0:	04913423          	sd	s1,72(sp)
    80201bd4:	05213023          	sd	s2,64(sp)
    80201bd8:	03313c23          	sd	s3,56(sp)
    80201bdc:	03413823          	sd	s4,48(sp)
    80201be0:	03513423          	sd	s5,40(sp)
    80201be4:	03613023          	sd	s6,32(sp)
    80201be8:	01713c23          	sd	s7,24(sp)
    80201bec:	01813823          	sd	s8,16(sp)
    80201bf0:	01913423          	sd	s9,8(sp)
    80201bf4:	06010413          	addi	s0,sp,96
    struct buf* b;

    for (int i = 0; i < BCACHE_GROUP_NUM; i++) {
    80201bf8:	00201a17          	auipc	s4,0x201
    80201bfc:	e18a0a13          	addi	s4,s4,-488 # 80402a10 <bcache+0x2598>
    80201c00:	00bfdc97          	auipc	s9,0xbfd
    80201c04:	e10c8c93          	addi	s9,s9,-496 # 80dfea10 <dirents+0x2598>
        initLock(&bcache[i].lock, "bcache");
    80201c08:	ffffeab7          	lui	s5,0xffffe
    80201c0c:	a68a8c13          	addi	s8,s5,-1432 # ffffffffffffda68 <bssEnd+0xffffffff7dc8da68>
    80201c10:	00014b97          	auipc	s7,0x14
    80201c14:	810b8b93          	addi	s7,s7,-2032 # 80215420 <textEnd+0x420>
    80201c18:	a80a8a93          	addi	s5,s5,-1408
        bcache[i].head.prev = &bcache[i].head;
        bcache[i].head.next = &bcache[i].head;
        for (b = bcache[i].buf; b < bcache[i].buf + NBUF; b++) {
            b->next = bcache[i].head.next;
            b->prev = &bcache[i].head;
            initsleeplock(&b->lock, "buffer");
    80201c1c:	00014997          	auipc	s3,0x14
    80201c20:	80c98993          	addi	s3,s3,-2036 # 80215428 <textEnd+0x428>
    for (int i = 0; i < BCACHE_GROUP_NUM; i++) {
    80201c24:	00002b37          	lui	s6,0x2
    80201c28:	7f0b0b13          	addi	s6,s6,2032 # 27f0 <_start-0x801fd810>
    80201c2c:	00c0006f          	j	80201c38 <binit+0x74>
    80201c30:	016a0a33          	add	s4,s4,s6
    80201c34:	059a0c63          	beq	s4,s9,80201c8c <binit+0xc8>
        initLock(&bcache[i].lock, "bcache");
    80201c38:	000b8593          	mv	a1,s7
    80201c3c:	018a0533          	add	a0,s4,s8
    80201c40:	00007097          	auipc	ra,0x7
    80201c44:	ba8080e7          	jalr	-1112(ra) # 802087e8 <initLock>
        bcache[i].head.prev = &bcache[i].head;
    80201c48:	000a0913          	mv	s2,s4
    80201c4c:	054a3423          	sd	s4,72(s4)
        bcache[i].head.next = &bcache[i].head;
    80201c50:	054a3823          	sd	s4,80(s4)
        for (b = bcache[i].buf; b < bcache[i].buf + NBUF; b++) {
    80201c54:	015a04b3          	add	s1,s4,s5
            b->next = bcache[i].head.next;
    80201c58:	05093783          	ld	a5,80(s2)
    80201c5c:	04f4b823          	sd	a5,80(s1)
            b->prev = &bcache[i].head;
    80201c60:	0524b423          	sd	s2,72(s1)
            initsleeplock(&b->lock, "buffer");
    80201c64:	00098593          	mv	a1,s3
    80201c68:	01048513          	addi	a0,s1,16
    80201c6c:	00007097          	auipc	ra,0x7
    80201c70:	a34080e7          	jalr	-1484(ra) # 802086a0 <initsleeplock>
            bcache[i].head.next->prev = b;
    80201c74:	05093783          	ld	a5,80(s2)
    80201c78:	0497b423          	sd	s1,72(a5)
            bcache[i].head.next = b;
    80201c7c:	04993823          	sd	s1,80(s2)
        for (b = bcache[i].buf; b < bcache[i].buf + NBUF; b++) {
    80201c80:	25848493          	addi	s1,s1,600
    80201c84:	fc991ae3          	bne	s2,s1,80201c58 <binit+0x94>
    80201c88:	fa9ff06f          	j	80201c30 <binit+0x6c>
        }
    }
}
    80201c8c:	05813083          	ld	ra,88(sp)
    80201c90:	05013403          	ld	s0,80(sp)
    80201c94:	04813483          	ld	s1,72(sp)
    80201c98:	04013903          	ld	s2,64(sp)
    80201c9c:	03813983          	ld	s3,56(sp)
    80201ca0:	03013a03          	ld	s4,48(sp)
    80201ca4:	02813a83          	ld	s5,40(sp)
    80201ca8:	02013b03          	ld	s6,32(sp)
    80201cac:	01813b83          	ld	s7,24(sp)
    80201cb0:	01013c03          	ld	s8,16(sp)
    80201cb4:	00813c83          	ld	s9,8(sp)
    80201cb8:	06010113          	addi	sp,sp,96
    80201cbc:	00008067          	ret

0000000080201cc0 <bread>:
struct buf* blockRead(FileSystem* fs, u64 blockNum) {
    return bread(fs->deviceNumber, blockNum);
}

// Return a locked buf with the contents of the indicated block.
struct buf* bread(uint dev, uint blockno) {
    80201cc0:	fe010113          	addi	sp,sp,-32
    80201cc4:	00113c23          	sd	ra,24(sp)
    80201cc8:	00813823          	sd	s0,16(sp)
    80201ccc:	00913423          	sd	s1,8(sp)
    80201cd0:	02010413          	addi	s0,sp,32
    int group = blockno & (BCACHE_GROUP_NUM - 1);
    80201cd4:	3ff5f713          	andi	a4,a1,1023
    if (dev >= 0) {
    80201cd8:	02054a63          	bltz	a0,80201d0c <bread+0x4c>
        for (b = bcache[group].head.next; b != &bcache[group].head; b = b->next) {
    80201cdc:	001fe817          	auipc	a6,0x1fe
    80201ce0:	79c80813          	addi	a6,a6,1948 # 80400478 <bcache>
    80201ce4:	000027b7          	lui	a5,0x2
    80201ce8:	7f078693          	addi	a3,a5,2032 # 27f0 <_start-0x801fd810>
    80201cec:	02d706b3          	mul	a3,a4,a3
    80201cf0:	00d80633          	add	a2,a6,a3
    80201cf4:	00c78633          	add	a2,a5,a2
    80201cf8:	5e863483          	ld	s1,1512(a2)
    80201cfc:	59878793          	addi	a5,a5,1432
    80201d00:	00f686b3          	add	a3,a3,a5
    80201d04:	010686b3          	add	a3,a3,a6
    80201d08:	06969863          	bne	a3,s1,80201d78 <bread+0xb8>
    for (b = bcache[group].head.prev; b != &bcache[group].head; b = b->prev) {
    80201d0c:	001fe617          	auipc	a2,0x1fe
    80201d10:	76c60613          	addi	a2,a2,1900 # 80400478 <bcache>
    80201d14:	000027b7          	lui	a5,0x2
    80201d18:	7f078693          	addi	a3,a5,2032 # 27f0 <_start-0x801fd810>
    80201d1c:	02d70733          	mul	a4,a4,a3
    80201d20:	00e606b3          	add	a3,a2,a4
    80201d24:	00d786b3          	add	a3,a5,a3
    80201d28:	5e06b483          	ld	s1,1504(a3)
    80201d2c:	59878793          	addi	a5,a5,1432
    80201d30:	00f70733          	add	a4,a4,a5
    80201d34:	00c70733          	add	a4,a4,a2
    80201d38:	00e48a63          	beq	s1,a4,80201d4c <bread+0x8c>
        if (b->refcnt == 0) {
    80201d3c:	0404a783          	lw	a5,64(s1)
    80201d40:	06078263          	beqz	a5,80201da4 <bread+0xe4>
    for (b = bcache[group].head.prev; b != &bcache[group].head; b = b->prev) {
    80201d44:	0484b483          	ld	s1,72(s1)
    80201d48:	fe971ae3          	bne	a4,s1,80201d3c <bread+0x7c>
    panic("bget: no buffers");
    80201d4c:	00013697          	auipc	a3,0x13
    80201d50:	6e468693          	addi	a3,a3,1764 # 80215430 <textEnd+0x430>
    80201d54:	00015617          	auipc	a2,0x15
    80201d58:	a0460613          	addi	a2,a2,-1532 # 80216758 <__func__.2>
    80201d5c:	05d00593          	li	a1,93
    80201d60:	00013517          	auipc	a0,0x13
    80201d64:	6e850513          	addi	a0,a0,1768 # 80215448 <textEnd+0x448>
    80201d68:	fffff097          	auipc	ra,0xfffff
    80201d6c:	180080e7          	jalr	384(ra) # 80200ee8 <_panic_>
        for (b = bcache[group].head.next; b != &bcache[group].head; b = b->next) {
    80201d70:	0504b483          	ld	s1,80(s1)
    80201d74:	f8968ce3          	beq	a3,s1,80201d0c <bread+0x4c>
            if (b->dev == dev && b->blockno == blockno) {
    80201d78:	0084a783          	lw	a5,8(s1)
    80201d7c:	fea79ae3          	bne	a5,a0,80201d70 <bread+0xb0>
    80201d80:	00c4a783          	lw	a5,12(s1)
    80201d84:	feb796e3          	bne	a5,a1,80201d70 <bread+0xb0>
                b->refcnt++;
    80201d88:	0404a783          	lw	a5,64(s1)
    80201d8c:	0017879b          	addiw	a5,a5,1
    80201d90:	04f4a023          	sw	a5,64(s1)
                acquiresleep(&b->lock);
    80201d94:	01048513          	addi	a0,s1,16
    80201d98:	00007097          	auipc	ra,0x7
    80201d9c:	960080e7          	jalr	-1696(ra) # 802086f8 <acquiresleep>
                return b;
    80201da0:	0240006f          	j	80201dc4 <bread+0x104>
            b->dev = dev;
    80201da4:	00a4a423          	sw	a0,8(s1)
            b->blockno = blockno;
    80201da8:	00b4a623          	sw	a1,12(s1)
            b->valid = 0;
    80201dac:	0004a023          	sw	zero,0(s1)
            b->refcnt = 1;
    80201db0:	00100793          	li	a5,1
    80201db4:	04f4a023          	sw	a5,64(s1)
            acquiresleep(&b->lock);
    80201db8:	01048513          	addi	a0,s1,16
    80201dbc:	00007097          	auipc	ra,0x7
    80201dc0:	93c080e7          	jalr	-1732(ra) # 802086f8 <acquiresleep>
    // static int cnt = 0;
    // printf("[Bread] %d\n", cnt++);
    struct buf* b;
    b = bget(dev, blockno);
    if (!b->valid) {
    80201dc4:	0004a783          	lw	a5,0(s1)
    80201dc8:	00078e63          	beqz	a5,80201de4 <bread+0x124>
        sdRead(b->data, b->blockno, 1);
        b->valid = 1;
    }
    return b;
}
    80201dcc:	00048513          	mv	a0,s1
    80201dd0:	01813083          	ld	ra,24(sp)
    80201dd4:	01013403          	ld	s0,16(sp)
    80201dd8:	00813483          	ld	s1,8(sp)
    80201ddc:	02010113          	addi	sp,sp,32
    80201de0:	00008067          	ret
        sdRead(b->data, b->blockno, 1);
    80201de4:	00100613          	li	a2,1
    80201de8:	00c4e583          	lwu	a1,12(s1)
    80201dec:	05848513          	addi	a0,s1,88
    80201df0:	fffff097          	auipc	ra,0xfffff
    80201df4:	2a8080e7          	jalr	680(ra) # 80201098 <sdRead>
        b->valid = 1;
    80201df8:	00100793          	li	a5,1
    80201dfc:	00f4a023          	sw	a5,0(s1)
    return b;
    80201e00:	fcdff06f          	j	80201dcc <bread+0x10c>

0000000080201e04 <mountBlockRead>:
struct buf* mountBlockRead(FileSystem* fs, u64 blockNum) {
    80201e04:	fe010113          	addi	sp,sp,-32
    80201e08:	00113c23          	sd	ra,24(sp)
    80201e0c:	00813823          	sd	s0,16(sp)
    80201e10:	00913423          	sd	s1,8(sp)
    80201e14:	01213023          	sd	s2,0(sp)
    80201e18:	02010413          	addi	s0,sp,32
    80201e1c:	00058913          	mv	s2,a1
    struct File* file = fs->image;
    80201e20:	2c853783          	ld	a5,712(a0)
    if (file->type == FD_DEVICE) {
    80201e24:	0007a683          	lw	a3,0(a5)
    80201e28:	00300713          	li	a4,3
    80201e2c:	06e68863          	beq	a3,a4,80201e9c <mountBlockRead+0x98>
    80201e30:	00050493          	mv	s1,a0
    assert(file->type == FD_ENTRY);
    80201e34:	ffe68693          	addi	a3,a3,-2
    80201e38:	0016b693          	seqz	a3,a3
    80201e3c:	00013617          	auipc	a2,0x13
    80201e40:	62460613          	addi	a2,a2,1572 # 80215460 <__func__.3>
    80201e44:	06500593          	li	a1,101
    80201e48:	00013517          	auipc	a0,0x13
    80201e4c:	60050513          	addi	a0,a0,1536 # 80215448 <textEnd+0x448>
    80201e50:	fffff097          	auipc	ra,0xfffff
    80201e54:	108080e7          	jalr	264(ra) # 80200f58 <_assert_>
    Dirent *image = fs->image->ep;
    80201e58:	2c84b783          	ld	a5,712(s1)
    80201e5c:	0187b503          	ld	a0,24(a5)
    FileSystem* parentFs = image->fileSystem;
    80201e60:	22053483          	ld	s1,544(a0)
    int parentBlockNum = getBlockNumber(image, blockNum); 
    80201e64:	0009059b          	sext.w	a1,s2
    80201e68:	00001097          	auipc	ra,0x1
    80201e6c:	e9c080e7          	jalr	-356(ra) # 80202d04 <getBlockNumber>
    80201e70:	00050593          	mv	a1,a0
    if (parentBlockNum < 0) {
    80201e74:	02054e63          	bltz	a0,80201eb0 <mountBlockRead+0xac>
    return parentFs->read(parentFs, parentBlockNum);
    80201e78:	2e04b783          	ld	a5,736(s1)
    80201e7c:	00048513          	mv	a0,s1
    80201e80:	000780e7          	jalr	a5
}
    80201e84:	01813083          	ld	ra,24(sp)
    80201e88:	01013403          	ld	s0,16(sp)
    80201e8c:	00813483          	ld	s1,8(sp)
    80201e90:	00013903          	ld	s2,0(sp)
    80201e94:	02010113          	addi	sp,sp,32
    80201e98:	00008067          	ret
        return bread(file->major, blockNum);
    80201e9c:	0005859b          	sext.w	a1,a1
    80201ea0:	02c79503          	lh	a0,44(a5)
    80201ea4:	00000097          	auipc	ra,0x0
    80201ea8:	e1c080e7          	jalr	-484(ra) # 80201cc0 <bread>
    80201eac:	fd9ff06f          	j	80201e84 <mountBlockRead+0x80>
        return 0;
    80201eb0:	00000513          	li	a0,0
    80201eb4:	fd1ff06f          	j	80201e84 <mountBlockRead+0x80>

0000000080201eb8 <blockRead>:
struct buf* blockRead(FileSystem* fs, u64 blockNum) {
    80201eb8:	ff010113          	addi	sp,sp,-16
    80201ebc:	00113423          	sd	ra,8(sp)
    80201ec0:	00813023          	sd	s0,0(sp)
    80201ec4:	01010413          	addi	s0,sp,16
    return bread(fs->deviceNumber, blockNum);
    80201ec8:	0005859b          	sext.w	a1,a1
    80201ecc:	2d852503          	lw	a0,728(a0)
    80201ed0:	00000097          	auipc	ra,0x0
    80201ed4:	df0080e7          	jalr	-528(ra) # 80201cc0 <bread>
}
    80201ed8:	00813083          	ld	ra,8(sp)
    80201edc:	00013403          	ld	s0,0(sp)
    80201ee0:	01010113          	addi	sp,sp,16
    80201ee4:	00008067          	ret

0000000080201ee8 <bwrite>:

// Write b's contents to disk.  Must be locked.
void bwrite(struct buf* b) {
    80201ee8:	ff010113          	addi	sp,sp,-16
    80201eec:	00113423          	sd	ra,8(sp)
    80201ef0:	00813023          	sd	s0,0(sp)
    80201ef4:	01010413          	addi	s0,sp,16
    if (!holdingsleep(&b->lock))
    80201ef8:	01050513          	addi	a0,a0,16
    80201efc:	00007097          	auipc	ra,0x7
    80201f00:	89c080e7          	jalr	-1892(ra) # 80208798 <holdingsleep>
    80201f04:	00050a63          	beqz	a0,80201f18 <bwrite+0x30>
        panic("bwrite");
    // sdWrite(b->data, b->blockno, 1);
}
    80201f08:	00813083          	ld	ra,8(sp)
    80201f0c:	00013403          	ld	s0,0(sp)
    80201f10:	01010113          	addi	sp,sp,16
    80201f14:	00008067          	ret
        panic("bwrite");
    80201f18:	00013697          	auipc	a3,0x13
    80201f1c:	53868693          	addi	a3,a3,1336 # 80215450 <textEnd+0x450>
    80201f20:	00015617          	auipc	a2,0x15
    80201f24:	83060613          	addi	a2,a2,-2000 # 80216750 <__func__.1>
    80201f28:	08300593          	li	a1,131
    80201f2c:	00013517          	auipc	a0,0x13
    80201f30:	51c50513          	addi	a0,a0,1308 # 80215448 <textEnd+0x448>
    80201f34:	fffff097          	auipc	ra,0xfffff
    80201f38:	fb4080e7          	jalr	-76(ra) # 80200ee8 <_panic_>

0000000080201f3c <brelse>:

// Release a locked buffer.
// Move to the head of the most-recently-used list.
void brelse(struct buf* b) {
    80201f3c:	fe010113          	addi	sp,sp,-32
    80201f40:	00113c23          	sd	ra,24(sp)
    80201f44:	00813823          	sd	s0,16(sp)
    80201f48:	00913423          	sd	s1,8(sp)
    80201f4c:	01213023          	sd	s2,0(sp)
    80201f50:	02010413          	addi	s0,sp,32
    80201f54:	00050493          	mv	s1,a0
    if (!holdingsleep(&b->lock))
    80201f58:	01050913          	addi	s2,a0,16
    80201f5c:	00090513          	mv	a0,s2
    80201f60:	00007097          	auipc	ra,0x7
    80201f64:	838080e7          	jalr	-1992(ra) # 80208798 <holdingsleep>
    80201f68:	08050e63          	beqz	a0,80202004 <brelse+0xc8>
        panic("brelse");

    releasesleep(&b->lock);
    80201f6c:	00090513          	mv	a0,s2
    80201f70:	00006097          	auipc	ra,0x6
    80201f74:	7f8080e7          	jalr	2040(ra) # 80208768 <releasesleep>

    int group = b->blockno & (BCACHE_GROUP_NUM - 1);
    80201f78:	00c4a783          	lw	a5,12(s1)
    // acquireLock(&bcache[group].lock);
    b->refcnt--;
    80201f7c:	0404a703          	lw	a4,64(s1)
    80201f80:	fff7071b          	addiw	a4,a4,-1
    80201f84:	0007069b          	sext.w	a3,a4
    80201f88:	04e4a023          	sw	a4,64(s1)
    if (b->refcnt == 0) {
    80201f8c:	06069063          	bnez	a3,80201fec <brelse+0xb0>
    int group = b->blockno & (BCACHE_GROUP_NUM - 1);
    80201f90:	3ff7f793          	andi	a5,a5,1023
        // no one is waiting for it.
        b->next->prev = b->prev;
    80201f94:	0504b703          	ld	a4,80(s1)
    80201f98:	0484b683          	ld	a3,72(s1)
    80201f9c:	04d73423          	sd	a3,72(a4)
        b->prev->next = b->next;
    80201fa0:	0484b703          	ld	a4,72(s1)
    80201fa4:	0504b683          	ld	a3,80(s1)
    80201fa8:	04d73823          	sd	a3,80(a4)
        b->next = bcache[group].head.next;
    80201fac:	001fe617          	auipc	a2,0x1fe
    80201fb0:	4cc60613          	addi	a2,a2,1228 # 80400478 <bcache>
    80201fb4:	000026b7          	lui	a3,0x2
    80201fb8:	7f068713          	addi	a4,a3,2032 # 27f0 <_start-0x801fd810>
    80201fbc:	02e787b3          	mul	a5,a5,a4
    80201fc0:	00f60733          	add	a4,a2,a5
    80201fc4:	00e68733          	add	a4,a3,a4
    80201fc8:	5e873583          	ld	a1,1512(a4)
    80201fcc:	04b4b823          	sd	a1,80(s1)
        b->prev = &bcache[group].head;
    80201fd0:	59868693          	addi	a3,a3,1432
    80201fd4:	00d787b3          	add	a5,a5,a3
    80201fd8:	00c787b3          	add	a5,a5,a2
    80201fdc:	04f4b423          	sd	a5,72(s1)
        bcache[group].head.next->prev = b;
    80201fe0:	5e873783          	ld	a5,1512(a4)
    80201fe4:	0497b423          	sd	s1,72(a5)
        bcache[group].head.next = b;
    80201fe8:	5e973423          	sd	s1,1512(a4)
    }

    // releaseLock(&bcache[group].lock);
}
    80201fec:	01813083          	ld	ra,24(sp)
    80201ff0:	01013403          	ld	s0,16(sp)
    80201ff4:	00813483          	ld	s1,8(sp)
    80201ff8:	00013903          	ld	s2,0(sp)
    80201ffc:	02010113          	addi	sp,sp,32
    80202000:	00008067          	ret
        panic("brelse");
    80202004:	00013697          	auipc	a3,0x13
    80202008:	45468693          	addi	a3,a3,1108 # 80215458 <textEnd+0x458>
    8020200c:	00014617          	auipc	a2,0x14
    80202010:	73c60613          	addi	a2,a2,1852 # 80216748 <__func__.0>
    80202014:	08b00593          	li	a1,139
    80202018:	00013517          	auipc	a0,0x13
    8020201c:	43050513          	addi	a0,a0,1072 # 80215448 <textEnd+0x448>
    80202020:	fffff097          	auipc	ra,0xfffff
    80202024:	ec8080e7          	jalr	-312(ra) # 80200ee8 <_panic_>

0000000080202028 <bpin>:

void bpin(struct buf* b) {
    80202028:	ff010113          	addi	sp,sp,-16
    8020202c:	00813423          	sd	s0,8(sp)
    80202030:	01010413          	addi	s0,sp,16
    // int group = b->blockno & (BCACHE_GROUP_NUM - 1);
    // acquireLock(&bcache[group].lock);
    b->refcnt++;
    80202034:	04052783          	lw	a5,64(a0)
    80202038:	0017879b          	addiw	a5,a5,1
    8020203c:	04f52023          	sw	a5,64(a0)
    // releaseLock(&bcache[group].lock);
}
    80202040:	00813403          	ld	s0,8(sp)
    80202044:	01010113          	addi	sp,sp,16
    80202048:	00008067          	ret

000000008020204c <bunpin>:

void bunpin(struct buf* b) {
    8020204c:	ff010113          	addi	sp,sp,-16
    80202050:	00813423          	sd	s0,8(sp)
    80202054:	01010413          	addi	s0,sp,16
    // int group = b->blockno & (BCACHE_GROUP_NUM - 1);
    // acquireLock(&bcache[group].lock);
    b->refcnt--;
    80202058:	04052783          	lw	a5,64(a0)
    8020205c:	fff7879b          	addiw	a5,a5,-1
    80202060:	04f52023          	sw	a5,64(a0)
    // releaseLock(&bcache[group].lock);
}
    80202064:	00813403          	ld	s0,8(sp)
    80202068:	01010113          	addi	sp,sp,16
    8020206c:	00008067          	ret

0000000080202070 <direntAlloc>:
#include <string.h>

Dirent dirents[DIRENT_NUM];
Dirent *direntHead;

int direntAlloc(Dirent **d) {
    80202070:	fe010113          	addi	sp,sp,-32
    80202074:	00113c23          	sd	ra,24(sp)
    80202078:	00813823          	sd	s0,16(sp)
    8020207c:	00913423          	sd	s1,8(sp)
    80202080:	01213023          	sd	s2,0(sp)
    80202084:	02010413          	addi	s0,sp,32
    80202088:	00050913          	mv	s2,a0
    assert(direntHead != NULL);
    8020208c:	010aa497          	auipc	s1,0x10aa
    80202090:	3ec48493          	addi	s1,s1,1004 # 812ac478 <direntHead>
    80202094:	0004b683          	ld	a3,0(s1)
    80202098:	00d036b3          	snez	a3,a3
    8020209c:	00013617          	auipc	a2,0x13
    802020a0:	3e460613          	addi	a2,a2,996 # 80215480 <__func__.0>
    802020a4:	00900593          	li	a1,9
    802020a8:	00013517          	auipc	a0,0x13
    802020ac:	3c850513          	addi	a0,a0,968 # 80215470 <__func__.3+0x10>
    802020b0:	fffff097          	auipc	ra,0xfffff
    802020b4:	ea8080e7          	jalr	-344(ra) # 80200f58 <_assert_>
    *d = direntHead;
    802020b8:	0004b783          	ld	a5,0(s1)
    802020bc:	00f93023          	sd	a5,0(s2)
    direntHead = direntHead->nextBrother;
    802020c0:	2487b783          	ld	a5,584(a5)
    802020c4:	00f4b023          	sd	a5,0(s1)
    return 0;
}
    802020c8:	00000513          	li	a0,0
    802020cc:	01813083          	ld	ra,24(sp)
    802020d0:	01013403          	ld	s0,16(sp)
    802020d4:	00813483          	ld	s1,8(sp)
    802020d8:	00013903          	ld	s2,0(sp)
    802020dc:	02010113          	addi	sp,sp,32
    802020e0:	00008067          	ret

00000000802020e4 <direntFree>:

void direntFree(Dirent *d) {
    802020e4:	ff010113          	addi	sp,sp,-16
    802020e8:	00813423          	sd	s0,8(sp)
    802020ec:	01010413          	addi	s0,sp,16
    d->nextBrother = direntHead;
    802020f0:	010aa797          	auipc	a5,0x10aa
    802020f4:	38878793          	addi	a5,a5,904 # 812ac478 <direntHead>
    802020f8:	0007b703          	ld	a4,0(a5)
    802020fc:	24e53423          	sd	a4,584(a0)
    direntHead = d;
    80202100:	00a7b023          	sd	a0,0(a5)
}
    80202104:	00813403          	ld	s0,8(sp)
    80202108:	01010113          	addi	sp,sp,16
    8020210c:	00008067          	ret

0000000080202110 <direntInit>:

void direntInit() {
    80202110:	ff010113          	addi	sp,sp,-16
    80202114:	00813423          	sd	s0,8(sp)
    80202118:	01010413          	addi	s0,sp,16
    for (int i = 0; i < DIRENT_NUM; i++) {
    8020211c:	010aa717          	auipc	a4,0x10aa
    80202120:	35c73703          	ld	a4,860(a4) # 812ac478 <direntHead>
    80202124:	00bfa797          	auipc	a5,0xbfa
    80202128:	35478793          	addi	a5,a5,852 # 80dfc478 <dirents>
    8020212c:	010aa617          	auipc	a2,0x10aa
    80202130:	34c60613          	addi	a2,a2,844 # 812ac478 <direntHead>
        dirents[i].nextBrother = direntHead;
    80202134:	00070693          	mv	a3,a4
    80202138:	00078713          	mv	a4,a5
    8020213c:	24d7b423          	sd	a3,584(a5)
    for (int i = 0; i < DIRENT_NUM; i++) {
    80202140:	25878793          	addi	a5,a5,600
    80202144:	fec798e3          	bne	a5,a2,80202134 <direntInit+0x24>
    80202148:	010aa797          	auipc	a5,0x10aa
    8020214c:	0d878793          	addi	a5,a5,216 # 812ac220 <dirents+0x4afda8>
    80202150:	010aa717          	auipc	a4,0x10aa
    80202154:	32f73423          	sd	a5,808(a4) # 812ac478 <direntHead>
        direntHead = dirents + i;
    }
}
    80202158:	00813403          	ld	s0,8(sp)
    8020215c:	01010113          	addi	sp,sp,16
    80202160:	00008067          	ret

0000000080202164 <read_fat>:
/**
 * Read the FAT table content corresponded to the given cluster number.
 * @param   cluster     the number of cluster which you want to read its content
 * in FAT table
 */
static uint32 read_fat(FileSystem *fs, uint32 cluster) {
    80202164:	fe010113          	addi	sp,sp,-32
    80202168:	00113c23          	sd	ra,24(sp)
    8020216c:	00813823          	sd	s0,16(sp)
    80202170:	00913423          	sd	s1,8(sp)
    80202174:	01213023          	sd	s2,0(sp)
    80202178:	02010413          	addi	s0,sp,32
    if (cluster >= FAT32_EOC) {
    8020217c:	100007b7          	lui	a5,0x10000
    80202180:	ff778793          	addi	a5,a5,-9 # ffffff7 <_start-0x70200009>
        return cluster;
    80202184:	00058493          	mv	s1,a1
    if (cluster >= FAT32_EOC) {
    80202188:	04b7ee63          	bltu	a5,a1,802021e4 <read_fat+0x80>
    8020218c:	00050913          	mv	s2,a0
    }
    if (cluster >
        fs->superBlock.data_clus_cnt + 1) {  // because cluster number starts at 2, not 0
    80202190:	04c52783          	lw	a5,76(a0)
    if (cluster >
    80202194:	0017879b          	addiw	a5,a5,1
        return 0;
    80202198:	00000493          	li	s1,0
    if (cluster >
    8020219c:	04b7e463          	bltu	a5,a1,802021e4 <read_fat+0x80>
    return fs->superBlock.bpb.rsvd_sec_cnt + (cluster << 2) / fs->superBlock.bpb.byts_per_sec +
    802021a0:	0025949b          	slliw	s1,a1,0x2
    802021a4:	05455583          	lhu	a1,84(a0)
    802021a8:	02b4d5bb          	divuw	a1,s1,a1
    802021ac:	05855783          	lhu	a5,88(a0)
    802021b0:	00f585bb          	addw	a1,a1,a5
    }
    uint32 fat_sec = fat_sec_of_clus(fs, cluster, 1);
    // here should be a cache layer for FAT table, but not implemented yet.
    struct buf* b = fs->read(fs, fat_sec);
    802021b4:	2e053783          	ld	a5,736(a0)
    802021b8:	02059593          	slli	a1,a1,0x20
    802021bc:	0205d593          	srli	a1,a1,0x20
    802021c0:	000780e7          	jalr	a5
    return (cluster << 2) % fs->superBlock.bpb.byts_per_sec;
    802021c4:	05495783          	lhu	a5,84(s2)
    802021c8:	02f4f5bb          	remuw	a1,s1,a5
    uint32 next_clus = *(uint32*)(b->data + fat_offset_of_clus(fs, cluster));
    802021cc:	02059593          	slli	a1,a1,0x20
    802021d0:	0205d593          	srli	a1,a1,0x20
    802021d4:	00b507b3          	add	a5,a0,a1
    802021d8:	0587a483          	lw	s1,88(a5)
    brelse(b);
    802021dc:	00000097          	auipc	ra,0x0
    802021e0:	d60080e7          	jalr	-672(ra) # 80201f3c <brelse>
    return next_clus;
}
    802021e4:	00048513          	mv	a0,s1
    802021e8:	01813083          	ld	ra,24(sp)
    802021ec:	01013403          	ld	s0,16(sp)
    802021f0:	00813483          	ld	s1,8(sp)
    802021f4:	00013903          	ld	s2,0(sp)
    802021f8:	02010113          	addi	sp,sp,32
    802021fc:	00008067          	ret

0000000080202200 <write_fat>:
 * @param   cluster     the number of cluster to write its content in FAT table
 * @param   content     the content which should be the next cluster number of
 * FAT end of chain flag
 */
static int write_fat(FileSystem *fs, uint32 cluster, uint32 content) {
    if (cluster > fs->superBlock.data_clus_cnt + 1) {
    80202200:	04c52783          	lw	a5,76(a0)
    80202204:	0017879b          	addiw	a5,a5,1
    80202208:	0ab7e263          	bltu	a5,a1,802022ac <write_fat+0xac>
static int write_fat(FileSystem *fs, uint32 cluster, uint32 content) {
    8020220c:	fd010113          	addi	sp,sp,-48
    80202210:	02113423          	sd	ra,40(sp)
    80202214:	02813023          	sd	s0,32(sp)
    80202218:	00913c23          	sd	s1,24(sp)
    8020221c:	01213823          	sd	s2,16(sp)
    80202220:	01313423          	sd	s3,8(sp)
    80202224:	01413023          	sd	s4,0(sp)
    80202228:	03010413          	addi	s0,sp,48
    8020222c:	00050913          	mv	s2,a0
    80202230:	00060a13          	mv	s4,a2
    return fs->superBlock.bpb.rsvd_sec_cnt + (cluster << 2) / fs->superBlock.bpb.byts_per_sec +
    80202234:	0025949b          	slliw	s1,a1,0x2
    80202238:	05455583          	lhu	a1,84(a0)
    8020223c:	02b4d5bb          	divuw	a1,s1,a1
    80202240:	05855783          	lhu	a5,88(a0)
    80202244:	00f585bb          	addw	a1,a1,a5
        return -1;
    }
    uint32 fat_sec = fat_sec_of_clus(fs, cluster, 1);
    struct buf* b = fs->read(fs, fat_sec);
    80202248:	2e053783          	ld	a5,736(a0)
    8020224c:	02059593          	slli	a1,a1,0x20
    80202250:	0205d593          	srli	a1,a1,0x20
    80202254:	000780e7          	jalr	a5
    80202258:	00050993          	mv	s3,a0
    return (cluster << 2) % fs->superBlock.bpb.byts_per_sec;
    8020225c:	05495783          	lhu	a5,84(s2)
    80202260:	02f4f5bb          	remuw	a1,s1,a5
    uint off = fat_offset_of_clus(fs, cluster);
    *(uint32*)(b->data + off) = content;
    80202264:	02059593          	slli	a1,a1,0x20
    80202268:	0205d593          	srli	a1,a1,0x20
    8020226c:	00b505b3          	add	a1,a0,a1
    80202270:	0545ac23          	sw	s4,88(a1) # 40000058 <_start-0x401fffa8>
    bwrite(b);
    80202274:	00000097          	auipc	ra,0x0
    80202278:	c74080e7          	jalr	-908(ra) # 80201ee8 <bwrite>
    brelse(b);
    8020227c:	00098513          	mv	a0,s3
    80202280:	00000097          	auipc	ra,0x0
    80202284:	cbc080e7          	jalr	-836(ra) # 80201f3c <brelse>
    return 0;
    80202288:	00000513          	li	a0,0
}
    8020228c:	02813083          	ld	ra,40(sp)
    80202290:	02013403          	ld	s0,32(sp)
    80202294:	01813483          	ld	s1,24(sp)
    80202298:	01013903          	ld	s2,16(sp)
    8020229c:	00813983          	ld	s3,8(sp)
    802022a0:	00013a03          	ld	s4,0(sp)
    802022a4:	03010113          	addi	sp,sp,48
    802022a8:	00008067          	ret
        return -1;
    802022ac:	fff00513          	li	a0,-1
}
    802022b0:	00008067          	ret

00000000802022b4 <eFindInode>:
static void eFindInode(Dirent *entry, int pos) {
    802022b4:	fd010113          	addi	sp,sp,-48
    802022b8:	02113423          	sd	ra,40(sp)
    802022bc:	02813023          	sd	s0,32(sp)
    802022c0:	00913c23          	sd	s1,24(sp)
    802022c4:	01213823          	sd	s2,16(sp)
    802022c8:	01313423          	sd	s3,8(sp)
    802022cc:	03010413          	addi	s0,sp,48
    802022d0:	00050913          	mv	s2,a0
    802022d4:	00058493          	mv	s1,a1
    assert(pos < entry->inodeMaxCluster);
    802022d8:	0005899b          	sext.w	s3,a1
    802022dc:	11052683          	lw	a3,272(a0)
    802022e0:	00d9b6b3          	sltu	a3,s3,a3
    802022e4:	00013617          	auipc	a2,0x13
    802022e8:	20460613          	addi	a2,a2,516 # 802154e8 <__func__.6>
    802022ec:	03000593          	li	a1,48
    802022f0:	00013517          	auipc	a0,0x13
    802022f4:	1a050513          	addi	a0,a0,416 # 80215490 <__func__.0+0x10>
    802022f8:	fffff097          	auipc	ra,0xfffff
    802022fc:	c60080e7          	jalr	-928(ra) # 80200f58 <_assert_>
    entry->clus_cnt = pos;
    80202300:	11392a23          	sw	s3,276(s2)
    if (pos < INODE_SECOND_LEVEL_BOTTOM) {
    80202304:	00700793          	li	a5,7
    80202308:	0a97dc63          	bge	a5,s1,802023c0 <eFindInode+0x10c>
    if (pos < INODE_THIRD_LEVEL_BOTTOM) {
    8020230c:	40700793          	li	a5,1031
    80202310:	0c97d263          	bge	a5,s1,802023d4 <eFindInode+0x120>
    if (pos < INODE_THIRD_LEVEL_TOP) {
    80202314:	000287b7          	lui	a5,0x28
    80202318:	40778793          	addi	a5,a5,1031 # 28407 <_start-0x801d7bf9>
    8020231c:	1097c463          	blt	a5,s1,80202424 <eFindInode+0x170>
        int idx1 = INODE_THIRD_ITEM_BASE + (pos - INODE_THIRD_LEVEL_BOTTOM) / INODE_ITEM_NUM / INODE_ITEM_NUM;
    80202320:	bf84849b          	addiw	s1,s1,-1032
        entry->cur_clus = inodes[inodes[entry->inode.item[idx1]].item[idx2]].item[(pos - INODE_THIRD_LEVEL_BOTTOM) % INODE_ITEM_NUM];
    80202324:	010b6617          	auipc	a2,0x10b6
    80202328:	f3c60613          	addi	a2,a2,-196 # 812b8260 <inodes>
    8020232c:	41f4d79b          	sraiw	a5,s1,0x1f
    80202330:	01a7d69b          	srliw	a3,a5,0x1a
    80202334:	00d4873b          	addw	a4,s1,a3
    80202338:	03f77593          	andi	a1,a4,63
    8020233c:	40d585bb          	subw	a1,a1,a3
        int idx2 = (pos - INODE_THIRD_LEVEL_BOTTOM) / INODE_ITEM_NUM % INODE_ITEM_NUM;
    80202340:	4067569b          	sraiw	a3,a4,0x6
    80202344:	41f7571b          	sraiw	a4,a4,0x1f
    80202348:	01a7571b          	srliw	a4,a4,0x1a
    8020234c:	00e686bb          	addw	a3,a3,a4
    80202350:	03f6f693          	andi	a3,a3,63
        entry->cur_clus = inodes[inodes[entry->inode.item[idx1]].item[idx2]].item[(pos - INODE_THIRD_LEVEL_BOTTOM) % INODE_ITEM_NUM];
    80202354:	40e6873b          	subw	a4,a3,a4
        int idx1 = INODE_THIRD_ITEM_BASE + (pos - INODE_THIRD_LEVEL_BOTTOM) / INODE_ITEM_NUM / INODE_ITEM_NUM;
    80202358:	0147d79b          	srliw	a5,a5,0x14
    8020235c:	009787bb          	addw	a5,a5,s1
    80202360:	40c7d79b          	sraiw	a5,a5,0xc
        entry->cur_clus = inodes[inodes[entry->inode.item[idx1]].item[idx2]].item[(pos - INODE_THIRD_LEVEL_BOTTOM) % INODE_ITEM_NUM];
    80202364:	0187879b          	addiw	a5,a5,24
    80202368:	04478793          	addi	a5,a5,68
    8020236c:	00279793          	slli	a5,a5,0x2
    80202370:	00f907b3          	add	a5,s2,a5
    80202374:	0087e783          	lwu	a5,8(a5)
    80202378:	00679793          	slli	a5,a5,0x6
    8020237c:	00e787b3          	add	a5,a5,a4
    80202380:	00279793          	slli	a5,a5,0x2
    80202384:	00f607b3          	add	a5,a2,a5
    80202388:	0007e783          	lwu	a5,0(a5)
    8020238c:	00679793          	slli	a5,a5,0x6
    80202390:	00b787b3          	add	a5,a5,a1
    80202394:	00279793          	slli	a5,a5,0x2
    80202398:	00f60633          	add	a2,a2,a5
    8020239c:	00062783          	lw	a5,0(a2)
        entry->cur_clus = entry->inode.item[pos];
    802023a0:	10f92623          	sw	a5,268(s2)
}
    802023a4:	02813083          	ld	ra,40(sp)
    802023a8:	02013403          	ld	s0,32(sp)
    802023ac:	01813483          	ld	s1,24(sp)
    802023b0:	01013903          	ld	s2,16(sp)
    802023b4:	00813983          	ld	s3,8(sp)
    802023b8:	03010113          	addi	sp,sp,48
    802023bc:	00008067          	ret
        entry->cur_clus = entry->inode.item[pos];
    802023c0:	04448493          	addi	s1,s1,68
    802023c4:	00249493          	slli	s1,s1,0x2
    802023c8:	009904b3          	add	s1,s2,s1
    802023cc:	0084a783          	lw	a5,8(s1)
        return;
    802023d0:	fd1ff06f          	j	802023a0 <eFindInode+0xec>
        int idx = INODE_SECOND_ITEM_BASE + (pos - INODE_SECOND_LEVEL_BOTTOM) / INODE_ITEM_NUM;
    802023d4:	ff84849b          	addiw	s1,s1,-8
        entry->cur_clus = inodes[entry->inode.item[idx]].item[(pos - INODE_SECOND_LEVEL_BOTTOM) % INODE_ITEM_NUM];
    802023d8:	41f4d79b          	sraiw	a5,s1,0x1f
    802023dc:	01a7d79b          	srliw	a5,a5,0x1a
    802023e0:	00f484bb          	addw	s1,s1,a5
    802023e4:	03f4f713          	andi	a4,s1,63
    802023e8:	40f7073b          	subw	a4,a4,a5
        int idx = INODE_SECOND_ITEM_BASE + (pos - INODE_SECOND_LEVEL_BOTTOM) / INODE_ITEM_NUM;
    802023ec:	4064d79b          	sraiw	a5,s1,0x6
        entry->cur_clus = inodes[entry->inode.item[idx]].item[(pos - INODE_SECOND_LEVEL_BOTTOM) % INODE_ITEM_NUM];
    802023f0:	0087879b          	addiw	a5,a5,8
    802023f4:	04478793          	addi	a5,a5,68
    802023f8:	00279793          	slli	a5,a5,0x2
    802023fc:	00f907b3          	add	a5,s2,a5
    80202400:	0087e783          	lwu	a5,8(a5)
    80202404:	00679793          	slli	a5,a5,0x6
    80202408:	00e787b3          	add	a5,a5,a4
    8020240c:	00279793          	slli	a5,a5,0x2
    80202410:	010b6717          	auipc	a4,0x10b6
    80202414:	e5070713          	addi	a4,a4,-432 # 812b8260 <inodes>
    80202418:	00f707b3          	add	a5,a4,a5
    8020241c:	0007a783          	lw	a5,0(a5)
        return;
    80202420:	f81ff06f          	j	802023a0 <eFindInode+0xec>
    panic("");
    80202424:	00013697          	auipc	a3,0x13
    80202428:	7c468693          	addi	a3,a3,1988 # 80215be8 <__func__.0+0x48>
    8020242c:	00013617          	auipc	a2,0x13
    80202430:	0bc60613          	addi	a2,a2,188 # 802154e8 <__func__.6>
    80202434:	04100593          	li	a1,65
    80202438:	00013517          	auipc	a0,0x13
    8020243c:	05850513          	addi	a0,a0,88 # 80215490 <__func__.0+0x10>
    80202440:	fffff097          	auipc	ra,0xfffff
    80202444:	aa8080e7          	jalr	-1368(ra) # 80200ee8 <_panic_>

0000000080202448 <alloc_clus>:
        bwrite(b);
        brelse(b);
    }
}

static uint32 alloc_clus(FileSystem *fs, uint8 dev) {
    80202448:	fc010113          	addi	sp,sp,-64
    8020244c:	02113c23          	sd	ra,56(sp)
    80202450:	02813823          	sd	s0,48(sp)
    80202454:	02913423          	sd	s1,40(sp)
    80202458:	03213023          	sd	s2,32(sp)
    8020245c:	01313c23          	sd	s3,24(sp)
    80202460:	01413823          	sd	s4,16(sp)
    80202464:	01513423          	sd	s5,8(sp)
    80202468:	04010413          	addi	s0,sp,64
    struct buf* (*read)(struct FileSystem *fs, u64 blockNum);
} FileSystem;

static inline u64 getFileSystemClusterBitmap(FileSystem *fs) {
    extern FileSystem fileSystem[];
    return FILE_SYSTEM_CLUSTER_BITMAP_BASE + ((fs - fileSystem) << 10) * PAGE_SIZE;
    8020246c:	010b0797          	auipc	a5,0x10b0
    80202470:	06c78793          	addi	a5,a5,108 # 812b24d8 <fileSystem>
    80202474:	40f507b3          	sub	a5,a0,a5
    80202478:	4037d793          	srai	a5,a5,0x3
    8020247c:	00014717          	auipc	a4,0x14
    80202480:	36473703          	ld	a4,868(a4) # 802167e0 <__func__.0+0x8>
    80202484:	02e787b3          	mul	a5,a5,a4
    80202488:	01679793          	slli	a5,a5,0x16
    8020248c:	03f00713          	li	a4,63
    80202490:	01e71693          	slli	a3,a4,0x1e
    80202494:	00d787b3          	add	a5,a5,a3
    u64 *clusterBitmap = (u64*)getFileSystemClusterBitmap(fs);
    int totalClusterNumber = fs->superBlock.bpb.fat_sz * fs->superBlock.bpb.byts_per_sec / sizeof(uint32);
    80202498:	05455603          	lhu	a2,84(a0)
    8020249c:	06452683          	lw	a3,100(a0)
    802024a0:	02d6063b          	mulw	a2,a2,a3
    802024a4:	0026569b          	srliw	a3,a2,0x2
    for (int i = 0; i < (totalClusterNumber / 64); i++) {
    802024a8:	0086561b          	srliw	a2,a2,0x8
    802024ac:	02d75463          	bge	a4,a3,802024d4 <alloc_clus+0x8c>
    802024b0:	00050913          	mv	s2,a0
    802024b4:	00000713          	li	a4,0
        if (~clusterBitmap[i]) {
    802024b8:	fff00513          	li	a0,-1
    802024bc:	00078593          	mv	a1,a5
    802024c0:	0007b683          	ld	a3,0(a5)
    802024c4:	02a69a63          	bne	a3,a0,802024f8 <alloc_clus+0xb0>
    for (int i = 0; i < (totalClusterNumber / 64); i++) {
    802024c8:	0017071b          	addiw	a4,a4,1
    802024cc:	00878793          	addi	a5,a5,8
    802024d0:	fec746e3          	blt	a4,a2,802024bc <alloc_clus+0x74>
            brelse(b);
            zero_clus(fs, cluster);
            return cluster;
        }
    }
    panic("");
    802024d4:	00013697          	auipc	a3,0x13
    802024d8:	71468693          	addi	a3,a3,1812 # 80215be8 <__func__.0+0x48>
    802024dc:	00013617          	auipc	a2,0x13
    802024e0:	01c60613          	addi	a2,a2,28 # 802154f8 <__func__.5>
    802024e4:	0a700593          	li	a1,167
    802024e8:	00013517          	auipc	a0,0x13
    802024ec:	fa850513          	addi	a0,a0,-88 # 80215490 <__func__.0+0x10>
    802024f0:	fffff097          	auipc	ra,0xfffff
    802024f4:	9f8080e7          	jalr	-1544(ra) # 80200ee8 <_panic_>
            int bit = LOW_BIT64(~clusterBitmap[i]);
    802024f8:	fff6c793          	not	a5,a3
        __a >= __b ? __a : __b; \
    })

inline int LOW_BIT64(u64 x) {
    int res = 0;
    if ((x & ((1UL << 32) - 1)) == 0) {
    802024fc:	02079513          	slli	a0,a5,0x20
    80202500:	02055513          	srli	a0,a0,0x20
    int res = 0;
    80202504:	00000613          	li	a2,0
    if ((x & ((1UL << 32) - 1)) == 0) {
    80202508:	00051663          	bnez	a0,80202514 <alloc_clus+0xcc>
        x >>= 32;
    8020250c:	0207d793          	srli	a5,a5,0x20
        res += 32;
    80202510:	02000613          	li	a2,32
    }
    if ((x & ((1UL << 16) - 1)) == 0) {
    80202514:	03079513          	slli	a0,a5,0x30
    80202518:	03055513          	srli	a0,a0,0x30
    8020251c:	00051663          	bnez	a0,80202528 <alloc_clus+0xe0>
        x >>= 16;
    80202520:	0107d793          	srli	a5,a5,0x10
        res += 16;
    80202524:	0106061b          	addiw	a2,a2,16
    }
    if ((x & ((1UL << 8) - 1)) == 0) {
    80202528:	0ff7f513          	zext.b	a0,a5
    8020252c:	00051663          	bnez	a0,80202538 <alloc_clus+0xf0>
        x >>= 8;
    80202530:	0087d793          	srli	a5,a5,0x8
        res += 8;
    80202534:	0086061b          	addiw	a2,a2,8
    }
    if ((x & ((1UL << 4) - 1)) == 0) {
    80202538:	00f7f513          	andi	a0,a5,15
    8020253c:	00051663          	bnez	a0,80202548 <alloc_clus+0x100>
        x >>= 4;
    80202540:	0047d793          	srli	a5,a5,0x4
        res += 4;
    80202544:	0046061b          	addiw	a2,a2,4
    }
    if ((x & ((1UL << 2) - 1)) == 0) {
    80202548:	0037f513          	andi	a0,a5,3
    8020254c:	00051663          	bnez	a0,80202558 <alloc_clus+0x110>
        x >>= 2;
    80202550:	0027d793          	srli	a5,a5,0x2
        res += 2;
    80202554:	0026061b          	addiw	a2,a2,2
    }
    if ((x & ((1UL << 1) - 1)) == 0) {
    80202558:	0017f513          	andi	a0,a5,1
    8020255c:	00051663          	bnez	a0,80202568 <alloc_clus+0x120>
        x >>= 1;
    80202560:	0017d793          	srli	a5,a5,0x1
        res += 1;
    80202564:	0016061b          	addiw	a2,a2,1
    }
    return x ? res : -1;
    80202568:	10078863          	beqz	a5,80202678 <alloc_clus+0x230>
            clusterBitmap[i] |= (1UL << bit);
    8020256c:	00100793          	li	a5,1
    80202570:	00c797b3          	sll	a5,a5,a2
    80202574:	00d7e7b3          	or	a5,a5,a3
    80202578:	00f5b023          	sd	a5,0(a1)
            uint32 const ent_per_sec = fs->superBlock.bpb.byts_per_sec / sizeof(uint32);
    8020257c:	05495483          	lhu	s1,84(s2)
    80202580:	0024d49b          	srliw	s1,s1,0x2
            int cluster = (i << 6) | bit;
    80202584:	0067171b          	slliw	a4,a4,0x6
    80202588:	00e66633          	or	a2,a2,a4
            uint32 sec = fs->superBlock.bpb.rsvd_sec_cnt + cluster / ent_per_sec;
    8020258c:	00060a9b          	sext.w	s5,a2
    80202590:	05895583          	lhu	a1,88(s2)
    80202594:	0296563b          	divuw	a2,a2,s1
    80202598:	00c585bb          	addw	a1,a1,a2
            b = fs->read(fs, sec);
    8020259c:	2e093783          	ld	a5,736(s2)
    802025a0:	02059593          	slli	a1,a1,0x20
    802025a4:	0205d593          	srli	a1,a1,0x20
    802025a8:	00090513          	mv	a0,s2
    802025ac:	000780e7          	jalr	a5
    802025b0:	00050993          	mv	s3,a0
            ((uint32*)(b->data))[j] = FAT32_EOC + 7;
    802025b4:	029af7bb          	remuw	a5,s5,s1
    802025b8:	00279793          	slli	a5,a5,0x2
    802025bc:	00f507b3          	add	a5,a0,a5
    802025c0:	10000737          	lui	a4,0x10000
    802025c4:	fff70713          	addi	a4,a4,-1 # fffffff <_start-0x70200001>
    802025c8:	04e7ac23          	sw	a4,88(a5)
            bwrite(b);
    802025cc:	00000097          	auipc	ra,0x0
    802025d0:	91c080e7          	jalr	-1764(ra) # 80201ee8 <bwrite>
            brelse(b);
    802025d4:	00098513          	mv	a0,s3
    802025d8:	00000097          	auipc	ra,0x0
    802025dc:	964080e7          	jalr	-1692(ra) # 80201f3c <brelse>
    return ((cluster - 2) * fs->superBlock.bpb.sec_per_clus) + fs->superBlock.first_data_sec;
    802025e0:	05694783          	lbu	a5,86(s2)
    802025e4:	ffea8a1b          	addiw	s4,s5,-2
    802025e8:	02fa0a3b          	mulw	s4,s4,a5
    802025ec:	04492703          	lw	a4,68(s2)
    802025f0:	00ea0a3b          	addw	s4,s4,a4
    for (int i = 0; i < fs->superBlock.bpb.sec_per_clus; i++) {
    802025f4:	04078e63          	beqz	a5,80202650 <alloc_clus+0x208>
    802025f8:	00000993          	li	s3,0
        b = fs->read(fs, sec++);
    802025fc:	014985bb          	addw	a1,s3,s4
    80202600:	2e093783          	ld	a5,736(s2)
    80202604:	02059593          	slli	a1,a1,0x20
    80202608:	0205d593          	srli	a1,a1,0x20
    8020260c:	00090513          	mv	a0,s2
    80202610:	000780e7          	jalr	a5
    80202614:	00050493          	mv	s1,a0
        memset(b->data, 0, BSIZE);
    80202618:	20000613          	li	a2,512
    8020261c:	00000593          	li	a1,0
    80202620:	05850513          	addi	a0,a0,88
    80202624:	0000c097          	auipc	ra,0xc
    80202628:	748080e7          	jalr	1864(ra) # 8020ed6c <memset>
        bwrite(b);
    8020262c:	00048513          	mv	a0,s1
    80202630:	00000097          	auipc	ra,0x0
    80202634:	8b8080e7          	jalr	-1864(ra) # 80201ee8 <bwrite>
        brelse(b);
    80202638:	00048513          	mv	a0,s1
    8020263c:	00000097          	auipc	ra,0x0
    80202640:	900080e7          	jalr	-1792(ra) # 80201f3c <brelse>
    for (int i = 0; i < fs->superBlock.bpb.sec_per_clus; i++) {
    80202644:	0019899b          	addiw	s3,s3,1
    80202648:	05694783          	lbu	a5,86(s2)
    8020264c:	faf9c8e3          	blt	s3,a5,802025fc <alloc_clus+0x1b4>
}
    80202650:	000a8513          	mv	a0,s5
    80202654:	03813083          	ld	ra,56(sp)
    80202658:	03013403          	ld	s0,48(sp)
    8020265c:	02813483          	ld	s1,40(sp)
    80202660:	02013903          	ld	s2,32(sp)
    80202664:	01813983          	ld	s3,24(sp)
    80202668:	01013a03          	ld	s4,16(sp)
    8020266c:	00813a83          	ld	s5,8(sp)
    80202670:	04010113          	addi	sp,sp,64
    80202674:	00008067          	ret
    80202678:	fff00613          	li	a2,-1
    8020267c:	ef1ff06f          	j	8020256c <alloc_clus+0x124>

0000000080202680 <eFreeInode>:
static void eFreeInode(Dirent *ep) {
    80202680:	f9010113          	addi	sp,sp,-112
    80202684:	06113423          	sd	ra,104(sp)
    80202688:	06813023          	sd	s0,96(sp)
    8020268c:	04913c23          	sd	s1,88(sp)
    80202690:	05213823          	sd	s2,80(sp)
    80202694:	05313423          	sd	s3,72(sp)
    80202698:	05413023          	sd	s4,64(sp)
    8020269c:	03513c23          	sd	s5,56(sp)
    802026a0:	03613823          	sd	s6,48(sp)
    802026a4:	03713423          	sd	s7,40(sp)
    802026a8:	03813023          	sd	s8,32(sp)
    802026ac:	01913c23          	sd	s9,24(sp)
    802026b0:	01a13823          	sd	s10,16(sp)
    802026b4:	01b13423          	sd	s11,8(sp)
    802026b8:	07010413          	addi	s0,sp,112
    802026bc:	00050493          	mv	s1,a0
    for (int i = INODE_SECOND_ITEM_BASE; i < INODE_THIRD_ITEM_BASE; i++) {
    802026c0:	13850993          	addi	s3,a0,312
    802026c4:	17850a13          	addi	s4,a0,376
static void eFreeInode(Dirent *ep) {
    802026c8:	00800913          	li	s2,8
        if (ep->inodeMaxCluster > INODE_SECOND_LEVEL_BOTTOM + (i - INODE_SECOND_ITEM_BASE) * INODE_ITEM_NUM) {
    802026cc:	1104a783          	lw	a5,272(s1)
    802026d0:	06f96863          	bltu	s2,a5,80202740 <eFreeInode+0xc0>
    for (int i = INODE_THIRD_ITEM_BASE; i < INODE_ITEM_NUM; i++) {
    802026d4:	17848993          	addi	s3,s1,376
    802026d8:	21848b13          	addi	s6,s1,536
static void eFreeInode(Dirent *ep) {
    802026dc:	00010937          	lui	s2,0x10
    802026e0:	40890913          	addi	s2,s2,1032 # 10408 <_start-0x801efbf8>
            for (int j = 0; j < INODE_ITEM_NUM; j++) {
    802026e4:	00000a93          	li	s5,0
                    inodeFree(inodes[ep->inode.item[i]].item[j]);
    802026e8:	010b6c97          	auipc	s9,0x10b6
    802026ec:	b78c8c93          	addi	s9,s9,-1160 # 812b8260 <inodes>
            for (int j = 0; j < INODE_ITEM_NUM; j++) {
    802026f0:	04000c13          	li	s8,64
    for (int i = INODE_THIRD_ITEM_BASE; i < INODE_ITEM_NUM; i++) {
    802026f4:	00001a37          	lui	s4,0x1
        if (ep->inodeMaxCluster > base) {
    802026f8:	1104a783          	lw	a5,272(s1)
    802026fc:	06f96063          	bltu	s2,a5,8020275c <eFreeInode+0xdc>
    ep->inodeMaxCluster = 0;
    80202700:	1004a823          	sw	zero,272(s1)
}
    80202704:	06813083          	ld	ra,104(sp)
    80202708:	06013403          	ld	s0,96(sp)
    8020270c:	05813483          	ld	s1,88(sp)
    80202710:	05013903          	ld	s2,80(sp)
    80202714:	04813983          	ld	s3,72(sp)
    80202718:	04013a03          	ld	s4,64(sp)
    8020271c:	03813a83          	ld	s5,56(sp)
    80202720:	03013b03          	ld	s6,48(sp)
    80202724:	02813b83          	ld	s7,40(sp)
    80202728:	02013c03          	ld	s8,32(sp)
    8020272c:	01813c83          	ld	s9,24(sp)
    80202730:	01013d03          	ld	s10,16(sp)
    80202734:	00813d83          	ld	s11,8(sp)
    80202738:	07010113          	addi	sp,sp,112
    8020273c:	00008067          	ret
            inodeFree(ep->inode.item[i]);
    80202740:	0009a503          	lw	a0,0(s3)
    80202744:	00003097          	auipc	ra,0x3
    80202748:	86c080e7          	jalr	-1940(ra) # 80204fb0 <inodeFree>
    for (int i = INODE_SECOND_ITEM_BASE; i < INODE_THIRD_ITEM_BASE; i++) {
    8020274c:	0409091b          	addiw	s2,s2,64
    80202750:	00498993          	addi	s3,s3,4
    80202754:	f7499ce3          	bne	s3,s4,802026cc <eFreeInode+0x4c>
    80202758:	f7dff06f          	j	802026d4 <eFreeInode+0x54>
    8020275c:	04090b9b          	addiw	s7,s2,64
            for (int j = 0; j < INODE_ITEM_NUM; j++) {
    80202760:	000a8d93          	mv	s11,s5
    80202764:	00098d13          	mv	s10,s3
                    inodeFree(inodes[ep->inode.item[i]].item[j]);
    80202768:	0009e783          	lwu	a5,0(s3)
    8020276c:	00679793          	slli	a5,a5,0x6
    80202770:	01b787b3          	add	a5,a5,s11
    80202774:	00279793          	slli	a5,a5,0x2
    80202778:	00fc87b3          	add	a5,s9,a5
    8020277c:	0007a503          	lw	a0,0(a5)
    80202780:	00003097          	auipc	ra,0x3
    80202784:	830080e7          	jalr	-2000(ra) # 80204fb0 <inodeFree>
            for (int j = 0; j < INODE_ITEM_NUM; j++) {
    80202788:	001d8d9b          	addiw	s11,s11,1
    8020278c:	018d8863          	beq	s11,s8,8020279c <eFreeInode+0x11c>
                if (ep->inodeMaxCluster > base + j * INODE_ITEM_NUM) {
    80202790:	040b871b          	addiw	a4,s7,64
    80202794:	1104a783          	lw	a5,272(s1)
    80202798:	02fbe063          	bltu	s7,a5,802027b8 <eFreeInode+0x138>
            inodeFree(ep->inode.item[i]);
    8020279c:	000d2503          	lw	a0,0(s10)
    802027a0:	00003097          	auipc	ra,0x3
    802027a4:	810080e7          	jalr	-2032(ra) # 80204fb0 <inodeFree>
    for (int i = INODE_THIRD_ITEM_BASE; i < INODE_ITEM_NUM; i++) {
    802027a8:	012a093b          	addw	s2,s4,s2
    802027ac:	00498993          	addi	s3,s3,4
    802027b0:	f56994e3          	bne	s3,s6,802026f8 <eFreeInode+0x78>
    802027b4:	f4dff06f          	j	80202700 <eFreeInode+0x80>
    802027b8:	00070b93          	mv	s7,a4
    802027bc:	fadff06f          	j	80202768 <eFreeInode+0xe8>

00000000802027c0 <rw_clus>:
uint rw_clus(FileSystem *fs, uint32 cluster,
                    int write,
                    int user,
                    u64 data,
                    uint off,
                    uint n) {
    802027c0:	f8010113          	addi	sp,sp,-128
    802027c4:	06113c23          	sd	ra,120(sp)
    802027c8:	06813823          	sd	s0,112(sp)
    802027cc:	06913423          	sd	s1,104(sp)
    802027d0:	07213023          	sd	s2,96(sp)
    802027d4:	05313c23          	sd	s3,88(sp)
    802027d8:	05413823          	sd	s4,80(sp)
    802027dc:	05513423          	sd	s5,72(sp)
    802027e0:	05613023          	sd	s6,64(sp)
    802027e4:	03713c23          	sd	s7,56(sp)
    802027e8:	03813823          	sd	s8,48(sp)
    802027ec:	03913423          	sd	s9,40(sp)
    802027f0:	03a13023          	sd	s10,32(sp)
    802027f4:	01b13c23          	sd	s11,24(sp)
    802027f8:	08010413          	addi	s0,sp,128
    802027fc:	f8d43023          	sd	a3,-128(s0)
    80202800:	00070b13          	mv	s6,a4
    if (off + n > fs->superBlock.byts_per_clus)
    80202804:	010786bb          	addw	a3,a5,a6
    80202808:	05052703          	lw	a4,80(a0)
    8020280c:	04d76463          	bltu	a4,a3,80202854 <rw_clus+0x94>
    80202810:	00050c13          	mv	s8,a0
    80202814:	00060b93          	mv	s7,a2
    80202818:	00080c93          	mv	s9,a6
        panic("offset out of range");
    // printf("%s %d: rw_clus get in\n", __FILE__, __LINE__);
    uint tot, m;
    struct buf* bp;
    uint sec = first_sec_of_clus(fs, cluster) + off / fs->superBlock.bpb.byts_per_sec;
    8020281c:	05455703          	lhu	a4,84(a0)
    return ((cluster - 2) * fs->superBlock.bpb.sec_per_clus) + fs->superBlock.first_data_sec;
    80202820:	ffe5899b          	addiw	s3,a1,-2
    80202824:	05654683          	lbu	a3,86(a0)
    80202828:	02d989bb          	mulw	s3,s3,a3
    8020282c:	04452683          	lw	a3,68(a0)
    80202830:	00d989bb          	addw	s3,s3,a3
    uint sec = first_sec_of_clus(fs, cluster) + off / fs->superBlock.bpb.byts_per_sec;
    80202834:	02e7d6bb          	divuw	a3,a5,a4
    80202838:	00d989bb          	addw	s3,s3,a3
    off = off % fs->superBlock.bpb.byts_per_sec;
    8020283c:	02e7fabb          	remuw	s5,a5,a4

    int bad = 0;
    for (tot = 0; tot < n; tot += m, off += m, data += m, sec++) {
    80202840:	14080c63          	beqz	a6,80202998 <rw_clus+0x1d8>
    80202844:	00000a13          	li	s4,0
        bp = fs->read(fs, sec);
        m = BSIZE - off % BSIZE;
    80202848:	20000d93          	li	s11,512
            }
        } else {
            bad = either_copyout(user, data, bp->data + (off % BSIZE), m);
        }
        brelse(bp);
        if (bad == -1) {
    8020284c:	fff00d13          	li	s10,-1
    80202850:	0980006f          	j	802028e8 <rw_clus+0x128>
        panic("offset out of range");
    80202854:	00013697          	auipc	a3,0x13
    80202858:	c4468693          	addi	a3,a3,-956 # 80215498 <__func__.0+0x18>
    8020285c:	00014617          	auipc	a2,0x14
    80202860:	f1460613          	addi	a2,a2,-236 # 80216770 <__func__.8>
    80202864:	0d800593          	li	a1,216
    80202868:	00013517          	auipc	a0,0x13
    8020286c:	c2850513          	addi	a0,a0,-984 # 80215490 <__func__.0+0x10>
    80202870:	ffffe097          	auipc	ra,0xffffe
    80202874:	678080e7          	jalr	1656(ra) # 80200ee8 <_panic_>
                bwrite(bp);
    80202878:	00090513          	mv	a0,s2
    8020287c:	fffff097          	auipc	ra,0xfffff
    80202880:	66c080e7          	jalr	1644(ra) # 80201ee8 <bwrite>
        brelse(bp);
    80202884:	00090513          	mv	a0,s2
    80202888:	fffff097          	auipc	ra,0xfffff
    8020288c:	6b4080e7          	jalr	1716(ra) # 80201f3c <brelse>
        if (bad == -1) {
    80202890:	03c0006f          	j	802028cc <rw_clus+0x10c>
            bad = either_copyout(user, data, bp->data + (off % BSIZE), m);
    80202894:	05890613          	addi	a2,s2,88
    80202898:	02069693          	slli	a3,a3,0x20
    8020289c:	0206d693          	srli	a3,a3,0x20
    802028a0:	00e60633          	add	a2,a2,a4
    802028a4:	000b0593          	mv	a1,s6
    802028a8:	f8043503          	ld	a0,-128(s0)
    802028ac:	0000e097          	auipc	ra,0xe
    802028b0:	ac4080e7          	jalr	-1340(ra) # 80210370 <either_copyout>
    802028b4:	f8a43423          	sd	a0,-120(s0)
        brelse(bp);
    802028b8:	00090513          	mv	a0,s2
    802028bc:	fffff097          	auipc	ra,0xfffff
    802028c0:	680080e7          	jalr	1664(ra) # 80201f3c <brelse>
        if (bad == -1) {
    802028c4:	f8843783          	ld	a5,-120(s0)
    802028c8:	09a78863          	beq	a5,s10,80202958 <rw_clus+0x198>
    for (tot = 0; tot < n; tot += m, off += m, data += m, sec++) {
    802028cc:	01448a3b          	addw	s4,s1,s4
    802028d0:	01548abb          	addw	s5,s1,s5
    802028d4:	02049493          	slli	s1,s1,0x20
    802028d8:	0204d493          	srli	s1,s1,0x20
    802028dc:	009b0b33          	add	s6,s6,s1
    802028e0:	0019899b          	addiw	s3,s3,1
    802028e4:	079a7a63          	bgeu	s4,s9,80202958 <rw_clus+0x198>
        bp = fs->read(fs, sec);
    802028e8:	2e0c3783          	ld	a5,736(s8)
    802028ec:	02099593          	slli	a1,s3,0x20
    802028f0:	0205d593          	srli	a1,a1,0x20
    802028f4:	000c0513          	mv	a0,s8
    802028f8:	000780e7          	jalr	a5
    802028fc:	00050913          	mv	s2,a0
        m = BSIZE - off % BSIZE;
    80202900:	1ffaf713          	andi	a4,s5,511
        if (n - tot < m) {
    80202904:	414c87bb          	subw	a5,s9,s4
        m = BSIZE - off % BSIZE;
    80202908:	40ed863b          	subw	a2,s11,a4
    8020290c:	00078693          	mv	a3,a5
    80202910:	0007879b          	sext.w	a5,a5
    80202914:	0006059b          	sext.w	a1,a2
    80202918:	00f5f463          	bgeu	a1,a5,80202920 <rw_clus+0x160>
    8020291c:	00060693          	mv	a3,a2
    80202920:	0006849b          	sext.w	s1,a3
        if (write) {
    80202924:	f60b88e3          	beqz	s7,80202894 <rw_clus+0xd4>
            if ((bad = either_copyin(bp->data + (off % BSIZE), user, data,
    80202928:	05890513          	addi	a0,s2,88
    8020292c:	02069693          	slli	a3,a3,0x20
    80202930:	0206d693          	srli	a3,a3,0x20
    80202934:	000b0613          	mv	a2,s6
    80202938:	f8043583          	ld	a1,-128(s0)
    8020293c:	00e50533          	add	a0,a0,a4
    80202940:	0000e097          	auipc	ra,0xe
    80202944:	b44080e7          	jalr	-1212(ra) # 80210484 <either_copyin>
    80202948:	f3a518e3          	bne	a0,s10,80202878 <rw_clus+0xb8>
        brelse(bp);
    8020294c:	00090513          	mv	a0,s2
    80202950:	fffff097          	auipc	ra,0xfffff
    80202954:	5ec080e7          	jalr	1516(ra) # 80201f3c <brelse>
            break;
        }
    }
    // printf("%s %d: rw_clus get out\n", __FILE__, __LINE__);
    return tot;
}
    80202958:	000a0513          	mv	a0,s4
    8020295c:	07813083          	ld	ra,120(sp)
    80202960:	07013403          	ld	s0,112(sp)
    80202964:	06813483          	ld	s1,104(sp)
    80202968:	06013903          	ld	s2,96(sp)
    8020296c:	05813983          	ld	s3,88(sp)
    80202970:	05013a03          	ld	s4,80(sp)
    80202974:	04813a83          	ld	s5,72(sp)
    80202978:	04013b03          	ld	s6,64(sp)
    8020297c:	03813b83          	ld	s7,56(sp)
    80202980:	03013c03          	ld	s8,48(sp)
    80202984:	02813c83          	ld	s9,40(sp)
    80202988:	02013d03          	ld	s10,32(sp)
    8020298c:	01813d83          	ld	s11,24(sp)
    80202990:	08010113          	addi	sp,sp,128
    80202994:	00008067          	ret
    for (tot = 0; tot < n; tot += m, off += m, data += m, sec++) {
    80202998:	00080a13          	mv	s4,a6
    8020299c:	fbdff06f          	j	80202958 <rw_clus+0x198>

00000000802029a0 <reloc_clus>:
 * @param   entry       modify its cur_clus field
 * @param   off         the offset from the beginning of the relative file
 * @param   alloc       whether alloc new cluster when meeting end of FAT chains
 * @return              the offset from the new cur_clus
 */
int reloc_clus(FileSystem *fs, Dirent* entry, uint off, int alloc) {
    802029a0:	f7010113          	addi	sp,sp,-144
    802029a4:	08113423          	sd	ra,136(sp)
    802029a8:	08813023          	sd	s0,128(sp)
    802029ac:	06913c23          	sd	s1,120(sp)
    802029b0:	07213823          	sd	s2,112(sp)
    802029b4:	07313423          	sd	s3,104(sp)
    802029b8:	07413023          	sd	s4,96(sp)
    802029bc:	05513c23          	sd	s5,88(sp)
    802029c0:	05613823          	sd	s6,80(sp)
    802029c4:	05713423          	sd	s7,72(sp)
    802029c8:	05813023          	sd	s8,64(sp)
    802029cc:	03913c23          	sd	s9,56(sp)
    802029d0:	03a13823          	sd	s10,48(sp)
    802029d4:	03b13423          	sd	s11,40(sp)
    802029d8:	09010413          	addi	s0,sp,144
    802029dc:	00050a93          	mv	s5,a0
    802029e0:	00058493          	mv	s1,a1
    802029e4:	00060913          	mv	s2,a2
    802029e8:	f8d43423          	sd	a3,-120(s0)
    assert(entry->first_clus != 0);
    802029ec:	1045a683          	lw	a3,260(a1)
    802029f0:	00013997          	auipc	s3,0x13
    802029f4:	b1898993          	addi	s3,s3,-1256 # 80215508 <__func__.7>
    802029f8:	00d036b3          	snez	a3,a3
    802029fc:	00098613          	mv	a2,s3
    80202a00:	0ff00593          	li	a1,255
    80202a04:	00013517          	auipc	a0,0x13
    80202a08:	a8c50513          	addi	a0,a0,-1396 # 80215490 <__func__.0+0x10>
    80202a0c:	ffffe097          	auipc	ra,0xffffe
    80202a10:	54c080e7          	jalr	1356(ra) # 80200f58 <_assert_>
    assert(entry->inodeMaxCluster > 0);
    80202a14:	1104a683          	lw	a3,272(s1)
    80202a18:	00d036b3          	snez	a3,a3
    80202a1c:	00098613          	mv	a2,s3
    80202a20:	10000593          	li	a1,256
    80202a24:	00013517          	auipc	a0,0x13
    80202a28:	a6c50513          	addi	a0,a0,-1428 # 80215490 <__func__.0+0x10>
    80202a2c:	ffffe097          	auipc	ra,0xffffe
    80202a30:	52c080e7          	jalr	1324(ra) # 80200f58 <_assert_>
    assert(entry->first_clus == entry->inode.item[0]);
    80202a34:	1044a683          	lw	a3,260(s1)
    80202a38:	1184a783          	lw	a5,280(s1)
    80202a3c:	40f686b3          	sub	a3,a3,a5
    80202a40:	0016b693          	seqz	a3,a3
    80202a44:	00098613          	mv	a2,s3
    80202a48:	10100593          	li	a1,257
    80202a4c:	00013517          	auipc	a0,0x13
    80202a50:	a4450513          	addi	a0,a0,-1468 # 80215490 <__func__.0+0x10>
    80202a54:	ffffe097          	auipc	ra,0xffffe
    80202a58:	504080e7          	jalr	1284(ra) # 80200f58 <_assert_>
    int clus_num = off / fs->superBlock.byts_per_clus;
    80202a5c:	050aa783          	lw	a5,80(s5)
    80202a60:	02f9573b          	divuw	a4,s2,a5
    80202a64:	00070b9b          	sext.w	s7,a4
    int ret = off % fs->superBlock.byts_per_clus;
    80202a68:	02f977bb          	remuw	a5,s2,a5
    80202a6c:	f6f43c23          	sd	a5,-136(s0)
    if (clus_num < entry->inodeMaxCluster) {
    80202a70:	1104a583          	lw	a1,272(s1)
    80202a74:	02bbec63          	bltu	s7,a1,80202aac <reloc_clus+0x10c>
        eFindInode(entry, clus_num);
        return ret;
    }
    if (entry->inodeMaxCluster > 0) {
    80202a78:	04059463          	bnez	a1,80202ac0 <reloc_clus+0x120>
        eFindInode(entry, entry->inodeMaxCluster - 1);
    }
    while (clus_num > entry->clus_cnt) {
    80202a7c:	1144a783          	lw	a5,276(s1)
    80202a80:	0777f463          	bgeu	a5,s7,80202ae8 <reloc_clus+0x148>
        int clus = read_fat(fs, entry->cur_clus);
        if (clus >= FAT32_EOC) {
    80202a84:	10000c37          	lui	s8,0x10000
    80202a88:	ff7c0c13          	addi	s8,s8,-9 # ffffff7 <_start-0x70200009>
        entry->cur_clus = clus;
        entry->clus_cnt++;
        u32 pos = entry->clus_cnt;
        assert(pos == entry->inodeMaxCluster);
        entry->inodeMaxCluster++;
        if (pos < INODE_SECOND_LEVEL_BOTTOM) {
    80202a8c:	00700c93          	li	s9,7
            entry->inode.item[pos] = clus;
            continue;
        }
        if (pos < INODE_THIRD_LEVEL_BOTTOM) {
    80202a90:	40700d13          	li	s10,1031
                entry->inode.item[idx1] = inodeAlloc();
            }
            inodes[entry->inode.item[idx1]].item[idx2] = clus;
            continue;
        }
        if (pos < INODE_THIRD_LEVEL_TOP) {
    80202a94:	000287b7          	lui	a5,0x28
    80202a98:	40778793          	addi	a5,a5,1031 # 28407 <_start-0x801d7bf9>
    80202a9c:	f8f43023          	sd	a5,-128(s0)
                if (idx2 == 0) {
                    entry->inode.item[idx1] = inodeAlloc();
                }
                inodes[entry->inode.item[idx1]].item[idx2] = inodeAlloc();
            }
            inodes[inodes[entry->inode.item[idx1]].item[idx2]].item[idx3] = clus;
    80202aa0:	010b5b17          	auipc	s6,0x10b5
    80202aa4:	7c0b0b13          	addi	s6,s6,1984 # 812b8260 <inodes>
    80202aa8:	1580006f          	j	80202c00 <reloc_clus+0x260>
        eFindInode(entry, clus_num);
    80202aac:	000b8593          	mv	a1,s7
    80202ab0:	00048513          	mv	a0,s1
    80202ab4:	00000097          	auipc	ra,0x0
    80202ab8:	800080e7          	jalr	-2048(ra) # 802022b4 <eFindInode>
        return ret;
    80202abc:	02c0006f          	j	80202ae8 <reloc_clus+0x148>
        eFindInode(entry, entry->inodeMaxCluster - 1);
    80202ac0:	fff5859b          	addiw	a1,a1,-1
    80202ac4:	00048513          	mv	a0,s1
    80202ac8:	fffff097          	auipc	ra,0xfffff
    80202acc:	7ec080e7          	jalr	2028(ra) # 802022b4 <eFindInode>
    80202ad0:	fadff06f          	j	80202a7c <reloc_clus+0xdc>
                entry->cur_clus = entry->first_clus;
    80202ad4:	1044a783          	lw	a5,260(s1)
    80202ad8:	10f4a623          	sw	a5,268(s1)
                entry->clus_cnt = 0;
    80202adc:	1004aa23          	sw	zero,276(s1)
                return -1;
    80202ae0:	fff00793          	li	a5,-1
    80202ae4:	f6f43c23          	sd	a5,-136(s0)
            continue;
        }
        panic("");
    }
    return ret;
}
    80202ae8:	f7843503          	ld	a0,-136(s0)
    80202aec:	08813083          	ld	ra,136(sp)
    80202af0:	08013403          	ld	s0,128(sp)
    80202af4:	07813483          	ld	s1,120(sp)
    80202af8:	07013903          	ld	s2,112(sp)
    80202afc:	06813983          	ld	s3,104(sp)
    80202b00:	06013a03          	ld	s4,96(sp)
    80202b04:	05813a83          	ld	s5,88(sp)
    80202b08:	05013b03          	ld	s6,80(sp)
    80202b0c:	04813b83          	ld	s7,72(sp)
    80202b10:	04013c03          	ld	s8,64(sp)
    80202b14:	03813c83          	ld	s9,56(sp)
    80202b18:	03013d03          	ld	s10,48(sp)
    80202b1c:	02813d83          	ld	s11,40(sp)
    80202b20:	09010113          	addi	sp,sp,144
    80202b24:	00008067          	ret
            entry->inode.item[pos] = clus;
    80202b28:	020a1793          	slli	a5,s4,0x20
    80202b2c:	01e7da13          	srli	s4,a5,0x1e
    80202b30:	01448a33          	add	s4,s1,s4
    80202b34:	112a2c23          	sw	s2,280(s4) # 1118 <_start-0x801feee8>
            continue;
    80202b38:	0c00006f          	j	80202bf8 <reloc_clus+0x258>
            int idx1 = INODE_SECOND_ITEM_BASE + (pos - INODE_SECOND_LEVEL_BOTTOM) / INODE_ITEM_NUM;
    80202b3c:	ff99899b          	addiw	s3,s3,-7
    80202b40:	0069d79b          	srliw	a5,s3,0x6
    80202b44:	00878a1b          	addiw	s4,a5,8
            int idx2 = (pos - INODE_SECOND_LEVEL_BOTTOM) % INODE_ITEM_NUM;
    80202b48:	03f9f993          	andi	s3,s3,63
            if (idx2 == 0) {
    80202b4c:	02098663          	beqz	s3,80202b78 <reloc_clus+0x1d8>
            inodes[entry->inode.item[idx1]].item[idx2] = clus;
    80202b50:	044a0a13          	addi	s4,s4,68
    80202b54:	002a1a13          	slli	s4,s4,0x2
    80202b58:	01448a33          	add	s4,s1,s4
    80202b5c:	008a6783          	lwu	a5,8(s4)
    80202b60:	00679793          	slli	a5,a5,0x6
    80202b64:	013787b3          	add	a5,a5,s3
    80202b68:	00279793          	slli	a5,a5,0x2
    80202b6c:	00fb07b3          	add	a5,s6,a5
    80202b70:	0127a023          	sw	s2,0(a5)
            continue;
    80202b74:	0840006f          	j	80202bf8 <reloc_clus+0x258>
                entry->inode.item[idx1] = inodeAlloc();
    80202b78:	00002097          	auipc	ra,0x2
    80202b7c:	354080e7          	jalr	852(ra) # 80204ecc <inodeAlloc>
    80202b80:	044a0793          	addi	a5,s4,68
    80202b84:	00279793          	slli	a5,a5,0x2
    80202b88:	00f487b3          	add	a5,s1,a5
    80202b8c:	00a7a423          	sw	a0,8(a5)
    80202b90:	fc1ff06f          	j	80202b50 <reloc_clus+0x1b0>
                inodes[entry->inode.item[idx1]].item[idx2] = inodeAlloc();
    80202b94:	00002097          	auipc	ra,0x2
    80202b98:	338080e7          	jalr	824(ra) # 80204ecc <inodeAlloc>
    80202b9c:	044a0793          	addi	a5,s4,68
    80202ba0:	00279793          	slli	a5,a5,0x2
    80202ba4:	00f487b3          	add	a5,s1,a5
    80202ba8:	0087e783          	lwu	a5,8(a5)
    80202bac:	00679793          	slli	a5,a5,0x6
    80202bb0:	01b787b3          	add	a5,a5,s11
    80202bb4:	00279793          	slli	a5,a5,0x2
    80202bb8:	00fb07b3          	add	a5,s6,a5
    80202bbc:	00a7a023          	sw	a0,0(a5)
            inodes[inodes[entry->inode.item[idx1]].item[idx2]].item[idx3] = clus;
    80202bc0:	044a0a13          	addi	s4,s4,68
    80202bc4:	002a1a13          	slli	s4,s4,0x2
    80202bc8:	01448a33          	add	s4,s1,s4
    80202bcc:	008a6783          	lwu	a5,8(s4)
    80202bd0:	00679793          	slli	a5,a5,0x6
    80202bd4:	01b787b3          	add	a5,a5,s11
    80202bd8:	00279793          	slli	a5,a5,0x2
    80202bdc:	00fb07b3          	add	a5,s6,a5
    80202be0:	0007e783          	lwu	a5,0(a5)
    80202be4:	00679793          	slli	a5,a5,0x6
    80202be8:	013787b3          	add	a5,a5,s3
    80202bec:	00279793          	slli	a5,a5,0x2
    80202bf0:	00fb07b3          	add	a5,s6,a5
    80202bf4:	0127a023          	sw	s2,0(a5)
    while (clus_num > entry->clus_cnt) {
    80202bf8:	1144a783          	lw	a5,276(s1)
    80202bfc:	ef77f6e3          	bgeu	a5,s7,80202ae8 <reloc_clus+0x148>
        int clus = read_fat(fs, entry->cur_clus);
    80202c00:	10c4a583          	lw	a1,268(s1)
    80202c04:	000a8513          	mv	a0,s5
    80202c08:	fffff097          	auipc	ra,0xfffff
    80202c0c:	55c080e7          	jalr	1372(ra) # 80202164 <read_fat>
    80202c10:	0005091b          	sext.w	s2,a0
        if (clus >= FAT32_EOC) {
    80202c14:	032c5a63          	bge	s8,s2,80202c48 <reloc_clus+0x2a8>
            if (alloc) {
    80202c18:	f8843783          	ld	a5,-120(s0)
    80202c1c:	ea078ce3          	beqz	a5,80202ad4 <reloc_clus+0x134>
                clus = alloc_clus(fs, entry->dev);
    80202c20:	2284c583          	lbu	a1,552(s1)
    80202c24:	000a8513          	mv	a0,s5
    80202c28:	00000097          	auipc	ra,0x0
    80202c2c:	820080e7          	jalr	-2016(ra) # 80202448 <alloc_clus>
    80202c30:	0005091b          	sext.w	s2,a0
                write_fat(fs, entry->cur_clus, clus);
    80202c34:	00090613          	mv	a2,s2
    80202c38:	10c4a583          	lw	a1,268(s1)
    80202c3c:	000a8513          	mv	a0,s5
    80202c40:	fffff097          	auipc	ra,0xfffff
    80202c44:	5c0080e7          	jalr	1472(ra) # 80202200 <write_fat>
        entry->cur_clus = clus;
    80202c48:	0009091b          	sext.w	s2,s2
    80202c4c:	1124a623          	sw	s2,268(s1)
        entry->clus_cnt++;
    80202c50:	1144a983          	lw	s3,276(s1)
    80202c54:	00198a1b          	addiw	s4,s3,1
    80202c58:	000a0d9b          	sext.w	s11,s4
    80202c5c:	1144aa23          	sw	s4,276(s1)
        assert(pos == entry->inodeMaxCluster);
    80202c60:	1104a683          	lw	a3,272(s1)
    80202c64:	41b686b3          	sub	a3,a3,s11
    80202c68:	0016b693          	seqz	a3,a3
    80202c6c:	00013617          	auipc	a2,0x13
    80202c70:	89c60613          	addi	a2,a2,-1892 # 80215508 <__func__.7>
    80202c74:	11a00593          	li	a1,282
    80202c78:	00013517          	auipc	a0,0x13
    80202c7c:	81850513          	addi	a0,a0,-2024 # 80215490 <__func__.0+0x10>
    80202c80:	ffffe097          	auipc	ra,0xffffe
    80202c84:	2d8080e7          	jalr	728(ra) # 80200f58 <_assert_>
        entry->inodeMaxCluster++;
    80202c88:	1104a783          	lw	a5,272(s1)
    80202c8c:	0017879b          	addiw	a5,a5,1
    80202c90:	10f4a823          	sw	a5,272(s1)
        if (pos < INODE_SECOND_LEVEL_BOTTOM) {
    80202c94:	e9bcfae3          	bgeu	s9,s11,80202b28 <reloc_clus+0x188>
        if (pos < INODE_THIRD_LEVEL_BOTTOM) {
    80202c98:	ebbd72e3          	bgeu	s10,s11,80202b3c <reloc_clus+0x19c>
        if (pos < INODE_THIRD_LEVEL_TOP) {
    80202c9c:	f8043783          	ld	a5,-128(s0)
    80202ca0:	05b7e063          	bltu	a5,s11,80202ce0 <reloc_clus+0x340>
            int idx1 = INODE_THIRD_ITEM_BASE + (pos - INODE_THIRD_LEVEL_BOTTOM) / INODE_ITEM_NUM / INODE_ITEM_NUM;
    80202ca4:	bf99899b          	addiw	s3,s3,-1031
    80202ca8:	00c9da1b          	srliw	s4,s3,0xc
    80202cac:	018a0a1b          	addiw	s4,s4,24
            int idx2 = (pos - INODE_THIRD_LEVEL_BOTTOM) / INODE_ITEM_NUM % INODE_ITEM_NUM;
    80202cb0:	0069dd9b          	srliw	s11,s3,0x6
    80202cb4:	03fdfd93          	andi	s11,s11,63
            int idx3 = (pos - INODE_THIRD_LEVEL_BOTTOM) % INODE_ITEM_NUM;
    80202cb8:	03f9f993          	andi	s3,s3,63
            if (idx3 == 0) {
    80202cbc:	f00992e3          	bnez	s3,80202bc0 <reloc_clus+0x220>
                if (idx2 == 0) {
    80202cc0:	ec0d9ae3          	bnez	s11,80202b94 <reloc_clus+0x1f4>
                    entry->inode.item[idx1] = inodeAlloc();
    80202cc4:	00002097          	auipc	ra,0x2
    80202cc8:	208080e7          	jalr	520(ra) # 80204ecc <inodeAlloc>
    80202ccc:	044a0793          	addi	a5,s4,68
    80202cd0:	00279793          	slli	a5,a5,0x2
    80202cd4:	00f487b3          	add	a5,s1,a5
    80202cd8:	00a7a423          	sw	a0,8(a5)
    80202cdc:	eb9ff06f          	j	80202b94 <reloc_clus+0x1f4>
        panic("");
    80202ce0:	00013697          	auipc	a3,0x13
    80202ce4:	f0868693          	addi	a3,a3,-248 # 80215be8 <__func__.0+0x48>
    80202ce8:	00013617          	auipc	a2,0x13
    80202cec:	82060613          	addi	a2,a2,-2016 # 80215508 <__func__.7>
    80202cf0:	13600593          	li	a1,310
    80202cf4:	00012517          	auipc	a0,0x12
    80202cf8:	79c50513          	addi	a0,a0,1948 # 80215490 <__func__.0+0x10>
    80202cfc:	ffffe097          	auipc	ra,0xffffe
    80202d00:	1ec080e7          	jalr	492(ra) # 80200ee8 <_panic_>

0000000080202d04 <getBlockNumber>:

int getBlockNumber(Dirent* entry, int dataBlockNum) {
    80202d04:	fd010113          	addi	sp,sp,-48
    80202d08:	02113423          	sd	ra,40(sp)
    80202d0c:	02813023          	sd	s0,32(sp)
    80202d10:	00913c23          	sd	s1,24(sp)
    80202d14:	01213823          	sd	s2,16(sp)
    80202d18:	01313423          	sd	s3,8(sp)
    80202d1c:	03010413          	addi	s0,sp,48
    int offset = (dataBlockNum << 9);
    80202d20:	0095949b          	slliw	s1,a1,0x9
    if (offset > entry->file_size) {
    80202d24:	0004861b          	sext.w	a2,s1
    80202d28:	10852783          	lw	a5,264(a0)
    80202d2c:	06c7e463          	bltu	a5,a2,80202d94 <getBlockNumber+0x90>
    80202d30:	00050913          	mv	s2,a0
        return -1;
    }
    
    FileSystem *fs = entry->fileSystem;
    80202d34:	22053983          	ld	s3,544(a0)
    reloc_clus(fs, entry, offset, 0);
    80202d38:	00000693          	li	a3,0
    80202d3c:	00050593          	mv	a1,a0
    80202d40:	00098513          	mv	a0,s3
    80202d44:	00000097          	auipc	ra,0x0
    80202d48:	c5c080e7          	jalr	-932(ra) # 802029a0 <reloc_clus>
    return ((cluster - 2) * fs->superBlock.bpb.sec_per_clus) + fs->superBlock.first_data_sec;
    80202d4c:	10c92503          	lw	a0,268(s2)
    80202d50:	ffe5051b          	addiw	a0,a0,-2
    80202d54:	0569c783          	lbu	a5,86(s3)
    80202d58:	02f5053b          	mulw	a0,a0,a5
    80202d5c:	0449a783          	lw	a5,68(s3)
    80202d60:	00f5053b          	addw	a0,a0,a5
    
    return first_sec_of_clus(fs, entry->cur_clus) + offset % fs->superBlock.byts_per_clus / fs->superBlock.bpb.byts_per_sec;
    80202d64:	0509a783          	lw	a5,80(s3)
    80202d68:	02f4f4bb          	remuw	s1,s1,a5
    80202d6c:	0549d783          	lhu	a5,84(s3)
    80202d70:	02f4d4bb          	divuw	s1,s1,a5
    80202d74:	0095053b          	addw	a0,a0,s1
}
    80202d78:	02813083          	ld	ra,40(sp)
    80202d7c:	02013403          	ld	s0,32(sp)
    80202d80:	01813483          	ld	s1,24(sp)
    80202d84:	01013903          	ld	s2,16(sp)
    80202d88:	00813983          	ld	s3,8(sp)
    80202d8c:	03010113          	addi	sp,sp,48
    80202d90:	00008067          	ret
        return -1;
    80202d94:	fff00513          	li	a0,-1
    80202d98:	fe1ff06f          	j	80202d78 <getBlockNumber+0x74>

0000000080202d9c <eread>:

/* like the original readi, but "reade" is odd, let alone "writee" */
// Caller must hold entry->lock.
int eread(Dirent* entry, int user_dst, u64 dst, uint off, uint n) {
    80202d9c:	f9010113          	addi	sp,sp,-112
    80202da0:	06113423          	sd	ra,104(sp)
    80202da4:	06813023          	sd	s0,96(sp)
    80202da8:	04913c23          	sd	s1,88(sp)
    80202dac:	05213823          	sd	s2,80(sp)
    80202db0:	05313423          	sd	s3,72(sp)
    80202db4:	05413023          	sd	s4,64(sp)
    80202db8:	03513c23          	sd	s5,56(sp)
    80202dbc:	03613823          	sd	s6,48(sp)
    80202dc0:	03713423          	sd	s7,40(sp)
    80202dc4:	03813023          	sd	s8,32(sp)
    80202dc8:	01913c23          	sd	s9,24(sp)
    80202dcc:	01a13823          	sd	s10,16(sp)
    80202dd0:	07010413          	addi	s0,sp,112
    80202dd4:	00058c13          	mv	s8,a1
    80202dd8:	00060a93          	mv	s5,a2
    80202ddc:	00070b13          	mv	s6,a4
    if (entry->dev == ZERO) {
    80202de0:	22852783          	lw	a5,552(a0)
    80202de4:	00a00713          	li	a4,10
    80202de8:	06e78063          	beq	a5,a4,80202e48 <eread+0xac>
    80202dec:	00050993          	mv	s3,a0
    80202df0:	00068913          	mv	s2,a3
        if (!either_memset(user_dst, dst, 0, n)) {
            return n;
        }
        panic("error!\n");
    } else if (entry->dev == OSRELEASE) {
    80202df4:	00c00713          	li	a4,12
    80202df8:	0ce78863          	beq	a5,a4,80202ec8 <eread+0x12c>
        if (!either_copyout(user_dst, dst, (char*)osrelease, sizeof(osrelease))) {
            return sizeof(osrelease);
        }
        panic("error!\n");
    }
    if (off > entry->file_size || off + n < off ||
    80202dfc:	10852783          	lw	a5,264(a0)
        (entry->attribute & ATTR_DIRECTORY)) {
        return 0;
    80202e00:	00000513          	li	a0,0
    if (off > entry->file_size || off + n < off ||
    80202e04:	06d7e463          	bltu	a5,a3,80202e6c <eread+0xd0>
    80202e08:	016686bb          	addw	a3,a3,s6
    80202e0c:	0726e063          	bltu	a3,s2,80202e6c <eread+0xd0>
    80202e10:	1009c703          	lbu	a4,256(s3)
    80202e14:	01077713          	andi	a4,a4,16
    80202e18:	04071a63          	bnez	a4,80202e6c <eread+0xd0>
    }
    if (off + n > entry->file_size) {
    80202e1c:	00d7f463          	bgeu	a5,a3,80202e24 <eread+0x88>
        n = entry->file_size - off;
    80202e20:	41278b3b          	subw	s6,a5,s2
    }

    FileSystem *fs = entry->fileSystem;
    80202e24:	2209bb83          	ld	s7,544(s3)
    uint tot, m;
    for (tot = 0; entry->cur_clus < FAT32_EOC && tot < n;
    80202e28:	10c9a703          	lw	a4,268(s3)
    80202e2c:	100007b7          	lui	a5,0x10000
    80202e30:	ff778793          	addi	a5,a5,-9 # ffffff7 <_start-0x70200009>
    80202e34:	18e7e463          	bltu	a5,a4,80202fbc <eread+0x220>
    80202e38:	180b0863          	beqz	s6,80202fc8 <eread+0x22c>
    80202e3c:	00000a13          	li	s4,0
    80202e40:	00078c93          	mv	s9,a5
    80202e44:	1340006f          	j	80202f78 <eread+0x1dc>
        if (!either_memset(user_dst, dst, 0, n)) {
    80202e48:	020b1693          	slli	a3,s6,0x20
    80202e4c:	0206d693          	srli	a3,a3,0x20
    80202e50:	00000613          	li	a2,0
    80202e54:	000a8593          	mv	a1,s5
    80202e58:	0ffc7513          	zext.b	a0,s8
    80202e5c:	0000d097          	auipc	ra,0xd
    80202e60:	5a4080e7          	jalr	1444(ra) # 80210400 <either_memset>
    80202e64:	04051063          	bnez	a0,80202ea4 <eread+0x108>
            return n;
    80202e68:	000b051b          	sext.w	a0,s6
            off % fs->superBlock.byts_per_clus, m) != m) {
            break;
        }
    }
    return tot;
}
    80202e6c:	06813083          	ld	ra,104(sp)
    80202e70:	06013403          	ld	s0,96(sp)
    80202e74:	05813483          	ld	s1,88(sp)
    80202e78:	05013903          	ld	s2,80(sp)
    80202e7c:	04813983          	ld	s3,72(sp)
    80202e80:	04013a03          	ld	s4,64(sp)
    80202e84:	03813a83          	ld	s5,56(sp)
    80202e88:	03013b03          	ld	s6,48(sp)
    80202e8c:	02813b83          	ld	s7,40(sp)
    80202e90:	02013c03          	ld	s8,32(sp)
    80202e94:	01813c83          	ld	s9,24(sp)
    80202e98:	01013d03          	ld	s10,16(sp)
    80202e9c:	07010113          	addi	sp,sp,112
    80202ea0:	00008067          	ret
        panic("error!\n");
    80202ea4:	00012697          	auipc	a3,0x12
    80202ea8:	50468693          	addi	a3,a3,1284 # 802153a8 <textEnd+0x3a8>
    80202eac:	00014617          	auipc	a2,0x14
    80202eb0:	8bc60613          	addi	a2,a2,-1860 # 80216768 <__func__.4>
    80202eb4:	14e00593          	li	a1,334
    80202eb8:	00012517          	auipc	a0,0x12
    80202ebc:	5d850513          	addi	a0,a0,1496 # 80215490 <__func__.0+0x10>
    80202ec0:	ffffe097          	auipc	ra,0xffffe
    80202ec4:	028080e7          	jalr	40(ra) # 80200ee8 <_panic_>
        char osrelease[] = "10.2.0";
    80202ec8:	322e37b7          	lui	a5,0x322e3
    80202ecc:	03178793          	addi	a5,a5,49 # 322e3031 <_start-0x4df1cfcf>
    80202ed0:	f8f42c23          	sw	a5,-104(s0)
    80202ed4:	000037b7          	lui	a5,0x3
    80202ed8:	02e78793          	addi	a5,a5,46 # 302e <_start-0x801fcfd2>
    80202edc:	f8f41e23          	sh	a5,-100(s0)
    80202ee0:	f8040f23          	sb	zero,-98(s0)
        if (!either_copyout(user_dst, dst, (char*)osrelease, sizeof(osrelease))) {
    80202ee4:	00700693          	li	a3,7
    80202ee8:	f9840613          	addi	a2,s0,-104
    80202eec:	000a8593          	mv	a1,s5
    80202ef0:	000c0513          	mv	a0,s8
    80202ef4:	0000d097          	auipc	ra,0xd
    80202ef8:	47c080e7          	jalr	1148(ra) # 80210370 <either_copyout>
    80202efc:	00051663          	bnez	a0,80202f08 <eread+0x16c>
            return sizeof(osrelease);
    80202f00:	00700513          	li	a0,7
    80202f04:	f69ff06f          	j	80202e6c <eread+0xd0>
        panic("error!\n");
    80202f08:	00012697          	auipc	a3,0x12
    80202f0c:	4a068693          	addi	a3,a3,1184 # 802153a8 <textEnd+0x3a8>
    80202f10:	00014617          	auipc	a2,0x14
    80202f14:	85860613          	addi	a2,a2,-1960 # 80216768 <__func__.4>
    80202f18:	15400593          	li	a1,340
    80202f1c:	00012517          	auipc	a0,0x12
    80202f20:	57450513          	addi	a0,a0,1396 # 80215490 <__func__.0+0x10>
    80202f24:	ffffe097          	auipc	ra,0xffffe
    80202f28:	fc4080e7          	jalr	-60(ra) # 80200ee8 <_panic_>
    80202f2c:	00048d1b          	sext.w	s10,s1
        if (rw_clus(fs, entry->cur_clus, 0, user_dst, dst, 
    80202f30:	000d0813          	mv	a6,s10
    80202f34:	000a8713          	mv	a4,s5
    80202f38:	000c0693          	mv	a3,s8
    80202f3c:	00000613          	li	a2,0
    80202f40:	10c9a583          	lw	a1,268(s3)
    80202f44:	000b8513          	mv	a0,s7
    80202f48:	00000097          	auipc	ra,0x0
    80202f4c:	878080e7          	jalr	-1928(ra) # 802027c0 <rw_clus>
    80202f50:	0005051b          	sext.w	a0,a0
    80202f54:	06ad1663          	bne	s10,a0,80202fc0 <eread+0x224>
         tot += m, off += m, dst += m) {
    80202f58:	01448a3b          	addw	s4,s1,s4
    80202f5c:	0124893b          	addw	s2,s1,s2
    80202f60:	02049493          	slli	s1,s1,0x20
    80202f64:	0204d493          	srli	s1,s1,0x20
    80202f68:	009a8ab3          	add	s5,s5,s1
    for (tot = 0; entry->cur_clus < FAT32_EOC && tot < n;
    80202f6c:	10c9a783          	lw	a5,268(s3)
    80202f70:	04fce863          	bltu	s9,a5,80202fc0 <eread+0x224>
    80202f74:	056a7663          	bgeu	s4,s6,80202fc0 <eread+0x224>
        reloc_clus(fs, entry, off, 0);
    80202f78:	00000693          	li	a3,0
    80202f7c:	00090613          	mv	a2,s2
    80202f80:	00098593          	mv	a1,s3
    80202f84:	000b8513          	mv	a0,s7
    80202f88:	00000097          	auipc	ra,0x0
    80202f8c:	a18080e7          	jalr	-1512(ra) # 802029a0 <reloc_clus>
        m = fs->superBlock.byts_per_clus - off % fs->superBlock.byts_per_clus;
    80202f90:	050ba703          	lw	a4,80(s7)
    80202f94:	02e976bb          	remuw	a3,s2,a4
    80202f98:	0006879b          	sext.w	a5,a3
        if (n - tot < m) {
    80202f9c:	414b083b          	subw	a6,s6,s4
        m = fs->superBlock.byts_per_clus - off % fs->superBlock.byts_per_clus;
    80202fa0:	40d7073b          	subw	a4,a4,a3
    80202fa4:	00080493          	mv	s1,a6
    80202fa8:	0008081b          	sext.w	a6,a6
    80202fac:	0007069b          	sext.w	a3,a4
    80202fb0:	f706fee3          	bgeu	a3,a6,80202f2c <eread+0x190>
    80202fb4:	00070493          	mv	s1,a4
    80202fb8:	f75ff06f          	j	80202f2c <eread+0x190>
    for (tot = 0; entry->cur_clus < FAT32_EOC && tot < n;
    80202fbc:	00000a13          	li	s4,0
    return tot;
    80202fc0:	000a051b          	sext.w	a0,s4
    80202fc4:	ea9ff06f          	j	80202e6c <eread+0xd0>
    for (tot = 0; entry->cur_clus < FAT32_EOC && tot < n;
    80202fc8:	000b0a13          	mv	s4,s6
    80202fcc:	ff5ff06f          	j	80202fc0 <eread+0x224>

0000000080202fd0 <ewrite>:

// Caller must hold entry->lock.
int ewrite(Dirent* entry, int user_src, u64 src, uint off, uint n) {
    80202fd0:	fa010113          	addi	sp,sp,-96
    80202fd4:	04113c23          	sd	ra,88(sp)
    80202fd8:	04813823          	sd	s0,80(sp)
    80202fdc:	04913423          	sd	s1,72(sp)
    80202fe0:	05213023          	sd	s2,64(sp)
    80202fe4:	03313c23          	sd	s3,56(sp)
    80202fe8:	03413823          	sd	s4,48(sp)
    80202fec:	03513423          	sd	s5,40(sp)
    80202ff0:	03613023          	sd	s6,32(sp)
    80202ff4:	01713c23          	sd	s7,24(sp)
    80202ff8:	01813823          	sd	s8,16(sp)
    80202ffc:	01913423          	sd	s9,8(sp)
    80203000:	06010413          	addi	s0,sp,96
    80203004:	00058c13          	mv	s8,a1
    80203008:	00070b93          	mv	s7,a4
    if (entry->dev == NONE) {
    8020300c:	22852583          	lw	a1,552(a0)
    80203010:	00f00793          	li	a5,15
    80203014:	06f58263          	beq	a1,a5,80203078 <ewrite+0xa8>
    80203018:	00050a93          	mv	s5,a0
    8020301c:	00060a13          	mv	s4,a2
    80203020:	00068913          	mv	s2,a3
        return n;
    }
    if (off > entry->file_size || off + n < off ||
    80203024:	10852783          	lw	a5,264(a0)
    80203028:	10d7ec63          	bltu	a5,a3,80203140 <ewrite+0x170>
    8020302c:	00e687bb          	addw	a5,a3,a4
    80203030:	10d7ec63          	bltu	a5,a3,80203148 <ewrite+0x178>
        (u64)off + n > 0xffffffff || (entry->attribute & ATTR_READ_ONLY)) {
    80203034:	02069793          	slli	a5,a3,0x20
    80203038:	0207d793          	srli	a5,a5,0x20
    8020303c:	02071713          	slli	a4,a4,0x20
    80203040:	02075713          	srli	a4,a4,0x20
    80203044:	00e787b3          	add	a5,a5,a4
    if (off > entry->file_size || off + n < off ||
    80203048:	fff00713          	li	a4,-1
    8020304c:	02075713          	srli	a4,a4,0x20
    80203050:	10f76063          	bltu	a4,a5,80203150 <ewrite+0x180>
        (u64)off + n > 0xffffffff || (entry->attribute & ATTR_READ_ONLY)) {
    80203054:	10054783          	lbu	a5,256(a0)
    80203058:	0017f793          	andi	a5,a5,1
    8020305c:	0e079e63          	bnez	a5,80203158 <ewrite+0x188>
        return -1;
    }
    FileSystem *fs = entry->fileSystem;
    80203060:	22053b03          	ld	s6,544(a0)
    if (entry->first_clus ==
    80203064:	10452783          	lw	a5,260(a0)
    80203068:	00078c63          	beqz	a5,80203080 <ewrite+0xb0>
        entry->cur_clus = entry->first_clus = entry->inode.item[0] = alloc_clus(fs, entry->dev);
        entry->inodeMaxCluster = 1;
        entry->clus_cnt = 0;
    }
    uint tot, m;
    for (tot = 0; tot < n; tot += m, off += m, src += m) {
    8020306c:	0c0b8663          	beqz	s7,80203138 <ewrite+0x168>
    80203070:	00000993          	li	s3,0
    80203074:	0800006f          	j	802030f4 <ewrite+0x124>
        return n;
    80203078:	0007051b          	sext.w	a0,a4
    8020307c:	0f40006f          	j	80203170 <ewrite+0x1a0>
        entry->cur_clus = entry->first_clus = entry->inode.item[0] = alloc_clus(fs, entry->dev);
    80203080:	0ff5f593          	zext.b	a1,a1
    80203084:	000b0513          	mv	a0,s6
    80203088:	fffff097          	auipc	ra,0xfffff
    8020308c:	3c0080e7          	jalr	960(ra) # 80202448 <alloc_clus>
    80203090:	0005051b          	sext.w	a0,a0
    80203094:	10aaac23          	sw	a0,280(s5)
    80203098:	10aaa223          	sw	a0,260(s5)
    8020309c:	10aaa623          	sw	a0,268(s5)
        entry->inodeMaxCluster = 1;
    802030a0:	00100793          	li	a5,1
    802030a4:	10faa823          	sw	a5,272(s5)
        entry->clus_cnt = 0;
    802030a8:	100aaa23          	sw	zero,276(s5)
    802030ac:	fc1ff06f          	j	8020306c <ewrite+0x9c>
    802030b0:	00048c9b          	sext.w	s9,s1
        reloc_clus(fs, entry, off, 1);
        m = fs->superBlock.byts_per_clus - off % fs->superBlock.byts_per_clus;
        if (n - tot < m) {
            m = n - tot;
        }
        if (rw_clus(fs, entry->cur_clus, 1, user_src, src, 
    802030b4:	000c8813          	mv	a6,s9
    802030b8:	000a0713          	mv	a4,s4
    802030bc:	000c0693          	mv	a3,s8
    802030c0:	00100613          	li	a2,1
    802030c4:	10caa583          	lw	a1,268(s5)
    802030c8:	000b0513          	mv	a0,s6
    802030cc:	fffff097          	auipc	ra,0xfffff
    802030d0:	6f4080e7          	jalr	1780(ra) # 802027c0 <rw_clus>
    802030d4:	0005051b          	sext.w	a0,a0
    802030d8:	08ac9463          	bne	s9,a0,80203160 <ewrite+0x190>
    for (tot = 0; tot < n; tot += m, off += m, src += m) {
    802030dc:	013489bb          	addw	s3,s1,s3
    802030e0:	0124893b          	addw	s2,s1,s2
    802030e4:	02049493          	slli	s1,s1,0x20
    802030e8:	0204d493          	srli	s1,s1,0x20
    802030ec:	009a0a33          	add	s4,s4,s1
    802030f0:	0779f863          	bgeu	s3,s7,80203160 <ewrite+0x190>
        reloc_clus(fs, entry, off, 1);
    802030f4:	00100693          	li	a3,1
    802030f8:	00090613          	mv	a2,s2
    802030fc:	000a8593          	mv	a1,s5
    80203100:	000b0513          	mv	a0,s6
    80203104:	00000097          	auipc	ra,0x0
    80203108:	89c080e7          	jalr	-1892(ra) # 802029a0 <reloc_clus>
        m = fs->superBlock.byts_per_clus - off % fs->superBlock.byts_per_clus;
    8020310c:	050b2703          	lw	a4,80(s6)
    80203110:	02e976bb          	remuw	a3,s2,a4
    80203114:	0006879b          	sext.w	a5,a3
        if (n - tot < m) {
    80203118:	413b883b          	subw	a6,s7,s3
        m = fs->superBlock.byts_per_clus - off % fs->superBlock.byts_per_clus;
    8020311c:	40d7073b          	subw	a4,a4,a3
    80203120:	00080493          	mv	s1,a6
    80203124:	0008081b          	sext.w	a6,a6
    80203128:	0007069b          	sext.w	a3,a4
    8020312c:	f906f2e3          	bgeu	a3,a6,802030b0 <ewrite+0xe0>
    80203130:	00070493          	mv	s1,a4
    80203134:	f7dff06f          	j	802030b0 <ewrite+0xe0>
    for (tot = 0; tot < n; tot += m, off += m, src += m) {
    80203138:	000b8993          	mv	s3,s7
    8020313c:	0300006f          	j	8020316c <ewrite+0x19c>
        return -1;
    80203140:	fff00513          	li	a0,-1
    80203144:	02c0006f          	j	80203170 <ewrite+0x1a0>
    80203148:	fff00513          	li	a0,-1
    8020314c:	0240006f          	j	80203170 <ewrite+0x1a0>
    80203150:	fff00513          	li	a0,-1
    80203154:	01c0006f          	j	80203170 <ewrite+0x1a0>
    80203158:	fff00513          	li	a0,-1
    8020315c:	0140006f          	j	80203170 <ewrite+0x1a0>
            off % fs->superBlock.byts_per_clus, m) != m) {
            break;
        }
    }
    if (n > 0) {
        if (off > entry->file_size) {
    80203160:	108aa783          	lw	a5,264(s5)
    80203164:	0127f463          	bgeu	a5,s2,8020316c <ewrite+0x19c>
            entry->file_size = off;
    80203168:	112aa423          	sw	s2,264(s5)
        }
    }
    return tot;
    8020316c:	0009851b          	sext.w	a0,s3
}
    80203170:	05813083          	ld	ra,88(sp)
    80203174:	05013403          	ld	s0,80(sp)
    80203178:	04813483          	ld	s1,72(sp)
    8020317c:	04013903          	ld	s2,64(sp)
    80203180:	03813983          	ld	s3,56(sp)
    80203184:	03013a03          	ld	s4,48(sp)
    80203188:	02813a83          	ld	s5,40(sp)
    8020318c:	02013b03          	ld	s6,32(sp)
    80203190:	01813b83          	ld	s7,24(sp)
    80203194:	01013c03          	ld	s8,16(sp)
    80203198:	00813c83          	ld	s9,8(sp)
    8020319c:	06010113          	addi	sp,sp,96
    802031a0:	00008067          	ret

00000000802031a4 <formatname>:

extern Dirent dirents[];

// trim ' ' in the head and tail, '.' in head, and test legality
char* formatname(char* name) {
    802031a4:	fd010113          	addi	sp,sp,-48
    802031a8:	02113423          	sd	ra,40(sp)
    802031ac:	02813023          	sd	s0,32(sp)
    802031b0:	00913c23          	sd	s1,24(sp)
    802031b4:	01213823          	sd	s2,16(sp)
    802031b8:	01313423          	sd	s3,8(sp)
    802031bc:	01413023          	sd	s4,0(sp)
    802031c0:	03010413          	addi	s0,sp,48
    802031c4:	00050493          	mv	s1,a0
    static char illegal[] = {'\"', '*', '/', ':', '<', '>', '?', '\\', '|', 0};
    char* p;
    while (*name == ' ' || *name == '.') {
    802031c8:	02000793          	li	a5,32
    802031cc:	02e00713          	li	a4,46
    802031d0:	0080006f          	j	802031d8 <formatname+0x34>
        name++;
    802031d4:	00148493          	addi	s1,s1,1
    while (*name == ' ' || *name == '.') {
    802031d8:	0004c583          	lbu	a1,0(s1)
    802031dc:	fef58ce3          	beq	a1,a5,802031d4 <formatname+0x30>
    802031e0:	fee58ae3          	beq	a1,a4,802031d4 <formatname+0x30>
    }
    for (p = name; *p; p++) {
    802031e4:	06058063          	beqz	a1,80203244 <formatname+0xa0>
    802031e8:	00048913          	mv	s2,s1
        char c = *p;
        if (c < 0x20 || strchr(illegal, c)) {
    802031ec:	01f00993          	li	s3,31
    802031f0:	00014a17          	auipc	s4,0x14
    802031f4:	e10a0a13          	addi	s4,s4,-496 # 80217000 <illegal.3>
    802031f8:	04b9fa63          	bgeu	s3,a1,8020324c <formatname+0xa8>
    802031fc:	000a0513          	mv	a0,s4
    80203200:	0000c097          	auipc	ra,0xc
    80203204:	dc4080e7          	jalr	-572(ra) # 8020efc4 <strchr>
    80203208:	06051463          	bnez	a0,80203270 <formatname+0xcc>
    for (p = name; *p; p++) {
    8020320c:	00190913          	addi	s2,s2,1
    80203210:	00094583          	lbu	a1,0(s2)
    80203214:	fe0592e3          	bnez	a1,802031f8 <formatname+0x54>
            return 0;
        }
    }
    while (p-- > name) {
        if (*p != ' ') {
    80203218:	02000693          	li	a3,32
    8020321c:	00090713          	mv	a4,s2
    while (p-- > name) {
    80203220:	0124fe63          	bgeu	s1,s2,8020323c <formatname+0x98>
        if (*p != ' ') {
    80203224:	fff90913          	addi	s2,s2,-1
    80203228:	00094783          	lbu	a5,0(s2)
    8020322c:	fed788e3          	beq	a5,a3,8020321c <formatname+0x78>
            p[1] = '\0';
    80203230:	00070023          	sb	zero,0(a4)
            break;
    80203234:	00048513          	mv	a0,s1
    80203238:	0180006f          	j	80203250 <formatname+0xac>
    8020323c:	00048513          	mv	a0,s1
    80203240:	0100006f          	j	80203250 <formatname+0xac>
    for (p = name; *p; p++) {
    80203244:	00048513          	mv	a0,s1
    80203248:	0080006f          	j	80203250 <formatname+0xac>
            return 0;
    8020324c:	00000513          	li	a0,0
        }
    }
    return name;
}
    80203250:	02813083          	ld	ra,40(sp)
    80203254:	02013403          	ld	s0,32(sp)
    80203258:	01813483          	ld	s1,24(sp)
    8020325c:	01013903          	ld	s2,16(sp)
    80203260:	00813983          	ld	s3,8(sp)
    80203264:	00013a03          	ld	s4,0(sp)
    80203268:	03010113          	addi	sp,sp,48
    8020326c:	00008067          	ret
            return 0;
    80203270:	00000513          	li	a0,0
    80203274:	fddff06f          	j	80203250 <formatname+0xac>

0000000080203278 <cal_checksum>:

uint8 cal_checksum(uchar* shortname) {
    80203278:	ff010113          	addi	sp,sp,-16
    8020327c:	00813423          	sd	s0,8(sp)
    80203280:	01010413          	addi	s0,sp,16
    80203284:	00050793          	mv	a5,a0
    uint8 sum = 0;
    for (int i = CHAR_SHORT_NAME; i != 0; i--) {
    80203288:	00b50613          	addi	a2,a0,11
    uint8 sum = 0;
    8020328c:	00000513          	li	a0,0
        sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortname++;
    80203290:	0075171b          	slliw	a4,a0,0x7
    80203294:	00178793          	addi	a5,a5,1
    80203298:	0015551b          	srliw	a0,a0,0x1
    8020329c:	fff7c683          	lbu	a3,-1(a5)
    802032a0:	00d5053b          	addw	a0,a0,a3
    802032a4:	00e50533          	add	a0,a0,a4
    802032a8:	0ff57513          	zext.b	a0,a0
    for (int i = CHAR_SHORT_NAME; i != 0; i--) {
    802032ac:	fef612e3          	bne	a2,a5,80203290 <cal_checksum+0x18>
    }
    return sum;
}
    802032b0:	00813403          	ld	s0,8(sp)
    802032b4:	01010113          	addi	sp,sp,16
    802032b8:	00008067          	ret

00000000802032bc <edup>:
        ep->attribute |= ATTR_ARCHIVE;
    }
    return ep;
}

Dirent* edup(Dirent* entry) {    
    802032bc:	ff010113          	addi	sp,sp,-16
    802032c0:	00813423          	sd	s0,8(sp)
    802032c4:	01010413          	addi	s0,sp,16
    return entry;
}
    802032c8:	00813403          	ld	s0,8(sp)
    802032cc:	01010113          	addi	sp,sp,16
    802032d0:	00008067          	ret

00000000802032d4 <eSetTime>:

#define UTIME_NOW ((1l << 30) - 1l)
#define UTIME_OMIT ((1l << 30) - 2l)
void eSetTime(Dirent *entry, TimeSpec ts[2]) {
    802032d4:	fa010113          	addi	sp,sp,-96
    802032d8:	04113c23          	sd	ra,88(sp)
    802032dc:	04813823          	sd	s0,80(sp)
    802032e0:	04913423          	sd	s1,72(sp)
    802032e4:	05213023          	sd	s2,64(sp)
    802032e8:	03313c23          	sd	s3,56(sp)
    802032ec:	06010413          	addi	s0,sp,96
    802032f0:	00050493          	mv	s1,a0
    802032f4:	00058913          	mv	s2,a1
    uint entcnt = 0;
    802032f8:	fc042623          	sw	zero,-52(s0)
    FileSystem *fs = entry->fileSystem;
    802032fc:	22053983          	ld	s3,544(a0)
    uint32 off = reloc_clus(fs, entry->parent, entry->off, 0);
    80203300:	00000693          	li	a3,0
    80203304:	23852603          	lw	a2,568(a0)
    80203308:	24053583          	ld	a1,576(a0)
    8020330c:	00098513          	mv	a0,s3
    80203310:	fffff097          	auipc	ra,0xfffff
    80203314:	690080e7          	jalr	1680(ra) # 802029a0 <reloc_clus>
    rw_clus(fs, entry->parent->cur_clus, 0, 0, (u64)&entcnt, off, 1);
    80203318:	2404b583          	ld	a1,576(s1)
    8020331c:	00100813          	li	a6,1
    80203320:	0005079b          	sext.w	a5,a0
    80203324:	fcc40713          	addi	a4,s0,-52
    80203328:	00000693          	li	a3,0
    8020332c:	00000613          	li	a2,0
    80203330:	10c5a583          	lw	a1,268(a1)
    80203334:	00098513          	mv	a0,s3
    80203338:	fffff097          	auipc	ra,0xfffff
    8020333c:	488080e7          	jalr	1160(ra) # 802027c0 <rw_clus>
    entcnt &= ~LAST_LONG_ENTRY;
    80203340:	fcc42603          	lw	a2,-52(s0)
    80203344:	fbf67613          	andi	a2,a2,-65
    80203348:	fcc42623          	sw	a2,-52(s0)
    off = reloc_clus(fs, entry->parent, entry->off + (entcnt << 5), 0);
    8020334c:	0056161b          	slliw	a2,a2,0x5
    80203350:	2384a783          	lw	a5,568(s1)
    80203354:	00000693          	li	a3,0
    80203358:	00f6063b          	addw	a2,a2,a5
    8020335c:	2404b583          	ld	a1,576(s1)
    80203360:	00098513          	mv	a0,s3
    80203364:	fffff097          	auipc	ra,0xfffff
    80203368:	63c080e7          	jalr	1596(ra) # 802029a0 <reloc_clus>
    8020336c:	0005099b          	sext.w	s3,a0
    union dentry de;
    rw_clus(entry->fileSystem, entry->parent->cur_clus, 0, 0, (u64)&de, off, sizeof(de));
    80203370:	2404b583          	ld	a1,576(s1)
    80203374:	02000813          	li	a6,32
    80203378:	00098793          	mv	a5,s3
    8020337c:	fa840713          	addi	a4,s0,-88
    80203380:	00000693          	li	a3,0
    80203384:	00000613          	li	a2,0
    80203388:	10c5a583          	lw	a1,268(a1)
    8020338c:	2204b503          	ld	a0,544(s1)
    80203390:	fffff097          	auipc	ra,0xfffff
    80203394:	430080e7          	jalr	1072(ra) # 802027c0 <rw_clus>
// supervisor-mode cycle counter
static inline u64 r_time() {
	u64 x;
  	// asm volatile("csrr %0, time" : "=r" (x) );
  	// this instruction will trap in SBI
	asm volatile("rdtime %0" : "=r" (x) );
    80203398:	c0102773          	rdtime	a4
	return x + (1ll << 35);
    8020339c:	00100793          	li	a5,1
    802033a0:	02379793          	slli	a5,a5,0x23
    802033a4:	00f70733          	add	a4,a4,a5
    u64 time = r_time();
    TimeSpec now;
    now.second = time / 1000000;
    802033a8:	000f47b7          	lui	a5,0xf4
    802033ac:	24078793          	addi	a5,a5,576 # f4240 <_start-0x8010bdc0>
    802033b0:	02f75733          	divu	a4,a4,a5
    now.nanoSecond = time % 1000000 * 1000;
    if (ts[0].nanoSecond != UTIME_OMIT) {
    802033b4:	00893683          	ld	a3,8(s2)
    802033b8:	400007b7          	lui	a5,0x40000
    802033bc:	ffe78793          	addi	a5,a5,-2 # 3ffffffe <_start-0x40200002>
    802033c0:	02f68463          	beq	a3,a5,802033e8 <eSetTime+0x114>
        if (ts[0].nanoSecond == UTIME_NOW) {
    802033c4:	400007b7          	lui	a5,0x40000
    802033c8:	fff78793          	addi	a5,a5,-1 # 3fffffff <_start-0x40200001>
    802033cc:	08f68a63          	beq	a3,a5,80203460 <eSetTime+0x18c>
            ts[0].second = now.second;
        }
        de.sne._crt_date = ts[0].second & ((1 << 16) - 1);
    802033d0:	00093783          	ld	a5,0(s2)
    802033d4:	faf41c23          	sh	a5,-72(s0)
        de.sne._crt_time = (ts[0].second >> 16) & ((1 << 16) - 1);
    802033d8:	0107d693          	srli	a3,a5,0x10
    802033dc:	fad41b23          	sh	a3,-74(s0)
        de.sne._crt_time_tenth = (ts[0].second >> 32) & ((1 << 8) - 1);
    802033e0:	0207d793          	srli	a5,a5,0x20
    802033e4:	faf40aa3          	sb	a5,-75(s0)
    }
    if (ts[1].nanoSecond != UTIME_OMIT) {
    802033e8:	01893683          	ld	a3,24(s2)
    802033ec:	400007b7          	lui	a5,0x40000
    802033f0:	ffe78793          	addi	a5,a5,-2 # 3ffffffe <_start-0x40200002>
    802033f4:	02f68463          	beq	a3,a5,8020341c <eSetTime+0x148>
        if (ts[1].nanoSecond == UTIME_NOW) {
    802033f8:	400007b7          	lui	a5,0x40000
    802033fc:	fff78793          	addi	a5,a5,-1 # 3fffffff <_start-0x40200001>
    80203400:	06f68463          	beq	a3,a5,80203468 <eSetTime+0x194>
            ts[1].second = now.second;
        }
        de.sne._lst_wrt_date = ts[1].second & ((1 << 16) - 1);
    80203404:	01093783          	ld	a5,16(s2)
    80203408:	fcf41023          	sh	a5,-64(s0)
        de.sne._lst_wrt_time = (ts[1].second >> 16) & ((1 << 16) - 1);
    8020340c:	0107d713          	srli	a4,a5,0x10
    80203410:	fae41f23          	sh	a4,-66(s0)
        de.sne._lst_acce_date = (ts[1].second >> 32) & ((1 << 16) - 1);
    80203414:	0207d793          	srli	a5,a5,0x20
    80203418:	faf41d23          	sh	a5,-70(s0)
    }
    rw_clus(entry->fileSystem, entry->parent->cur_clus, true, 0, (u64)&de, off, sizeof(de));
    8020341c:	2404b583          	ld	a1,576(s1)
    80203420:	02000813          	li	a6,32
    80203424:	00098793          	mv	a5,s3
    80203428:	fa840713          	addi	a4,s0,-88
    8020342c:	00000693          	li	a3,0
    80203430:	00100613          	li	a2,1
    80203434:	10c5a583          	lw	a1,268(a1)
    80203438:	2204b503          	ld	a0,544(s1)
    8020343c:	fffff097          	auipc	ra,0xfffff
    80203440:	384080e7          	jalr	900(ra) # 802027c0 <rw_clus>
}
    80203444:	05813083          	ld	ra,88(sp)
    80203448:	05013403          	ld	s0,80(sp)
    8020344c:	04813483          	ld	s1,72(sp)
    80203450:	04013903          	ld	s2,64(sp)
    80203454:	03813983          	ld	s3,56(sp)
    80203458:	06010113          	addi	sp,sp,96
    8020345c:	00008067          	ret
            ts[0].second = now.second;
    80203460:	00e93023          	sd	a4,0(s2)
    80203464:	f6dff06f          	j	802033d0 <eSetTime+0xfc>
            ts[1].second = now.second;
    80203468:	00e93823          	sd	a4,16(s2)
    8020346c:	f99ff06f          	j	80203404 <eSetTime+0x130>

0000000080203470 <eremove>:

// caller must hold entry->lock
// caller must hold entry->parent->lock
// remove the entry in its parent directory
void eremove(Dirent* entry) {
    80203470:	ff010113          	addi	sp,sp,-16
    80203474:	00113423          	sd	ra,8(sp)
    80203478:	00813023          	sd	s0,0(sp)
    8020347c:	01010413          	addi	s0,sp,16
    Dirent *i = entry->parent->firstChild;
    80203480:	24053703          	ld	a4,576(a0)
    80203484:	25073783          	ld	a5,592(a4)
    if (i == entry) {
    80203488:	02f50a63          	beq	a0,a5,802034bc <eremove+0x4c>
        entry->parent->firstChild = entry->nextBrother;
    } else {
        for (; i->nextBrother; i = i->nextBrother) {
    8020348c:	00078713          	mv	a4,a5
    80203490:	2487b783          	ld	a5,584(a5)
    80203494:	00078863          	beqz	a5,802034a4 <eremove+0x34>
            if (i->nextBrother == entry) {
    80203498:	fea79ae3          	bne	a5,a0,8020348c <eremove+0x1c>
                i->nextBrother = entry->nextBrother;
    8020349c:	24853783          	ld	a5,584(a0)
    802034a0:	24f73423          	sd	a5,584(a4)
                break;
            }
        }
    }
    direntFree(entry);
    802034a4:	fffff097          	auipc	ra,0xfffff
    802034a8:	c40080e7          	jalr	-960(ra) # 802020e4 <direntFree>
}
    802034ac:	00813083          	ld	ra,8(sp)
    802034b0:	00013403          	ld	s0,0(sp)
    802034b4:	01010113          	addi	sp,sp,16
    802034b8:	00008067          	ret
        entry->parent->firstChild = entry->nextBrother;
    802034bc:	2487b783          	ld	a5,584(a5)
    802034c0:	24f73823          	sd	a5,592(a4)
    802034c4:	fe1ff06f          	j	802034a4 <eremove+0x34>

00000000802034c8 <etrunc>:

// truncate a file
// caller must hold entry->lock*全部文件名目录项
void etrunc(Dirent* entry) {
    802034c8:	fb010113          	addi	sp,sp,-80
    802034cc:	04113423          	sd	ra,72(sp)
    802034d0:	04813023          	sd	s0,64(sp)
    802034d4:	02913c23          	sd	s1,56(sp)
    802034d8:	03213823          	sd	s2,48(sp)
    802034dc:	03313423          	sd	s3,40(sp)
    802034e0:	03413023          	sd	s4,32(sp)
    802034e4:	01513c23          	sd	s5,24(sp)
    802034e8:	01613823          	sd	s6,16(sp)
    802034ec:	01713423          	sd	s7,8(sp)
    802034f0:	05010413          	addi	s0,sp,80
    802034f4:	00050b93          	mv	s7,a0
    FileSystem *fs = entry->fileSystem;
    802034f8:	22053983          	ld	s3,544(a0)

    for (uint32 clus = entry->first_clus; clus >= 2 && clus < FAT32_EOC;) {
    802034fc:	10452903          	lw	s2,260(a0)
    80203500:	ffe9071b          	addiw	a4,s2,-2
    80203504:	100007b7          	lui	a5,0x10000
    80203508:	ff578793          	addi	a5,a5,-11 # ffffff5 <_start-0x7020000b>
    8020350c:	08e7e863          	bltu	a5,a4,8020359c <etrunc+0xd4>
    80203510:	010afa17          	auipc	s4,0x10af
    80203514:	fc8a0a13          	addi	s4,s4,-56 # 812b24d8 <fileSystem>
    80203518:	41498a33          	sub	s4,s3,s4
    8020351c:	403a5a13          	srai	s4,s4,0x3
    80203520:	00013797          	auipc	a5,0x13
    80203524:	2c07b783          	ld	a5,704(a5) # 802167e0 <__func__.0+0x8>
    80203528:	02fa0a33          	mul	s4,s4,a5
    8020352c:	016a1a13          	slli	s4,s4,0x16
    80203530:	03f00793          	li	a5,63
    80203534:	01e79793          	slli	a5,a5,0x1e
    80203538:	00fa0a33          	add	s4,s4,a5
    clusterBitmap[cluster >> 6] &= ~(1UL << (cluster & 63));
    8020353c:	00100b13          	li	s6,1
    for (uint32 clus = entry->first_clus; clus >= 2 && clus < FAT32_EOC;) {
    80203540:	10000ab7          	lui	s5,0x10000
    80203544:	ff5a8a93          	addi	s5,s5,-11 # ffffff5 <_start-0x7020000b>
        uint32 next = read_fat(fs, clus);
    80203548:	0009049b          	sext.w	s1,s2
    8020354c:	00090593          	mv	a1,s2
    80203550:	00098513          	mv	a0,s3
    80203554:	fffff097          	auipc	ra,0xfffff
    80203558:	c10080e7          	jalr	-1008(ra) # 80202164 <read_fat>
    8020355c:	0005091b          	sext.w	s2,a0
    write_fat(fs, cluster, 0);
    80203560:	00000613          	li	a2,0
    80203564:	00048593          	mv	a1,s1
    80203568:	00098513          	mv	a0,s3
    8020356c:	fffff097          	auipc	ra,0xfffff
    80203570:	c94080e7          	jalr	-876(ra) # 80202200 <write_fat>
    clusterBitmap[cluster >> 6] &= ~(1UL << (cluster & 63));
    80203574:	0064d79b          	srliw	a5,s1,0x6
    80203578:	00379793          	slli	a5,a5,0x3
    8020357c:	00fa07b3          	add	a5,s4,a5
    80203580:	009b14b3          	sll	s1,s6,s1
    80203584:	fff4c493          	not	s1,s1
    80203588:	0007b703          	ld	a4,0(a5)
    8020358c:	00977733          	and	a4,a4,s1
    80203590:	00e7b023          	sd	a4,0(a5)
    for (uint32 clus = entry->first_clus; clus >= 2 && clus < FAT32_EOC;) {
    80203594:	ffe9079b          	addiw	a5,s2,-2
    80203598:	fafaf8e3          	bgeu	s5,a5,80203548 <etrunc+0x80>
        free_clus(fs, clus);
        clus = next;
    }
    entry->file_size = 0;
    8020359c:	100ba423          	sw	zero,264(s7)
    entry->first_clus = 0;
    802035a0:	100ba223          	sw	zero,260(s7)
    eFreeInode(entry);
    802035a4:	000b8513          	mv	a0,s7
    802035a8:	fffff097          	auipc	ra,0xfffff
    802035ac:	0d8080e7          	jalr	216(ra) # 80202680 <eFreeInode>
}
    802035b0:	04813083          	ld	ra,72(sp)
    802035b4:	04013403          	ld	s0,64(sp)
    802035b8:	03813483          	ld	s1,56(sp)
    802035bc:	03013903          	ld	s2,48(sp)
    802035c0:	02813983          	ld	s3,40(sp)
    802035c4:	02013a03          	ld	s4,32(sp)
    802035c8:	01813a83          	ld	s5,24(sp)
    802035cc:	01013b03          	ld	s6,16(sp)
    802035d0:	00813b83          	ld	s7,8(sp)
    802035d4:	05010113          	addi	sp,sp,80
    802035d8:	00008067          	ret

00000000802035dc <elock>:

void elock(Dirent* entry) {
    802035dc:	ff010113          	addi	sp,sp,-16
    802035e0:	00813423          	sd	s0,8(sp)
    802035e4:	01010413          	addi	s0,sp,16
}
    802035e8:	00813403          	ld	s0,8(sp)
    802035ec:	01010113          	addi	sp,sp,16
    802035f0:	00008067          	ret

00000000802035f4 <eunlock>:

void eunlock(Dirent* entry) {
    802035f4:	ff010113          	addi	sp,sp,-16
    802035f8:	00813423          	sd	s0,8(sp)
    802035fc:	01010413          	addi	s0,sp,16
}
    80203600:	00813403          	ld	s0,8(sp)
    80203604:	01010113          	addi	sp,sp,16
    80203608:	00008067          	ret

000000008020360c <eput>:

void eput(Dirent* entry) {
    8020360c:	ff010113          	addi	sp,sp,-16
    80203610:	00813423          	sd	s0,8(sp)
    80203614:	01010413          	addi	s0,sp,16
}
    80203618:	00813403          	ld	s0,8(sp)
    8020361c:	01010113          	addi	sp,sp,16
    80203620:	00008067          	ret

0000000080203624 <estat>:

//todo(need more)
void estat(Dirent* ep, struct stat* st) {
    80203624:	fa010113          	addi	sp,sp,-96
    80203628:	04113c23          	sd	ra,88(sp)
    8020362c:	04813823          	sd	s0,80(sp)
    80203630:	04913423          	sd	s1,72(sp)
    80203634:	05213023          	sd	s2,64(sp)
    80203638:	03313c23          	sd	s3,56(sp)
    8020363c:	06010413          	addi	s0,sp,96
    80203640:	00050913          	mv	s2,a0
    80203644:	00058493          	mv	s1,a1
    // strncpy(st->name, de->filename, STAT_MAX_NAME);
    // st->type = (de->attribute & ATTR_DIRECTORY) ? T_DIR : T_FILE;
    st->st_dev = ep->dev;
    80203648:	22856783          	lwu	a5,552(a0)
    8020364c:	00f5b023          	sd	a5,0(a1)
    st->st_size = ep->file_size;
    80203650:	10856703          	lwu	a4,264(a0)
    80203654:	02e5b823          	sd	a4,48(a1)
    st->st_ino = (ep - dirents);
    80203658:	00bf9797          	auipc	a5,0xbf9
    8020365c:	e2078793          	addi	a5,a5,-480 # 80dfc478 <dirents>
    80203660:	40f507b3          	sub	a5,a0,a5
    80203664:	4037d793          	srai	a5,a5,0x3
    80203668:	00013697          	auipc	a3,0x13
    8020366c:	1806b683          	ld	a3,384(a3) # 802167e8 <__func__.0+0x10>
    80203670:	02d787b3          	mul	a5,a5,a3
    80203674:	00f5b423          	sd	a5,8(a1)
    st->st_mode = (ep->attribute & ATTR_DIRECTORY ? DIR_TYPE :
    80203678:	10054683          	lbu	a3,256(a0)
    8020367c:	0106f613          	andi	a2,a3,16
    80203680:	000047b7          	lui	a5,0x4
    80203684:	02061063          	bnez	a2,802036a4 <estat+0x80>
    80203688:	0186969b          	slliw	a3,a3,0x18
    8020368c:	4186d69b          	sraiw	a3,a3,0x18
    80203690:	43f6d793          	srai	a5,a3,0x3f
    80203694:	ffffa6b7          	lui	a3,0xffffa
    80203698:	00d7f7b3          	and	a5,a5,a3
    8020369c:	000086b7          	lui	a3,0x8
    802036a0:	00d787b3          	add	a5,a5,a3
    802036a4:	00f4a823          	sw	a5,16(s1)
                ep->attribute & ATTR_CHARACTER_DEVICE ? CHR_TYPE : REG_TYPE);
    st->st_nlink = 1;
    802036a8:	00100793          	li	a5,1
    802036ac:	00f4aa23          	sw	a5,20(s1)
    st->st_uid = 0;
    802036b0:	0004ac23          	sw	zero,24(s1)
    st->st_gid = 0;
    802036b4:	0004ae23          	sw	zero,28(s1)
    st->st_rdev = 0;  // What's this?
    802036b8:	0204b023          	sd	zero,32(s1)
    st->st_blksize = ep->fileSystem->superBlock.bpb.byts_per_sec;
    802036bc:	22093783          	ld	a5,544(s2)
    802036c0:	0547d783          	lhu	a5,84(a5) # 4054 <_start-0x801fbfac>
    802036c4:	02f4ac23          	sw	a5,56(s1)
    st->st_blocks = st->st_size / st->st_blksize;
    802036c8:	02f74733          	div	a4,a4,a5
    802036cc:	04e4b023          	sd	a4,64(s1)
    // printf("attr: %d\n", st->st_mode);
    if (ep->parent != NULL) {
    802036d0:	24093583          	ld	a1,576(s2)
    802036d4:	10058463          	beqz	a1,802037dc <estat+0x1b8>
        uint entcnt = 0;
    802036d8:	fa042623          	sw	zero,-84(s0)
        FileSystem *fs = ep->fileSystem;
    802036dc:	22093983          	ld	s3,544(s2)
        uint32 off = reloc_clus(fs, ep->parent, ep->off, 0);
    802036e0:	00000693          	li	a3,0
    802036e4:	23892603          	lw	a2,568(s2)
    802036e8:	00098513          	mv	a0,s3
    802036ec:	fffff097          	auipc	ra,0xfffff
    802036f0:	2b4080e7          	jalr	692(ra) # 802029a0 <reloc_clus>
        rw_clus(fs, ep->parent->cur_clus, 0, 0, (u64)&entcnt, off, 1);
    802036f4:	24093583          	ld	a1,576(s2)
    802036f8:	00100813          	li	a6,1
    802036fc:	0005079b          	sext.w	a5,a0
    80203700:	fac40713          	addi	a4,s0,-84
    80203704:	00000693          	li	a3,0
    80203708:	00000613          	li	a2,0
    8020370c:	10c5a583          	lw	a1,268(a1)
    80203710:	00098513          	mv	a0,s3
    80203714:	fffff097          	auipc	ra,0xfffff
    80203718:	0ac080e7          	jalr	172(ra) # 802027c0 <rw_clus>
        entcnt &= ~LAST_LONG_ENTRY;
    8020371c:	fac42603          	lw	a2,-84(s0)
    80203720:	fbf67613          	andi	a2,a2,-65
    80203724:	fac42623          	sw	a2,-84(s0)
        off = reloc_clus(fs, ep->parent, ep->off + (entcnt << 5), 0);
    80203728:	0056161b          	slliw	a2,a2,0x5
    8020372c:	23892783          	lw	a5,568(s2)
    80203730:	00000693          	li	a3,0
    80203734:	00f6063b          	addw	a2,a2,a5
    80203738:	24093583          	ld	a1,576(s2)
    8020373c:	00098513          	mv	a0,s3
    80203740:	fffff097          	auipc	ra,0xfffff
    80203744:	260080e7          	jalr	608(ra) # 802029a0 <reloc_clus>
        union dentry de;
        rw_clus(ep->fileSystem, ep->parent->cur_clus, 0, 0, (u64)&de, off, sizeof(de));
    80203748:	24093583          	ld	a1,576(s2)
    8020374c:	02000813          	li	a6,32
    80203750:	0005079b          	sext.w	a5,a0
    80203754:	fb040713          	addi	a4,s0,-80
    80203758:	00000693          	li	a3,0
    8020375c:	00000613          	li	a2,0
    80203760:	10c5a583          	lw	a1,268(a1)
    80203764:	22093503          	ld	a0,544(s2)
    80203768:	fffff097          	auipc	ra,0xfffff
    8020376c:	058080e7          	jalr	88(ra) # 802027c0 <rw_clus>
        st->st_atime_sec = (((u64)de.sne._crt_time_tenth) << 32) + 
    80203770:	fbd44783          	lbu	a5,-67(s0)
    80203774:	02079793          	slli	a5,a5,0x20
            (((u64)de.sne._crt_time) << 16) + de.sne._crt_date;
    80203778:	fbe45703          	lhu	a4,-66(s0)
    8020377c:	01071713          	slli	a4,a4,0x10
        st->st_atime_sec = (((u64)de.sne._crt_time_tenth) << 32) + 
    80203780:	00e787b3          	add	a5,a5,a4
            (((u64)de.sne._crt_time) << 16) + de.sne._crt_date;
    80203784:	fc045703          	lhu	a4,-64(s0)
    80203788:	00e787b3          	add	a5,a5,a4
        st->st_atime_sec = (((u64)de.sne._crt_time_tenth) << 32) + 
    8020378c:	04f4b423          	sd	a5,72(s1)
        st->st_atime_nsec = 0;
    80203790:	0404b823          	sd	zero,80(s1)
        st->st_mtime_sec = (((u64)de.sne._lst_acce_date) << 32) + 
    80203794:	fc245783          	lhu	a5,-62(s0)
    80203798:	02079793          	slli	a5,a5,0x20
            (((u64)de.sne._lst_wrt_time) << 16) + de.sne._lst_wrt_date;
    8020379c:	fc645703          	lhu	a4,-58(s0)
    802037a0:	01071713          	slli	a4,a4,0x10
        st->st_mtime_sec = (((u64)de.sne._lst_acce_date) << 32) + 
    802037a4:	00e787b3          	add	a5,a5,a4
            (((u64)de.sne._lst_wrt_time) << 16) + de.sne._lst_wrt_date;
    802037a8:	fc845703          	lhu	a4,-56(s0)
    802037ac:	00e787b3          	add	a5,a5,a4
        st->st_mtime_sec = (((u64)de.sne._lst_acce_date) << 32) + 
    802037b0:	04f4bc23          	sd	a5,88(s1)
        st->st_mtime_nsec = 0;
    802037b4:	0604b023          	sd	zero,96(s1)
        st->st_ctime_sec = 0;
    802037b8:	0604b423          	sd	zero,104(s1)
        st->st_ctime_nsec = 0;
    802037bc:	0604b823          	sd	zero,112(s1)
        st->st_mtime_sec = 0;
        st->st_mtime_nsec = 0;
        st->st_ctime_sec = 0;
        st->st_ctime_nsec = 0;
    }
}
    802037c0:	05813083          	ld	ra,88(sp)
    802037c4:	05013403          	ld	s0,80(sp)
    802037c8:	04813483          	ld	s1,72(sp)
    802037cc:	04013903          	ld	s2,64(sp)
    802037d0:	03813983          	ld	s3,56(sp)
    802037d4:	06010113          	addi	sp,sp,96
    802037d8:	00008067          	ret
        st->st_atime_sec = 0;
    802037dc:	0404b423          	sd	zero,72(s1)
        st->st_atime_nsec = 0;
    802037e0:	0404b823          	sd	zero,80(s1)
        st->st_mtime_sec = 0;
    802037e4:	0404bc23          	sd	zero,88(s1)
        st->st_mtime_nsec = 0;
    802037e8:	0604b023          	sd	zero,96(s1)
        st->st_ctime_sec = 0;
    802037ec:	0604b423          	sd	zero,104(s1)
        st->st_ctime_nsec = 0;
    802037f0:	0604b823          	sd	zero,112(s1)
}
    802037f4:	fcdff06f          	j	802037c0 <estat+0x19c>

00000000802037f8 <dirlookup>:
 * @param   dp          entry of a directory file
 * @param   filename    target filename
 * @param   poff        offset of proper empty entry slots from the beginning of
 * the dir
 */
Dirent* dirlookup(Dirent* dp, char* filename) {
    802037f8:	fe010113          	addi	sp,sp,-32
    802037fc:	00113c23          	sd	ra,24(sp)
    80203800:	00813823          	sd	s0,16(sp)
    80203804:	00913423          	sd	s1,8(sp)
    80203808:	01213023          	sd	s2,0(sp)
    8020380c:	02010413          	addi	s0,sp,32
    if (!(dp->attribute & ATTR_DIRECTORY))
    80203810:	10054783          	lbu	a5,256(a0)
    80203814:	0107f793          	andi	a5,a5,16
    80203818:	04078263          	beqz	a5,8020385c <dirlookup+0x64>
    8020381c:	00050493          	mv	s1,a0
    80203820:	00058913          	mv	s2,a1
        panic("dirlookup not DIR");

    if (strncmp(filename, ".", FAT32_MAX_FILENAME) == 0) {
    80203824:	0ff00613          	li	a2,255
    80203828:	00012597          	auipc	a1,0x12
    8020382c:	ca058593          	addi	a1,a1,-864 # 802154c8 <__func__.0+0x48>
    80203830:	00090513          	mv	a0,s2
    80203834:	0000b097          	auipc	ra,0xb
    80203838:	63c080e7          	jalr	1596(ra) # 8020ee70 <strncmp>
    8020383c:	04051263          	bnez	a0,80203880 <dirlookup+0x88>
        if (strncmp(ep->filename, filename, FAT32_MAX_FILENAME) == 0) {
            return ep;
        }
    }
    return NULL;
}
    80203840:	00048513          	mv	a0,s1
    80203844:	01813083          	ld	ra,24(sp)
    80203848:	01013403          	ld	s0,16(sp)
    8020384c:	00813483          	ld	s1,8(sp)
    80203850:	00013903          	ld	s2,0(sp)
    80203854:	02010113          	addi	sp,sp,32
    80203858:	00008067          	ret
        panic("dirlookup not DIR");
    8020385c:	00012697          	auipc	a3,0x12
    80203860:	c5468693          	addi	a3,a3,-940 # 802154b0 <__func__.0+0x30>
    80203864:	00012617          	auipc	a2,0x12
    80203868:	cb460613          	addi	a2,a2,-844 # 80215518 <__func__.1>
    8020386c:	26400593          	li	a1,612
    80203870:	00012517          	auipc	a0,0x12
    80203874:	c2050513          	addi	a0,a0,-992 # 80215490 <__func__.0+0x10>
    80203878:	ffffd097          	auipc	ra,0xffffd
    8020387c:	670080e7          	jalr	1648(ra) # 80200ee8 <_panic_>
    } else if (strncmp(filename, "..", FAT32_MAX_FILENAME) == 0) {
    80203880:	0ff00613          	li	a2,255
    80203884:	00012597          	auipc	a1,0x12
    80203888:	c4c58593          	addi	a1,a1,-948 # 802154d0 <__func__.0+0x50>
    8020388c:	00090513          	mv	a0,s2
    80203890:	0000b097          	auipc	ra,0xb
    80203894:	5e0080e7          	jalr	1504(ra) # 8020ee70 <strncmp>
    80203898:	00051c63          	bnez	a0,802038b0 <dirlookup+0xb8>
        if (dp == &dp->fileSystem->root) {
    8020389c:	2204b783          	ld	a5,544(s1)
    802038a0:	07078793          	addi	a5,a5,112
    802038a4:	f8f48ee3          	beq	s1,a5,80203840 <dirlookup+0x48>
        return edup(dp->parent);
    802038a8:	2404b483          	ld	s1,576(s1)
    802038ac:	f95ff06f          	j	80203840 <dirlookup+0x48>
    for (Dirent *ep = dp->firstChild; ep; ep = ep->nextBrother) {
    802038b0:	2504b483          	ld	s1,592(s1)
    802038b4:	f80486e3          	beqz	s1,80203840 <dirlookup+0x48>
        if (strncmp(ep->filename, filename, FAT32_MAX_FILENAME) == 0) {
    802038b8:	0ff00613          	li	a2,255
    802038bc:	00090593          	mv	a1,s2
    802038c0:	00048513          	mv	a0,s1
    802038c4:	0000b097          	auipc	ra,0xb
    802038c8:	5ac080e7          	jalr	1452(ra) # 8020ee70 <strncmp>
    802038cc:	f6050ae3          	beqz	a0,80203840 <dirlookup+0x48>
    for (Dirent *ep = dp->firstChild; ep; ep = ep->nextBrother) {
    802038d0:	2484b483          	ld	s1,584(s1)
    802038d4:	fe0492e3          	bnez	s1,802038b8 <dirlookup+0xc0>
    802038d8:	f69ff06f          	j	80203840 <dirlookup+0x48>

00000000802038dc <ealloc>:
Dirent* ealloc(Dirent* dp, char* name, int attr) {
    802038dc:	fc010113          	addi	sp,sp,-64
    802038e0:	02113c23          	sd	ra,56(sp)
    802038e4:	02813823          	sd	s0,48(sp)
    802038e8:	02913423          	sd	s1,40(sp)
    802038ec:	03213023          	sd	s2,32(sp)
    802038f0:	01313c23          	sd	s3,24(sp)
    802038f4:	04010413          	addi	s0,sp,64
    if (!(dp->attribute & ATTR_DIRECTORY)) {
    802038f8:	10054783          	lbu	a5,256(a0)
    802038fc:	0107f793          	andi	a5,a5,16
    80203900:	02078e63          	beqz	a5,8020393c <ealloc+0x60>
    80203904:	00050493          	mv	s1,a0
    80203908:	00058913          	mv	s2,a1
    8020390c:	00060993          	mv	s3,a2
    if ((ep = dirlookup(dp, name)) != 0) {  // entry exists
    80203910:	00000097          	auipc	ra,0x0
    80203914:	ee8080e7          	jalr	-280(ra) # 802037f8 <dirlookup>
    80203918:	fca43423          	sd	a0,-56(s0)
    8020391c:	04050263          	beqz	a0,80203960 <ealloc+0x84>
}
    80203920:	03813083          	ld	ra,56(sp)
    80203924:	03013403          	ld	s0,48(sp)
    80203928:	02813483          	ld	s1,40(sp)
    8020392c:	02013903          	ld	s2,32(sp)
    80203930:	01813983          	ld	s3,24(sp)
    80203934:	04010113          	addi	sp,sp,64
    80203938:	00008067          	ret
        panic("ealloc not dir");
    8020393c:	00012697          	auipc	a3,0x12
    80203940:	b9c68693          	addi	a3,a3,-1124 # 802154d8 <__func__.0+0x58>
    80203944:	00013617          	auipc	a2,0x13
    80203948:	e1c60613          	addi	a2,a2,-484 # 80216760 <__func__.2>
    8020394c:	1b800593          	li	a1,440
    80203950:	00012517          	auipc	a0,0x12
    80203954:	b4050513          	addi	a0,a0,-1216 # 80215490 <__func__.0+0x10>
    80203958:	ffffd097          	auipc	ra,0xffffd
    8020395c:	590080e7          	jalr	1424(ra) # 80200ee8 <_panic_>
    direntAlloc(&ep);
    80203960:	fc840513          	addi	a0,s0,-56
    80203964:	ffffe097          	auipc	ra,0xffffe
    80203968:	70c080e7          	jalr	1804(ra) # 80202070 <direntAlloc>
    if (attr == ATTR_LINK) {
    8020396c:	04000793          	li	a5,64
    80203970:	08f98063          	beq	s3,a5,802039f0 <ealloc+0x114>
        ep->attribute = attr;
    80203974:	fc843783          	ld	a5,-56(s0)
    80203978:	11378023          	sb	s3,256(a5)
        ep->_nt_res = 0;
    8020397c:	20078c23          	sb	zero,536(a5)
    ep->file_size = 0;
    80203980:	fc843503          	ld	a0,-56(s0)
    80203984:	10052423          	sw	zero,264(a0)
    ep->first_clus = 0;
    80203988:	10052223          	sw	zero,260(a0)
    eFreeInode(ep);
    8020398c:	fffff097          	auipc	ra,0xfffff
    80203990:	cf4080e7          	jalr	-780(ra) # 80202680 <eFreeInode>
    ep->parent = dp;
    80203994:	fc843503          	ld	a0,-56(s0)
    80203998:	24953023          	sd	s1,576(a0)
    ep->nextBrother = dp->firstChild;
    8020399c:	2504b783          	ld	a5,592(s1)
    802039a0:	24f53423          	sd	a5,584(a0)
    dp->firstChild = ep;
    802039a4:	24a4b823          	sd	a0,592(s1)
    ep->clus_cnt = 0;
    802039a8:	10052a23          	sw	zero,276(a0)
    ep->cur_clus = 0;
    802039ac:	10052623          	sw	zero,268(a0)
    ep->fileSystem = dp->fileSystem;
    802039b0:	2204b783          	ld	a5,544(s1)
    802039b4:	22f53023          	sd	a5,544(a0)
    strncpy(ep->filename, name, FAT32_MAX_FILENAME);
    802039b8:	0ff00613          	li	a2,255
    802039bc:	00090593          	mv	a1,s2
    802039c0:	0000b097          	auipc	ra,0xb
    802039c4:	514080e7          	jalr	1300(ra) # 8020eed4 <strncpy>
    ep->filename[FAT32_MAX_FILENAME] = '\0';
    802039c8:	fc843903          	ld	s2,-56(s0)
    802039cc:	0e090fa3          	sb	zero,255(s2)
    FileSystem *fs = ep->fileSystem;
    802039d0:	22093503          	ld	a0,544(s2)
    if (attr == ATTR_DIRECTORY) {  // generate "." and ".." for ep
    802039d4:	01000793          	li	a5,16
    802039d8:	02f98663          	beq	s3,a5,80203a04 <ealloc+0x128>
        ep->attribute |= ATTR_ARCHIVE;
    802039dc:	10094783          	lbu	a5,256(s2)
    802039e0:	0207e793          	ori	a5,a5,32
    802039e4:	10f90023          	sb	a5,256(s2)
    return ep;
    802039e8:	fc843503          	ld	a0,-56(s0)
    802039ec:	f35ff06f          	j	80203920 <ealloc+0x44>
        ep->attribute = 0;
    802039f0:	fc843783          	ld	a5,-56(s0)
    802039f4:	10078023          	sb	zero,256(a5)
        ep->_nt_res = DT_LNK;
    802039f8:	00a00713          	li	a4,10
    802039fc:	20e78c23          	sb	a4,536(a5)
    80203a00:	f81ff06f          	j	80203980 <ealloc+0xa4>
        ep->attribute |= ATTR_DIRECTORY;
    80203a04:	10094783          	lbu	a5,256(s2)
    80203a08:	0107e793          	ori	a5,a5,16
    80203a0c:	10f90023          	sb	a5,256(s2)
        ep->cur_clus = ep->first_clus = ep->inode.item[0] = alloc_clus(fs, dp->dev);
    80203a10:	2284c583          	lbu	a1,552(s1)
    80203a14:	fffff097          	auipc	ra,0xfffff
    80203a18:	a34080e7          	jalr	-1484(ra) # 80202448 <alloc_clus>
    80203a1c:	0005051b          	sext.w	a0,a0
    80203a20:	10a92c23          	sw	a0,280(s2)
    80203a24:	fc843783          	ld	a5,-56(s0)
    80203a28:	10a7a223          	sw	a0,260(a5)
    80203a2c:	10a7a623          	sw	a0,268(a5)
        ep->inodeMaxCluster = 1;
    80203a30:	00100713          	li	a4,1
    80203a34:	10e7a823          	sw	a4,272(a5)
    80203a38:	fb1ff06f          	j	802039e8 <ealloc+0x10c>

0000000080203a3c <ename>:
        return NULL;
    }
    return entry;
}

Dirent* ename(int fd, char* path, bool jump) {
    80203a3c:	ef010113          	addi	sp,sp,-272
    80203a40:	10113423          	sd	ra,264(sp)
    80203a44:	10813023          	sd	s0,256(sp)
    80203a48:	11010413          	addi	s0,sp,272
    80203a4c:	00060713          	mv	a4,a2
    char name[FAT32_MAX_FILENAME + 1];
    return lookup_path(fd, path, 0, name, jump);
    80203a50:	ef040693          	addi	a3,s0,-272
    80203a54:	00000613          	li	a2,0
    80203a58:	00000097          	auipc	ra,0x0
    80203a5c:	0b8080e7          	jalr	184(ra) # 80203b10 <lookup_path>
}
    80203a60:	10813083          	ld	ra,264(sp)
    80203a64:	10013403          	ld	s0,256(sp)
    80203a68:	11010113          	addi	sp,sp,272
    80203a6c:	00008067          	ret

0000000080203a70 <jumpToLinkDirent>:
static Dirent* jumpToLinkDirent(Dirent* link) {
    80203a70:	ee010113          	addi	sp,sp,-288
    80203a74:	10113c23          	sd	ra,280(sp)
    80203a78:	10813823          	sd	s0,272(sp)
    80203a7c:	10913423          	sd	s1,264(sp)
    80203a80:	12010413          	addi	s0,sp,288
    while (link && link->_nt_res == DT_LNK) {
    80203a84:	00a00493          	li	s1,10
    80203a88:	04050263          	beqz	a0,80203acc <jumpToLinkDirent+0x5c>
    80203a8c:	21854783          	lbu	a5,536(a0)
    80203a90:	04979263          	bne	a5,s1,80203ad4 <jumpToLinkDirent+0x64>
        eread(link, 0, (u64)buf, 0, FAT32_MAX_FILENAME);
    80203a94:	0ff00713          	li	a4,255
    80203a98:	00000693          	li	a3,0
    80203a9c:	ee040613          	addi	a2,s0,-288
    80203aa0:	00000593          	li	a1,0
    80203aa4:	fffff097          	auipc	ra,0xfffff
    80203aa8:	2f8080e7          	jalr	760(ra) # 80202d9c <eread>
        link = ename(AT_FDCWD, buf, true);
    80203aac:	00100613          	li	a2,1
    80203ab0:	ee040593          	addi	a1,s0,-288
    80203ab4:	f9c00513          	li	a0,-100
    80203ab8:	00000097          	auipc	ra,0x0
    80203abc:	f84080e7          	jalr	-124(ra) # 80203a3c <ename>
    while (link && link->_nt_res == DT_LNK) {
    80203ac0:	fc0516e3          	bnez	a0,80203a8c <jumpToLinkDirent+0x1c>
        link = ename(AT_FDCWD, buf, true);
    80203ac4:	00050493          	mv	s1,a0
    80203ac8:	0100006f          	j	80203ad8 <jumpToLinkDirent+0x68>
    while (link && link->_nt_res == DT_LNK) {
    80203acc:	00050493          	mv	s1,a0
    80203ad0:	0080006f          	j	80203ad8 <jumpToLinkDirent+0x68>
    80203ad4:	00050493          	mv	s1,a0
    assert(link != NULL);
    80203ad8:	009036b3          	snez	a3,s1
    80203adc:	00012617          	auipc	a2,0x12
    80203ae0:	a4c60613          	addi	a2,a2,-1460 # 80215528 <__func__.0>
    80203ae4:	29400593          	li	a1,660
    80203ae8:	00012517          	auipc	a0,0x12
    80203aec:	9a850513          	addi	a0,a0,-1624 # 80215490 <__func__.0+0x10>
    80203af0:	ffffd097          	auipc	ra,0xffffd
    80203af4:	468080e7          	jalr	1128(ra) # 80200f58 <_assert_>
}
    80203af8:	00048513          	mv	a0,s1
    80203afc:	11813083          	ld	ra,280(sp)
    80203b00:	11013403          	ld	s0,272(sp)
    80203b04:	10813483          	ld	s1,264(sp)
    80203b08:	12010113          	addi	sp,sp,288
    80203b0c:	00008067          	ret

0000000080203b10 <lookup_path>:
static Dirent* lookup_path(int fd, char* path, int parent, char* name, bool jump) {
    80203b10:	fb010113          	addi	sp,sp,-80
    80203b14:	04113423          	sd	ra,72(sp)
    80203b18:	04813023          	sd	s0,64(sp)
    80203b1c:	02913c23          	sd	s1,56(sp)
    80203b20:	03213823          	sd	s2,48(sp)
    80203b24:	03313423          	sd	s3,40(sp)
    80203b28:	03413023          	sd	s4,32(sp)
    80203b2c:	01513c23          	sd	s5,24(sp)
    80203b30:	01613823          	sd	s6,16(sp)
    80203b34:	01713423          	sd	s7,8(sp)
    80203b38:	01813023          	sd	s8,0(sp)
    80203b3c:	05010413          	addi	s0,sp,80
    80203b40:	00058493          	mv	s1,a1
    80203b44:	00060a93          	mv	s5,a2
    80203b48:	00068a13          	mv	s4,a3
    80203b4c:	00070c13          	mv	s8,a4
    if (*path != '/' && fd != AT_FDCWD && fd >= 0 && fd < NOFILE) {
    80203b50:	0005c783          	lbu	a5,0(a1)
    80203b54:	02f00713          	li	a4,47
    80203b58:	06e78c63          	beq	a5,a4,80203bd0 <lookup_path+0xc0>
    80203b5c:	00050913          	mv	s2,a0
    80203b60:	0005071b          	sext.w	a4,a0
    80203b64:	3ff00693          	li	a3,1023
    80203b68:	02e6f663          	bgeu	a3,a4,80203b94 <lookup_path+0x84>
    } else if (*path != '\0' && fd == AT_FDCWD) {
    80203b6c:	14078c63          	beqz	a5,80203cc4 <lookup_path+0x1b4>
    80203b70:	f9c00793          	li	a5,-100
        return NULL;
    80203b74:	00000993          	li	s3,0
    } else if (*path != '\0' && fd == AT_FDCWD) {
    80203b78:	16f51663          	bne	a0,a5,80203ce4 <lookup_path+0x1d4>
        entry = edup(myProcess()->cwd);
    80203b7c:	0000c097          	auipc	ra,0xc
    80203b80:	e6c080e7          	jalr	-404(ra) # 8020f9e8 <myProcess>
    80203b84:	000027b7          	lui	a5,0x2
    80203b88:	00f507b3          	add	a5,a0,a5
    80203b8c:	0887b983          	ld	s3,136(a5) # 2088 <_start-0x801fdf78>
    80203b90:	04c0006f          	j	80203bdc <lookup_path+0xcc>
        if (myProcess()->ofile[fd] == 0) {
    80203b94:	0000c097          	auipc	ra,0xc
    80203b98:	e54080e7          	jalr	-428(ra) # 8020f9e8 <myProcess>
    80203b9c:	00e90793          	addi	a5,s2,14
    80203ba0:	00379793          	slli	a5,a5,0x3
    80203ba4:	00f507b3          	add	a5,a0,a5
    80203ba8:	0007b983          	ld	s3,0(a5)
    80203bac:	12098c63          	beqz	s3,80203ce4 <lookup_path+0x1d4>
        entry = edup(myProcess()->ofile[fd]->ep);
    80203bb0:	0000c097          	auipc	ra,0xc
    80203bb4:	e38080e7          	jalr	-456(ra) # 8020f9e8 <myProcess>
    80203bb8:	00e90793          	addi	a5,s2,14
    80203bbc:	00379793          	slli	a5,a5,0x3
    80203bc0:	00f507b3          	add	a5,a0,a5
    80203bc4:	0007b783          	ld	a5,0(a5)
    80203bc8:	0187b983          	ld	s3,24(a5)
    80203bcc:	0100006f          	j	80203bdc <lookup_path+0xcc>
        entry = edup(&rootFileSystem->root);
    80203bd0:	010b4997          	auipc	s3,0x10b4
    80203bd4:	6089b983          	ld	s3,1544(s3) # 812b81d8 <rootFileSystem>
    80203bd8:	07098993          	addi	s3,s3,112
    while (*path == '/') {
    80203bdc:	02f00913          	li	s2,47
    80203be0:	0ff00b13          	li	s6,255
    80203be4:	0ff00b93          	li	s7,255
    80203be8:	0940006f          	j	80203c7c <lookup_path+0x16c>
    int len = path - s;
    80203bec:	40b487b3          	sub	a5,s1,a1
    80203bf0:	00078613          	mv	a2,a5
    80203bf4:	0007879b          	sext.w	a5,a5
    80203bf8:	00fb5463          	bge	s6,a5,80203c00 <lookup_path+0xf0>
    80203bfc:	000b8613          	mv	a2,s7
    80203c00:	0006079b          	sext.w	a5,a2
    name[len] = 0;
    80203c04:	00fa07b3          	add	a5,s4,a5
    80203c08:	00078023          	sb	zero,0(a5)
    memmove(name, s, len);
    80203c0c:	0006061b          	sext.w	a2,a2
    80203c10:	000a0513          	mv	a0,s4
    80203c14:	0000b097          	auipc	ra,0xb
    80203c18:	1ec080e7          	jalr	492(ra) # 8020ee00 <memmove>
    while (*path == '/') {
    80203c1c:	0004c783          	lbu	a5,0(s1)
    80203c20:	01279863          	bne	a5,s2,80203c30 <lookup_path+0x120>
        path++;
    80203c24:	00148493          	addi	s1,s1,1
    while (*path == '/') {
    80203c28:	0004c783          	lbu	a5,0(s1)
    80203c2c:	ff278ce3          	beq	a5,s2,80203c24 <lookup_path+0x114>
        entry = jumpToLinkDirent(entry);
    80203c30:	00098513          	mv	a0,s3
    80203c34:	00000097          	auipc	ra,0x0
    80203c38:	e3c080e7          	jalr	-452(ra) # 80203a70 <jumpToLinkDirent>
    80203c3c:	00050993          	mv	s3,a0
        if (!(entry->attribute & ATTR_DIRECTORY)) {
    80203c40:	10054783          	lbu	a5,256(a0)
    80203c44:	0107f793          	andi	a5,a5,16
    80203c48:	08078263          	beqz	a5,80203ccc <lookup_path+0x1bc>
        if (entry->head != NULL) {
    80203c4c:	2309b783          	ld	a5,560(s3)
    80203c50:	00078463          	beqz	a5,80203c58 <lookup_path+0x148>
            Dirent* mountDirent = &entry->head->root;
    80203c54:	07078993          	addi	s3,a5,112
        if (parent && *path == '\0') {
    80203c58:	000a8663          	beqz	s5,80203c64 <lookup_path+0x154>
    80203c5c:	0004c783          	lbu	a5,0(s1)
    80203c60:	08078263          	beqz	a5,80203ce4 <lookup_path+0x1d4>
        if ((next = dirlookup(entry, name)) == 0) {
    80203c64:	000a0593          	mv	a1,s4
    80203c68:	00098513          	mv	a0,s3
    80203c6c:	00000097          	auipc	ra,0x0
    80203c70:	b8c080e7          	jalr	-1140(ra) # 802037f8 <dirlookup>
    80203c74:	00050993          	mv	s3,a0
    80203c78:	06050663          	beqz	a0,80203ce4 <lookup_path+0x1d4>
    while (*path == '/') {
    80203c7c:	0004c783          	lbu	a5,0(s1)
    80203c80:	09279c63          	bne	a5,s2,80203d18 <lookup_path+0x208>
        path++;
    80203c84:	00148493          	addi	s1,s1,1
    while (*path == '/') {
    80203c88:	0004c783          	lbu	a5,0(s1)
    80203c8c:	ff278ce3          	beq	a5,s2,80203c84 <lookup_path+0x174>
    if (*path == 0) {
    80203c90:	04078263          	beqz	a5,80203cd4 <lookup_path+0x1c4>
        path++;
    80203c94:	00048593          	mv	a1,s1
    while (*path != '/' && *path != 0) {
    80203c98:	f5278ae3          	beq	a5,s2,80203bec <lookup_path+0xdc>
    80203c9c:	f40788e3          	beqz	a5,80203bec <lookup_path+0xdc>
        path++;
    80203ca0:	00148493          	addi	s1,s1,1
    while (*path != '/' && *path != 0) {
    80203ca4:	0004c783          	lbu	a5,0(s1)
    80203ca8:	ff279ae3          	bne	a5,s2,80203c9c <lookup_path+0x18c>
    80203cac:	f41ff06f          	j	80203bec <lookup_path+0xdc>
        entry = jumpToLinkDirent(entry);
    80203cb0:	00098513          	mv	a0,s3
    80203cb4:	00000097          	auipc	ra,0x0
    80203cb8:	dbc080e7          	jalr	-580(ra) # 80203a70 <jumpToLinkDirent>
    80203cbc:	00050993          	mv	s3,a0
    80203cc0:	0180006f          	j	80203cd8 <lookup_path+0x1c8>
        return NULL;
    80203cc4:	00000993          	li	s3,0
    80203cc8:	01c0006f          	j	80203ce4 <lookup_path+0x1d4>
            return NULL;
    80203ccc:	00000993          	li	s3,0
    80203cd0:	0140006f          	j	80203ce4 <lookup_path+0x1d4>
    if (jump) {
    80203cd4:	fc0c1ee3          	bnez	s8,80203cb0 <lookup_path+0x1a0>
        return NULL;
    80203cd8:	001ab793          	seqz	a5,s5
    80203cdc:	40f007b3          	neg	a5,a5
    80203ce0:	00f9f9b3          	and	s3,s3,a5
}
    80203ce4:	00098513          	mv	a0,s3
    80203ce8:	04813083          	ld	ra,72(sp)
    80203cec:	04013403          	ld	s0,64(sp)
    80203cf0:	03813483          	ld	s1,56(sp)
    80203cf4:	03013903          	ld	s2,48(sp)
    80203cf8:	02813983          	ld	s3,40(sp)
    80203cfc:	02013a03          	ld	s4,32(sp)
    80203d00:	01813a83          	ld	s5,24(sp)
    80203d04:	01013b03          	ld	s6,16(sp)
    80203d08:	00813b83          	ld	s7,8(sp)
    80203d0c:	00013c03          	ld	s8,0(sp)
    80203d10:	05010113          	addi	sp,sp,80
    80203d14:	00008067          	ret
    if (*path == 0) {
    80203d18:	fa078ee3          	beqz	a5,80203cd4 <lookup_path+0x1c4>
    while (*path != '/' && *path != 0) {
    80203d1c:	0004c783          	lbu	a5,0(s1)
    80203d20:	00048593          	mv	a1,s1
    80203d24:	f79ff06f          	j	80203c9c <lookup_path+0x18c>

0000000080203d28 <enameparent>:

Dirent* enameparent(int fd, char* path, char* name) {
    80203d28:	ff010113          	addi	sp,sp,-16
    80203d2c:	00113423          	sd	ra,8(sp)
    80203d30:	00813023          	sd	s0,0(sp)
    80203d34:	01010413          	addi	s0,sp,16
    80203d38:	00060693          	mv	a3,a2
    return lookup_path(fd, path, 1, name, true);
    80203d3c:	00100713          	li	a4,1
    80203d40:	00100613          	li	a2,1
    80203d44:	00000097          	auipc	ra,0x0
    80203d48:	dcc080e7          	jalr	-564(ra) # 80203b10 <lookup_path>
}
    80203d4c:	00813083          	ld	ra,8(sp)
    80203d50:	00013403          	ld	s0,0(sp)
    80203d54:	01010113          	addi	sp,sp,16
    80203d58:	00008067          	ret

0000000080203d5c <create>:
Dirent* create(int fd, char* path, short type, int mode) {
    80203d5c:	ee010113          	addi	sp,sp,-288
    80203d60:	10113c23          	sd	ra,280(sp)
    80203d64:	10813823          	sd	s0,272(sp)
    80203d68:	10913423          	sd	s1,264(sp)
    80203d6c:	12010413          	addi	s0,sp,288
    80203d70:	00060493          	mv	s1,a2
    if ((dp = enameparent(fd, path, name)) == NULL) {
    80203d74:	ee040613          	addi	a2,s0,-288
    80203d78:	00000097          	auipc	ra,0x0
    80203d7c:	fb0080e7          	jalr	-80(ra) # 80203d28 <enameparent>
    80203d80:	04050063          	beqz	a0,80203dc0 <create+0x64>
    if (type == T_DIR) {
    80203d84:	0004879b          	sext.w	a5,s1
    80203d88:	00400713          	li	a4,4
    80203d8c:	04e78463          	beq	a5,a4,80203dd4 <create+0x78>
    80203d90:	00500713          	li	a4,5
    80203d94:	04e78463          	beq	a5,a4,80203ddc <create+0x80>
    80203d98:	00100713          	li	a4,1
    80203d9c:	06e78a63          	beq	a5,a4,80203e10 <create+0xb4>
    if ((ep = ealloc(dp, name, mode)) == NULL) {
    80203da0:	00000613          	li	a2,0
    80203da4:	ee040593          	addi	a1,s0,-288
    80203da8:	00000097          	auipc	ra,0x0
    80203dac:	b34080e7          	jalr	-1228(ra) # 802038dc <ealloc>
    80203db0:	00050863          	beqz	a0,80203dc0 <create+0x64>
    if ((type == T_DIR && !(ep->attribute & ATTR_DIRECTORY)) ||
    80203db4:	0004849b          	sext.w	s1,s1
    80203db8:	00200793          	li	a5,2
    80203dbc:	04f48263          	beq	s1,a5,80203e00 <create+0xa4>
}
    80203dc0:	11813083          	ld	ra,280(sp)
    80203dc4:	11013403          	ld	s0,272(sp)
    80203dc8:	10813483          	ld	s1,264(sp)
    80203dcc:	12010113          	addi	sp,sp,288
    80203dd0:	00008067          	ret
    if ((dp = enameparent(fd, path, name)) == NULL) {
    80203dd4:	04000613          	li	a2,64
    80203dd8:	0080006f          	j	80203de0 <create+0x84>
    80203ddc:	08000613          	li	a2,128
    if ((ep = ealloc(dp, name, mode)) == NULL) {
    80203de0:	ee040593          	addi	a1,s0,-288
    80203de4:	00000097          	auipc	ra,0x0
    80203de8:	af8080e7          	jalr	-1288(ra) # 802038dc <ealloc>
    80203dec:	fc050ae3          	beqz	a0,80203dc0 <create+0x64>
    if ((type == T_DIR && !(ep->attribute & ATTR_DIRECTORY)) ||
    80203df0:	0004879b          	sext.w	a5,s1
    80203df4:	00100713          	li	a4,1
    80203df8:	02e78663          	beq	a5,a4,80203e24 <create+0xc8>
    80203dfc:	fb9ff06f          	j	80203db4 <create+0x58>
        (type == T_FILE && (ep->attribute & ATTR_DIRECTORY))) {
    80203e00:	10054783          	lbu	a5,256(a0)
    80203e04:	0107f793          	andi	a5,a5,16
    80203e08:	fa078ce3          	beqz	a5,80203dc0 <create+0x64>
    80203e0c:	0240006f          	j	80203e30 <create+0xd4>
    if ((ep = ealloc(dp, name, mode)) == NULL) {
    80203e10:	01000613          	li	a2,16
    80203e14:	ee040593          	addi	a1,s0,-288
    80203e18:	00000097          	auipc	ra,0x0
    80203e1c:	ac4080e7          	jalr	-1340(ra) # 802038dc <ealloc>
    80203e20:	fa0500e3          	beqz	a0,80203dc0 <create+0x64>
    if ((type == T_DIR && !(ep->attribute & ATTR_DIRECTORY)) ||
    80203e24:	10054783          	lbu	a5,256(a0)
    80203e28:	0107f793          	andi	a5,a5,16
    80203e2c:	f8079ae3          	bnez	a5,80203dc0 <create+0x64>
        return NULL;
    80203e30:	00000513          	li	a0,0
    80203e34:	f8dff06f          	j	80203dc0 <create+0x64>

0000000080203e38 <fileinit>:
struct {
    struct Spinlock lock;
    struct File file[NFILE];
} ftable;

void fileinit(void) {
    80203e38:	fe010113          	addi	sp,sp,-32
    80203e3c:	00113c23          	sd	ra,24(sp)
    80203e40:	00813823          	sd	s0,16(sp)
    80203e44:	00913423          	sd	s1,8(sp)
    80203e48:	01213023          	sd	s2,0(sp)
    80203e4c:	02010413          	addi	s0,sp,32
    initLock(&ftable.lock, "ftable");
    80203e50:	00011597          	auipc	a1,0x11
    80203e54:	6f058593          	addi	a1,a1,1776 # 80215540 <__func__.0+0x18>
    80203e58:	010a8517          	auipc	a0,0x10a8
    80203e5c:	66850513          	addi	a0,a0,1640 # 812ac4c0 <ftable>
    80203e60:	00005097          	auipc	ra,0x5
    80203e64:	988080e7          	jalr	-1656(ra) # 802087e8 <initLock>
    struct File* f;
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
    80203e68:	010a8497          	auipc	s1,0x10a8
    80203e6c:	67048493          	addi	s1,s1,1648 # 812ac4d8 <ftable+0x18>
    80203e70:	010ae917          	auipc	s2,0x10ae
    80203e74:	66890913          	addi	s2,s2,1640 # 812b24d8 <fileSystem>
        memset(f, 0, sizeof(struct File));
    80203e78:	03000613          	li	a2,48
    80203e7c:	00000593          	li	a1,0
    80203e80:	00048513          	mv	a0,s1
    80203e84:	0000b097          	auipc	ra,0xb
    80203e88:	ee8080e7          	jalr	-280(ra) # 8020ed6c <memset>
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
    80203e8c:	03048493          	addi	s1,s1,48
    80203e90:	ff2494e3          	bne	s1,s2,80203e78 <fileinit+0x40>
    }
}
    80203e94:	01813083          	ld	ra,24(sp)
    80203e98:	01013403          	ld	s0,16(sp)
    80203e9c:	00813483          	ld	s1,8(sp)
    80203ea0:	00013903          	ld	s2,0(sp)
    80203ea4:	02010113          	addi	sp,sp,32
    80203ea8:	00008067          	ret

0000000080203eac <filealloc>:

// Allocate a file structure.
struct File* filealloc(void) {
    80203eac:	ff010113          	addi	sp,sp,-16
    80203eb0:	00813423          	sd	s0,8(sp)
    80203eb4:	01010413          	addi	s0,sp,16
    struct File* f;

    // acquireLock(&ftable.lock);
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
    80203eb8:	010a8517          	auipc	a0,0x10a8
    80203ebc:	62050513          	addi	a0,a0,1568 # 812ac4d8 <ftable+0x18>
    80203ec0:	010ae717          	auipc	a4,0x10ae
    80203ec4:	61870713          	addi	a4,a4,1560 # 812b24d8 <fileSystem>
        if (f->ref == 0) {
    80203ec8:	00452783          	lw	a5,4(a0)
    80203ecc:	00078a63          	beqz	a5,80203ee0 <filealloc+0x34>
    for (f = ftable.file; f < ftable.file + NFILE; f++) {
    80203ed0:	03050513          	addi	a0,a0,48
    80203ed4:	fee51ae3          	bne	a0,a4,80203ec8 <filealloc+0x1c>
            // releaseLock(&ftable.lock);
            return f;
        }
    }
    // releaseLock(&ftable.lock);
    return NULL;
    80203ed8:	00000513          	li	a0,0
    80203edc:	00c0006f          	j	80203ee8 <filealloc+0x3c>
            f->ref = 1;
    80203ee0:	00100793          	li	a5,1
    80203ee4:	00f52223          	sw	a5,4(a0)
}
    80203ee8:	00813403          	ld	s0,8(sp)
    80203eec:	01010113          	addi	sp,sp,16
    80203ef0:	00008067          	ret

0000000080203ef4 <filedup>:

// Increment ref count for file f.
struct File* filedup(struct File* f) {
    // acquireLock(&ftable.lock);
    if (f->ref < 1)
    80203ef4:	00452783          	lw	a5,4(a0)
    80203ef8:	00f05863          	blez	a5,80203f08 <filedup+0x14>
        panic("filedup");
    f->ref++;
    80203efc:	0017879b          	addiw	a5,a5,1
    80203f00:	00f52223          	sw	a5,4(a0)
    // releaseLock(&ftable.lock);
    return f;
}
    80203f04:	00008067          	ret
struct File* filedup(struct File* f) {
    80203f08:	ff010113          	addi	sp,sp,-16
    80203f0c:	00113423          	sd	ra,8(sp)
    80203f10:	00813023          	sd	s0,0(sp)
    80203f14:	01010413          	addi	s0,sp,16
        panic("filedup");
    80203f18:	00011697          	auipc	a3,0x11
    80203f1c:	63068693          	addi	a3,a3,1584 # 80215548 <__func__.0+0x20>
    80203f20:	00013617          	auipc	a2,0x13
    80203f24:	86060613          	addi	a2,a2,-1952 # 80216780 <__func__.4>
    80203f28:	03200593          	li	a1,50
    80203f2c:	00011517          	auipc	a0,0x11
    80203f30:	62450513          	addi	a0,a0,1572 # 80215550 <__func__.0+0x28>
    80203f34:	ffffd097          	auipc	ra,0xffffd
    80203f38:	fb4080e7          	jalr	-76(ra) # 80200ee8 <_panic_>

0000000080203f3c <fileclose>:

// Close file f.  (Decrement ref count, close when reaches 0.)
void fileclose(struct File* f) {
    80203f3c:	ff010113          	addi	sp,sp,-16
    80203f40:	00113423          	sd	ra,8(sp)
    80203f44:	00813023          	sd	s0,0(sp)
    80203f48:	01010413          	addi	s0,sp,16
    struct File ff;

    // printf("[FILE CLOSE]%x %x\n", f, f->ref);
    // acquireLock(&ftable.lock);
    if (f->ref < 1)
    80203f4c:	00452703          	lw	a4,4(a0)
    80203f50:	04e05e63          	blez	a4,80203fac <fileclose+0x70>
    80203f54:	00050793          	mv	a5,a0
        panic("fileclose");
    if (--f->ref > 0) {
    80203f58:	fff7071b          	addiw	a4,a4,-1
    80203f5c:	0007069b          	sext.w	a3,a4
    80203f60:	00e52223          	sw	a4,4(a0)
    80203f64:	02d04c63          	bgtz	a3,80203f9c <fileclose+0x60>
        // releaseLock(&ftable.lock);
        return;
    }
    ff = *f;
    80203f68:	00052703          	lw	a4,0(a0)
    80203f6c:	00954583          	lbu	a1,9(a0)
    80203f70:	01053683          	ld	a3,16(a0)
    80203f74:	01853503          	ld	a0,24(a0)
    80203f78:	0207b603          	ld	a2,32(a5)
    f->ref = 0;
    80203f7c:	0007a223          	sw	zero,4(a5)
    f->type = FD_NONE;
    80203f80:	0007a023          	sw	zero,0(a5)
    // releaseLock(&ftable.lock);

    // printf("FILECLOSE %x\n", ff.type);
    if (ff.type == FD_PIPE) {
    80203f84:	00100793          	li	a5,1
    80203f88:	04f70463          	beq	a4,a5,80203fd0 <fileclose+0x94>
        pipeClose(ff.pipe, ff.writable);
    } else if (ff.type == FD_ENTRY) {
    80203f8c:	00200793          	li	a5,2
    80203f90:	04f70863          	beq	a4,a5,80203fe0 <fileclose+0xa4>
        eput(ff.ep);
    } else if (ff.type == FD_DEVICE) {
    } else if (ff.type == FD_SOCKET) {
    80203f94:	00400793          	li	a5,4
    80203f98:	04f70a63          	beq	a4,a5,80203fec <fileclose+0xb0>
        socketFree(ff.socket);
    }
}
    80203f9c:	00813083          	ld	ra,8(sp)
    80203fa0:	00013403          	ld	s0,0(sp)
    80203fa4:	01010113          	addi	sp,sp,16
    80203fa8:	00008067          	ret
        panic("fileclose");
    80203fac:	00011697          	auipc	a3,0x11
    80203fb0:	5ac68693          	addi	a3,a3,1452 # 80215558 <__func__.0+0x30>
    80203fb4:	00011617          	auipc	a2,0x11
    80203fb8:	5d460613          	addi	a2,a2,1492 # 80215588 <__func__.3>
    80203fbc:	03f00593          	li	a1,63
    80203fc0:	00011517          	auipc	a0,0x11
    80203fc4:	59050513          	addi	a0,a0,1424 # 80215550 <__func__.0+0x28>
    80203fc8:	ffffd097          	auipc	ra,0xffffd
    80203fcc:	f20080e7          	jalr	-224(ra) # 80200ee8 <_panic_>
        pipeClose(ff.pipe, ff.writable);
    80203fd0:	00068513          	mv	a0,a3
    80203fd4:	00001097          	auipc	ra,0x1
    80203fd8:	31c080e7          	jalr	796(ra) # 802052f0 <pipeClose>
    80203fdc:	fc1ff06f          	j	80203f9c <fileclose+0x60>
        eput(ff.ep);
    80203fe0:	fffff097          	auipc	ra,0xfffff
    80203fe4:	62c080e7          	jalr	1580(ra) # 8020360c <eput>
    80203fe8:	fb5ff06f          	j	80203f9c <fileclose+0x60>
        socketFree(ff.socket);
    80203fec:	00060513          	mv	a0,a2
    80203ff0:	00002097          	auipc	ra,0x2
    80203ff4:	a78080e7          	jalr	-1416(ra) # 80205a68 <socketFree>
    80203ff8:	fa5ff06f          	j	80203f9c <fileclose+0x60>

0000000080203ffc <filestat>:

// Get metadata about file f.
// addr is a user virtual address, pointing to a struct stat.
int filestat(struct File* f, u64 addr) {
    80203ffc:	f5010113          	addi	sp,sp,-176
    80204000:	0a113423          	sd	ra,168(sp)
    80204004:	0a813023          	sd	s0,160(sp)
    80204008:	08913c23          	sd	s1,152(sp)
    8020400c:	09213823          	sd	s2,144(sp)
    80204010:	09313423          	sd	s3,136(sp)
    80204014:	0b010413          	addi	s0,sp,176
    80204018:	00050493          	mv	s1,a0
    8020401c:	00058993          	mv	s3,a1
    struct Process *p = myProcess();
    80204020:	0000c097          	auipc	ra,0xc
    80204024:	9c8080e7          	jalr	-1592(ra) # 8020f9e8 <myProcess>
    struct stat st;

    if (f->type == FD_ENTRY) {
    80204028:	0004a703          	lw	a4,0(s1)
    8020402c:	00200793          	li	a5,2
    80204030:	06f71463          	bne	a4,a5,80204098 <filestat+0x9c>
    80204034:	00050913          	mv	s2,a0
        elock(f->ep);
    80204038:	0184b503          	ld	a0,24(s1)
    8020403c:	fffff097          	auipc	ra,0xfffff
    80204040:	5a0080e7          	jalr	1440(ra) # 802035dc <elock>
        estat(f->ep, &st);
    80204044:	f5040593          	addi	a1,s0,-176
    80204048:	0184b503          	ld	a0,24(s1)
    8020404c:	fffff097          	auipc	ra,0xfffff
    80204050:	5d8080e7          	jalr	1496(ra) # 80203624 <estat>
        eunlock(f->ep);
    80204054:	0184b503          	ld	a0,24(s1)
    80204058:	fffff097          	auipc	ra,0xfffff
    8020405c:	59c080e7          	jalr	1436(ra) # 802035f4 <eunlock>
        if(copyout(p->pgdir, addr, (char *)&st, sizeof(st)) < 0)
    80204060:	08000693          	li	a3,128
    80204064:	f5040613          	addi	a2,s0,-176
    80204068:	00098593          	mv	a1,s3
    8020406c:	04093503          	ld	a0,64(s2)
    80204070:	00006097          	auipc	ra,0x6
    80204074:	ac8080e7          	jalr	-1336(ra) # 80209b38 <copyout>
    80204078:	41f5551b          	sraiw	a0,a0,0x1f
            return -1;
        return 0;
    }
    return -1;
}
    8020407c:	0a813083          	ld	ra,168(sp)
    80204080:	0a013403          	ld	s0,160(sp)
    80204084:	09813483          	ld	s1,152(sp)
    80204088:	09013903          	ld	s2,144(sp)
    8020408c:	08813983          	ld	s3,136(sp)
    80204090:	0b010113          	addi	sp,sp,176
    80204094:	00008067          	ret
    return -1;
    80204098:	fff00513          	li	a0,-1
    8020409c:	fe1ff06f          	j	8020407c <filestat+0x80>

00000000802040a0 <fileread>:

// Read from file f.
// addr is a user virtual address.
int fileread(struct File* f, bool isUser, u64 addr, int n) {
    802040a0:	fe010113          	addi	sp,sp,-32
    802040a4:	00113c23          	sd	ra,24(sp)
    802040a8:	00813823          	sd	s0,16(sp)
    802040ac:	00913423          	sd	s1,8(sp)
    802040b0:	02010413          	addi	s0,sp,32
    802040b4:	00050493          	mv	s1,a0
    int r = 0;

    if (f->readable == 0)
    802040b8:	00854783          	lbu	a5,8(a0)
    802040bc:	0e078a63          	beqz	a5,802041b0 <fileread+0x110>
    802040c0:	00058513          	mv	a0,a1
    802040c4:	00060593          	mv	a1,a2
        return -1;

    switch (f->type) {
    802040c8:	0004a783          	lw	a5,0(s1)
    802040cc:	00300713          	li	a4,3
    802040d0:	08e78263          	beq	a5,a4,80204154 <fileread+0xb4>
    802040d4:	04f76063          	bltu	a4,a5,80204114 <fileread+0x74>
    802040d8:	00100713          	li	a4,1
    802040dc:	04e78a63          	beq	a5,a4,80204130 <fileread+0x90>
    802040e0:	00200713          	li	a4,2
    802040e4:	0ae79463          	bne	a5,a4,8020418c <fileread+0xec>
                return -1;
            r = devsw[f->major].read(isUser, addr, 0, n);
            break;
        case FD_ENTRY:
            // elock(f->ep);
            if ((r = eread(f->ep, isUser, addr, f->off, n)) > 0)
    802040e8:	00068713          	mv	a4,a3
    802040ec:	0284a683          	lw	a3,40(s1)
    802040f0:	00050593          	mv	a1,a0
    802040f4:	0184b503          	ld	a0,24(s1)
    802040f8:	fffff097          	auipc	ra,0xfffff
    802040fc:	ca4080e7          	jalr	-860(ra) # 80202d9c <eread>
    80204100:	04a05063          	blez	a0,80204140 <fileread+0xa0>
                f->off += r;
    80204104:	0284a783          	lw	a5,40(s1)
    80204108:	00a787bb          	addw	a5,a5,a0
    8020410c:	02f4a423          	sw	a5,40(s1)
    80204110:	0300006f          	j	80204140 <fileread+0xa0>
    switch (f->type) {
    80204114:	00400713          	li	a4,4
    80204118:	06e79a63          	bne	a5,a4,8020418c <fileread+0xec>
            //     r++;
            // }
            // eunlock(f->ep);
            break;
        case FD_SOCKET:
            r = socket_read(f->socket, isUser, addr, n);
    8020411c:	00050593          	mv	a1,a0
    80204120:	0204b503          	ld	a0,32(s1)
    80204124:	00002097          	auipc	ra,0x2
    80204128:	f38080e7          	jalr	-200(ra) # 8020605c <socket_read>
            break;
    8020412c:	0140006f          	j	80204140 <fileread+0xa0>
            r = pipeRead(f->pipe, isUser, addr, n);
    80204130:	00050593          	mv	a1,a0
    80204134:	0104b503          	ld	a0,16(s1)
    80204138:	00001097          	auipc	ra,0x1
    8020413c:	494080e7          	jalr	1172(ra) # 802055cc <pipeRead>
        default:
            panic("fileread");
    }

    return r;
}
    80204140:	01813083          	ld	ra,24(sp)
    80204144:	01013403          	ld	s0,16(sp)
    80204148:	00813483          	ld	s1,8(sp)
    8020414c:	02010113          	addi	sp,sp,32
    80204150:	00008067          	ret
            if (f->major < 0 || f->major >= NDEV || !devsw[f->major].read)
    80204154:	02c49783          	lh	a5,44(s1)
    80204158:	03079613          	slli	a2,a5,0x30
    8020415c:	03065613          	srli	a2,a2,0x30
    80204160:	00300713          	li	a4,3
    80204164:	04c76a63          	bltu	a4,a2,802041b8 <fileread+0x118>
    80204168:	00479793          	slli	a5,a5,0x4
    8020416c:	010a8717          	auipc	a4,0x10a8
    80204170:	31470713          	addi	a4,a4,788 # 812ac480 <devsw>
    80204174:	00f707b3          	add	a5,a4,a5
    80204178:	0007b783          	ld	a5,0(a5)
    8020417c:	04078263          	beqz	a5,802041c0 <fileread+0x120>
            r = devsw[f->major].read(isUser, addr, 0, n);
    80204180:	00000613          	li	a2,0
    80204184:	000780e7          	jalr	a5
            break;
    80204188:	fb9ff06f          	j	80204140 <fileread+0xa0>
            panic("fileread");
    8020418c:	00011697          	auipc	a3,0x11
    80204190:	3dc68693          	addi	a3,a3,988 # 80215568 <__func__.0+0x40>
    80204194:	00011617          	auipc	a2,0x11
    80204198:	40460613          	addi	a2,a2,1028 # 80215598 <__func__.2>
    8020419c:	08500593          	li	a1,133
    802041a0:	00011517          	auipc	a0,0x11
    802041a4:	3b050513          	addi	a0,a0,944 # 80215550 <__func__.0+0x28>
    802041a8:	ffffd097          	auipc	ra,0xffffd
    802041ac:	d40080e7          	jalr	-704(ra) # 80200ee8 <_panic_>
        return -1;
    802041b0:	fff00513          	li	a0,-1
    802041b4:	f8dff06f          	j	80204140 <fileread+0xa0>
                return -1;
    802041b8:	fff00513          	li	a0,-1
    802041bc:	f85ff06f          	j	80204140 <fileread+0xa0>
    802041c0:	fff00513          	li	a0,-1
    802041c4:	f7dff06f          	j	80204140 <fileread+0xa0>

00000000802041c8 <filewrite>:

// Write to file f.
// addr is a user virtual address.
int filewrite(struct File* f, bool isUser, u64 addr, int n) {
    802041c8:	fd010113          	addi	sp,sp,-48
    802041cc:	02113423          	sd	ra,40(sp)
    802041d0:	02813023          	sd	s0,32(sp)
    802041d4:	00913c23          	sd	s1,24(sp)
    802041d8:	01213823          	sd	s2,16(sp)
    802041dc:	01313423          	sd	s3,8(sp)
    802041e0:	03010413          	addi	s0,sp,48
    802041e4:	00050913          	mv	s2,a0
    int ret = 0;

    if (f->writable == 0)
    802041e8:	00954783          	lbu	a5,9(a0)
    802041ec:	10078263          	beqz	a5,802042f0 <filewrite+0x128>
    802041f0:	00058513          	mv	a0,a1
    802041f4:	00060593          	mv	a1,a2
    802041f8:	00068493          	mv	s1,a3
        return -1;

    if (f->type == FD_PIPE) {
    802041fc:	00092783          	lw	a5,0(s2)
    80204200:	00100713          	li	a4,1
    80204204:	04e78463          	beq	a5,a4,8020424c <filewrite+0x84>
        ret = pipeWrite(f->pipe, isUser, addr, n);
        // assert(ret != 0);
    } else if (f->type == FD_DEVICE) {
    80204208:	00300713          	li	a4,3
    8020420c:	04e78a63          	beq	a5,a4,80204260 <filewrite+0x98>
        if (f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
            return -1;
        ret = devsw[f->major].write(isUser, addr, 0, n);
    } else if (f->type == FD_ENTRY) {
    80204210:	00200713          	li	a4,2
    80204214:	08e78263          	beq	a5,a4,80204298 <filewrite+0xd0>
            f->off += n;
        } else {
            ret = -1;
        }
        // eunlock(f->ep);
    } else if (f->type == FD_SOCKET) {
    80204218:	00400713          	li	a4,4
    8020421c:	0ae79863          	bne	a5,a4,802042cc <filewrite+0x104>
        ret = socket_write(f->socket, isUser, addr, n);
    80204220:	00050593          	mv	a1,a0
    80204224:	02093503          	ld	a0,32(s2)
    80204228:	00002097          	auipc	ra,0x2
    8020422c:	eb8080e7          	jalr	-328(ra) # 802060e0 <socket_write>
    } else {
        panic("filewrite");
    }

    return ret;
}
    80204230:	02813083          	ld	ra,40(sp)
    80204234:	02013403          	ld	s0,32(sp)
    80204238:	01813483          	ld	s1,24(sp)
    8020423c:	01013903          	ld	s2,16(sp)
    80204240:	00813983          	ld	s3,8(sp)
    80204244:	03010113          	addi	sp,sp,48
    80204248:	00008067          	ret
        ret = pipeWrite(f->pipe, isUser, addr, n);
    8020424c:	00050593          	mv	a1,a0
    80204250:	01093503          	ld	a0,16(s2)
    80204254:	00001097          	auipc	ra,0x1
    80204258:	128080e7          	jalr	296(ra) # 8020537c <pipeWrite>
    8020425c:	fd5ff06f          	j	80204230 <filewrite+0x68>
        if (f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
    80204260:	02c91783          	lh	a5,44(s2)
    80204264:	03079693          	slli	a3,a5,0x30
    80204268:	0306d693          	srli	a3,a3,0x30
    8020426c:	08d76663          	bltu	a4,a3,802042f8 <filewrite+0x130>
    80204270:	00479793          	slli	a5,a5,0x4
    80204274:	010a8717          	auipc	a4,0x10a8
    80204278:	20c70713          	addi	a4,a4,524 # 812ac480 <devsw>
    8020427c:	00f707b3          	add	a5,a4,a5
    80204280:	0087b783          	ld	a5,8(a5)
    80204284:	06078e63          	beqz	a5,80204300 <filewrite+0x138>
        ret = devsw[f->major].write(isUser, addr, 0, n);
    80204288:	00048693          	mv	a3,s1
    8020428c:	00000613          	li	a2,0
    80204290:	000780e7          	jalr	a5
    80204294:	f9dff06f          	j	80204230 <filewrite+0x68>
        if (ewrite(f->ep, isUser, addr, f->off, n) == n) {
    80204298:	0006899b          	sext.w	s3,a3
    8020429c:	00098713          	mv	a4,s3
    802042a0:	02892683          	lw	a3,40(s2)
    802042a4:	00050593          	mv	a1,a0
    802042a8:	01893503          	ld	a0,24(s2)
    802042ac:	fffff097          	auipc	ra,0xfffff
    802042b0:	d24080e7          	jalr	-732(ra) # 80202fd0 <ewrite>
    802042b4:	04951a63          	bne	a0,s1,80204308 <filewrite+0x140>
            f->off += n;
    802042b8:	02892703          	lw	a4,40(s2)
    802042bc:	0137073b          	addw	a4,a4,s3
    802042c0:	02e92423          	sw	a4,40(s2)
            ret = n;
    802042c4:	00048513          	mv	a0,s1
    802042c8:	f69ff06f          	j	80204230 <filewrite+0x68>
        panic("filewrite");
    802042cc:	00011697          	auipc	a3,0x11
    802042d0:	2ac68693          	addi	a3,a3,684 # 80215578 <__func__.0+0x50>
    802042d4:	00011617          	auipc	a2,0x11
    802042d8:	2d460613          	addi	a2,a2,724 # 802155a8 <__func__.1>
    802042dc:	0a700593          	li	a1,167
    802042e0:	00011517          	auipc	a0,0x11
    802042e4:	27050513          	addi	a0,a0,624 # 80215550 <__func__.0+0x28>
    802042e8:	ffffd097          	auipc	ra,0xffffd
    802042ec:	c00080e7          	jalr	-1024(ra) # 80200ee8 <_panic_>
        return -1;
    802042f0:	fff00513          	li	a0,-1
    802042f4:	f3dff06f          	j	80204230 <filewrite+0x68>
            return -1;
    802042f8:	fff00513          	li	a0,-1
    802042fc:	f35ff06f          	j	80204230 <filewrite+0x68>
    80204300:	fff00513          	li	a0,-1
    80204304:	f2dff06f          	j	80204230 <filewrite+0x68>
            ret = -1;
    80204308:	fff00513          	li	a0,-1
    8020430c:	f25ff06f          	j	80204230 <filewrite+0x68>

0000000080204310 <do_mmap>:

u64 do_mmap(struct File* fd, u64 start, u64 len, int perm, int flags, u64 off) {
    80204310:	f8010113          	addi	sp,sp,-128
    80204314:	06113c23          	sd	ra,120(sp)
    80204318:	06813823          	sd	s0,112(sp)
    8020431c:	06913423          	sd	s1,104(sp)
    80204320:	07213023          	sd	s2,96(sp)
    80204324:	05313c23          	sd	s3,88(sp)
    80204328:	05413823          	sd	s4,80(sp)
    8020432c:	05513423          	sd	s5,72(sp)
    80204330:	05613023          	sd	s6,64(sp)
    80204334:	03713c23          	sd	s7,56(sp)
    80204338:	03813823          	sd	s8,48(sp)
    8020433c:	03913423          	sd	s9,40(sp)
    80204340:	03a13023          	sd	s10,32(sp)
    80204344:	01b13c23          	sd	s11,24(sp)
    80204348:	08010413          	addi	s0,sp,128
    8020434c:	00050d13          	mv	s10,a0
    80204350:	00058a13          	mv	s4,a1
    80204354:	00060c93          	mv	s9,a2
    80204358:	00068993          	mv	s3,a3
    8020435c:	00070b13          	mv	s6,a4
    80204360:	00078d93          	mv	s11,a5
    // printf("domap: fd: %d, start: %lx, len: %lx, perm: %lx, flags: %lx, off: %lx\n", fd, start, len, perm, flags, off);
    bool alloc = (start == 0);
    if (alloc) {
    80204364:	02058a63          	beqz	a1,80204398 <do_mmap+0x88>
        myProcess()->heapBottom = UP_ALIGN(myProcess()->heapBottom, PAGE_SIZE);
        start = myProcess()->heapBottom;
        myProcess()->heapBottom = UP_ALIGN(myProcess()->heapBottom + len, PAGE_SIZE);
        assert(myProcess()->heapBottom  < USER_STACK_BOTTOM);
    }
    u64 addr = start, end = start + len;
    80204368:	019a0933          	add	s2,s4,s9
    start = DOWN_ALIGN(start, PAGE_SIZE);
    8020436c:	fffff4b7          	lui	s1,0xfffff
    80204370:	009a74b3          	and	s1,s4,s1
    while (start < end) {
    80204374:	0f24f463          	bgeu	s1,s2,8020445c <do_mmap+0x14c>
        if (pa == 0) {
            PhysicalPage* page;
            if (pageAlloc(&page) < 0) {
                return -1;
            }
            pageInsert(myProcess()->pgdir, start, page2pa(page), perm | PTE_USER);
    80204378:	0109e993          	ori	s3,s3,16
    int hartId;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    8020437c:	01903c17          	auipc	s8,0x1903
    80204380:	b84c0c13          	addi	s8,s8,-1148 # 81b06f00 <pages>
    80204384:	00012b97          	auipc	s7,0x12
    80204388:	474b8b93          	addi	s7,s7,1140 # 802167f8 <__func__.0+0x20>
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020438c:	00100a93          	li	s5,1
    80204390:	01fa9a93          	slli	s5,s5,0x1f
    80204394:	1980006f          	j	8020452c <do_mmap+0x21c>
        myProcess()->heapBottom = UP_ALIGN(myProcess()->heapBottom, PAGE_SIZE);
    80204398:	0000b097          	auipc	ra,0xb
    8020439c:	650080e7          	jalr	1616(ra) # 8020f9e8 <myProcess>
    802043a0:	00002937          	lui	s2,0x2
    802043a4:	01250533          	add	a0,a0,s2
    802043a8:	07853483          	ld	s1,120(a0)
    802043ac:	fff48493          	addi	s1,s1,-1 # ffffffffffffefff <bssEnd+0xffffffff7dc8efff>
    802043b0:	fffffbb7          	lui	s7,0xfffff
    802043b4:	0174f4b3          	and	s1,s1,s7
    802043b8:	0000b097          	auipc	ra,0xb
    802043bc:	630080e7          	jalr	1584(ra) # 8020f9e8 <myProcess>
    802043c0:	01250533          	add	a0,a0,s2
    802043c4:	00001ab7          	lui	s5,0x1
    802043c8:	015484b3          	add	s1,s1,s5
    802043cc:	06953c23          	sd	s1,120(a0)
        start = myProcess()->heapBottom;
    802043d0:	0000b097          	auipc	ra,0xb
    802043d4:	618080e7          	jalr	1560(ra) # 8020f9e8 <myProcess>
    802043d8:	01250533          	add	a0,a0,s2
    802043dc:	07853a03          	ld	s4,120(a0)
        myProcess()->heapBottom = UP_ALIGN(myProcess()->heapBottom + len, PAGE_SIZE);
    802043e0:	0000b097          	auipc	ra,0xb
    802043e4:	608080e7          	jalr	1544(ra) # 8020f9e8 <myProcess>
    802043e8:	01250533          	add	a0,a0,s2
    802043ec:	fffc8493          	addi	s1,s9,-1
    802043f0:	07853783          	ld	a5,120(a0)
    802043f4:	00f484b3          	add	s1,s1,a5
    802043f8:	0174f4b3          	and	s1,s1,s7
    802043fc:	0000b097          	auipc	ra,0xb
    80204400:	5ec080e7          	jalr	1516(ra) # 8020f9e8 <myProcess>
    80204404:	01250533          	add	a0,a0,s2
    80204408:	015484b3          	add	s1,s1,s5
    8020440c:	06953c23          	sd	s1,120(a0)
        assert(myProcess()->heapBottom  < USER_STACK_BOTTOM);
    80204410:	0000b097          	auipc	ra,0xb
    80204414:	5d8080e7          	jalr	1496(ra) # 8020f9e8 <myProcess>
    80204418:	01250533          	add	a0,a0,s2
    8020441c:	07853683          	ld	a3,120(a0)
    80204420:	00012797          	auipc	a5,0x12
    80204424:	3d07b783          	ld	a5,976(a5) # 802167f0 <__func__.0+0x18>
    80204428:	00d7b6b3          	sltu	a3,a5,a3
    8020442c:	0016c693          	xori	a3,a3,1
    80204430:	0016f693          	andi	a3,a3,1
    80204434:	00012617          	auipc	a2,0x12
    80204438:	34460613          	addi	a2,a2,836 # 80216778 <__func__.0>
    8020443c:	0b400593          	li	a1,180
    80204440:	00011517          	auipc	a0,0x11
    80204444:	11050513          	addi	a0,a0,272 # 80215550 <__func__.0+0x28>
    80204448:	ffffd097          	auipc	ra,0xffffd
    8020444c:	b10080e7          	jalr	-1264(ra) # 80200f58 <_assert_>
    80204450:	f19ff06f          	j	80204368 <do_mmap+0x58>
                return -1;
    80204454:	fff00a13          	li	s4,-1
    80204458:	0300006f          	j	80204488 <do_mmap+0x178>
        }
        start += PGSIZE;
    }

    if (flags & MAP_ANONYMOUS) {
    8020445c:	020b7b13          	andi	s6,s6,32
    80204460:	020b1463          	bnez	s6,80204488 <do_mmap+0x178>
        return addr;
    }
    /* if fd == NULL, we think this is a anonymous map */
    if (fd != NULL) {
    80204464:	020d0263          	beqz	s10,80204488 <do_mmap+0x178>
        fd->off = off;
    80204468:	03bd2423          	sw	s11,40(s10)
        if (fileread(fd, true, addr, len) >= 0) {
    8020446c:	000c869b          	sext.w	a3,s9
    80204470:	000a0613          	mv	a2,s4
    80204474:	00100593          	li	a1,1
    80204478:	000d0513          	mv	a0,s10
    8020447c:	00000097          	auipc	ra,0x0
    80204480:	c24080e7          	jalr	-988(ra) # 802040a0 <fileread>
    80204484:	04054263          	bltz	a0,802044c8 <do_mmap+0x1b8>
            return -1;
        }
    } else {
        return addr;
    }
    80204488:	000a0513          	mv	a0,s4
    8020448c:	07813083          	ld	ra,120(sp)
    80204490:	07013403          	ld	s0,112(sp)
    80204494:	06813483          	ld	s1,104(sp)
    80204498:	06013903          	ld	s2,96(sp)
    8020449c:	05813983          	ld	s3,88(sp)
    802044a0:	05013a03          	ld	s4,80(sp)
    802044a4:	04813a83          	ld	s5,72(sp)
    802044a8:	04013b03          	ld	s6,64(sp)
    802044ac:	03813b83          	ld	s7,56(sp)
    802044b0:	03013c03          	ld	s8,48(sp)
    802044b4:	02813c83          	ld	s9,40(sp)
    802044b8:	02013d03          	ld	s10,32(sp)
    802044bc:	01813d83          	ld	s11,24(sp)
    802044c0:	08010113          	addi	sp,sp,128
    802044c4:	00008067          	ret
            return -1;
    802044c8:	fff00a13          	li	s4,-1
    802044cc:	fbdff06f          	j	80204488 <do_mmap+0x178>
            if (pageAlloc(&page) < 0) {
    802044d0:	f8840513          	addi	a0,s0,-120
    802044d4:	00005097          	auipc	ra,0x5
    802044d8:	9e8080e7          	jalr	-1560(ra) # 80208ebc <pageAlloc>
    802044dc:	f6054ce3          	bltz	a0,80204454 <do_mmap+0x144>
            pageInsert(myProcess()->pgdir, start, page2pa(page), perm | PTE_USER);
    802044e0:	0000b097          	auipc	ra,0xb
    802044e4:	508080e7          	jalr	1288(ra) # 8020f9e8 <myProcess>
    return page - pages;
    802044e8:	f8843603          	ld	a2,-120(s0)
    802044ec:	41860633          	sub	a2,a2,s8
    802044f0:	40365613          	srai	a2,a2,0x3
    802044f4:	000bb783          	ld	a5,0(s7) # fffffffffffff000 <bssEnd+0xffffffff7dc8f000>
    802044f8:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802044fc:	00c6161b          	slliw	a2,a2,0xc
    80204500:	02061613          	slli	a2,a2,0x20
    80204504:	02065613          	srli	a2,a2,0x20
    80204508:	00098693          	mv	a3,s3
    8020450c:	01560633          	add	a2,a2,s5
    80204510:	00048593          	mv	a1,s1
    80204514:	04053503          	ld	a0,64(a0)
    80204518:	00005097          	auipc	ra,0x5
    8020451c:	d58080e7          	jalr	-680(ra) # 80209270 <pageInsert>
        start += PGSIZE;
    80204520:	000017b7          	lui	a5,0x1
    80204524:	00f484b3          	add	s1,s1,a5
    while (start < end) {
    80204528:	f324fae3          	bgeu	s1,s2,8020445c <do_mmap+0x14c>
        u64 pa = pageLookup(myProcess()->pgdir, start, &pte);
    8020452c:	0000b097          	auipc	ra,0xb
    80204530:	4bc080e7          	jalr	1212(ra) # 8020f9e8 <myProcess>
    80204534:	f8040613          	addi	a2,s0,-128
    80204538:	00048593          	mv	a1,s1
    8020453c:	04053503          	ld	a0,64(a0)
    80204540:	00005097          	auipc	ra,0x5
    80204544:	a38080e7          	jalr	-1480(ra) # 80208f78 <pageLookup>
        if (pa > 0 && (*pte & PTE_COW)) {
    80204548:	f80504e3          	beqz	a0,802044d0 <do_mmap+0x1c0>
    8020454c:	f8043783          	ld	a5,-128(s0)
    80204550:	0007b783          	ld	a5,0(a5) # 1000 <_start-0x801ff000>
    80204554:	1007f793          	andi	a5,a5,256
    80204558:	fc0784e3          	beqz	a5,80204520 <do_mmap+0x210>
            cowHandler(myProcess()->pgdir, start);
    8020455c:	0000b097          	auipc	ra,0xb
    80204560:	48c080e7          	jalr	1164(ra) # 8020f9e8 <myProcess>
    80204564:	00048593          	mv	a1,s1
    80204568:	04053503          	ld	a0,64(a0)
    8020456c:	00005097          	auipc	ra,0x5
    80204570:	2b8080e7          	jalr	696(ra) # 80209824 <cowHandler>
    80204574:	fadff06f          	j	80204520 <do_mmap+0x210>

0000000080204578 <read_entry_name>:
 * Read filename from directory entry.
 * @param   buffer      pointer to the array that stores the name
 * @param   raw_entry   pointer to the entry in a sector buffer
 * @param   islong      if non-zero, read as l-n-e, otherwise s-n-e.
 */
static void read_entry_name(char* buffer, union dentry* d) {
    80204578:	fd010113          	addi	sp,sp,-48
    8020457c:	02113423          	sd	ra,40(sp)
    80204580:	02813023          	sd	s0,32(sp)
    80204584:	00913c23          	sd	s1,24(sp)
    80204588:	01213823          	sd	s2,16(sp)
    8020458c:	03010413          	addi	s0,sp,48
    80204590:	00050493          	mv	s1,a0
    80204594:	00058913          	mv	s2,a1
    if (d->lne.attr == ATTR_LONG_NAME) {  // long entry branch
    80204598:	00b5c703          	lbu	a4,11(a1)
    8020459c:	00f00793          	li	a5,15
    802045a0:	0af70463          	beq	a4,a5,80204648 <read_entry_name+0xd0>
        snstr(buffer, d->lne.name2, NELEM(d->lne.name2));
        buffer += NELEM(d->lne.name2);
        snstr(buffer, d->lne.name3, NELEM(d->lne.name3));
    } else {
        // assert: only "." and ".." will enter this branch
        memset(buffer, 0, CHAR_SHORT_NAME + 2);  // plus '.' and '\0'
    802045a4:	00d00613          	li	a2,13
    802045a8:	00000593          	li	a1,0
    802045ac:	0000a097          	auipc	ra,0xa
    802045b0:	7c0080e7          	jalr	1984(ra) # 8020ed6c <memset>
        int i;
        for (i = 0; d->sne.name[i] != ' ' && i < 8; i++) {
    802045b4:	00094703          	lbu	a4,0(s2) # 2000 <_start-0x801fe000>
    802045b8:	02000793          	li	a5,32
    802045bc:	0ef70063          	beq	a4,a5,8020469c <read_entry_name+0x124>
    802045c0:	00100793          	li	a5,1
    802045c4:	02000613          	li	a2,32
    802045c8:	00900593          	li	a1,9
            buffer[i] = d->sne.name[i];
    802045cc:	00f486b3          	add	a3,s1,a5
    802045d0:	fee68fa3          	sb	a4,-1(a3)
        for (i = 0; d->sne.name[i] != ' ' && i < 8; i++) {
    802045d4:	0007869b          	sext.w	a3,a5
    802045d8:	00f90733          	add	a4,s2,a5
    802045dc:	00074703          	lbu	a4,0(a4)
    802045e0:	00c70663          	beq	a4,a2,802045ec <read_entry_name+0x74>
    802045e4:	00178793          	addi	a5,a5,1
    802045e8:	feb792e3          	bne	a5,a1,802045cc <read_entry_name+0x54>
        }
        if (d->sne.name[8] != ' ') {
    802045ec:	00894703          	lbu	a4,8(s2)
    802045f0:	02000793          	li	a5,32
    802045f4:	00f70a63          	beq	a4,a5,80204608 <read_entry_name+0x90>
            buffer[i++] = '.';
    802045f8:	00d487b3          	add	a5,s1,a3
    802045fc:	02e00713          	li	a4,46
    80204600:	00e78023          	sb	a4,0(a5)
    80204604:	0016869b          	addiw	a3,a3,1
        }
        for (int j = 8; j < CHAR_SHORT_NAME; j++, i++) {
    80204608:	00890793          	addi	a5,s2,8
    8020460c:	00d484b3          	add	s1,s1,a3
    80204610:	00b90913          	addi	s2,s2,11
            if (d->sne.name[j] == ' ') {
    80204614:	02000693          	li	a3,32
    80204618:	0007c703          	lbu	a4,0(a5)
    8020461c:	00d70a63          	beq	a4,a3,80204630 <read_entry_name+0xb8>
                break;
            }
            buffer[i] = d->sne.name[j];
    80204620:	00e48023          	sb	a4,0(s1)
        for (int j = 8; j < CHAR_SHORT_NAME; j++, i++) {
    80204624:	00178793          	addi	a5,a5,1
    80204628:	00148493          	addi	s1,s1,1
    8020462c:	ff2796e3          	bne	a5,s2,80204618 <read_entry_name+0xa0>
        }
    }
}
    80204630:	02813083          	ld	ra,40(sp)
    80204634:	02013403          	ld	s0,32(sp)
    80204638:	01813483          	ld	s1,24(sp)
    8020463c:	01013903          	ld	s2,16(sp)
    80204640:	03010113          	addi	sp,sp,48
    80204644:	00008067          	ret
        memmove(temp, d->lne.name1, sizeof(temp));
    80204648:	00a00613          	li	a2,10
    8020464c:	00158593          	addi	a1,a1,1
    80204650:	fd040513          	addi	a0,s0,-48
    80204654:	0000a097          	auipc	ra,0xa
    80204658:	7ac080e7          	jalr	1964(ra) # 8020ee00 <memmove>
        snstr(buffer, temp, NELEM(d->lne.name1));
    8020465c:	00500613          	li	a2,5
    80204660:	fd040593          	addi	a1,s0,-48
    80204664:	00048513          	mv	a0,s1
    80204668:	0000b097          	auipc	ra,0xb
    8020466c:	998080e7          	jalr	-1640(ra) # 8020f000 <snstr>
        snstr(buffer, d->lne.name2, NELEM(d->lne.name2));
    80204670:	00600613          	li	a2,6
    80204674:	00e90593          	addi	a1,s2,14
    80204678:	00548513          	addi	a0,s1,5
    8020467c:	0000b097          	auipc	ra,0xb
    80204680:	984080e7          	jalr	-1660(ra) # 8020f000 <snstr>
        snstr(buffer, d->lne.name3, NELEM(d->lne.name3));
    80204684:	00200613          	li	a2,2
    80204688:	01c90593          	addi	a1,s2,28
    8020468c:	00b48513          	addi	a0,s1,11
    80204690:	0000b097          	auipc	ra,0xb
    80204694:	970080e7          	jalr	-1680(ra) # 8020f000 <snstr>
    80204698:	f99ff06f          	j	80204630 <read_entry_name+0xb8>
        for (i = 0; d->sne.name[i] != ' ' && i < 8; i++) {
    8020469c:	00000693          	li	a3,0
    802046a0:	f4dff06f          	j	802045ec <read_entry_name+0x74>

00000000802046a4 <fsAlloc>:
    for (int i = 0; i < 32; i++) {
    802046a4:	010ae717          	auipc	a4,0x10ae
    802046a8:	e3470713          	addi	a4,a4,-460 # 812b24d8 <fileSystem>
    802046ac:	00000793          	li	a5,0
    802046b0:	02000613          	li	a2,32
        if (!fileSystem[i].valid) {
    802046b4:	00074683          	lbu	a3,0(a4)
    802046b8:	00068c63          	beqz	a3,802046d0 <fsAlloc+0x2c>
    for (int i = 0; i < 32; i++) {
    802046bc:	0017879b          	addiw	a5,a5,1
    802046c0:	2e870713          	addi	a4,a4,744
    802046c4:	fec798e3          	bne	a5,a2,802046b4 <fsAlloc+0x10>
    return -1;
    802046c8:	fff00513          	li	a0,-1
}
    802046cc:	00008067          	ret
int fsAlloc(FileSystem **fs) {
    802046d0:	fe010113          	addi	sp,sp,-32
    802046d4:	00113c23          	sd	ra,24(sp)
    802046d8:	00813823          	sd	s0,16(sp)
    802046dc:	00913423          	sd	s1,8(sp)
    802046e0:	02010413          	addi	s0,sp,32
            *fs = &fileSystem[i];
    802046e4:	2e800713          	li	a4,744
    802046e8:	02e787b3          	mul	a5,a5,a4
    802046ec:	010ae717          	auipc	a4,0x10ae
    802046f0:	dec70713          	addi	a4,a4,-532 # 812b24d8 <fileSystem>
    802046f4:	00e784b3          	add	s1,a5,a4
    802046f8:	00953023          	sd	s1,0(a0)
            memset(*fs, 0, sizeof(FileSystem));
    802046fc:	2e800613          	li	a2,744
    80204700:	00000593          	li	a1,0
    80204704:	00048513          	mv	a0,s1
    80204708:	0000a097          	auipc	ra,0xa
    8020470c:	664080e7          	jalr	1636(ra) # 8020ed6c <memset>
            fileSystem[i].valid = true;
    80204710:	00100793          	li	a5,1
    80204714:	00f48023          	sb	a5,0(s1)
            return 0;
    80204718:	00000513          	li	a0,0
}
    8020471c:	01813083          	ld	ra,24(sp)
    80204720:	01013403          	ld	s0,16(sp)
    80204724:	00813483          	ld	s1,8(sp)
    80204728:	02010113          	addi	sp,sp,32
    8020472c:	00008067          	ret

0000000080204730 <loadDirents>:
        }
    }
    return -1;
}

void loadDirents(FileSystem *fs, Dirent *parent) {
    80204730:	f5010113          	addi	sp,sp,-176
    80204734:	0a113423          	sd	ra,168(sp)
    80204738:	0a813023          	sd	s0,160(sp)
    8020473c:	08913c23          	sd	s1,152(sp)
    80204740:	09213823          	sd	s2,144(sp)
    80204744:	09313423          	sd	s3,136(sp)
    80204748:	09413023          	sd	s4,128(sp)
    8020474c:	07513c23          	sd	s5,120(sp)
    80204750:	07613823          	sd	s6,112(sp)
    80204754:	07713423          	sd	s7,104(sp)
    80204758:	07813023          	sd	s8,96(sp)
    8020475c:	05913c23          	sd	s9,88(sp)
    80204760:	05a13823          	sd	s10,80(sp)
    80204764:	05b13423          	sd	s11,72(sp)
    80204768:	0b010413          	addi	s0,sp,176
    8020476c:	00050493          	mv	s1,a0
    80204770:	f4a43c23          	sd	a0,-168(s0)
    80204774:	00058913          	mv	s2,a1
    u32 off = 0;
    int type;
    reloc_clus(fs, parent, 0, 0);
    80204778:	00000693          	li	a3,0
    8020477c:	00000613          	li	a2,0
    80204780:	ffffe097          	auipc	ra,0xffffe
    80204784:	220080e7          	jalr	544(ra) # 802029a0 <reloc_clus>
    Dirent *ep;
    direntAlloc(&ep);
    80204788:	f8840513          	addi	a0,s0,-120
    8020478c:	ffffe097          	auipc	ra,0xffffe
    80204790:	8e4080e7          	jalr	-1820(ra) # 80202070 <direntAlloc>
    int count;
    while ((type = enext(parent, ep, off, &count) != -1)) {
    80204794:	f8843d03          	ld	s10,-120(s0)
    if (!(dp->attribute & ATTR_DIRECTORY))
    80204798:	10094783          	lbu	a5,256(s2)
    8020479c:	0107f793          	andi	a5,a5,16
    802047a0:	02078e63          	beqz	a5,802047dc <loadDirents+0xac>
    u32 off = 0;
    802047a4:	00000d93          	li	s11,0
        if (de.lne.order == EMPTY_ENTRY) {
    802047a8:	0e500b13          	li	s6,229
        if (de.lne.attr == ATTR_LONG_NAME) {
    802047ac:	00f00c93          	li	s9,15
        ep->off = off;
        ep->nextBrother = parent->firstChild;
        ep->fileSystem = fs;
        parent->firstChild = ep;
        printf("name: %s, parent: %s\n", ep->filename, parent->filename);
        if ((ep->attribute & ATTR_DIRECTORY) && (off > 32 || parent == &fs->root)) {
    802047b0:	07048793          	addi	a5,s1,112
    802047b4:	f4f43823          	sd	a5,-176(s0)
    802047b8:	0c00006f          	j	80204878 <loadDirents+0x148>
    802047bc:	02000793          	li	a5,32
    802047c0:	01b7e663          	bltu	a5,s11,802047cc <loadDirents+0x9c>
    802047c4:	f5043783          	ld	a5,-176(s0)
    802047c8:	08f91463          	bne	s2,a5,80204850 <loadDirents+0x120>
            loadDirents(fs, ep);
    802047cc:	f5843503          	ld	a0,-168(s0)
    802047d0:	00000097          	auipc	ra,0x0
    802047d4:	f60080e7          	jalr	-160(ra) # 80204730 <loadDirents>
    802047d8:	0780006f          	j	80204850 <loadDirents+0x120>
        panic("enext not dir");
    802047dc:	00011697          	auipc	a3,0x11
    802047e0:	ddc68693          	addi	a3,a3,-548 # 802155b8 <__func__.1+0x10>
    802047e4:	00012617          	auipc	a2,0x12
    802047e8:	fac60613          	addi	a2,a2,-84 # 80216790 <__func__.1>
    802047ec:	05400593          	li	a1,84
    802047f0:	00011517          	auipc	a0,0x11
    802047f4:	dd850513          	addi	a0,a0,-552 # 802155c8 <__func__.1+0x20>
    802047f8:	ffffc097          	auipc	ra,0xffffc
    802047fc:	6f0080e7          	jalr	1776(ra) # 80200ee8 <_panic_>
            cnt++;
    80204800:	001a0a1b          	addiw	s4,s4,1
            continue;
    80204804:	0c80006f          	j	802048cc <loadDirents+0x19c>
            *count = cnt;
    80204808:	014ba023          	sw	s4,0(s7)
        ep->parent = parent;
    8020480c:	f8843583          	ld	a1,-120(s0)
    80204810:	2525b023          	sd	s2,576(a1)
        ep->off = off;
    80204814:	23b5ac23          	sw	s11,568(a1)
        ep->nextBrother = parent->firstChild;
    80204818:	25093783          	ld	a5,592(s2)
    8020481c:	24f5b423          	sd	a5,584(a1)
        ep->fileSystem = fs;
    80204820:	f5843783          	ld	a5,-168(s0)
    80204824:	22f5b023          	sd	a5,544(a1)
        parent->firstChild = ep;
    80204828:	24b93823          	sd	a1,592(s2)
        printf("name: %s, parent: %s\n", ep->filename, parent->filename);
    8020482c:	00090613          	mv	a2,s2
    80204830:	00011517          	auipc	a0,0x11
    80204834:	da850513          	addi	a0,a0,-600 # 802155d8 <__func__.1+0x30>
    80204838:	ffffc097          	auipc	ra,0xffffc
    8020483c:	618080e7          	jalr	1560(ra) # 80200e50 <printf>
        if ((ep->attribute & ATTR_DIRECTORY) && (off > 32 || parent == &fs->root)) {
    80204840:	f8843583          	ld	a1,-120(s0)
    80204844:	1005c783          	lbu	a5,256(a1)
    80204848:	0107f793          	andi	a5,a5,16
    8020484c:	f60798e3          	bnez	a5,802047bc <loadDirents+0x8c>
        }
        direntAlloc(&ep);
    80204850:	f8840513          	addi	a0,s0,-120
    80204854:	ffffe097          	auipc	ra,0xffffe
    80204858:	81c080e7          	jalr	-2020(ra) # 80202070 <direntAlloc>
        off += count << 5;
    8020485c:	f8442783          	lw	a5,-124(s0)
    80204860:	0057979b          	slliw	a5,a5,0x5
    80204864:	01b78dbb          	addw	s11,a5,s11
    while ((type = enext(parent, ep, off, &count) != -1)) {
    80204868:	f8843d03          	ld	s10,-120(s0)
    if (!(dp->attribute & ATTR_DIRECTORY))
    8020486c:	10094783          	lbu	a5,256(s2)
    80204870:	0107f793          	andi	a5,a5,16
    80204874:	f60784e3          	beqz	a5,802047dc <loadDirents+0xac>
    memset(ep->filename, 0, FAT32_MAX_FILENAME + 1);
    80204878:	000d0c13          	mv	s8,s10
    8020487c:	10000613          	li	a2,256
    80204880:	00000593          	li	a1,0
    80204884:	000d0513          	mv	a0,s10
    80204888:	0000a097          	auipc	ra,0xa
    8020488c:	4e4080e7          	jalr	1252(ra) # 8020ed6c <memset>
    FileSystem *fs = dp->fileSystem;
    80204890:	22093983          	ld	s3,544(s2)
    for (int off2; (off2 = reloc_clus(fs, dp, off, 0)) != -1; off += 32) {
    80204894:	000d8493          	mv	s1,s11
    int cnt = 0;
    80204898:	00000a13          	li	s4,0
    for (int off2; (off2 = reloc_clus(fs, dp, off, 0)) != -1; off += 32) {
    8020489c:	f8440b93          	addi	s7,s0,-124
    802048a0:	fff00a93          	li	s5,-1
    802048a4:	02c0006f          	j	802048d0 <loadDirents+0x1a0>
            read_entry_name(ep->filename + (lcnt - 1) * CHAR_LONG_NAME, &de);
    802048a8:	fff7079b          	addiw	a5,a4,-1
    802048ac:	0017951b          	slliw	a0,a5,0x1
    802048b0:	00f5053b          	addw	a0,a0,a5
    802048b4:	0025151b          	slliw	a0,a0,0x2
    802048b8:	00f5053b          	addw	a0,a0,a5
    802048bc:	f6040593          	addi	a1,s0,-160
    802048c0:	00ac0533          	add	a0,s8,a0
    802048c4:	00000097          	auipc	ra,0x0
    802048c8:	cb4080e7          	jalr	-844(ra) # 80204578 <read_entry_name>
    for (int off2; (off2 = reloc_clus(fs, dp, off, 0)) != -1; off += 32) {
    802048cc:	0204849b          	addiw	s1,s1,32
    802048d0:	00000693          	li	a3,0
    802048d4:	00048613          	mv	a2,s1
    802048d8:	00090593          	mv	a1,s2
    802048dc:	00098513          	mv	a0,s3
    802048e0:	ffffe097          	auipc	ra,0xffffe
    802048e4:	0c0080e7          	jalr	192(ra) # 802029a0 <reloc_clus>
    802048e8:	0d550663          	beq	a0,s5,802049b4 <loadDirents+0x284>
        if (rw_clus(fs, dp->cur_clus, 0, 0, (u64)&de, off2, 32) != 32 ||
    802048ec:	02000813          	li	a6,32
    802048f0:	0005079b          	sext.w	a5,a0
    802048f4:	f6040713          	addi	a4,s0,-160
    802048f8:	00000693          	li	a3,0
    802048fc:	00000613          	li	a2,0
    80204900:	10c92583          	lw	a1,268(s2)
    80204904:	00098513          	mv	a0,s3
    80204908:	ffffe097          	auipc	ra,0xffffe
    8020490c:	eb8080e7          	jalr	-328(ra) # 802027c0 <rw_clus>
    80204910:	0005051b          	sext.w	a0,a0
    80204914:	02000793          	li	a5,32
    80204918:	08f51e63          	bne	a0,a5,802049b4 <loadDirents+0x284>
            de.lne.order == END_OF_ENTRY) {
    8020491c:	f6044783          	lbu	a5,-160(s0)
        if (rw_clus(fs, dp->cur_clus, 0, 0, (u64)&de, off2, 32) != 32 ||
    80204920:	08078a63          	beqz	a5,802049b4 <loadDirents+0x284>
        if (de.lne.order == EMPTY_ENTRY) {
    80204924:	ed678ee3          	beq	a5,s6,80204800 <loadDirents+0xd0>
        } else if (cnt) {
    80204928:	ee0a10e3          	bnez	s4,80204808 <loadDirents+0xd8>
        if (de.lne.attr == ATTR_LONG_NAME) {
    8020492c:	f6b44703          	lbu	a4,-149(s0)
    80204930:	03971063          	bne	a4,s9,80204950 <loadDirents+0x220>
            int lcnt = de.lne.order & ~LAST_LONG_ENTRY;
    80204934:	0bf7f713          	andi	a4,a5,191
            if (de.lne.order & LAST_LONG_ENTRY) {
    80204938:	0407f793          	andi	a5,a5,64
    8020493c:	f60786e3          	beqz	a5,802048a8 <loadDirents+0x178>
                *count = lcnt + 1;  // plus the s-n-e;
    80204940:	0017079b          	addiw	a5,a4,1
    80204944:	00fba023          	sw	a5,0(s7)
                count = 0;
    80204948:	00000b93          	li	s7,0
    8020494c:	f5dff06f          	j	802048a8 <loadDirents+0x178>
            if (count) {
    80204950:	000b8e63          	beqz	s7,8020496c <loadDirents+0x23c>
                *count = 1;
    80204954:	00100793          	li	a5,1
    80204958:	00fba023          	sw	a5,0(s7)
                read_entry_name(ep->filename, &de);
    8020495c:	f6040593          	addi	a1,s0,-160
    80204960:	000c0513          	mv	a0,s8
    80204964:	00000097          	auipc	ra,0x0
    80204968:	c14080e7          	jalr	-1004(ra) # 80204578 <read_entry_name>
    entry->attribute = d->sne.attr;
    8020496c:	f6b44783          	lbu	a5,-149(s0)
    80204970:	10fd0023          	sb	a5,256(s10)
    entry->first_clus = ((uint32)d->sne.fst_clus_hi << 16) | d->sne.fst_clus_lo;
    80204974:	f7445783          	lhu	a5,-140(s0)
    80204978:	0107979b          	slliw	a5,a5,0x10
    8020497c:	f7a45703          	lhu	a4,-134(s0)
    80204980:	00e7e7b3          	or	a5,a5,a4
    80204984:	0007879b          	sext.w	a5,a5
    80204988:	10fd2223          	sw	a5,260(s10)
    entry->inode.item[0] = entry->first_clus;
    8020498c:	10fd2c23          	sw	a5,280(s10)
    entry->inodeMaxCluster = 1;
    80204990:	00100713          	li	a4,1
    80204994:	10ed2823          	sw	a4,272(s10)
    entry->file_size = d->sne.file_size;
    80204998:	f7c42703          	lw	a4,-132(s0)
    8020499c:	10ed2423          	sw	a4,264(s10)
    entry->cur_clus = entry->first_clus;
    802049a0:	10fd2623          	sw	a5,268(s10)
    entry->clus_cnt = 0;
    802049a4:	100d2a23          	sw	zero,276(s10)
    entry->_nt_res = d->sne._nt_res;
    802049a8:	f6c44783          	lbu	a5,-148(s0)
    802049ac:	20fd0c23          	sb	a5,536(s10)
}
    802049b0:	e5dff06f          	j	8020480c <loadDirents+0xdc>
    }
    direntFree(ep);
    802049b4:	f8843503          	ld	a0,-120(s0)
    802049b8:	ffffd097          	auipc	ra,0xffffd
    802049bc:	72c080e7          	jalr	1836(ra) # 802020e4 <direntFree>
}
    802049c0:	0a813083          	ld	ra,168(sp)
    802049c4:	0a013403          	ld	s0,160(sp)
    802049c8:	09813483          	ld	s1,152(sp)
    802049cc:	09013903          	ld	s2,144(sp)
    802049d0:	08813983          	ld	s3,136(sp)
    802049d4:	08013a03          	ld	s4,128(sp)
    802049d8:	07813a83          	ld	s5,120(sp)
    802049dc:	07013b03          	ld	s6,112(sp)
    802049e0:	06813b83          	ld	s7,104(sp)
    802049e4:	06013c03          	ld	s8,96(sp)
    802049e8:	05813c83          	ld	s9,88(sp)
    802049ec:	05013d03          	ld	s10,80(sp)
    802049f0:	04813d83          	ld	s11,72(sp)
    802049f4:	0b010113          	addi	sp,sp,176
    802049f8:	00008067          	ret

00000000802049fc <fatInit>:

FileSystem *rootFileSystem;
// fs's read, name, mount_point should be inited
int fatInit(FileSystem *fs) {
    802049fc:	f7010113          	addi	sp,sp,-144
    80204a00:	08113423          	sd	ra,136(sp)
    80204a04:	08813023          	sd	s0,128(sp)
    80204a08:	06913c23          	sd	s1,120(sp)
    80204a0c:	07213823          	sd	s2,112(sp)
    80204a10:	07313423          	sd	s3,104(sp)
    80204a14:	07413023          	sd	s4,96(sp)
    80204a18:	05513c23          	sd	s5,88(sp)
    80204a1c:	05613823          	sd	s6,80(sp)
    80204a20:	05713423          	sd	s7,72(sp)
    80204a24:	05813023          	sd	s8,64(sp)
    80204a28:	03913c23          	sd	s9,56(sp)
    80204a2c:	03a13823          	sd	s10,48(sp)
    80204a30:	03b13423          	sd	s11,40(sp)
    80204a34:	09010413          	addi	s0,sp,144
    80204a38:	00050913          	mv	s2,a0
    printf("[FAT32 init]fat init begin\n");
    80204a3c:	00011517          	auipc	a0,0x11
    80204a40:	bb450513          	addi	a0,a0,-1100 # 802155f0 <__func__.1+0x48>
    80204a44:	ffffc097          	auipc	ra,0xffffc
    80204a48:	40c080e7          	jalr	1036(ra) # 80200e50 <printf>
    struct buf *b = fs->read(fs, 0);
    80204a4c:	2e093783          	ld	a5,736(s2)
    80204a50:	00000593          	li	a1,0
    80204a54:	00090513          	mv	a0,s2
    80204a58:	000780e7          	jalr	a5
    if (b == 0) {
    80204a5c:	1e050e63          	beqz	a0,80204c58 <fatInit+0x25c>
    80204a60:	00050493          	mv	s1,a0
        panic("");
    }
    if (strncmp((char const*)(b->data + 82), "FAT32", 5)) {
    80204a64:	00500613          	li	a2,5
    80204a68:	00011597          	auipc	a1,0x11
    80204a6c:	ba858593          	addi	a1,a1,-1112 # 80215610 <__func__.1+0x68>
    80204a70:	0aa50513          	addi	a0,a0,170
    80204a74:	0000a097          	auipc	ra,0xa
    80204a78:	3fc080e7          	jalr	1020(ra) # 8020ee70 <strncmp>
    80204a7c:	20051063          	bnez	a0,80204c7c <fatInit+0x280>
        panic("not FAT32 volume");
        return -1;
    }
    memmove(&fs->superBlock.bpb.byts_per_sec, b->data + 11, 2); 
    80204a80:	00200613          	li	a2,2
    80204a84:	06348593          	addi	a1,s1,99
    80204a88:	05490513          	addi	a0,s2,84
    80204a8c:	0000a097          	auipc	ra,0xa
    80204a90:	374080e7          	jalr	884(ra) # 8020ee00 <memmove>
    fs->superBlock.bpb.sec_per_clus = *(b->data + 13);
    80204a94:	0654c683          	lbu	a3,101(s1)
    80204a98:	04d90b23          	sb	a3,86(s2)
    fs->superBlock.bpb.rsvd_sec_cnt = *(uint16*)(b->data + 14);
    80204a9c:	0664d603          	lhu	a2,102(s1)
    80204aa0:	04c91c23          	sh	a2,88(s2)
    fs->superBlock.bpb.fat_cnt = *(b->data + 16);
    80204aa4:	0684c703          	lbu	a4,104(s1)
    80204aa8:	04e90d23          	sb	a4,90(s2)
    fs->superBlock.bpb.hidd_sec = *(uint32*)(b->data + 28);
    80204aac:	0744a783          	lw	a5,116(s1)
    80204ab0:	04f92e23          	sw	a5,92(s2)
    fs->superBlock.bpb.tot_sec = *(uint32*)(b->data + 32);
    80204ab4:	0784a783          	lw	a5,120(s1)
    80204ab8:	06f92023          	sw	a5,96(s2)
    fs->superBlock.bpb.fat_sz = *(uint32*)(b->data + 36);
    80204abc:	07c4a583          	lw	a1,124(s1)
    80204ac0:	06b92223          	sw	a1,100(s2)
    fs->superBlock.bpb.root_clus = *(uint32*)(b->data + 44);
    80204ac4:	0844a503          	lw	a0,132(s1)
    80204ac8:	06a92423          	sw	a0,104(s2)
    fs->superBlock.first_data_sec = fs->superBlock.bpb.rsvd_sec_cnt + fs->superBlock.bpb.fat_cnt * fs->superBlock.bpb.fat_sz;
    80204acc:	02b7073b          	mulw	a4,a4,a1
    80204ad0:	00c7073b          	addw	a4,a4,a2
    80204ad4:	04e92223          	sw	a4,68(s2)
    fs->superBlock.data_sec_cnt = fs->superBlock.bpb.tot_sec - fs->superBlock.first_data_sec;
    80204ad8:	40e787bb          	subw	a5,a5,a4
    80204adc:	04f92423          	sw	a5,72(s2)
    fs->superBlock.data_clus_cnt = fs->superBlock.data_sec_cnt / fs->superBlock.bpb.sec_per_clus;
    80204ae0:	02d7d7bb          	divuw	a5,a5,a3
    80204ae4:	04f92623          	sw	a5,76(s2)
    fs->superBlock.byts_per_clus = fs->superBlock.bpb.sec_per_clus * fs->superBlock.bpb.byts_per_sec;
    80204ae8:	05495783          	lhu	a5,84(s2)
    80204aec:	02d787bb          	mulw	a5,a5,a3
    80204af0:	04f92823          	sw	a5,80(s2)
    brelse(b);
    80204af4:	00048513          	mv	a0,s1
    80204af8:	ffffd097          	auipc	ra,0xffffd
    80204afc:	444080e7          	jalr	1092(ra) # 80201f3c <brelse>
    printf("[FAT32 init]fat_sz: %d\n", fat.bpb.fat_sz);
    printf("[FAT32 init]first_data_sec: %d\n", fat.first_data_sec);
#endif

    // make sure that byts_per_sec has the same value with BSIZE
    if (BSIZE != fs->superBlock.bpb.byts_per_sec)
    80204b00:	05495703          	lhu	a4,84(s2)
    80204b04:	20000793          	li	a5,512
    80204b08:	18f71c63          	bne	a4,a5,80204ca0 <fatInit+0x2a4>
        panic("byts_per_sec != BSIZE");
    memset(&fs->root, 0, sizeof(fs->root));
    80204b0c:	07090793          	addi	a5,s2,112
    80204b10:	f6f43c23          	sd	a5,-136(s0)
    80204b14:	25800613          	li	a2,600
    80204b18:	00000593          	li	a1,0
    80204b1c:	00078513          	mv	a0,a5
    80204b20:	0000a097          	auipc	ra,0xa
    80204b24:	24c080e7          	jalr	588(ra) # 8020ed6c <memset>
    fs->root.attribute = (ATTR_DIRECTORY | ATTR_SYSTEM);
    80204b28:	01400793          	li	a5,20
    80204b2c:	16f90823          	sb	a5,368(s2)
    memset(&fs->root.inode, -1, sizeof(Inode));
    80204b30:	10000613          	li	a2,256
    80204b34:	fff00593          	li	a1,-1
    80204b38:	18890513          	addi	a0,s2,392
    80204b3c:	0000a097          	auipc	ra,0xa
    80204b40:	230080e7          	jalr	560(ra) # 8020ed6c <memset>
    fs->root.inode.item[0] = fs->root.first_clus = fs->root.cur_clus = fs->superBlock.bpb.root_clus;
    80204b44:	06892783          	lw	a5,104(s2)
    80204b48:	16f92e23          	sw	a5,380(s2)
    80204b4c:	16f92a23          	sw	a5,372(s2)
    80204b50:	18f92423          	sw	a5,392(s2)
    fs->root.inodeMaxCluster = 1;
    80204b54:	00100793          	li	a5,1
    80204b58:	18f92023          	sw	a5,384(s2)
    fs->root.filename[0]='/';
    80204b5c:	02f00793          	li	a5,47
    80204b60:	06f90823          	sb	a5,112(s2)
    fs->root.fileSystem = fs;
    80204b64:	29293823          	sd	s2,656(s2)
    // fs->superBlock.bpb.fat_sz = MIN(512, fs->superBlock.bpb.fat_sz);
    int totalClusterNumber = fs->superBlock.bpb.fat_sz * fs->superBlock.bpb.byts_per_sec / sizeof(uint32);
    80204b68:	05495a83          	lhu	s5,84(s2)
    80204b6c:	06492783          	lw	a5,100(s2)
    80204b70:	02fa8abb          	mulw	s5,s5,a5
    80204b74:	002ada9b          	srliw	s5,s5,0x2
    80204b78:	010ae497          	auipc	s1,0x10ae
    80204b7c:	96048493          	addi	s1,s1,-1696 # 812b24d8 <fileSystem>
    80204b80:	409904b3          	sub	s1,s2,s1
    80204b84:	4034d493          	srai	s1,s1,0x3
    80204b88:	00012797          	auipc	a5,0x12
    80204b8c:	c587b783          	ld	a5,-936(a5) # 802167e0 <__func__.0+0x8>
    80204b90:	02f484b3          	mul	s1,s1,a5
    80204b94:	01649493          	slli	s1,s1,0x16
    80204b98:	03f00793          	li	a5,63
    80204b9c:	01e79793          	slli	a5,a5,0x1e
    80204ba0:	00f484b3          	add	s1,s1,a5
    u64 *clusterBitmap = (u64*)getFileSystemClusterBitmap(fs);
    80204ba4:	00048a13          	mv	s4,s1
    80204ba8:	00000993          	li	s3,0
    return page - pages;
    80204bac:	01902d97          	auipc	s11,0x1902
    80204bb0:	354d8d93          	addi	s11,s11,852 # 81b06f00 <pages>
    80204bb4:	00012d17          	auipc	s10,0x12
    80204bb8:	c44d0d13          	addi	s10,s10,-956 # 802167f8 <__func__.0+0x20>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80204bbc:	00100b13          	li	s6,1
    80204bc0:	01fb1b13          	slli	s6,s6,0x1f
    do {
        PhysicalPage *pp;
        if (pageAlloc(&pp) < 0) {
            panic("");
        }
        if (pageInsert(kernelPageDirectory, ((u64)clusterBitmap) + cnt, page2pa(pp), PTE_READ | PTE_WRITE) < 0) {
    80204bc4:	0216ac97          	auipc	s9,0x216a
    80204bc8:	43cc8c93          	addi	s9,s9,1084 # 8236f000 <_pgdir>
            panic("");
        }
        cnt += PAGE_SIZE;
    } while (cnt * 8 < totalClusterNumber);
    80204bcc:	00008c37          	lui	s8,0x8
    80204bd0:	00001bb7          	lui	s7,0x1
        if (pageAlloc(&pp) < 0) {
    80204bd4:	f8840513          	addi	a0,s0,-120
    80204bd8:	00004097          	auipc	ra,0x4
    80204bdc:	2e4080e7          	jalr	740(ra) # 80208ebc <pageAlloc>
    80204be0:	0e054263          	bltz	a0,80204cc4 <fatInit+0x2c8>
    return page - pages;
    80204be4:	f8843603          	ld	a2,-120(s0)
    80204be8:	41b60633          	sub	a2,a2,s11
    80204bec:	40365613          	srai	a2,a2,0x3
    80204bf0:	000d3783          	ld	a5,0(s10)
    80204bf4:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80204bf8:	00c6161b          	slliw	a2,a2,0xc
    80204bfc:	02061613          	slli	a2,a2,0x20
    80204c00:	02065613          	srli	a2,a2,0x20
        if (pageInsert(kernelPageDirectory, ((u64)clusterBitmap) + cnt, page2pa(pp), PTE_READ | PTE_WRITE) < 0) {
    80204c04:	00600693          	li	a3,6
    80204c08:	01660633          	add	a2,a2,s6
    80204c0c:	00048593          	mv	a1,s1
    80204c10:	000c8513          	mv	a0,s9
    80204c14:	00004097          	auipc	ra,0x4
    80204c18:	65c080e7          	jalr	1628(ra) # 80209270 <pageInsert>
    80204c1c:	0c054663          	bltz	a0,80204ce8 <fatInit+0x2ec>
    } while (cnt * 8 < totalClusterNumber);
    80204c20:	013c07bb          	addw	a5,s8,s3
    80204c24:	0007899b          	sext.w	s3,a5
    80204c28:	017484b3          	add	s1,s1,s7
    80204c2c:	fb59c4e3          	blt	s3,s5,80204bd4 <fatInit+0x1d8>
    uint32 sec = fs->superBlock.bpb.rsvd_sec_cnt;
    80204c30:	05895b03          	lhu	s6,88(s2)
    uint32 const ent_per_sec = fs->superBlock.bpb.byts_per_sec / sizeof(uint32);
    80204c34:	05495a83          	lhu	s5,84(s2)
    80204c38:	002ada93          	srli	s5,s5,0x2
    for (uint32 i = 0; i < fs->superBlock.bpb.fat_sz; i++, sec++) {
    80204c3c:	06492783          	lw	a5,100(s2)
    80204c40:	14078263          	beqz	a5,80204d84 <fatInit+0x388>
    80204c44:	000a8493          	mv	s1,s5
    80204c48:	00000c13          	li	s8,0
    80204c4c:	00000b93          	li	s7,0
        b = fs->read(fs, sec);
        for (uint32 j = 0; j < ent_per_sec; j++) {
            if (((uint32*)(b->data))[j]) {
                int no = i * ent_per_sec + j;
                clusterBitmap[no >> 6] |= (1UL << (no & 63));
    80204c50:	00100993          	li	s3,1
    80204c54:	10c0006f          	j	80204d60 <fatInit+0x364>
        panic("");
    80204c58:	00011697          	auipc	a3,0x11
    80204c5c:	f9068693          	addi	a3,a3,-112 # 80215be8 <__func__.0+0x48>
    80204c60:	00012617          	auipc	a2,0x12
    80204c64:	b2860613          	addi	a2,a2,-1240 # 80216788 <__func__.0>
    80204c68:	09b00593          	li	a1,155
    80204c6c:	00011517          	auipc	a0,0x11
    80204c70:	95c50513          	addi	a0,a0,-1700 # 802155c8 <__func__.1+0x20>
    80204c74:	ffffc097          	auipc	ra,0xffffc
    80204c78:	274080e7          	jalr	628(ra) # 80200ee8 <_panic_>
        panic("not FAT32 volume");
    80204c7c:	00011697          	auipc	a3,0x11
    80204c80:	99c68693          	addi	a3,a3,-1636 # 80215618 <__func__.1+0x70>
    80204c84:	00012617          	auipc	a2,0x12
    80204c88:	b0460613          	addi	a2,a2,-1276 # 80216788 <__func__.0>
    80204c8c:	09e00593          	li	a1,158
    80204c90:	00011517          	auipc	a0,0x11
    80204c94:	93850513          	addi	a0,a0,-1736 # 802155c8 <__func__.1+0x20>
    80204c98:	ffffc097          	auipc	ra,0xffffc
    80204c9c:	250080e7          	jalr	592(ra) # 80200ee8 <_panic_>
        panic("byts_per_sec != BSIZE");
    80204ca0:	00011697          	auipc	a3,0x11
    80204ca4:	99068693          	addi	a3,a3,-1648 # 80215630 <__func__.1+0x88>
    80204ca8:	00012617          	auipc	a2,0x12
    80204cac:	ae060613          	addi	a2,a2,-1312 # 80216788 <__func__.0>
    80204cb0:	0bb00593          	li	a1,187
    80204cb4:	00011517          	auipc	a0,0x11
    80204cb8:	91450513          	addi	a0,a0,-1772 # 802155c8 <__func__.1+0x20>
    80204cbc:	ffffc097          	auipc	ra,0xffffc
    80204cc0:	22c080e7          	jalr	556(ra) # 80200ee8 <_panic_>
            panic("");
    80204cc4:	00011697          	auipc	a3,0x11
    80204cc8:	f2468693          	addi	a3,a3,-220 # 80215be8 <__func__.0+0x48>
    80204ccc:	00012617          	auipc	a2,0x12
    80204cd0:	abc60613          	addi	a2,a2,-1348 # 80216788 <__func__.0>
    80204cd4:	0cb00593          	li	a1,203
    80204cd8:	00011517          	auipc	a0,0x11
    80204cdc:	8f050513          	addi	a0,a0,-1808 # 802155c8 <__func__.1+0x20>
    80204ce0:	ffffc097          	auipc	ra,0xffffc
    80204ce4:	208080e7          	jalr	520(ra) # 80200ee8 <_panic_>
            panic("");
    80204ce8:	00011697          	auipc	a3,0x11
    80204cec:	f0068693          	addi	a3,a3,-256 # 80215be8 <__func__.0+0x48>
    80204cf0:	00012617          	auipc	a2,0x12
    80204cf4:	a9860613          	addi	a2,a2,-1384 # 80216788 <__func__.0>
    80204cf8:	0ce00593          	li	a1,206
    80204cfc:	00011517          	auipc	a0,0x11
    80204d00:	8cc50513          	addi	a0,a0,-1844 # 802155c8 <__func__.1+0x20>
    80204d04:	ffffc097          	auipc	ra,0xffffc
    80204d08:	1e4080e7          	jalr	484(ra) # 80200ee8 <_panic_>
        for (uint32 j = 0; j < ent_per_sec; j++) {
    80204d0c:	00468693          	addi	a3,a3,4
    80204d10:	0017879b          	addiw	a5,a5,1
    80204d14:	02978663          	beq	a5,s1,80204d40 <fatInit+0x344>
            if (((uint32*)(b->data))[j]) {
    80204d18:	0006a703          	lw	a4,0(a3)
    80204d1c:	fe0708e3          	beqz	a4,80204d0c <fatInit+0x310>
                clusterBitmap[no >> 6] |= (1UL << (no & 63));
    80204d20:	4067d71b          	sraiw	a4,a5,0x6
    80204d24:	00371713          	slli	a4,a4,0x3
    80204d28:	00ea0733          	add	a4,s4,a4
    80204d2c:	00f995b3          	sll	a1,s3,a5
    80204d30:	00073603          	ld	a2,0(a4)
    80204d34:	00b66633          	or	a2,a2,a1
    80204d38:	00c73023          	sd	a2,0(a4)
    80204d3c:	fd1ff06f          	j	80204d0c <fatInit+0x310>
            }
        }
        brelse(b);
    80204d40:	ffffd097          	auipc	ra,0xffffd
    80204d44:	1fc080e7          	jalr	508(ra) # 80201f3c <brelse>
    for (uint32 i = 0; i < fs->superBlock.bpb.fat_sz; i++, sec++) {
    80204d48:	001b8b9b          	addiw	s7,s7,1
    80204d4c:	001b0b1b          	addiw	s6,s6,1
    80204d50:	009a84bb          	addw	s1,s5,s1
    80204d54:	018a8c3b          	addw	s8,s5,s8
    80204d58:	06492783          	lw	a5,100(s2)
    80204d5c:	02fbf463          	bgeu	s7,a5,80204d84 <fatInit+0x388>
        b = fs->read(fs, sec);
    80204d60:	2e093783          	ld	a5,736(s2)
    80204d64:	020b1593          	slli	a1,s6,0x20
    80204d68:	0205d593          	srli	a1,a1,0x20
    80204d6c:	00090513          	mv	a0,s2
    80204d70:	000780e7          	jalr	a5
        for (uint32 j = 0; j < ent_per_sec; j++) {
    80204d74:	fc0a86e3          	beqz	s5,80204d40 <fatInit+0x344>
    80204d78:	05850693          	addi	a3,a0,88
    80204d7c:	000c0793          	mv	a5,s8
    80204d80:	f99ff06f          	j	80204d18 <fatInit+0x31c>
    }
    loadDirents(fs, &fs->root);
    80204d84:	f7843583          	ld	a1,-136(s0)
    80204d88:	00090513          	mv	a0,s2
    80204d8c:	00000097          	auipc	ra,0x0
    80204d90:	9a4080e7          	jalr	-1628(ra) # 80204730 <loadDirents>
    
    printf("[FAT32 init]fat init end\n");
    80204d94:	00011517          	auipc	a0,0x11
    80204d98:	8b450513          	addi	a0,a0,-1868 # 80215648 <__func__.1+0xa0>
    80204d9c:	ffffc097          	auipc	ra,0xffffc
    80204da0:	0b4080e7          	jalr	180(ra) # 80200e50 <printf>
    return 0;
}
    80204da4:	00000513          	li	a0,0
    80204da8:	08813083          	ld	ra,136(sp)
    80204dac:	08013403          	ld	s0,128(sp)
    80204db0:	07813483          	ld	s1,120(sp)
    80204db4:	07013903          	ld	s2,112(sp)
    80204db8:	06813983          	ld	s3,104(sp)
    80204dbc:	06013a03          	ld	s4,96(sp)
    80204dc0:	05813a83          	ld	s5,88(sp)
    80204dc4:	05013b03          	ld	s6,80(sp)
    80204dc8:	04813b83          	ld	s7,72(sp)
    80204dcc:	04013c03          	ld	s8,64(sp)
    80204dd0:	03813c83          	ld	s9,56(sp)
    80204dd4:	03013d03          	ld	s10,48(sp)
    80204dd8:	02813d83          	ld	s11,40(sp)
    80204ddc:	09010113          	addi	sp,sp,144
    80204de0:	00008067          	ret

0000000080204de4 <initRootFileSystem>:

void initRootFileSystem() {
    80204de4:	ff010113          	addi	sp,sp,-16
    80204de8:	00113423          	sd	ra,8(sp)
    80204dec:	00813023          	sd	s0,0(sp)
    80204df0:	01010413          	addi	s0,sp,16
    struct File* file = filealloc();
    80204df4:	fffff097          	auipc	ra,0xfffff
    80204df8:	0b8080e7          	jalr	184(ra) # 80203eac <filealloc>
    rootFileSystem->image = file;
    80204dfc:	010b3797          	auipc	a5,0x10b3
    80204e00:	3dc7b783          	ld	a5,988(a5) # 812b81d8 <rootFileSystem>
    80204e04:	2ca7b423          	sd	a0,712(a5)
    file->type = FD_DEVICE;
    80204e08:	00300793          	li	a5,3
    80204e0c:	00f52023          	sw	a5,0(a0)
    file->major = 0;
    80204e10:	02051623          	sh	zero,44(a0)
    file->readable = true;
    80204e14:	00100793          	li	a5,1
    80204e18:	00f50423          	sb	a5,8(a0)
    file->writable = true;
    80204e1c:	00f504a3          	sb	a5,9(a0)
}
    80204e20:	00813083          	ld	ra,8(sp)
    80204e24:	00013403          	ld	s0,0(sp)
    80204e28:	01010113          	addi	sp,sp,16
    80204e2c:	00008067          	ret

0000000080204e30 <getFsStatus>:

int getFsStatus(char *path, FileSystemStatus *fss) {
    80204e30:	fe010113          	addi	sp,sp,-32
    80204e34:	00113c23          	sd	ra,24(sp)
    80204e38:	00813823          	sd	s0,16(sp)
    80204e3c:	00913423          	sd	s1,8(sp)
    80204e40:	02010413          	addi	s0,sp,32
    80204e44:	00058493          	mv	s1,a1
    Dirent *de;
    if ((de = ename(AT_FDCWD, path, true)) == NULL) {
    80204e48:	00100613          	li	a2,1
    80204e4c:	00050593          	mv	a1,a0
    80204e50:	f9c00513          	li	a0,-100
    80204e54:	fffff097          	auipc	ra,0xfffff
    80204e58:	be8080e7          	jalr	-1048(ra) # 80203a3c <ename>
    80204e5c:	06050463          	beqz	a0,80204ec4 <getFsStatus+0x94>
        return -1;
    }
    FileSystem *fs = de->fileSystem;
    80204e60:	22053703          	ld	a4,544(a0)
    fss->f_bsize = 189;
    80204e64:	0bd00793          	li	a5,189
    80204e68:	00f4b423          	sd	a5,8(s1)
    fss->f_blocks = fs->superBlock.bpb.tot_sec - fs->superBlock.first_data_sec;
    80204e6c:	06072783          	lw	a5,96(a4)
    80204e70:	04472703          	lw	a4,68(a4)
    80204e74:	40e787bb          	subw	a5,a5,a4
    80204e78:	02079793          	slli	a5,a5,0x20
    80204e7c:	0207d793          	srli	a5,a5,0x20
    80204e80:	00f4b823          	sd	a5,16(s1)
    fss->f_bfree = 1;
    80204e84:	00100793          	li	a5,1
    80204e88:	00f4bc23          	sd	a5,24(s1)
    fss->f_bavail = 2;
    80204e8c:	00200793          	li	a5,2
    80204e90:	02f4b023          	sd	a5,32(s1)
    fss->f_files = 4;
    80204e94:	00400793          	li	a5,4
    80204e98:	02f4b423          	sd	a5,40(s1)
    fss->f_ffree = 3;
    80204e9c:	00300793          	li	a5,3
    80204ea0:	02f4b823          	sd	a5,48(s1)
    fss->f_namelen = FAT32_MAX_FILENAME;
    80204ea4:	0ff00793          	li	a5,255
    80204ea8:	04f4b023          	sd	a5,64(s1)
    return 0;
    80204eac:	00000513          	li	a0,0
}
    80204eb0:	01813083          	ld	ra,24(sp)
    80204eb4:	01013403          	ld	s0,16(sp)
    80204eb8:	00813483          	ld	s1,8(sp)
    80204ebc:	02010113          	addi	sp,sp,32
    80204ec0:	00008067          	ret
        return -1;
    80204ec4:	fff00513          	li	a0,-1
    80204ec8:	fe9ff06f          	j	80204eb0 <getFsStatus+0x80>

0000000080204ecc <inodeAlloc>:
#include <string.h>

Inode inodes[INODE_NUM];
u64 inodeBitmap[INODE_NUM / 64];

int inodeAlloc() {
    80204ecc:	ff010113          	addi	sp,sp,-16
    80204ed0:	00813423          	sd	s0,8(sp)
    80204ed4:	01010413          	addi	s0,sp,16
    for (int i = 0; i < sizeof(inodeBitmap); i++) {
    80204ed8:	010b3797          	auipc	a5,0x10b3
    80204edc:	30878793          	addi	a5,a5,776 # 812b81e0 <inodeBitmap>
    80204ee0:	00000713          	li	a4,0
        if (~inodeBitmap[i]) {
    80204ee4:	fff00613          	li	a2,-1
    80204ee8:	00878793          	addi	a5,a5,8
    80204eec:	ff87b683          	ld	a3,-8(a5)
    80204ef0:	00c69663          	bne	a3,a2,80204efc <inodeAlloc+0x30>
    for (int i = 0; i < sizeof(inodeBitmap); i++) {
    80204ef4:	0017071b          	addiw	a4,a4,1
    80204ef8:	ff1ff06f          	j	80204ee8 <inodeAlloc+0x1c>
            int bit = LOW_BIT64(~inodeBitmap[i]);
    80204efc:	fff6c793          	not	a5,a3
    if ((x & ((1UL << 32) - 1)) == 0) {
    80204f00:	02079613          	slli	a2,a5,0x20
    80204f04:	02065613          	srli	a2,a2,0x20
    int res = 0;
    80204f08:	00000513          	li	a0,0
    if ((x & ((1UL << 32) - 1)) == 0) {
    80204f0c:	00061663          	bnez	a2,80204f18 <inodeAlloc+0x4c>
        x >>= 32;
    80204f10:	0207d793          	srli	a5,a5,0x20
        res += 32;
    80204f14:	02000513          	li	a0,32
    if ((x & ((1UL << 16) - 1)) == 0) {
    80204f18:	03079613          	slli	a2,a5,0x30
    80204f1c:	03065613          	srli	a2,a2,0x30
    80204f20:	00061663          	bnez	a2,80204f2c <inodeAlloc+0x60>
        x >>= 16;
    80204f24:	0107d793          	srli	a5,a5,0x10
        res += 16;
    80204f28:	0105051b          	addiw	a0,a0,16
    if ((x & ((1UL << 8) - 1)) == 0) {
    80204f2c:	0ff7f613          	zext.b	a2,a5
    80204f30:	00061663          	bnez	a2,80204f3c <inodeAlloc+0x70>
        x >>= 8;
    80204f34:	0087d793          	srli	a5,a5,0x8
        res += 8;
    80204f38:	0085051b          	addiw	a0,a0,8
    if ((x & ((1UL << 4) - 1)) == 0) {
    80204f3c:	00f7f613          	andi	a2,a5,15
    80204f40:	00061663          	bnez	a2,80204f4c <inodeAlloc+0x80>
        x >>= 4;
    80204f44:	0047d793          	srli	a5,a5,0x4
        res += 4;
    80204f48:	0045051b          	addiw	a0,a0,4
    if ((x & ((1UL << 2) - 1)) == 0) {
    80204f4c:	0037f613          	andi	a2,a5,3
    80204f50:	00061663          	bnez	a2,80204f5c <inodeAlloc+0x90>
        x >>= 2;
    80204f54:	0027d793          	srli	a5,a5,0x2
        res += 2;
    80204f58:	0025051b          	addiw	a0,a0,2
    if ((x & ((1UL << 1) - 1)) == 0) {
    80204f5c:	0017f613          	andi	a2,a5,1
    80204f60:	00061663          	bnez	a2,80204f6c <inodeAlloc+0xa0>
        x >>= 1;
    80204f64:	0017d793          	srli	a5,a5,0x1
        res += 1;
    80204f68:	0015051b          	addiw	a0,a0,1
    return x ? res : -1;
    80204f6c:	02078e63          	beqz	a5,80204fa8 <inodeAlloc+0xdc>
            inodeBitmap[i] |= (1UL << bit);
    80204f70:	00371793          	slli	a5,a4,0x3
    80204f74:	010b3617          	auipc	a2,0x10b3
    80204f78:	26c60613          	addi	a2,a2,620 # 812b81e0 <inodeBitmap>
    80204f7c:	00f60633          	add	a2,a2,a5
    80204f80:	00100793          	li	a5,1
    80204f84:	00a797b3          	sll	a5,a5,a0
    80204f88:	00d7e7b3          	or	a5,a5,a3
    80204f8c:	00f63023          	sd	a5,0(a2)
            int ret = (i << 6) | bit;
    80204f90:	0067171b          	slliw	a4,a4,0x6
    80204f94:	00e56533          	or	a0,a0,a4
            return ret;
        }
    }
    return -1;
}
    80204f98:	0005051b          	sext.w	a0,a0
    80204f9c:	00813403          	ld	s0,8(sp)
    80204fa0:	01010113          	addi	sp,sp,16
    80204fa4:	00008067          	ret
    80204fa8:	fff00513          	li	a0,-1
    80204fac:	fc5ff06f          	j	80204f70 <inodeAlloc+0xa4>

0000000080204fb0 <inodeFree>:

void inodeFree(int x) {
    80204fb0:	fe010113          	addi	sp,sp,-32
    80204fb4:	00113c23          	sd	ra,24(sp)
    80204fb8:	00813823          	sd	s0,16(sp)
    80204fbc:	00913423          	sd	s1,8(sp)
    80204fc0:	01213023          	sd	s2,0(sp)
    80204fc4:	02010413          	addi	s0,sp,32
    assert(inodeBitmap[x >> 6] & (1UL << (x & 63)));
    80204fc8:	4065579b          	sraiw	a5,a0,0x6
    80204fcc:	00100493          	li	s1,1
    80204fd0:	00a494b3          	sll	s1,s1,a0
    80204fd4:	00379793          	slli	a5,a5,0x3
    80204fd8:	010b3917          	auipc	s2,0x10b3
    80204fdc:	20890913          	addi	s2,s2,520 # 812b81e0 <inodeBitmap>
    80204fe0:	00f90933          	add	s2,s2,a5
    80204fe4:	00093683          	ld	a3,0(s2)
    80204fe8:	00d4f6b3          	and	a3,s1,a3
    80204fec:	00010617          	auipc	a2,0x10
    80204ff0:	68460613          	addi	a2,a2,1668 # 80215670 <__func__.0>
    80204ff4:	01500593          	li	a1,21
    80204ff8:	00010517          	auipc	a0,0x10
    80204ffc:	67050513          	addi	a0,a0,1648 # 80215668 <__func__.1+0xc0>
    80205000:	ffffc097          	auipc	ra,0xffffc
    80205004:	f58080e7          	jalr	-168(ra) # 80200f58 <_assert_>
    inodeBitmap[x >> 6] &= ~(1UL << (x & 63));
    80205008:	fff4c493          	not	s1,s1
    8020500c:	00093783          	ld	a5,0(s2)
    80205010:	0097f7b3          	and	a5,a5,s1
    80205014:	00f93023          	sd	a5,0(s2)
}
    80205018:	01813083          	ld	ra,24(sp)
    8020501c:	01013403          	ld	s0,16(sp)
    80205020:	00813483          	ld	s1,8(sp)
    80205024:	00013903          	ld	s2,0(sp)
    80205028:	02010113          	addi	sp,sp,32
    8020502c:	00008067          	ret

0000000080205030 <pipeAlloc>:
struct pipe pipeBuffer[MAX_PIPE];
u64 pipeBitMap[MAX_PIPE / 64];

int pipeAlloc(struct pipe** p) {
    for (int i = 0; i < MAX_PIPE / 64; i++) {
        if (~pipeBitMap[i]) {
    80205030:	010f3797          	auipc	a5,0x10f3
    80205034:	2307b783          	ld	a5,560(a5) # 812f8260 <pipeBitMap>
    80205038:	fff00713          	li	a4,-1
    8020503c:	04e79463          	bne	a5,a4,80205084 <pipeAlloc+0x54>
    80205040:	010f3797          	auipc	a5,0x10f3
    80205044:	2287b783          	ld	a5,552(a5) # 812f8268 <pipeBitMap+0x8>
    for (int i = 0; i < MAX_PIPE / 64; i++) {
    80205048:	00100613          	li	a2,1
        if (~pipeBitMap[i]) {
    8020504c:	02e79e63          	bne	a5,a4,80205088 <pipeAlloc+0x58>
int pipeAlloc(struct pipe** p) {
    80205050:	ff010113          	addi	sp,sp,-16
    80205054:	00113423          	sd	ra,8(sp)
    80205058:	00813023          	sd	s0,0(sp)
    8020505c:	01010413          	addi	s0,sp,16
            *p = &pipeBuffer[(i << 6) | bit];
            (*p)->nread = (*p)->nwrite = 0;
            return 0;
        }
    }
    panic("no pipe!");
    80205060:	00010697          	auipc	a3,0x10
    80205064:	62068693          	addi	a3,a3,1568 # 80215680 <__func__.0+0x10>
    80205068:	00010617          	auipc	a2,0x10
    8020506c:	63860613          	addi	a2,a2,1592 # 802156a0 <__func__.1>
    80205070:	01900593          	li	a1,25
    80205074:	00010517          	auipc	a0,0x10
    80205078:	61c50513          	addi	a0,a0,1564 # 80215690 <__func__.0+0x20>
    8020507c:	ffffc097          	auipc	ra,0xffffc
    80205080:	e6c080e7          	jalr	-404(ra) # 80200ee8 <_panic_>
    for (int i = 0; i < MAX_PIPE / 64; i++) {
    80205084:	00000613          	li	a2,0
            int bit = LOW_BIT64(~pipeBitMap[i]);
    80205088:	fff7c693          	not	a3,a5
    if ((x & ((1UL << 32) - 1)) == 0) {
    8020508c:	02069593          	slli	a1,a3,0x20
    80205090:	0205d593          	srli	a1,a1,0x20
    int res = 0;
    80205094:	00000713          	li	a4,0
    if ((x & ((1UL << 32) - 1)) == 0) {
    80205098:	00059663          	bnez	a1,802050a4 <pipeAlloc+0x74>
        x >>= 32;
    8020509c:	0206d693          	srli	a3,a3,0x20
        res += 32;
    802050a0:	02000713          	li	a4,32
    if ((x & ((1UL << 16) - 1)) == 0) {
    802050a4:	03069593          	slli	a1,a3,0x30
    802050a8:	0305d593          	srli	a1,a1,0x30
    802050ac:	00059663          	bnez	a1,802050b8 <pipeAlloc+0x88>
        x >>= 16;
    802050b0:	0106d693          	srli	a3,a3,0x10
        res += 16;
    802050b4:	0107071b          	addiw	a4,a4,16
    if ((x & ((1UL << 8) - 1)) == 0) {
    802050b8:	0ff6f593          	zext.b	a1,a3
    802050bc:	00059663          	bnez	a1,802050c8 <pipeAlloc+0x98>
        x >>= 8;
    802050c0:	0086d693          	srli	a3,a3,0x8
        res += 8;
    802050c4:	0087071b          	addiw	a4,a4,8
    if ((x & ((1UL << 4) - 1)) == 0) {
    802050c8:	00f6f593          	andi	a1,a3,15
    802050cc:	00059663          	bnez	a1,802050d8 <pipeAlloc+0xa8>
        x >>= 4;
    802050d0:	0046d693          	srli	a3,a3,0x4
        res += 4;
    802050d4:	0047071b          	addiw	a4,a4,4
    if ((x & ((1UL << 2) - 1)) == 0) {
    802050d8:	0036f593          	andi	a1,a3,3
    802050dc:	00059663          	bnez	a1,802050e8 <pipeAlloc+0xb8>
        x >>= 2;
    802050e0:	0026d693          	srli	a3,a3,0x2
        res += 2;
    802050e4:	0027071b          	addiw	a4,a4,2
    if ((x & ((1UL << 1) - 1)) == 0) {
    802050e8:	0016f593          	andi	a1,a3,1
    802050ec:	00059663          	bnez	a1,802050f8 <pipeAlloc+0xc8>
        x >>= 1;
    802050f0:	0016d693          	srli	a3,a3,0x1
        res += 1;
    802050f4:	0017071b          	addiw	a4,a4,1
    return x ? res : -1;
    802050f8:	06068463          	beqz	a3,80205160 <pipeAlloc+0x130>
            pipeBitMap[i] |= (1UL << bit);
    802050fc:	00361693          	slli	a3,a2,0x3
    80205100:	010f3597          	auipc	a1,0x10f3
    80205104:	16058593          	addi	a1,a1,352 # 812f8260 <pipeBitMap>
    80205108:	00d585b3          	add	a1,a1,a3
    8020510c:	00100693          	li	a3,1
    80205110:	00e696b3          	sll	a3,a3,a4
    80205114:	00f6e7b3          	or	a5,a3,a5
    80205118:	00f5b023          	sd	a5,0(a1)
            *p = &pipeBuffer[(i << 6) | bit];
    8020511c:	0066161b          	slliw	a2,a2,0x6
    80205120:	00c767b3          	or	a5,a4,a2
    80205124:	0007879b          	sext.w	a5,a5
    80205128:	00010737          	lui	a4,0x10
    8020512c:	03070693          	addi	a3,a4,48 # 10030 <_start-0x801effd0>
    80205130:	02d787b3          	mul	a5,a5,a3
    80205134:	010f3697          	auipc	a3,0x10f3
    80205138:	13c68693          	addi	a3,a3,316 # 812f8270 <pipeBuffer>
    8020513c:	00d787b3          	add	a5,a5,a3
    80205140:	00f53023          	sd	a5,0(a0)
            (*p)->nread = (*p)->nwrite = 0;
    80205144:	00f707b3          	add	a5,a4,a5
    80205148:	0207b023          	sd	zero,32(a5)
    8020514c:	00053783          	ld	a5,0(a0)
    80205150:	00e787b3          	add	a5,a5,a4
    80205154:	0007bc23          	sd	zero,24(a5)
}
    80205158:	00000513          	li	a0,0
    8020515c:	00008067          	ret
    80205160:	fff00713          	li	a4,-1
    80205164:	f99ff06f          	j	802050fc <pipeAlloc+0xcc>

0000000080205168 <pipeFree>:

void pipeFree(struct pipe* p) {
    80205168:	ff010113          	addi	sp,sp,-16
    8020516c:	00813423          	sd	s0,8(sp)
    80205170:	01010413          	addi	s0,sp,16
    int off = p - pipeBuffer;
    80205174:	010f3797          	auipc	a5,0x10f3
    80205178:	0fc78793          	addi	a5,a5,252 # 812f8270 <pipeBuffer>
    8020517c:	40f50533          	sub	a0,a0,a5
    80205180:	40455513          	srai	a0,a0,0x4
    80205184:	00011797          	auipc	a5,0x11
    80205188:	67c7b783          	ld	a5,1660(a5) # 80216800 <__func__.0+0x28>
    8020518c:	02f5053b          	mulw	a0,a0,a5
    pipeBitMap[off >> 6] &= ~(1UL << (off & 63));
    80205190:	4065579b          	sraiw	a5,a0,0x6
    80205194:	00379793          	slli	a5,a5,0x3
    80205198:	010f3717          	auipc	a4,0x10f3
    8020519c:	0c870713          	addi	a4,a4,200 # 812f8260 <pipeBitMap>
    802051a0:	00f70733          	add	a4,a4,a5
    802051a4:	00100793          	li	a5,1
    802051a8:	00a797b3          	sll	a5,a5,a0
    802051ac:	fff7c793          	not	a5,a5
    802051b0:	00073683          	ld	a3,0(a4)
    802051b4:	00d7f7b3          	and	a5,a5,a3
    802051b8:	00f73023          	sd	a5,0(a4)
}
    802051bc:	00813403          	ld	s0,8(sp)
    802051c0:	01010113          	addi	sp,sp,16
    802051c4:	00008067          	ret

00000000802051c8 <pipeNew>:

int pipeNew(struct File** f0, struct File** f1) {
    802051c8:	fc010113          	addi	sp,sp,-64
    802051cc:	02113c23          	sd	ra,56(sp)
    802051d0:	02813823          	sd	s0,48(sp)
    802051d4:	02913423          	sd	s1,40(sp)
    802051d8:	03213023          	sd	s2,32(sp)
    802051dc:	01313c23          	sd	s3,24(sp)
    802051e0:	01413823          	sd	s4,16(sp)
    802051e4:	04010413          	addi	s0,sp,64
    802051e8:	00050493          	mv	s1,a0
    802051ec:	00058993          	mv	s3,a1
    struct pipe* pi;

    pi = 0;
    802051f0:	fc043423          	sd	zero,-56(s0)
    *f0 = *f1 = 0;
    802051f4:	0005b023          	sd	zero,0(a1)
    802051f8:	00053023          	sd	zero,0(a0)
    if ((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
    802051fc:	fffff097          	auipc	ra,0xfffff
    80205200:	cb0080e7          	jalr	-848(ra) # 80203eac <filealloc>
    80205204:	00a4b023          	sd	a0,0(s1)
    80205208:	0c050063          	beqz	a0,802052c8 <pipeNew+0x100>
    8020520c:	fffff097          	auipc	ra,0xfffff
    80205210:	ca0080e7          	jalr	-864(ra) # 80203eac <filealloc>
    80205214:	00a9b023          	sd	a0,0(s3)
    80205218:	0a050063          	beqz	a0,802052b8 <pipeNew+0xf0>
        goto bad;
    pipeAlloc(&pi);
    8020521c:	fc840513          	addi	a0,s0,-56
    80205220:	00000097          	auipc	ra,0x0
    80205224:	e10080e7          	jalr	-496(ra) # 80205030 <pipeAlloc>
    pi->readopen = 1;
    80205228:	fc843a03          	ld	s4,-56(s0)
    8020522c:	000107b7          	lui	a5,0x10
    80205230:	00fa07b3          	add	a5,s4,a5
    80205234:	00100913          	li	s2,1
    80205238:	0327a423          	sw	s2,40(a5) # 10028 <_start-0x801effd8>
    pi->writeopen = 1;
    8020523c:	0327a623          	sw	s2,44(a5)
    initLock(&pi->lock, "pipe");
    80205240:	00010597          	auipc	a1,0x10
    80205244:	45858593          	addi	a1,a1,1112 # 80215698 <__func__.0+0x28>
    80205248:	000a0513          	mv	a0,s4
    8020524c:	00003097          	auipc	ra,0x3
    80205250:	59c080e7          	jalr	1436(ra) # 802087e8 <initLock>
    (*f0)->type = FD_PIPE;
    80205254:	0004b783          	ld	a5,0(s1)
    80205258:	0127a023          	sw	s2,0(a5)
    (*f0)->readable = 1;
    8020525c:	0004b783          	ld	a5,0(s1)
    80205260:	01278423          	sb	s2,8(a5)
    (*f0)->writable = 0;
    80205264:	0004b783          	ld	a5,0(s1)
    80205268:	000784a3          	sb	zero,9(a5)
    (*f0)->pipe = pi;
    8020526c:	0004b783          	ld	a5,0(s1)
    80205270:	0147b823          	sd	s4,16(a5)
    (*f1)->type = FD_PIPE;
    80205274:	0009b783          	ld	a5,0(s3)
    80205278:	0127a023          	sw	s2,0(a5)
    (*f1)->readable = 0;
    8020527c:	0009b783          	ld	a5,0(s3)
    80205280:	00078423          	sb	zero,8(a5)
    (*f1)->writable = 1;
    80205284:	0009b783          	ld	a5,0(s3)
    80205288:	012784a3          	sb	s2,9(a5)
    (*f1)->pipe = pi;
    8020528c:	0009b783          	ld	a5,0(s3)
    80205290:	0147b823          	sd	s4,16(a5)
    return 0;
    80205294:	00000513          	li	a0,0
    if (*f0)
        fileclose(*f0);
    if (*f1)
        fileclose(*f1);
    return -1;
}
    80205298:	03813083          	ld	ra,56(sp)
    8020529c:	03013403          	ld	s0,48(sp)
    802052a0:	02813483          	ld	s1,40(sp)
    802052a4:	02013903          	ld	s2,32(sp)
    802052a8:	01813983          	ld	s3,24(sp)
    802052ac:	01013a03          	ld	s4,16(sp)
    802052b0:	04010113          	addi	sp,sp,64
    802052b4:	00008067          	ret
    if (*f0)
    802052b8:	0004b503          	ld	a0,0(s1)
    802052bc:	02050663          	beqz	a0,802052e8 <pipeNew+0x120>
        fileclose(*f0);
    802052c0:	fffff097          	auipc	ra,0xfffff
    802052c4:	c7c080e7          	jalr	-900(ra) # 80203f3c <fileclose>
    if (*f1)
    802052c8:	0009b783          	ld	a5,0(s3)
    return -1;
    802052cc:	fff00513          	li	a0,-1
    if (*f1)
    802052d0:	fc0784e3          	beqz	a5,80205298 <pipeNew+0xd0>
        fileclose(*f1);
    802052d4:	00078513          	mv	a0,a5
    802052d8:	fffff097          	auipc	ra,0xfffff
    802052dc:	c64080e7          	jalr	-924(ra) # 80203f3c <fileclose>
    return -1;
    802052e0:	fff00513          	li	a0,-1
    802052e4:	fb5ff06f          	j	80205298 <pipeNew+0xd0>
    802052e8:	fff00513          	li	a0,-1
    802052ec:	fadff06f          	j	80205298 <pipeNew+0xd0>

00000000802052f0 <pipeClose>:

void pipeClose(struct pipe* pi, int writable) {
    802052f0:	fe010113          	addi	sp,sp,-32
    802052f4:	00113c23          	sd	ra,24(sp)
    802052f8:	00813823          	sd	s0,16(sp)
    802052fc:	00913423          	sd	s1,8(sp)
    80205300:	02010413          	addi	s0,sp,32
    80205304:	00050493          	mv	s1,a0
    // acquireLock(&pi->lock);
    // printf("%x %x %x\n", pi->writeopen, pi->readopen, writable);
    if (writable) {
    80205308:	04058263          	beqz	a1,8020534c <pipeClose+0x5c>
        pi->writeopen = 0;
    8020530c:	00010537          	lui	a0,0x10
    80205310:	00a487b3          	add	a5,s1,a0
    80205314:	0207a623          	sw	zero,44(a5)
        wakeup(&pi->nread);
    80205318:	01850513          	addi	a0,a0,24 # 10018 <_start-0x801effe8>
    8020531c:	00a48533          	add	a0,s1,a0
    80205320:	0000d097          	auipc	ra,0xd
    80205324:	984080e7          	jalr	-1660(ra) # 80211ca4 <wakeup>
    } else {
        pi->readopen = 0;
        wakeup(&pi->nwrite);
    }
    if (pi->readopen == 0 && pi->writeopen == 0) {
    80205328:	000107b7          	lui	a5,0x10
    8020532c:	00f487b3          	add	a5,s1,a5
    80205330:	0287b783          	ld	a5,40(a5) # 10028 <_start-0x801effd8>
    80205334:	02078c63          	beqz	a5,8020536c <pipeClose+0x7c>
        // releaseLock(&pi->lock);
        pipeFree(pi);
    }
    // } else
        // releaseLock(&pi->lock);
}
    80205338:	01813083          	ld	ra,24(sp)
    8020533c:	01013403          	ld	s0,16(sp)
    80205340:	00813483          	ld	s1,8(sp)
    80205344:	02010113          	addi	sp,sp,32
    80205348:	00008067          	ret
        pi->readopen = 0;
    8020534c:	00010537          	lui	a0,0x10
    80205350:	00a487b3          	add	a5,s1,a0
    80205354:	0207a423          	sw	zero,40(a5)
        wakeup(&pi->nwrite);
    80205358:	02050513          	addi	a0,a0,32 # 10020 <_start-0x801effe0>
    8020535c:	00a48533          	add	a0,s1,a0
    80205360:	0000d097          	auipc	ra,0xd
    80205364:	944080e7          	jalr	-1724(ra) # 80211ca4 <wakeup>
    80205368:	fc1ff06f          	j	80205328 <pipeClose+0x38>
        pipeFree(pi);
    8020536c:	00048513          	mv	a0,s1
    80205370:	00000097          	auipc	ra,0x0
    80205374:	df8080e7          	jalr	-520(ra) # 80205168 <pipeFree>
}
    80205378:	fc1ff06f          	j	80205338 <pipeClose+0x48>

000000008020537c <pipeWrite>:

void pipeOut(bool isUser, u64 dstva, char* src);
void pipeIn(bool isUser, char* dst, u64 srcva);

int pipeWrite(struct pipe* pi, bool isUser, u64 addr, int n) {
    8020537c:	f7010113          	addi	sp,sp,-144
    80205380:	08113423          	sd	ra,136(sp)
    80205384:	08813023          	sd	s0,128(sp)
    80205388:	06913c23          	sd	s1,120(sp)
    8020538c:	07213823          	sd	s2,112(sp)
    80205390:	07313423          	sd	s3,104(sp)
    80205394:	07413023          	sd	s4,96(sp)
    80205398:	05513c23          	sd	s5,88(sp)
    8020539c:	05613823          	sd	s6,80(sp)
    802053a0:	05713423          	sd	s7,72(sp)
    802053a4:	05813023          	sd	s8,64(sp)
    802053a8:	03913c23          	sd	s9,56(sp)
    802053ac:	03a13823          	sd	s10,48(sp)
    802053b0:	03b13423          	sd	s11,40(sp)
    802053b4:	09010413          	addi	s0,sp,144
    802053b8:	00050a13          	mv	s4,a0
    802053bc:	00058b93          	mv	s7,a1
    802053c0:	00060c93          	mv	s9,a2
    802053c4:	00068a93          	mv	s5,a3
    int i = 0, cow;
    
    u64* pageTable = myProcess()->pgdir;
    802053c8:	0000a097          	auipc	ra,0xa
    802053cc:	620080e7          	jalr	1568(ra) # 8020f9e8 <myProcess>
    802053d0:	04053d83          	ld	s11,64(a0)
    u64 pa = addr;
    802053d4:	000c8993          	mv	s3,s9
    if (isUser) {
    802053d8:	020b9c63          	bnez	s7,80205410 <pipeWrite+0x94>
            // pa = vir2phy(pageTable, addr, NULL);
        }
    }

    // acquireLock(&pi->lock);
    while (i < n) {
    802053dc:	17505c63          	blez	s5,80205554 <pipeWrite+0x1d8>
    802053e0:	00000913          	li	s2,0
        if (pi->readopen == 0 /*|| pr->killed*/) {
    802053e4:	00010b37          	lui	s6,0x10
    802053e8:	016a04b3          	add	s1,s4,s6
            // }
            // pipeIn(isUser, &ch, addr + i);
            ch = *((char*)pa);
            pi->data[(pi->nwrite++) & (PIPESIZE - 1)] = ch;
            i++;
            if (isUser && (!((addr + i) & (PAGE_SIZE - 1)))) {
    802053ec:	00001d37          	lui	s10,0x1
    802053f0:	fffd0d13          	addi	s10,s10,-1 # fff <_start-0x801ff001>
            wakeup(&pi->nread);
    802053f4:	018b0793          	addi	a5,s6,24 # 10018 <_start-0x801effe8>
    802053f8:	00fa07b3          	add	a5,s4,a5
    802053fc:	f6f43c23          	sd	a5,-136(s0)
            sleep(&pi->nwrite, &pi->lock);
    80205400:	020b0793          	addi	a5,s6,32
    80205404:	00fa07b3          	add	a5,s4,a5
    80205408:	f6f43823          	sd	a5,-144(s0)
    8020540c:	0c40006f          	j	802054d0 <pipeWrite+0x154>
        pa = vir2phy(pageTable, addr, &cow);
    80205410:	f8c40613          	addi	a2,s0,-116
    80205414:	000c8593          	mv	a1,s9
    80205418:	000d8513          	mv	a0,s11
    8020541c:	00004097          	auipc	ra,0x4
    80205420:	558080e7          	jalr	1368(ra) # 80209974 <vir2phy>
    80205424:	00050993          	mv	s3,a0
        if (pa == NULL) {
    80205428:	02050263          	beqz	a0,8020544c <pipeWrite+0xd0>
        if (cow) {
    8020542c:	f8c42783          	lw	a5,-116(s0)
    80205430:	fa0786e3          	beqz	a5,802053dc <pipeWrite+0x60>
            pa = cowHandler(pageTable, addr);
    80205434:	000c8593          	mv	a1,s9
    80205438:	000d8513          	mv	a0,s11
    8020543c:	00004097          	auipc	ra,0x4
    80205440:	3e8080e7          	jalr	1000(ra) # 80209824 <cowHandler>
    80205444:	00050993          	mv	s3,a0
    80205448:	f95ff06f          	j	802053dc <pipeWrite+0x60>
            cow = 0;
    8020544c:	f8042623          	sw	zero,-116(s0)
            pa = pageout(pageTable, addr);
    80205450:	000c8593          	mv	a1,s9
    80205454:	000d8513          	mv	a0,s11
    80205458:	00004097          	auipc	ra,0x4
    8020545c:	0bc080e7          	jalr	188(ra) # 80209514 <pageout>
    80205460:	00050993          	mv	s3,a0
    80205464:	fc9ff06f          	j	8020542c <pipeWrite+0xb0>
            panic("");
    80205468:	00010697          	auipc	a3,0x10
    8020546c:	78068693          	addi	a3,a3,1920 # 80215be8 <__func__.0+0x48>
    80205470:	00010617          	auipc	a2,0x10
    80205474:	24060613          	addi	a2,a2,576 # 802156b0 <__func__.0>
    80205478:	06800593          	li	a1,104
    8020547c:	00010517          	auipc	a0,0x10
    80205480:	21450513          	addi	a0,a0,532 # 80215690 <__func__.0+0x20>
    80205484:	ffffc097          	auipc	ra,0xffffc
    80205488:	a64080e7          	jalr	-1436(ra) # 80200ee8 <_panic_>
            wakeup(&pi->nread);
    8020548c:	f7843503          	ld	a0,-136(s0)
    80205490:	0000d097          	auipc	ra,0xd
    80205494:	814080e7          	jalr	-2028(ra) # 80211ca4 <wakeup>
            sleep(&pi->nwrite, &pi->lock);
    80205498:	000a0593          	mv	a1,s4
    8020549c:	f7043503          	ld	a0,-144(s0)
    802054a0:	0000c097          	auipc	ra,0xc
    802054a4:	748080e7          	jalr	1864(ra) # 80211be8 <sleep>
    802054a8:	0240006f          	j	802054cc <pipeWrite+0x150>
                pa = vir2phy(pageTable, addr + i, &cow);
                if (pa == NULL) {
                    cow = 0;
    802054ac:	f8042623          	sw	zero,-116(s0)
                    pa = pageout(pageTable, addr + i);
    802054b0:	000c0593          	mv	a1,s8
    802054b4:	000d8513          	mv	a0,s11
    802054b8:	00004097          	auipc	ra,0x4
    802054bc:	05c080e7          	jalr	92(ra) # 80209514 <pageout>
    802054c0:	00050993          	mv	s3,a0
    802054c4:	0700006f          	j	80205534 <pipeWrite+0x1b8>
                if (cow) {
                    pa = cowHandler(pageTable, addr);
                    // pa = vir2phy(pageTable, addr, NULL);
                }
            } else {
                pa++;
    802054c8:	00198993          	addi	s3,s3,1
    while (i < n) {
    802054cc:	09595663          	bge	s2,s5,80205558 <pipeWrite+0x1dc>
        if (pi->readopen == 0 /*|| pr->killed*/) {
    802054d0:	0284a783          	lw	a5,40(s1)
    802054d4:	f8078ae3          	beqz	a5,80205468 <pipeWrite+0xec>
        if (pi->nwrite == pi->nread + PIPESIZE) {  // DOC: pipewrite-full
    802054d8:	0204b783          	ld	a5,32(s1)
    802054dc:	0184b703          	ld	a4,24(s1)
    802054e0:	00eb0733          	add	a4,s6,a4
    802054e4:	fae784e3          	beq	a5,a4,8020548c <pipeWrite+0x110>
            ch = *((char*)pa);
    802054e8:	0009c703          	lbu	a4,0(s3)
            pi->data[(pi->nwrite++) & (PIPESIZE - 1)] = ch;
    802054ec:	00178693          	addi	a3,a5,1
    802054f0:	02d4b023          	sd	a3,32(s1)
    802054f4:	03079793          	slli	a5,a5,0x30
    802054f8:	0307d793          	srli	a5,a5,0x30
    802054fc:	00fa07b3          	add	a5,s4,a5
    80205500:	00e78c23          	sb	a4,24(a5)
            i++;
    80205504:	0019091b          	addiw	s2,s2,1
            if (isUser && (!((addr + i) & (PAGE_SIZE - 1)))) {
    80205508:	fc0b80e3          	beqz	s7,802054c8 <pipeWrite+0x14c>
    8020550c:	01990c33          	add	s8,s2,s9
    80205510:	01ac77b3          	and	a5,s8,s10
    80205514:	fa079ae3          	bnez	a5,802054c8 <pipeWrite+0x14c>
                pa = vir2phy(pageTable, addr + i, &cow);
    80205518:	f8c40613          	addi	a2,s0,-116
    8020551c:	000c0593          	mv	a1,s8
    80205520:	000d8513          	mv	a0,s11
    80205524:	00004097          	auipc	ra,0x4
    80205528:	450080e7          	jalr	1104(ra) # 80209974 <vir2phy>
    8020552c:	00050993          	mv	s3,a0
                if (pa == NULL) {
    80205530:	f6050ee3          	beqz	a0,802054ac <pipeWrite+0x130>
                if (cow) {
    80205534:	f8c42783          	lw	a5,-116(s0)
    80205538:	f8078ae3          	beqz	a5,802054cc <pipeWrite+0x150>
                    pa = cowHandler(pageTable, addr);
    8020553c:	000c8593          	mv	a1,s9
    80205540:	000d8513          	mv	a0,s11
    80205544:	00004097          	auipc	ra,0x4
    80205548:	2e0080e7          	jalr	736(ra) # 80209824 <cowHandler>
    8020554c:	00050993          	mv	s3,a0
    80205550:	f7dff06f          	j	802054cc <pipeWrite+0x150>
    while (i < n) {
    80205554:	00000913          	li	s2,0
            }
        }
    }
    wakeup(&pi->nread);
    80205558:	00010537          	lui	a0,0x10
    8020555c:	01850513          	addi	a0,a0,24 # 10018 <_start-0x801effe8>
    80205560:	00aa0533          	add	a0,s4,a0
    80205564:	0000c097          	auipc	ra,0xc
    80205568:	740080e7          	jalr	1856(ra) # 80211ca4 <wakeup>
    // releaseLock(&pi->lock);
    assert(i != 0);
    8020556c:	012036b3          	snez	a3,s2
    80205570:	00010617          	auipc	a2,0x10
    80205574:	14060613          	addi	a2,a2,320 # 802156b0 <__func__.0>
    80205578:	08800593          	li	a1,136
    8020557c:	00010517          	auipc	a0,0x10
    80205580:	11450513          	addi	a0,a0,276 # 80215690 <__func__.0+0x20>
    80205584:	ffffc097          	auipc	ra,0xffffc
    80205588:	9d4080e7          	jalr	-1580(ra) # 80200f58 <_assert_>
    return i;
}
    8020558c:	00090513          	mv	a0,s2
    80205590:	08813083          	ld	ra,136(sp)
    80205594:	08013403          	ld	s0,128(sp)
    80205598:	07813483          	ld	s1,120(sp)
    8020559c:	07013903          	ld	s2,112(sp)
    802055a0:	06813983          	ld	s3,104(sp)
    802055a4:	06013a03          	ld	s4,96(sp)
    802055a8:	05813a83          	ld	s5,88(sp)
    802055ac:	05013b03          	ld	s6,80(sp)
    802055b0:	04813b83          	ld	s7,72(sp)
    802055b4:	04013c03          	ld	s8,64(sp)
    802055b8:	03813c83          	ld	s9,56(sp)
    802055bc:	03013d03          	ld	s10,48(sp)
    802055c0:	02813d83          	ld	s11,40(sp)
    802055c4:	09010113          	addi	sp,sp,144
    802055c8:	00008067          	ret

00000000802055cc <pipeRead>:

int pipeRead(struct pipe* pi, bool isUser, u64 addr, int n) {
    802055cc:	fa010113          	addi	sp,sp,-96
    802055d0:	04113c23          	sd	ra,88(sp)
    802055d4:	04813823          	sd	s0,80(sp)
    802055d8:	04913423          	sd	s1,72(sp)
    802055dc:	05213023          	sd	s2,64(sp)
    802055e0:	03313c23          	sd	s3,56(sp)
    802055e4:	03413823          	sd	s4,48(sp)
    802055e8:	03513423          	sd	s5,40(sp)
    802055ec:	03613023          	sd	s6,32(sp)
    802055f0:	01713c23          	sd	s7,24(sp)
    802055f4:	01813823          	sd	s8,16(sp)
    802055f8:	01913423          	sd	s9,8(sp)
    802055fc:	01a13023          	sd	s10,0(sp)
    80205600:	06010413          	addi	s0,sp,96
    80205604:	00050a93          	mv	s5,a0
    80205608:	00058b93          	mv	s7,a1
    8020560c:	00060913          	mv	s2,a2
    80205610:	00068b13          	mv	s6,a3
    int i;
    char ch;
    u64* pageTable = myProcess()->pgdir;
    80205614:	0000a097          	auipc	ra,0xa
    80205618:	3d4080e7          	jalr	980(ra) # 8020f9e8 <myProcess>
    8020561c:	04053d03          	ld	s10,64(a0)
    u64 pa = addr;
    80205620:	00090493          	mv	s1,s2
    if (isUser) {
    80205624:	060b9863          	bnez	s7,80205694 <pipeRead+0xc8>
            pa = pageout(pageTable, addr);
        }
    }

    // acquireLock(&pi->lock);
    while (pi->nread == pi->nwrite && pi->writeopen) {  // DOC: pipe-empty
    80205628:	000107b7          	lui	a5,0x10
    8020562c:	00fa87b3          	add	a5,s5,a5
    80205630:	0187b703          	ld	a4,24(a5) # 10018 <_start-0x801effe8>
    80205634:	0207b783          	ld	a5,32(a5)
    80205638:	02f71c63          	bne	a4,a5,80205670 <pipeRead+0xa4>
    8020563c:	00010a37          	lui	s4,0x10
    80205640:	014a89b3          	add	s3,s5,s4
        sleep(&pi->nread, &pi->lock);  // DOC: piperead-sleep
    80205644:	018a0a13          	addi	s4,s4,24 # 10018 <_start-0x801effe8>
    80205648:	014a8a33          	add	s4,s5,s4
    while (pi->nread == pi->nwrite && pi->writeopen) {  // DOC: pipe-empty
    8020564c:	02c9a783          	lw	a5,44(s3)
    80205650:	02078063          	beqz	a5,80205670 <pipeRead+0xa4>
        sleep(&pi->nread, &pi->lock);  // DOC: piperead-sleep
    80205654:	000a8593          	mv	a1,s5
    80205658:	000a0513          	mv	a0,s4
    8020565c:	0000c097          	auipc	ra,0xc
    80205660:	58c080e7          	jalr	1420(ra) # 80211be8 <sleep>
    while (pi->nread == pi->nwrite && pi->writeopen) {  // DOC: pipe-empty
    80205664:	0189b703          	ld	a4,24(s3)
    80205668:	0209b783          	ld	a5,32(s3)
    8020566c:	fef700e3          	beq	a4,a5,8020564c <pipeRead+0x80>
    }
    for (i = 0; i < n;) {  // DOC: piperead-copy
    80205670:	13605063          	blez	s6,80205790 <pipeRead+0x1c4>
    80205674:	00190913          	addi	s2,s2,1
    80205678:	00000993          	li	s3,0
        if (pi->nread == pi->nwrite) {
    8020567c:	00010c37          	lui	s8,0x10
    80205680:	018a8a33          	add	s4,s5,s8
            break;
        }
        ch = pi->data[(pi->nread++) & (PIPESIZE - 1)];
    80205684:	fffc0c13          	addi	s8,s8,-1 # ffff <_start-0x801f0001>
        *((char*)pa) = ch;
        i++;
        if (isUser && (!((addr + i) & (PAGE_SIZE - 1)))) {
    80205688:	00001cb7          	lui	s9,0x1
    8020568c:	fffc8c93          	addi	s9,s9,-1 # fff <_start-0x801ff001>
    80205690:	0440006f          	j	802056d4 <pipeRead+0x108>
        pa = vir2phy(pageTable, addr, NULL);
    80205694:	00000613          	li	a2,0
    80205698:	00090593          	mv	a1,s2
    8020569c:	000d0513          	mv	a0,s10
    802056a0:	00004097          	auipc	ra,0x4
    802056a4:	2d4080e7          	jalr	724(ra) # 80209974 <vir2phy>
    802056a8:	00050493          	mv	s1,a0
        if (pa == NULL) {
    802056ac:	f6051ee3          	bnez	a0,80205628 <pipeRead+0x5c>
            pa = pageout(pageTable, addr);
    802056b0:	00090593          	mv	a1,s2
    802056b4:	000d0513          	mv	a0,s10
    802056b8:	00004097          	auipc	ra,0x4
    802056bc:	e5c080e7          	jalr	-420(ra) # 80209514 <pageout>
    802056c0:	00050493          	mv	s1,a0
    802056c4:	f65ff06f          	j	80205628 <pipeRead+0x5c>
            pa = vir2phy(pageTable, addr + i, NULL);
            if (pa == NULL) {
                pa = pageout(pageTable, addr + i);
            }
        } else {
            pa++;
    802056c8:	00148493          	addi	s1,s1,1
    for (i = 0; i < n;) {  // DOC: piperead-copy
    802056cc:	00190913          	addi	s2,s2,1
    802056d0:	073b0663          	beq	s6,s3,8020573c <pipeRead+0x170>
        if (pi->nread == pi->nwrite) {
    802056d4:	018a3783          	ld	a5,24(s4)
    802056d8:	020a3703          	ld	a4,32(s4)
    802056dc:	06e78263          	beq	a5,a4,80205740 <pipeRead+0x174>
        ch = pi->data[(pi->nread++) & (PIPESIZE - 1)];
    802056e0:	00178713          	addi	a4,a5,1
    802056e4:	00ea3c23          	sd	a4,24(s4)
    802056e8:	0187f7b3          	and	a5,a5,s8
    802056ec:	00fa87b3          	add	a5,s5,a5
    802056f0:	0187c783          	lbu	a5,24(a5)
        *((char*)pa) = ch;
    802056f4:	00f48023          	sb	a5,0(s1)
        i++;
    802056f8:	0019899b          	addiw	s3,s3,1
        if (isUser && (!((addr + i) & (PAGE_SIZE - 1)))) {
    802056fc:	fc0b86e3          	beqz	s7,802056c8 <pipeRead+0xfc>
    80205700:	019977b3          	and	a5,s2,s9
    80205704:	fc0792e3          	bnez	a5,802056c8 <pipeRead+0xfc>
            pa = vir2phy(pageTable, addr + i, NULL);
    80205708:	00000613          	li	a2,0
    8020570c:	00090593          	mv	a1,s2
    80205710:	000d0513          	mv	a0,s10
    80205714:	00004097          	auipc	ra,0x4
    80205718:	260080e7          	jalr	608(ra) # 80209974 <vir2phy>
    8020571c:	00050493          	mv	s1,a0
            if (pa == NULL) {
    80205720:	fa0516e3          	bnez	a0,802056cc <pipeRead+0x100>
                pa = pageout(pageTable, addr + i);
    80205724:	00090593          	mv	a1,s2
    80205728:	000d0513          	mv	a0,s10
    8020572c:	00004097          	auipc	ra,0x4
    80205730:	de8080e7          	jalr	-536(ra) # 80209514 <pageout>
    80205734:	00050493          	mv	s1,a0
    80205738:	f95ff06f          	j	802056cc <pipeRead+0x100>
        i++;
    8020573c:	000b0993          	mv	s3,s6
        // if (either_copyout(isUser, addr + i, &ch, 1) == -1) {
        //     break;
        // }
        // pipeOut(isUser, addr + i, &ch);
    }
    wakeup(&pi->nwrite);  // DOC: piperead-wakeup
    80205740:	00010537          	lui	a0,0x10
    80205744:	02050513          	addi	a0,a0,32 # 10020 <_start-0x801effe0>
    80205748:	00aa8533          	add	a0,s5,a0
    8020574c:	0000c097          	auipc	ra,0xc
    80205750:	558080e7          	jalr	1368(ra) # 80211ca4 <wakeup>
    // releaseLock(&pi->lock);
    return i;
}
    80205754:	00098513          	mv	a0,s3
    80205758:	05813083          	ld	ra,88(sp)
    8020575c:	05013403          	ld	s0,80(sp)
    80205760:	04813483          	ld	s1,72(sp)
    80205764:	04013903          	ld	s2,64(sp)
    80205768:	03813983          	ld	s3,56(sp)
    8020576c:	03013a03          	ld	s4,48(sp)
    80205770:	02813a83          	ld	s5,40(sp)
    80205774:	02013b03          	ld	s6,32(sp)
    80205778:	01813b83          	ld	s7,24(sp)
    8020577c:	01013c03          	ld	s8,16(sp)
    80205780:	00813c83          	ld	s9,8(sp)
    80205784:	00013d03          	ld	s10,0(sp)
    80205788:	06010113          	addi	sp,sp,96
    8020578c:	00008067          	ret
    for (i = 0; i < n;) {  // DOC: piperead-copy
    80205790:	00000993          	li	s3,0
    80205794:	fadff06f          	j	80205740 <pipeRead+0x174>

0000000080205798 <pipeOut>:

void pipeOut(bool isUser, u64 dstva, char* src) {
    80205798:	fc010113          	addi	sp,sp,-64
    8020579c:	02113c23          	sd	ra,56(sp)
    802057a0:	02813823          	sd	s0,48(sp)
    802057a4:	02913423          	sd	s1,40(sp)
    802057a8:	03213023          	sd	s2,32(sp)
    802057ac:	01313c23          	sd	s3,24(sp)
    802057b0:	04010413          	addi	s0,sp,64
    802057b4:	00058493          	mv	s1,a1
    802057b8:	00060913          	mv	s2,a2
    if (!isUser) {
    802057bc:	02051463          	bnez	a0,802057e4 <pipeOut+0x4c>
        *((char*)dstva) = *src;
    802057c0:	00064783          	lbu	a5,0(a2)
    802057c4:	00f58023          	sb	a5,0(a1)
    if (cow) {
        pa = cowHandler(pageTable, dstva);
        // pa = vir2phy(pageTable, dstva, &cow);
    }
    *((char*)pa) = *src;
}
    802057c8:	03813083          	ld	ra,56(sp)
    802057cc:	03013403          	ld	s0,48(sp)
    802057d0:	02813483          	ld	s1,40(sp)
    802057d4:	02013903          	ld	s2,32(sp)
    802057d8:	01813983          	ld	s3,24(sp)
    802057dc:	04010113          	addi	sp,sp,64
    802057e0:	00008067          	ret
    u64* pageTable = myProcess()->pgdir;
    802057e4:	0000a097          	auipc	ra,0xa
    802057e8:	204080e7          	jalr	516(ra) # 8020f9e8 <myProcess>
    802057ec:	04053983          	ld	s3,64(a0)
    u64 pa = vir2phy(pageTable, dstva, &cow);
    802057f0:	fcc40613          	addi	a2,s0,-52
    802057f4:	00048593          	mv	a1,s1
    802057f8:	00098513          	mv	a0,s3
    802057fc:	00004097          	auipc	ra,0x4
    80205800:	178080e7          	jalr	376(ra) # 80209974 <vir2phy>
    if (pa == NULL) {
    80205804:	00050c63          	beqz	a0,8020581c <pipeOut+0x84>
    if (cow) {
    80205808:	fcc42783          	lw	a5,-52(s0)
    8020580c:	02079463          	bnez	a5,80205834 <pipeOut+0x9c>
    *((char*)pa) = *src;
    80205810:	00094783          	lbu	a5,0(s2)
    80205814:	00f50023          	sb	a5,0(a0)
    80205818:	fb1ff06f          	j	802057c8 <pipeOut+0x30>
        cow = 0;
    8020581c:	fc042623          	sw	zero,-52(s0)
        pa = pageout(pageTable, dstva);
    80205820:	00048593          	mv	a1,s1
    80205824:	00098513          	mv	a0,s3
    80205828:	00004097          	auipc	ra,0x4
    8020582c:	cec080e7          	jalr	-788(ra) # 80209514 <pageout>
    80205830:	fd9ff06f          	j	80205808 <pipeOut+0x70>
        pa = cowHandler(pageTable, dstva);
    80205834:	00048593          	mv	a1,s1
    80205838:	00098513          	mv	a0,s3
    8020583c:	00004097          	auipc	ra,0x4
    80205840:	fe8080e7          	jalr	-24(ra) # 80209824 <cowHandler>
    80205844:	fcdff06f          	j	80205810 <pipeOut+0x78>

0000000080205848 <pipeIn>:

void pipeIn(bool isUser, char* dst, u64 srcva) {
    80205848:	fd010113          	addi	sp,sp,-48
    8020584c:	02113423          	sd	ra,40(sp)
    80205850:	02813023          	sd	s0,32(sp)
    80205854:	00913c23          	sd	s1,24(sp)
    80205858:	01213823          	sd	s2,16(sp)
    8020585c:	01313423          	sd	s3,8(sp)
    80205860:	03010413          	addi	s0,sp,48
    80205864:	00058913          	mv	s2,a1
    80205868:	00060493          	mv	s1,a2
    if (!isUser) {
    8020586c:	02051463          	bnez	a0,80205894 <pipeIn+0x4c>
        *dst = *((char*)srcva);
    80205870:	00064783          	lbu	a5,0(a2)
    80205874:	00f90023          	sb	a5,0(s2)
    u64 pa = vir2phy(pageTable, srcva, NULL);
    if (pa == NULL) {
        pa = pageout(pageTable, srcva);
    }
    *dst = *((char*)pa);
}
    80205878:	02813083          	ld	ra,40(sp)
    8020587c:	02013403          	ld	s0,32(sp)
    80205880:	01813483          	ld	s1,24(sp)
    80205884:	01013903          	ld	s2,16(sp)
    80205888:	00813983          	ld	s3,8(sp)
    8020588c:	03010113          	addi	sp,sp,48
    80205890:	00008067          	ret
    u64* pageTable = myProcess()->pgdir;
    80205894:	0000a097          	auipc	ra,0xa
    80205898:	154080e7          	jalr	340(ra) # 8020f9e8 <myProcess>
    8020589c:	04053983          	ld	s3,64(a0)
    u64 pa = vir2phy(pageTable, srcva, NULL);
    802058a0:	00000613          	li	a2,0
    802058a4:	00048593          	mv	a1,s1
    802058a8:	00098513          	mv	a0,s3
    802058ac:	00004097          	auipc	ra,0x4
    802058b0:	0c8080e7          	jalr	200(ra) # 80209974 <vir2phy>
    if (pa == NULL) {
    802058b4:	00050663          	beqz	a0,802058c0 <pipeIn+0x78>
    *dst = *((char*)pa);
    802058b8:	00054783          	lbu	a5,0(a0)
    802058bc:	fb9ff06f          	j	80205874 <pipeIn+0x2c>
        pa = pageout(pageTable, srcva);
    802058c0:	00048593          	mv	a1,s1
    802058c4:	00098513          	mv	a0,s3
    802058c8:	00004097          	auipc	ra,0x4
    802058cc:	c4c080e7          	jalr	-948(ra) # 80209514 <pageout>
    802058d0:	fe9ff06f          	j	802058b8 <pipeIn+0x70>

00000000802058d4 <remote_find_socket>:
    static char buf[128];
    either_copyin(buf, isUser, addr, n);
    return sendTo(0, buf, n, 0, &sock->target_addr);
}

static Socket* remote_find_socket(const SocketAddr* addr) {
    802058d4:	ff010113          	addi	sp,sp,-16
    802058d8:	00813423          	sd	s0,8(sp)
    802058dc:	01010413          	addi	s0,sp,16
    for (int i = 0; i < SOCKET_COUNT; ++i) {
    802058e0:	018f4797          	auipc	a5,0x18f4
    802058e4:	21078793          	addi	a5,a5,528 # 81af9af0 <sockets>
    802058e8:	00000713          	li	a4,0
    802058ec:	08000613          	li	a2,128
    802058f0:	0100006f          	j	80205900 <remote_find_socket+0x2c>
    802058f4:	0017071b          	addiw	a4,a4,1
    802058f8:	1a878793          	addi	a5,a5,424
    802058fc:	02c70c63          	beq	a4,a2,80205934 <remote_find_socket+0x60>
        if (sockets[i].used && /*sockets[i].addr.family == addr->family &&*/
    80205900:	0007c683          	lbu	a3,0(a5)
    80205904:	fe0688e3          	beqz	a3,802058f4 <remote_find_socket+0x20>
    80205908:	0127d583          	lhu	a1,18(a5)
    8020590c:	00255683          	lhu	a3,2(a0)
    80205910:	fed592e3          	bne	a1,a3,802058f4 <remote_find_socket+0x20>
            sockets[i].addr.port == addr->port) {
            return &sockets[i];
    80205914:	1a800793          	li	a5,424
    80205918:	02f70733          	mul	a4,a4,a5
    8020591c:	018f4797          	auipc	a5,0x18f4
    80205920:	1d478793          	addi	a5,a5,468 # 81af9af0 <sockets>
    80205924:	00f70533          	add	a0,a4,a5
        }
    }
    return NULL;
}
    80205928:	00813403          	ld	s0,8(sp)
    8020592c:	01010113          	addi	sp,sp,16
    80205930:	00008067          	ret
    return NULL;
    80205934:	00000513          	li	a0,0
    80205938:	ff1ff06f          	j	80205928 <remote_find_socket+0x54>

000000008020593c <socketAlloc>:
int socketAlloc(Socket **s) {
    8020593c:	fd010113          	addi	sp,sp,-48
    80205940:	02113423          	sd	ra,40(sp)
    80205944:	02813023          	sd	s0,32(sp)
    80205948:	00913c23          	sd	s1,24(sp)
    8020594c:	01213823          	sd	s2,16(sp)
    80205950:	03010413          	addi	s0,sp,48
    80205954:	00050913          	mv	s2,a0
    for (int i = 0; i < SOCKET_COUNT; i++) {
    80205958:	018f4797          	auipc	a5,0x18f4
    8020595c:	19878793          	addi	a5,a5,408 # 81af9af0 <sockets>
    80205960:	00000493          	li	s1,0
    80205964:	08000693          	li	a3,128
        if (!sockets[i].used) {
    80205968:	0007c703          	lbu	a4,0(a5)
    8020596c:	00070c63          	beqz	a4,80205984 <socketAlloc+0x48>
    for (int i = 0; i < SOCKET_COUNT; i++) {
    80205970:	0014849b          	addiw	s1,s1,1
    80205974:	1a878793          	addi	a5,a5,424
    80205978:	fed498e3          	bne	s1,a3,80205968 <socketAlloc+0x2c>
    return -1;
    8020597c:	fff00513          	li	a0,-1
    80205980:	0380006f          	j	802059b8 <socketAlloc+0x7c>
            sockets[i].used = true;
    80205984:	1a800713          	li	a4,424
    80205988:	02e48733          	mul	a4,s1,a4
    8020598c:	018f4797          	auipc	a5,0x18f4
    80205990:	16478793          	addi	a5,a5,356 # 81af9af0 <sockets>
    80205994:	00e787b3          	add	a5,a5,a4
    80205998:	00100713          	li	a4,1
    8020599c:	00e78023          	sb	a4,0(a5)
            sockets[i].head = sockets[i].tail = 0;
    802059a0:	0407bc23          	sd	zero,88(a5)
    802059a4:	0407b823          	sd	zero,80(a5)
            if ((r = pageAlloc(&page)) < 0) {
    802059a8:	fd840513          	addi	a0,s0,-40
    802059ac:	00003097          	auipc	ra,0x3
    802059b0:	510080e7          	jalr	1296(ra) # 80208ebc <pageAlloc>
    802059b4:	00055e63          	bgez	a0,802059d0 <socketAlloc+0x94>
}
    802059b8:	02813083          	ld	ra,40(sp)
    802059bc:	02013403          	ld	s0,32(sp)
    802059c0:	01813483          	ld	s1,24(sp)
    802059c4:	01013903          	ld	s2,16(sp)
    802059c8:	03010113          	addi	sp,sp,48
    802059cc:	00008067          	ret
            pageInsert(kernelPageDirectory, getSocketBufferBase(&sockets[i]), page2pa(page), PTE_READ | PTE_WRITE);
    802059d0:	1a800793          	li	a5,424
    802059d4:	02f484b3          	mul	s1,s1,a5
    return page - pages;
    802059d8:	fd843783          	ld	a5,-40(s0)
    802059dc:	01901717          	auipc	a4,0x1901
    802059e0:	52470713          	addi	a4,a4,1316 # 81b06f00 <pages>
    802059e4:	40e787b3          	sub	a5,a5,a4
    802059e8:	4037d793          	srai	a5,a5,0x3
    802059ec:	00011717          	auipc	a4,0x11
    802059f0:	e0c73703          	ld	a4,-500(a4) # 802167f8 <__func__.0+0x20>
    802059f4:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802059f8:	00c7979b          	slliw	a5,a5,0xc
    802059fc:	02079793          	slli	a5,a5,0x20
    80205a00:	0207d793          	srli	a5,a5,0x20
    return SOCKET_BUFFER_BASE + (((u64)(s - sockets)) << PAGE_SHIFT);
    80205a04:	4034d713          	srai	a4,s1,0x3
    80205a08:	00011697          	auipc	a3,0x11
    80205a0c:	e006b683          	ld	a3,-512(a3) # 80216808 <__func__.0+0x30>
    80205a10:	02d70733          	mul	a4,a4,a3
    80205a14:	00c71713          	slli	a4,a4,0xc
            pageInsert(kernelPageDirectory, getSocketBufferBase(&sockets[i]), page2pa(page), PTE_READ | PTE_WRITE);
    80205a18:	00600693          	li	a3,6
    80205a1c:	00100613          	li	a2,1
    80205a20:	01f61613          	slli	a2,a2,0x1f
    80205a24:	00c78633          	add	a2,a5,a2
    80205a28:	02100593          	li	a1,33
    80205a2c:	01f59593          	slli	a1,a1,0x1f
    80205a30:	00b705b3          	add	a1,a4,a1
    80205a34:	02169517          	auipc	a0,0x2169
    80205a38:	5cc50513          	addi	a0,a0,1484 # 8236f000 <_pgdir>
    80205a3c:	00004097          	auipc	ra,0x4
    80205a40:	834080e7          	jalr	-1996(ra) # 80209270 <pageInsert>
            sockets[i].process = myProcess();
    80205a44:	0000a097          	auipc	ra,0xa
    80205a48:	fa4080e7          	jalr	-92(ra) # 8020f9e8 <myProcess>
    80205a4c:	018f4797          	auipc	a5,0x18f4
    80205a50:	0a478793          	addi	a5,a5,164 # 81af9af0 <sockets>
    80205a54:	009787b3          	add	a5,a5,s1
    80205a58:	00a7b423          	sd	a0,8(a5)
            *s = &sockets[i];
    80205a5c:	00f93023          	sd	a5,0(s2)
            return 0;
    80205a60:	00000513          	li	a0,0
    80205a64:	f55ff06f          	j	802059b8 <socketAlloc+0x7c>

0000000080205a68 <socketFree>:
void socketFree(Socket *s) {
    80205a68:	fe010113          	addi	sp,sp,-32
    80205a6c:	00113c23          	sd	ra,24(sp)
    80205a70:	00813823          	sd	s0,16(sp)
    80205a74:	00913423          	sd	s1,8(sp)
    80205a78:	02010413          	addi	s0,sp,32
    80205a7c:	00050493          	mv	s1,a0
    return SOCKET_BUFFER_BASE + (((u64)(s - sockets)) << PAGE_SHIFT);
    80205a80:	018f4797          	auipc	a5,0x18f4
    80205a84:	07078793          	addi	a5,a5,112 # 81af9af0 <sockets>
    80205a88:	40f507b3          	sub	a5,a0,a5
    80205a8c:	4037d793          	srai	a5,a5,0x3
    80205a90:	00011717          	auipc	a4,0x11
    80205a94:	d7873703          	ld	a4,-648(a4) # 80216808 <__func__.0+0x30>
    80205a98:	02e787b3          	mul	a5,a5,a4
    80205a9c:	00c79793          	slli	a5,a5,0xc
    pageRemove(kernelPageDirectory, getSocketBufferBase(s));
    80205aa0:	02100593          	li	a1,33
    80205aa4:	01f59593          	slli	a1,a1,0x1f
    80205aa8:	00b785b3          	add	a1,a5,a1
    80205aac:	02169517          	auipc	a0,0x2169
    80205ab0:	55450513          	addi	a0,a0,1364 # 8236f000 <_pgdir>
    80205ab4:	00003097          	auipc	ra,0x3
    80205ab8:	5b4080e7          	jalr	1460(ra) # 80209068 <pageRemove>
    s->used = false;
    80205abc:	00048023          	sb	zero,0(s1)
}
    80205ac0:	01813083          	ld	ra,24(sp)
    80205ac4:	01013403          	ld	s0,16(sp)
    80205ac8:	00813483          	ld	s1,8(sp)
    80205acc:	02010113          	addi	sp,sp,32
    80205ad0:	00008067          	ret

0000000080205ad4 <createSocket>:
int createSocket(int family, int type, int protocal) {
    80205ad4:	fd010113          	addi	sp,sp,-48
    80205ad8:	02113423          	sd	ra,40(sp)
    80205adc:	02813023          	sd	s0,32(sp)
    80205ae0:	00913c23          	sd	s1,24(sp)
    80205ae4:	01213823          	sd	s2,16(sp)
    80205ae8:	03010413          	addi	s0,sp,48
    80205aec:	00050913          	mv	s2,a0
    80205af0:	00058693          	mv	a3,a1
    80205af4:	00060713          	mv	a4,a2
    printf("[%s] family %x type  %x protocal %x\n", __func__, family, type, protocal);
    80205af8:	00050613          	mv	a2,a0
    80205afc:	00010597          	auipc	a1,0x10
    80205b00:	cac58593          	addi	a1,a1,-852 # 802157a8 <__func__.10>
    80205b04:	00010517          	auipc	a0,0x10
    80205b08:	bbc50513          	addi	a0,a0,-1092 # 802156c0 <__func__.0+0x10>
    80205b0c:	ffffb097          	auipc	ra,0xffffb
    80205b10:	344080e7          	jalr	836(ra) # 80200e50 <printf>
    File *f = filealloc();
    80205b14:	ffffe097          	auipc	ra,0xffffe
    80205b18:	398080e7          	jalr	920(ra) # 80203eac <filealloc>
    80205b1c:	00050493          	mv	s1,a0
    if (socketAlloc(&s) < 0) {
    80205b20:	fd840513          	addi	a0,s0,-40
    80205b24:	00000097          	auipc	ra,0x0
    80205b28:	e18080e7          	jalr	-488(ra) # 8020593c <socketAlloc>
    80205b2c:	06054863          	bltz	a0,80205b9c <createSocket+0xc8>
    s->addr.family = family;
    80205b30:	fd843783          	ld	a5,-40(s0)
    80205b34:	01279823          	sh	s2,16(a5)
    s->pending_h = s->pending_t = 0;
    80205b38:	1a07a223          	sw	zero,420(a5)
    80205b3c:	1a07a023          	sw	zero,416(a5)
    f->socket = s;
    80205b40:	02f4b023          	sd	a5,32(s1)
    f->type = FD_SOCKET;
    80205b44:	00400793          	li	a5,4
    80205b48:	00f4a023          	sw	a5,0(s1)
    f->readable = f->writable = true;
    80205b4c:	00100793          	li	a5,1
    80205b50:	00f484a3          	sb	a5,9(s1)
    80205b54:	00f48423          	sb	a5,8(s1)
    assert(f != NULL);
    80205b58:	00100693          	li	a3,1
    80205b5c:	00010617          	auipc	a2,0x10
    80205b60:	c4c60613          	addi	a2,a2,-948 # 802157a8 <__func__.10>
    80205b64:	03500593          	li	a1,53
    80205b68:	00010517          	auipc	a0,0x10
    80205b6c:	b8050513          	addi	a0,a0,-1152 # 802156e8 <__func__.0+0x38>
    80205b70:	ffffb097          	auipc	ra,0xffffb
    80205b74:	3e8080e7          	jalr	1000(ra) # 80200f58 <_assert_>
    return fdalloc(f);
    80205b78:	00048513          	mv	a0,s1
    80205b7c:	00001097          	auipc	ra,0x1
    80205b80:	9d0080e7          	jalr	-1584(ra) # 8020654c <fdalloc>
}
    80205b84:	02813083          	ld	ra,40(sp)
    80205b88:	02013403          	ld	s0,32(sp)
    80205b8c:	01813483          	ld	s1,24(sp)
    80205b90:	01013903          	ld	s2,16(sp)
    80205b94:	03010113          	addi	sp,sp,48
    80205b98:	00008067          	ret
        panic("");
    80205b9c:	00010697          	auipc	a3,0x10
    80205ba0:	04c68693          	addi	a3,a3,76 # 80215be8 <__func__.0+0x48>
    80205ba4:	00010617          	auipc	a2,0x10
    80205ba8:	c0460613          	addi	a2,a2,-1020 # 802157a8 <__func__.10>
    80205bac:	02e00593          	li	a1,46
    80205bb0:	00010517          	auipc	a0,0x10
    80205bb4:	b3850513          	addi	a0,a0,-1224 # 802156e8 <__func__.0+0x38>
    80205bb8:	ffffb097          	auipc	ra,0xffffb
    80205bbc:	330080e7          	jalr	816(ra) # 80200ee8 <_panic_>

0000000080205bc0 <bindSocket>:
int bindSocket(int fd, SocketAddr *sa) {
    80205bc0:	fd010113          	addi	sp,sp,-48
    80205bc4:	02113423          	sd	ra,40(sp)
    80205bc8:	02813023          	sd	s0,32(sp)
    80205bcc:	00913c23          	sd	s1,24(sp)
    80205bd0:	01213823          	sd	s2,16(sp)
    80205bd4:	01313423          	sd	s3,8(sp)
    80205bd8:	03010413          	addi	s0,sp,48
    80205bdc:	00050913          	mv	s2,a0
    80205be0:	00058493          	mv	s1,a1
    printf("[%s]  addr 0x%lx port 0x%lx \n",__func__, sa->addr, sa->port);
    80205be4:	00010997          	auipc	s3,0x10
    80205be8:	bd498993          	addi	s3,s3,-1068 # 802157b8 <__func__.9>
    80205bec:	0025d683          	lhu	a3,2(a1)
    80205bf0:	0045a603          	lw	a2,4(a1)
    80205bf4:	00098593          	mv	a1,s3
    80205bf8:	00010517          	auipc	a0,0x10
    80205bfc:	b0050513          	addi	a0,a0,-1280 # 802156f8 <__func__.0+0x48>
    80205c00:	ffffb097          	auipc	ra,0xffffb
    80205c04:	250080e7          	jalr	592(ra) # 80200e50 <printf>
    File *f = myProcess()->ofile[fd];
    80205c08:	0000a097          	auipc	ra,0xa
    80205c0c:	de0080e7          	jalr	-544(ra) # 8020f9e8 <myProcess>
    80205c10:	00e90913          	addi	s2,s2,14
    80205c14:	00391913          	slli	s2,s2,0x3
    80205c18:	01250533          	add	a0,a0,s2
    80205c1c:	00053903          	ld	s2,0(a0)
    assert(f->type == FD_SOCKET);
    80205c20:	00092683          	lw	a3,0(s2)
    80205c24:	ffc68693          	addi	a3,a3,-4
    80205c28:	0016b693          	seqz	a3,a3
    80205c2c:	00098613          	mv	a2,s3
    80205c30:	03c00593          	li	a1,60
    80205c34:	00010517          	auipc	a0,0x10
    80205c38:	ab450513          	addi	a0,a0,-1356 # 802156e8 <__func__.0+0x38>
    80205c3c:	ffffb097          	auipc	ra,0xffffb
    80205c40:	31c080e7          	jalr	796(ra) # 80200f58 <_assert_>
    Socket *s = f->socket;
    80205c44:	02093903          	ld	s2,32(s2)
    assert(s->addr.family == sa->family);
    80205c48:	01095683          	lhu	a3,16(s2)
    80205c4c:	0004d783          	lhu	a5,0(s1)
    80205c50:	40f686b3          	sub	a3,a3,a5
    80205c54:	0016b693          	seqz	a3,a3
    80205c58:	00098613          	mv	a2,s3
    80205c5c:	03e00593          	li	a1,62
    80205c60:	00010517          	auipc	a0,0x10
    80205c64:	a8850513          	addi	a0,a0,-1400 # 802156e8 <__func__.0+0x38>
    80205c68:	ffffb097          	auipc	ra,0xffffb
    80205c6c:	2f0080e7          	jalr	752(ra) # 80200f58 <_assert_>
    assert(sa->addr == 0 || (sa->addr >> 24) == 127);
    80205c70:	0044a683          	lw	a3,4(s1)
    80205c74:	04068e63          	beqz	a3,80205cd0 <bindSocket+0x110>
    80205c78:	0186d69b          	srliw	a3,a3,0x18
    80205c7c:	f8168693          	addi	a3,a3,-127
    80205c80:	0016b693          	seqz	a3,a3
    80205c84:	00010617          	auipc	a2,0x10
    80205c88:	b3460613          	addi	a2,a2,-1228 # 802157b8 <__func__.9>
    80205c8c:	03f00593          	li	a1,63
    80205c90:	00010517          	auipc	a0,0x10
    80205c94:	a5850513          	addi	a0,a0,-1448 # 802156e8 <__func__.0+0x38>
    80205c98:	ffffb097          	auipc	ra,0xffffb
    80205c9c:	2c0080e7          	jalr	704(ra) # 80200f58 <_assert_>
    s->addr.addr = sa->addr;
    80205ca0:	0044a783          	lw	a5,4(s1)
    80205ca4:	00f92a23          	sw	a5,20(s2)
    s->addr.port = sa->port;
    80205ca8:	0024d783          	lhu	a5,2(s1)
    80205cac:	00f91923          	sh	a5,18(s2)
}
    80205cb0:	00000513          	li	a0,0
    80205cb4:	02813083          	ld	ra,40(sp)
    80205cb8:	02013403          	ld	s0,32(sp)
    80205cbc:	01813483          	ld	s1,24(sp)
    80205cc0:	01013903          	ld	s2,16(sp)
    80205cc4:	00813983          	ld	s3,8(sp)
    80205cc8:	03010113          	addi	sp,sp,48
    80205ccc:	00008067          	ret
    assert(sa->addr == 0 || (sa->addr >> 24) == 127);
    80205cd0:	00100693          	li	a3,1
    80205cd4:	fb1ff06f          	j	80205c84 <bindSocket+0xc4>

0000000080205cd8 <getSocketName>:
int getSocketName(int fd, u64 va) {
    80205cd8:	fe010113          	addi	sp,sp,-32
    80205cdc:	00113c23          	sd	ra,24(sp)
    80205ce0:	00813823          	sd	s0,16(sp)
    80205ce4:	00913423          	sd	s1,8(sp)
    80205ce8:	01213023          	sd	s2,0(sp)
    80205cec:	02010413          	addi	s0,sp,32
    80205cf0:	00050493          	mv	s1,a0
    80205cf4:	00058913          	mv	s2,a1
    File *f = myProcess()->ofile[fd];
    80205cf8:	0000a097          	auipc	ra,0xa
    80205cfc:	cf0080e7          	jalr	-784(ra) # 8020f9e8 <myProcess>
    80205d00:	00e48493          	addi	s1,s1,14
    80205d04:	00349493          	slli	s1,s1,0x3
    80205d08:	00950533          	add	a0,a0,s1
    80205d0c:	00053483          	ld	s1,0(a0)
    assert(f->type == FD_SOCKET);
    80205d10:	0004a683          	lw	a3,0(s1)
    80205d14:	ffc68693          	addi	a3,a3,-4
    80205d18:	0016b693          	seqz	a3,a3
    80205d1c:	00010617          	auipc	a2,0x10
    80205d20:	aac60613          	addi	a2,a2,-1364 # 802157c8 <__func__.8>
    80205d24:	04700593          	li	a1,71
    80205d28:	00010517          	auipc	a0,0x10
    80205d2c:	9c050513          	addi	a0,a0,-1600 # 802156e8 <__func__.0+0x38>
    80205d30:	ffffb097          	auipc	ra,0xffffb
    80205d34:	228080e7          	jalr	552(ra) # 80200f58 <_assert_>
    copyout(myProcess()->pgdir, va, (char*)&f->socket->addr, sizeof(SocketAddr));
    80205d38:	0000a097          	auipc	ra,0xa
    80205d3c:	cb0080e7          	jalr	-848(ra) # 8020f9e8 <myProcess>
    80205d40:	0204b603          	ld	a2,32(s1)
    80205d44:	02000693          	li	a3,32
    80205d48:	01060613          	addi	a2,a2,16
    80205d4c:	00090593          	mv	a1,s2
    80205d50:	04053503          	ld	a0,64(a0)
    80205d54:	00004097          	auipc	ra,0x4
    80205d58:	de4080e7          	jalr	-540(ra) # 80209b38 <copyout>
}
    80205d5c:	00000513          	li	a0,0
    80205d60:	01813083          	ld	ra,24(sp)
    80205d64:	01013403          	ld	s0,16(sp)
    80205d68:	00813483          	ld	s1,8(sp)
    80205d6c:	00013903          	ld	s2,0(sp)
    80205d70:	02010113          	addi	sp,sp,32
    80205d74:	00008067          	ret

0000000080205d78 <sendTo>:
int sendTo(Socket *sock, char *buf, u32 len, int flags, SocketAddr *dest) {
    80205d78:	fc010113          	addi	sp,sp,-64
    80205d7c:	02113c23          	sd	ra,56(sp)
    80205d80:	02813823          	sd	s0,48(sp)
    80205d84:	02913423          	sd	s1,40(sp)
    80205d88:	03213023          	sd	s2,32(sp)
    80205d8c:	01313c23          	sd	s3,24(sp)
    80205d90:	01413823          	sd	s4,16(sp)
    80205d94:	01513423          	sd	s5,8(sp)
    80205d98:	01613023          	sd	s6,0(sp)
    80205d9c:	04010413          	addi	s0,sp,64
    80205da0:	00058a13          	mv	s4,a1
    80205da4:	00070913          	mv	s2,a4
    buf[len] = 0;
    80205da8:	02061993          	slli	s3,a2,0x20
    80205dac:	0209d993          	srli	s3,s3,0x20
    80205db0:	013587b3          	add	a5,a1,s3
    80205db4:	00078023          	sb	zero,0(a5)
    printf("[%s] addr 0x%x port 0x%x data %s\n", __func__, dest->addr, dest->port, buf);
    80205db8:	00058713          	mv	a4,a1
    80205dbc:	00295683          	lhu	a3,2(s2)
    80205dc0:	00492603          	lw	a2,4(s2)
    80205dc4:	00011597          	auipc	a1,0x11
    80205dc8:	9e458593          	addi	a1,a1,-1564 # 802167a8 <__func__.7>
    80205dcc:	00010517          	auipc	a0,0x10
    80205dd0:	94c50513          	addi	a0,a0,-1716 # 80215718 <__func__.0+0x68>
    80205dd4:	ffffb097          	auipc	ra,0xffffb
    80205dd8:	07c080e7          	jalr	124(ra) # 80200e50 <printf>
    for (int i = 0; i < SOCKET_COUNT; i++) {
    80205ddc:	018f4797          	auipc	a5,0x18f4
    80205de0:	d1478793          	addi	a5,a5,-748 # 81af9af0 <sockets>
    80205de4:	00000493          	li	s1,0
    80205de8:	08000513          	li	a0,128
    80205dec:	0280006f          	j	80205e14 <sendTo+0x9c>
                strncpy((char*)(getSocketBufferBase(&sockets[i])), buf + len1, num - len1);
    80205df0:	413b063b          	subw	a2,s6,s3
    80205df4:	013a05b3          	add	a1,s4,s3
    80205df8:	000a8513          	mv	a0,s5
    80205dfc:	00009097          	auipc	ra,0x9
    80205e00:	0d8080e7          	jalr	216(ra) # 8020eed4 <strncpy>
    80205e04:	0ac0006f          	j	80205eb0 <sendTo+0x138>
    for (int i = 0; i < SOCKET_COUNT; i++) {
    80205e08:	0014849b          	addiw	s1,s1,1
    80205e0c:	1a878793          	addi	a5,a5,424
    80205e10:	0ea48663          	beq	s1,a0,80205efc <sendTo+0x184>
        if (sockets[i].used && (sockets[i].addr.port == dest->port/*sockets[i].addr.addr == dest->addr || sockets[i].addr.addr == 0*/)) {
    80205e14:	0007c683          	lbu	a3,0(a5)
    80205e18:	fe0688e3          	beqz	a3,80205e08 <sendTo+0x90>
    80205e1c:	0127d803          	lhu	a6,18(a5)
    80205e20:	00295683          	lhu	a3,2(s2)
    80205e24:	fed812e3          	bne	a6,a3,80205e08 <sendTo+0x90>
    return SOCKET_BUFFER_BASE + (((u64)(s - sockets)) << PAGE_SHIFT);
    80205e28:	1a800713          	li	a4,424
    80205e2c:	02e48733          	mul	a4,s1,a4
    80205e30:	40375a93          	srai	s5,a4,0x3
    80205e34:	00011797          	auipc	a5,0x11
    80205e38:	9d47b783          	ld	a5,-1580(a5) # 80216808 <__func__.0+0x30>
    80205e3c:	02fa8ab3          	mul	s5,s5,a5
    80205e40:	00ca9a93          	slli	s5,s5,0xc
    80205e44:	02100793          	li	a5,33
    80205e48:	01f79793          	slli	a5,a5,0x1f
    80205e4c:	00fa8ab3          	add	s5,s5,a5
            char *dst = (char*)(getSocketBufferBase(&sockets[i]) + (sockets[i].tail & (PAGE_SIZE - 1)));
    80205e50:	018f4797          	auipc	a5,0x18f4
    80205e54:	ca078793          	addi	a5,a5,-864 # 81af9af0 <sockets>
    80205e58:	00e787b3          	add	a5,a5,a4
    80205e5c:	0587b703          	ld	a4,88(a5)
    80205e60:	00001937          	lui	s2,0x1
    80205e64:	fff90513          	addi	a0,s2,-1 # fff <_start-0x801ff001>
    80205e68:	00a77533          	and	a0,a4,a0
            u32 num = MIN(PAGE_SIZE - (sockets[i].tail - sockets[i].head), len);
    80205e6c:	0507b783          	ld	a5,80(a5)
    80205e70:	00f90933          	add	s2,s2,a5
    80205e74:	40e90933          	sub	s2,s2,a4
    80205e78:	0129f463          	bgeu	s3,s2,80205e80 <sendTo+0x108>
    80205e7c:	00098913          	mv	s2,s3
    80205e80:	00090b1b          	sext.w	s6,s2
            int len1 = MIN(num, PAGE_SIZE - (sockets[i].tail & (PAGE_SIZE - 1)));
    80205e84:	000019b7          	lui	s3,0x1
    80205e88:	40a989b3          	sub	s3,s3,a0
    80205e8c:	01397463          	bgeu	s2,s3,80205e94 <sendTo+0x11c>
    80205e90:	00090993          	mv	s3,s2
    80205e94:	0009899b          	sext.w	s3,s3
            strncpy(dst, buf, len1);
    80205e98:	00098613          	mv	a2,s3
    80205e9c:	000a0593          	mv	a1,s4
    80205ea0:	01550533          	add	a0,a0,s5
    80205ea4:	00009097          	auipc	ra,0x9
    80205ea8:	030080e7          	jalr	48(ra) # 8020eed4 <strncpy>
            if (len1 < num) {
    80205eac:	f569e2e3          	bltu	s3,s6,80205df0 <sendTo+0x78>
            sockets[i].tail += num;
    80205eb0:	1a800793          	li	a5,424
    80205eb4:	02f484b3          	mul	s1,s1,a5
    80205eb8:	018f4797          	auipc	a5,0x18f4
    80205ebc:	c3878793          	addi	a5,a5,-968 # 81af9af0 <sockets>
    80205ec0:	009787b3          	add	a5,a5,s1
    80205ec4:	0587b703          	ld	a4,88(a5)
    80205ec8:	01270733          	add	a4,a4,s2
    80205ecc:	04e7bc23          	sd	a4,88(a5)
            return num;
    80205ed0:	0009051b          	sext.w	a0,s2
}
    80205ed4:	03813083          	ld	ra,56(sp)
    80205ed8:	03013403          	ld	s0,48(sp)
    80205edc:	02813483          	ld	s1,40(sp)
    80205ee0:	02013903          	ld	s2,32(sp)
    80205ee4:	01813983          	ld	s3,24(sp)
    80205ee8:	01013a03          	ld	s4,16(sp)
    80205eec:	00813a83          	ld	s5,8(sp)
    80205ef0:	00013b03          	ld	s6,0(sp)
    80205ef4:	04010113          	addi	sp,sp,64
    80205ef8:	00008067          	ret
    return -1;
    80205efc:	fff00513          	li	a0,-1
    80205f00:	fd5ff06f          	j	80205ed4 <sendTo+0x15c>

0000000080205f04 <receiveFrom>:
int receiveFrom(Socket *s, u64 buf, u32 len, int flags, u64 srcAddr) {
    80205f04:	fb010113          	addi	sp,sp,-80
    80205f08:	04113423          	sd	ra,72(sp)
    80205f0c:	04813023          	sd	s0,64(sp)
    80205f10:	02913c23          	sd	s1,56(sp)
    80205f14:	03213823          	sd	s2,48(sp)
    80205f18:	03313423          	sd	s3,40(sp)
    80205f1c:	03413023          	sd	s4,32(sp)
    80205f20:	01513c23          	sd	s5,24(sp)
    80205f24:	01613823          	sd	s6,16(sp)
    80205f28:	01713423          	sd	s7,8(sp)
    80205f2c:	05010413          	addi	s0,sp,80
    80205f30:	00050993          	mv	s3,a0
    80205f34:	00058a13          	mv	s4,a1
    80205f38:	00060913          	mv	s2,a2
    return SOCKET_BUFFER_BASE + (((u64)(s - sockets)) << PAGE_SHIFT);
    80205f3c:	018f4497          	auipc	s1,0x18f4
    80205f40:	bb448493          	addi	s1,s1,-1100 # 81af9af0 <sockets>
    80205f44:	409504b3          	sub	s1,a0,s1
    80205f48:	4034d493          	srai	s1,s1,0x3
    80205f4c:	00011797          	auipc	a5,0x11
    80205f50:	8bc7b783          	ld	a5,-1860(a5) # 80216808 <__func__.0+0x30>
    80205f54:	02f484b3          	mul	s1,s1,a5
    80205f58:	00c49493          	slli	s1,s1,0xc
    80205f5c:	02100793          	li	a5,33
    80205f60:	01f79793          	slli	a5,a5,0x1f
    80205f64:	00f484b3          	add	s1,s1,a5
    char *src = (char*)(getSocketBufferBase(s) + (s->head & (PAGE_SIZE - 1)));
    80205f68:	05053b03          	ld	s6,80(a0)
    80205f6c:	034b1b13          	slli	s6,s6,0x34
    80205f70:	034b5b13          	srli	s6,s6,0x34
    80205f74:	009b0b33          	add	s6,s6,s1
    printf("[%s] data %s\n",__func__, src);
    80205f78:	000b0613          	mv	a2,s6
    80205f7c:	00010597          	auipc	a1,0x10
    80205f80:	85c58593          	addi	a1,a1,-1956 # 802157d8 <__func__.6>
    80205f84:	0000f517          	auipc	a0,0xf
    80205f88:	7bc50513          	addi	a0,a0,1980 # 80215740 <__func__.0+0x90>
    80205f8c:	ffffb097          	auipc	ra,0xffffb
    80205f90:	ec4080e7          	jalr	-316(ra) # 80200e50 <printf>
    u32 num = MIN(len, (s->tail - s->head));
    80205f94:	0509b783          	ld	a5,80(s3) # 1050 <_start-0x801fefb0>
    80205f98:	0589ba83          	ld	s5,88(s3)
    80205f9c:	02091913          	slli	s2,s2,0x20
    80205fa0:	02095913          	srli	s2,s2,0x20
    80205fa4:	40fa8ab3          	sub	s5,s5,a5
    80205fa8:	01597463          	bgeu	s2,s5,80205fb0 <receiveFrom+0xac>
    80205fac:	00090a93          	mv	s5,s2
    80205fb0:	000a8b9b          	sext.w	s7,s5
    int len1 = MIN(num, PAGE_SIZE - (s->head & (PAGE_SIZE - 1)));
    80205fb4:	00001937          	lui	s2,0x1
    80205fb8:	fff90713          	addi	a4,s2,-1 # fff <_start-0x801ff001>
    80205fbc:	00e7f7b3          	and	a5,a5,a4
    80205fc0:	40f90933          	sub	s2,s2,a5
    80205fc4:	012af463          	bgeu	s5,s2,80205fcc <receiveFrom+0xc8>
    80205fc8:	000a8913          	mv	s2,s5
    copyout(myProcess()->pgdir, buf, src, len1);
    80205fcc:	0000a097          	auipc	ra,0xa
    80205fd0:	a1c080e7          	jalr	-1508(ra) # 8020f9e8 <myProcess>
    80205fd4:	0009091b          	sext.w	s2,s2
    80205fd8:	00090693          	mv	a3,s2
    80205fdc:	000b0613          	mv	a2,s6
    80205fe0:	000a0593          	mv	a1,s4
    80205fe4:	04053503          	ld	a0,64(a0)
    80205fe8:	00004097          	auipc	ra,0x4
    80205fec:	b50080e7          	jalr	-1200(ra) # 80209b38 <copyout>
    if (len1 < num) {
    80205ff0:	05796063          	bltu	s2,s7,80206030 <receiveFrom+0x12c>
    s->head += num;
    80205ff4:	0509b783          	ld	a5,80(s3)
    80205ff8:	015787b3          	add	a5,a5,s5
    80205ffc:	04f9b823          	sd	a5,80(s3)
}
    80206000:	000a851b          	sext.w	a0,s5
    80206004:	04813083          	ld	ra,72(sp)
    80206008:	04013403          	ld	s0,64(sp)
    8020600c:	03813483          	ld	s1,56(sp)
    80206010:	03013903          	ld	s2,48(sp)
    80206014:	02813983          	ld	s3,40(sp)
    80206018:	02013a03          	ld	s4,32(sp)
    8020601c:	01813a83          	ld	s5,24(sp)
    80206020:	01013b03          	ld	s6,16(sp)
    80206024:	00813b83          	ld	s7,8(sp)
    80206028:	05010113          	addi	sp,sp,80
    8020602c:	00008067          	ret
        copyout(myProcess()->pgdir, buf + len1, (char*)(getSocketBufferBase(s)), num - len1);
    80206030:	0000a097          	auipc	ra,0xa
    80206034:	9b8080e7          	jalr	-1608(ra) # 8020f9e8 <myProcess>
    80206038:	412b86bb          	subw	a3,s7,s2
    8020603c:	02069693          	slli	a3,a3,0x20
    80206040:	0206d693          	srli	a3,a3,0x20
    80206044:	00048613          	mv	a2,s1
    80206048:	014905b3          	add	a1,s2,s4
    8020604c:	04053503          	ld	a0,64(a0)
    80206050:	00004097          	auipc	ra,0x4
    80206054:	ae8080e7          	jalr	-1304(ra) # 80209b38 <copyout>
    80206058:	f9dff06f          	j	80205ff4 <receiveFrom+0xf0>

000000008020605c <socket_read>:
int socket_read(Socket* sock, bool isUser, u64 addr, int n) {
    8020605c:	fd010113          	addi	sp,sp,-48
    80206060:	02113423          	sd	ra,40(sp)
    80206064:	02813023          	sd	s0,32(sp)
    80206068:	00913c23          	sd	s1,24(sp)
    8020606c:	01213823          	sd	s2,16(sp)
    80206070:	01313423          	sd	s3,8(sp)
    80206074:	03010413          	addi	s0,sp,48
    80206078:	00050493          	mv	s1,a0
    8020607c:	00060913          	mv	s2,a2
    80206080:	00068993          	mv	s3,a3
    assert(isUser == 1);
    80206084:	fff58693          	addi	a3,a1,-1
    80206088:	0016b693          	seqz	a3,a3
    8020608c:	0000f617          	auipc	a2,0xf
    80206090:	75c60613          	addi	a2,a2,1884 # 802157e8 <__func__.5>
    80206094:	06d00593          	li	a1,109
    80206098:	0000f517          	auipc	a0,0xf
    8020609c:	65050513          	addi	a0,a0,1616 # 802156e8 <__func__.0+0x38>
    802060a0:	ffffb097          	auipc	ra,0xffffb
    802060a4:	eb8080e7          	jalr	-328(ra) # 80200f58 <_assert_>
    return receiveFrom(sock, addr, n, 0, 0);
    802060a8:	00000713          	li	a4,0
    802060ac:	00000693          	li	a3,0
    802060b0:	00098613          	mv	a2,s3
    802060b4:	00090593          	mv	a1,s2
    802060b8:	00048513          	mv	a0,s1
    802060bc:	00000097          	auipc	ra,0x0
    802060c0:	e48080e7          	jalr	-440(ra) # 80205f04 <receiveFrom>
}
    802060c4:	02813083          	ld	ra,40(sp)
    802060c8:	02013403          	ld	s0,32(sp)
    802060cc:	01813483          	ld	s1,24(sp)
    802060d0:	01013903          	ld	s2,16(sp)
    802060d4:	00813983          	ld	s3,8(sp)
    802060d8:	03010113          	addi	sp,sp,48
    802060dc:	00008067          	ret

00000000802060e0 <socket_write>:
int socket_write(Socket* sock, bool isUser, u64 addr, int n) {
    802060e0:	fd010113          	addi	sp,sp,-48
    802060e4:	02113423          	sd	ra,40(sp)
    802060e8:	02813023          	sd	s0,32(sp)
    802060ec:	00913c23          	sd	s1,24(sp)
    802060f0:	01213823          	sd	s2,16(sp)
    802060f4:	01313423          	sd	s3,8(sp)
    802060f8:	03010413          	addi	s0,sp,48
    802060fc:	00050913          	mv	s2,a0
    80206100:	00068493          	mv	s1,a3
    either_copyin(buf, isUser, addr, n);
    80206104:	018f4997          	auipc	s3,0x18f4
    80206108:	96c98993          	addi	s3,s3,-1684 # 81af9a70 <buf.4>
    8020610c:	00098513          	mv	a0,s3
    80206110:	0000a097          	auipc	ra,0xa
    80206114:	374080e7          	jalr	884(ra) # 80210484 <either_copyin>
    return sendTo(0, buf, n, 0, &sock->target_addr);
    80206118:	03090713          	addi	a4,s2,48
    8020611c:	00000693          	li	a3,0
    80206120:	00048613          	mv	a2,s1
    80206124:	00098593          	mv	a1,s3
    80206128:	00000513          	li	a0,0
    8020612c:	00000097          	auipc	ra,0x0
    80206130:	c4c080e7          	jalr	-948(ra) # 80205d78 <sendTo>
}
    80206134:	02813083          	ld	ra,40(sp)
    80206138:	02013403          	ld	s0,32(sp)
    8020613c:	01813483          	ld	s1,24(sp)
    80206140:	01013903          	ld	s2,16(sp)
    80206144:	00813983          	ld	s3,8(sp)
    80206148:	03010113          	addi	sp,sp,48
    8020614c:	00008067          	ret

0000000080206150 <accept>:

int accept(int sockfd, SocketAddr* addr) {
    80206150:	fc010113          	addi	sp,sp,-64
    80206154:	02113c23          	sd	ra,56(sp)
    80206158:	02813823          	sd	s0,48(sp)
    8020615c:	02913423          	sd	s1,40(sp)
    80206160:	03213023          	sd	s2,32(sp)
    80206164:	01313c23          	sd	s3,24(sp)
    80206168:	04010413          	addi	s0,sp,64
    8020616c:	00050913          	mv	s2,a0
    80206170:	00058493          	mv	s1,a1
    printf("[%s]] addr %lx port %x\n", __func__, addr->addr, addr->port);
    80206174:	0025d683          	lhu	a3,2(a1)
    80206178:	0045a603          	lw	a2,4(a1)
    8020617c:	00010597          	auipc	a1,0x10
    80206180:	62458593          	addi	a1,a1,1572 # 802167a0 <__func__.3>
    80206184:	0000f517          	auipc	a0,0xf
    80206188:	5cc50513          	addi	a0,a0,1484 # 80215750 <__func__.0+0xa0>
    8020618c:	ffffb097          	auipc	ra,0xffffb
    80206190:	cc4080e7          	jalr	-828(ra) # 80200e50 <printf>
    File* f = myProcess()->ofile[sockfd];
    80206194:	0000a097          	auipc	ra,0xa
    80206198:	854080e7          	jalr	-1964(ra) # 8020f9e8 <myProcess>
    8020619c:	00e90913          	addi	s2,s2,14
    802061a0:	00391913          	slli	s2,s2,0x3
    802061a4:	01250533          	add	a0,a0,s2
    802061a8:	00053903          	ld	s2,0(a0)
    assert(f->type == FD_SOCKET);
    802061ac:	00092683          	lw	a3,0(s2)
    802061b0:	ffc68693          	addi	a3,a3,-4
    802061b4:	0016b693          	seqz	a3,a3
    802061b8:	00010617          	auipc	a2,0x10
    802061bc:	5e860613          	addi	a2,a2,1512 # 802167a0 <__func__.3>
    802061c0:	08300593          	li	a1,131
    802061c4:	0000f517          	auipc	a0,0xf
    802061c8:	52450513          	addi	a0,a0,1316 # 802156e8 <__func__.0+0x38>
    802061cc:	ffffb097          	auipc	ra,0xffffb
    802061d0:	d8c080e7          	jalr	-628(ra) # 80200f58 <_assert_>
    Socket* local_sock = f->socket;
    802061d4:	02093903          	ld	s2,32(s2)
    *addr = local_sock->pending_queue[local_sock->pending_h++];
    802061d8:	1a092783          	lw	a5,416(s2)
    802061dc:	0017871b          	addiw	a4,a5,1
    802061e0:	1ae92023          	sw	a4,416(s2)
    802061e4:	00378793          	addi	a5,a5,3
    802061e8:	00579793          	slli	a5,a5,0x5
    802061ec:	00f907b3          	add	a5,s2,a5
    802061f0:	0007a883          	lw	a7,0(a5)
    802061f4:	0047a803          	lw	a6,4(a5)
    802061f8:	0087a503          	lw	a0,8(a5)
    802061fc:	00c7a583          	lw	a1,12(a5)
    80206200:	0107a603          	lw	a2,16(a5)
    80206204:	0147a683          	lw	a3,20(a5)
    80206208:	0187a703          	lw	a4,24(a5)
    8020620c:	01c7a783          	lw	a5,28(a5)
    80206210:	0114a023          	sw	a7,0(s1)
    80206214:	0104a223          	sw	a6,4(s1)
    80206218:	00a4a423          	sw	a0,8(s1)
    8020621c:	00b4a623          	sw	a1,12(s1)
    80206220:	00c4a823          	sw	a2,16(s1)
    80206224:	00d4aa23          	sw	a3,20(s1)
    80206228:	00e4ac23          	sw	a4,24(s1)
    8020622c:	00f4ae23          	sw	a5,28(s1)

    Socket* new_sock;
    socketAlloc(&new_sock);
    80206230:	fc840513          	addi	a0,s0,-56
    80206234:	fffff097          	auipc	ra,0xfffff
    80206238:	708080e7          	jalr	1800(ra) # 8020593c <socketAlloc>
    new_sock->addr = local_sock->addr;
    8020623c:	fc843783          	ld	a5,-56(s0)
    80206240:	01093583          	ld	a1,16(s2)
    80206244:	01893603          	ld	a2,24(s2)
    80206248:	02093683          	ld	a3,32(s2)
    8020624c:	02893703          	ld	a4,40(s2)
    80206250:	00b7b823          	sd	a1,16(a5)
    80206254:	00c7bc23          	sd	a2,24(a5)
    80206258:	02d7b023          	sd	a3,32(a5)
    8020625c:	02e7b423          	sd	a4,40(a5)
    new_sock->target_addr = *addr;
    80206260:	0004a303          	lw	t1,0(s1)
    80206264:	0044a883          	lw	a7,4(s1)
    80206268:	0084a803          	lw	a6,8(s1)
    8020626c:	00c4a503          	lw	a0,12(s1)
    80206270:	0104a583          	lw	a1,16(s1)
    80206274:	0144a603          	lw	a2,20(s1)
    80206278:	0184a683          	lw	a3,24(s1)
    8020627c:	01c4a703          	lw	a4,28(s1)
    80206280:	0267a823          	sw	t1,48(a5)
    80206284:	0317aa23          	sw	a7,52(a5)
    80206288:	0307ac23          	sw	a6,56(a5)
    8020628c:	02a7ae23          	sw	a0,60(a5)
    80206290:	04b7a023          	sw	a1,64(a5)
    80206294:	04c7a223          	sw	a2,68(a5)
    80206298:	04d7a423          	sw	a3,72(a5)
    8020629c:	04e7a623          	sw	a4,76(a5)

    File* new_f = filealloc();
    802062a0:	ffffe097          	auipc	ra,0xffffe
    802062a4:	c0c080e7          	jalr	-1012(ra) # 80203eac <filealloc>
    802062a8:	00050993          	mv	s3,a0
    assert(new_f != NULL);
    802062ac:	00a036b3          	snez	a3,a0
    802062b0:	00010617          	auipc	a2,0x10
    802062b4:	4f060613          	addi	a2,a2,1264 # 802167a0 <__func__.3>
    802062b8:	08d00593          	li	a1,141
    802062bc:	0000f517          	auipc	a0,0xf
    802062c0:	42c50513          	addi	a0,a0,1068 # 802156e8 <__func__.0+0x38>
    802062c4:	ffffb097          	auipc	ra,0xffffb
    802062c8:	c94080e7          	jalr	-876(ra) # 80200f58 <_assert_>
    new_f->socket = local_sock;
    802062cc:	0329b023          	sd	s2,32(s3)
    new_f->type = FD_SOCKET;
    802062d0:	00400793          	li	a5,4
    802062d4:	00f9a023          	sw	a5,0(s3)
    new_f->readable = new_f->writable = true;
    802062d8:	00100793          	li	a5,1
    802062dc:	00f984a3          	sb	a5,9(s3)
    802062e0:	00f98423          	sb	a5,8(s3)

/* ----------- process Remote Host --------- */

    Socket * peer_sock = remote_find_socket(addr);
    802062e4:	00048513          	mv	a0,s1
    802062e8:	fffff097          	auipc	ra,0xfffff
    802062ec:	5ec080e7          	jalr	1516(ra) # 802058d4 <remote_find_socket>
    peer_sock -> target_addr  = local_sock->addr;
    802062f0:	01093603          	ld	a2,16(s2)
    802062f4:	01893683          	ld	a3,24(s2)
    802062f8:	02093703          	ld	a4,32(s2)
    802062fc:	02893783          	ld	a5,40(s2)
    80206300:	02c53823          	sd	a2,48(a0)
    80206304:	02d53c23          	sd	a3,56(a0)
    80206308:	04e53023          	sd	a4,64(a0)
    8020630c:	04f53423          	sd	a5,72(a0)
    
/* ----------- process Remote Host --------- */

    return fdalloc(new_f);
    80206310:	00098513          	mv	a0,s3
    80206314:	00000097          	auipc	ra,0x0
    80206318:	238080e7          	jalr	568(ra) # 8020654c <fdalloc>
}
    8020631c:	03813083          	ld	ra,56(sp)
    80206320:	03013403          	ld	s0,48(sp)
    80206324:	02813483          	ld	s1,40(sp)
    80206328:	02013903          	ld	s2,32(sp)
    8020632c:	01813983          	ld	s3,24(sp)
    80206330:	04010113          	addi	sp,sp,64
    80206334:	00008067          	ret

0000000080206338 <connect>:

/**
 * @brief The connect() system call connects the socket referred to by the
 * file descriptor sockfd to the address specified by addr. 
 */
int connect(int sockfd, const SocketAddr* addr) {
    80206338:	fe010113          	addi	sp,sp,-32
    8020633c:	00113c23          	sd	ra,24(sp)
    80206340:	00813823          	sd	s0,16(sp)
    80206344:	00913423          	sd	s1,8(sp)
    80206348:	01213023          	sd	s2,0(sp)
    8020634c:	02010413          	addi	s0,sp,32
    80206350:	00050493          	mv	s1,a0
    80206354:	00058913          	mv	s2,a1
    printf("[%s] fd %d addr %lx port %x\n", __func__, sockfd, addr->addr,
    80206358:	0025d703          	lhu	a4,2(a1)
    8020635c:	0045a683          	lw	a3,4(a1)
    80206360:	00050613          	mv	a2,a0
    80206364:	00010597          	auipc	a1,0x10
    80206368:	43458593          	addi	a1,a1,1076 # 80216798 <__func__.2>
    8020636c:	0000f517          	auipc	a0,0xf
    80206370:	3fc50513          	addi	a0,a0,1020 # 80215768 <__func__.0+0xb8>
    80206374:	ffffb097          	auipc	ra,0xffffb
    80206378:	adc080e7          	jalr	-1316(ra) # 80200e50 <printf>
           addr->port);
    File* f = myProcess()->ofile[sockfd];
    8020637c:	00009097          	auipc	ra,0x9
    80206380:	66c080e7          	jalr	1644(ra) # 8020f9e8 <myProcess>
    80206384:	00e48493          	addi	s1,s1,14
    80206388:	00349493          	slli	s1,s1,0x3
    8020638c:	00950533          	add	a0,a0,s1
    80206390:	00053483          	ld	s1,0(a0)
    assert(f->type == FD_SOCKET);
    80206394:	0004a683          	lw	a3,0(s1)
    80206398:	ffc68693          	addi	a3,a3,-4
    8020639c:	0016b693          	seqz	a3,a3
    802063a0:	00010617          	auipc	a2,0x10
    802063a4:	3f860613          	addi	a2,a2,1016 # 80216798 <__func__.2>
    802063a8:	0ae00593          	li	a1,174
    802063ac:	0000f517          	auipc	a0,0xf
    802063b0:	33c50513          	addi	a0,a0,828 # 802156e8 <__func__.0+0x38>
    802063b4:	ffffb097          	auipc	ra,0xffffb
    802063b8:	ba4080e7          	jalr	-1116(ra) # 80200f58 <_assert_>

    Socket* local_sock = f->socket;
    802063bc:	0204b483          	ld	s1,32(s1)
    addr.port = local_port++;
    802063c0:	001f9717          	auipc	a4,0x1f9
    802063c4:	c4470713          	addi	a4,a4,-956 # 803ff004 <local_port.0>
    802063c8:	00072783          	lw	a5,0(a4)
    802063cc:	0017869b          	addiw	a3,a5,1
    802063d0:	00d72023          	sw	a3,0(a4)
    802063d4:	00f49923          	sh	a5,18(s1)
    local_sock->addr = gen_local_socket_addr();
    802063d8:	7f0007b7          	lui	a5,0x7f000
    802063dc:	00178793          	addi	a5,a5,1 # 7f000001 <_start-0x11fffff>
    802063e0:	00f4aa23          	sw	a5,20(s1)
    local_sock->target_addr = *addr;
    802063e4:	00092883          	lw	a7,0(s2)
    802063e8:	00492803          	lw	a6,4(s2)
    802063ec:	00892503          	lw	a0,8(s2)
    802063f0:	00c92583          	lw	a1,12(s2)
    802063f4:	01092603          	lw	a2,16(s2)
    802063f8:	01492683          	lw	a3,20(s2)
    802063fc:	01892703          	lw	a4,24(s2)
    80206400:	01c92783          	lw	a5,28(s2)
    80206404:	0314a823          	sw	a7,48(s1)
    80206408:	0304aa23          	sw	a6,52(s1)
    8020640c:	02a4ac23          	sw	a0,56(s1)
    80206410:	02b4ae23          	sw	a1,60(s1)
    80206414:	04c4a023          	sw	a2,64(s1)
    80206418:	04d4a223          	sw	a3,68(s1)
    8020641c:	04e4a423          	sw	a4,72(s1)
    80206420:	04f4a623          	sw	a5,76(s1)
 
/* ----------- process Remote Host --------- */
    Socket* target_socket = remote_find_socket(addr);
    80206424:	00090513          	mv	a0,s2
    80206428:	fffff097          	auipc	ra,0xfffff
    8020642c:	4ac080e7          	jalr	1196(ra) # 802058d4 <remote_find_socket>
    if (target_socket == NULL) {
    80206430:	04050c63          	beqz	a0,80206488 <connect+0x150>
        printf("remote socket don't exists!");
        return -1;
    }
    target_socket->pending_queue[target_socket->pending_t++] = local_sock->addr;
    80206434:	1a452783          	lw	a5,420(a0)
    80206438:	0017871b          	addiw	a4,a5,1
    8020643c:	1ae52223          	sw	a4,420(a0)
    80206440:	00378793          	addi	a5,a5,3
    80206444:	00579793          	slli	a5,a5,0x5
    80206448:	00f50533          	add	a0,a0,a5
    8020644c:	0104b603          	ld	a2,16(s1)
    80206450:	0184b683          	ld	a3,24(s1)
    80206454:	0204b703          	ld	a4,32(s1)
    80206458:	0284b783          	ld	a5,40(s1)
    8020645c:	00c53023          	sd	a2,0(a0)
    80206460:	00d53423          	sd	a3,8(a0)
    80206464:	00e53823          	sd	a4,16(a0)
    80206468:	00f53c23          	sd	a5,24(a0)

/* ----------- process Remote Host --------- */



    return 0;
    8020646c:	00000513          	li	a0,0
    80206470:	01813083          	ld	ra,24(sp)
    80206474:	01013403          	ld	s0,16(sp)
    80206478:	00813483          	ld	s1,8(sp)
    8020647c:	00013903          	ld	s2,0(sp)
    80206480:	02010113          	addi	sp,sp,32
    80206484:	00008067          	ret
        printf("remote socket don't exists!");
    80206488:	0000f517          	auipc	a0,0xf
    8020648c:	30050513          	addi	a0,a0,768 # 80215788 <__func__.0+0xd8>
    80206490:	ffffb097          	auipc	ra,0xffffb
    80206494:	9c0080e7          	jalr	-1600(ra) # 80200e50 <printf>
        return -1;
    80206498:	fff00513          	li	a0,-1
    8020649c:	fd5ff06f          	j	80206470 <connect+0x138>

00000000802064a0 <argfd>:
#include <Fcntl.h>
#include <Error.h>

// Fetch the nth word-sized system call argument as a file descriptor
// and return both the descriptor and the corresponding struct file.
int argfd(int n, int* pfd, struct File** pf) {
    802064a0:	fd010113          	addi	sp,sp,-48
    802064a4:	02113423          	sd	ra,40(sp)
    802064a8:	02813023          	sd	s0,32(sp)
    802064ac:	00913c23          	sd	s1,24(sp)
    802064b0:	01213823          	sd	s2,16(sp)
    802064b4:	03010413          	addi	s0,sp,48
    802064b8:	00058913          	mv	s2,a1
    802064bc:	00060493          	mv	s1,a2
    int fd;
    struct File* f;

    if (argint(n, &fd) < 0)
    802064c0:	fdc40593          	addi	a1,s0,-36
    802064c4:	00006097          	auipc	ra,0x6
    802064c8:	f4c080e7          	jalr	-180(ra) # 8020c410 <argint>
    802064cc:	06054c63          	bltz	a0,80206544 <argfd+0xa4>
        return -1;
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802064d0:	fdc42703          	lw	a4,-36(s0)
    802064d4:	3ff00793          	li	a5,1023
    802064d8:	04e7e863          	bltu	a5,a4,80206528 <argfd+0x88>
    802064dc:	00009097          	auipc	ra,0x9
    802064e0:	50c080e7          	jalr	1292(ra) # 8020f9e8 <myProcess>
    802064e4:	fdc42703          	lw	a4,-36(s0)
    802064e8:	00e70793          	addi	a5,a4,14
    802064ec:	00379793          	slli	a5,a5,0x3
    802064f0:	00f50533          	add	a0,a0,a5
    802064f4:	00053783          	ld	a5,0(a0)
    802064f8:	02078863          	beqz	a5,80206528 <argfd+0x88>
            *pfd = -1;
        if (pf)
            *pf = NULL;
        return -1;
    }
    if (pfd)
    802064fc:	00090463          	beqz	s2,80206504 <argfd+0x64>
        *pfd = fd;
    80206500:	00e92023          	sw	a4,0(s2)
    if (pf)
        *pf = f;
    return 0;
    80206504:	00000513          	li	a0,0
    if (pf)
    80206508:	00048463          	beqz	s1,80206510 <argfd+0x70>
        *pf = f;
    8020650c:	00f4b023          	sd	a5,0(s1)
}
    80206510:	02813083          	ld	ra,40(sp)
    80206514:	02013403          	ld	s0,32(sp)
    80206518:	01813483          	ld	s1,24(sp)
    8020651c:	01013903          	ld	s2,16(sp)
    80206520:	03010113          	addi	sp,sp,48
    80206524:	00008067          	ret
        if (pfd)
    80206528:	00090663          	beqz	s2,80206534 <argfd+0x94>
            *pfd = -1;
    8020652c:	fff00793          	li	a5,-1
    80206530:	00f92023          	sw	a5,0(s2)
        return -1;
    80206534:	fff00513          	li	a0,-1
        if (pf)
    80206538:	fc048ce3          	beqz	s1,80206510 <argfd+0x70>
            *pf = NULL;
    8020653c:	0004b023          	sd	zero,0(s1)
    80206540:	fd1ff06f          	j	80206510 <argfd+0x70>
        return -1;
    80206544:	fff00513          	li	a0,-1
    80206548:	fc9ff06f          	j	80206510 <argfd+0x70>

000000008020654c <fdalloc>:

// Allocate a file descriptor for the given file.
// Takes over file reference from caller on success.
int fdalloc(struct File* f) {
    8020654c:	fe010113          	addi	sp,sp,-32
    80206550:	00113c23          	sd	ra,24(sp)
    80206554:	00813823          	sd	s0,16(sp)
    80206558:	00913423          	sd	s1,8(sp)
    8020655c:	02010413          	addi	s0,sp,32
    80206560:	00050493          	mv	s1,a0
    int fd;
    struct Process* p = myProcess();
    80206564:	00009097          	auipc	ra,0x9
    80206568:	484080e7          	jalr	1156(ra) # 8020f9e8 <myProcess>
    
    for (fd = 0; fd < p->fileDescription.hard; fd++) {
    8020656c:	000027b7          	lui	a5,0x2
    80206570:	00f507b3          	add	a5,a0,a5
    80206574:	0a07b603          	ld	a2,160(a5) # 20a0 <_start-0x801fdf60>
    80206578:	04060a63          	beqz	a2,802065cc <fdalloc+0x80>
    8020657c:	00050593          	mv	a1,a0
    80206580:	07050713          	addi	a4,a0,112
    80206584:	00000793          	li	a5,0
    80206588:	0007851b          	sext.w	a0,a5
        if (p->ofile[fd] == 0) {
    8020658c:	00073683          	ld	a3,0(a4)
    80206590:	00068c63          	beqz	a3,802065a8 <fdalloc+0x5c>
    for (fd = 0; fd < p->fileDescription.hard; fd++) {
    80206594:	00178793          	addi	a5,a5,1
    80206598:	00870713          	addi	a4,a4,8
    8020659c:	fec796e3          	bne	a5,a2,80206588 <fdalloc+0x3c>
            p->ofile[fd] = f;
            return fd;
        }
    }
    return -1;
    802065a0:	fff00513          	li	a0,-1
    802065a4:	0140006f          	j	802065b8 <fdalloc+0x6c>
            p->ofile[fd] = f;
    802065a8:	00e50793          	addi	a5,a0,14
    802065ac:	00379793          	slli	a5,a5,0x3
    802065b0:	00f585b3          	add	a1,a1,a5
    802065b4:	0095b023          	sd	s1,0(a1)
}
    802065b8:	01813083          	ld	ra,24(sp)
    802065bc:	01013403          	ld	s0,16(sp)
    802065c0:	00813483          	ld	s1,8(sp)
    802065c4:	02010113          	addi	sp,sp,32
    802065c8:	00008067          	ret
    return -1;
    802065cc:	fff00513          	li	a0,-1
    802065d0:	fe9ff06f          	j	802065b8 <fdalloc+0x6c>

00000000802065d4 <syscallDup>:

void syscallDup(void) {
    802065d4:	fd010113          	addi	sp,sp,-48
    802065d8:	02113423          	sd	ra,40(sp)
    802065dc:	02813023          	sd	s0,32(sp)
    802065e0:	00913c23          	sd	s1,24(sp)
    802065e4:	01213823          	sd	s2,16(sp)
    802065e8:	01313423          	sd	s3,8(sp)
    802065ec:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    802065f0:	00004097          	auipc	ra,0x4
    802065f4:	bec080e7          	jalr	-1044(ra) # 8020a1dc <getHartTrapFrame>
    802065f8:	00050913          	mv	s2,a0
    struct File* f;
    int fd = tf->a0;
    802065fc:	07053483          	ld	s1,112(a0)
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206600:	0004871b          	sext.w	a4,s1
    80206604:	3ff00793          	li	a5,1023
    80206608:	02e7f463          	bgeu	a5,a4,80206630 <syscallDup+0x5c>
        tf->a0 = -1;
        return;
    8020660c:	fff00793          	li	a5,-1
        tf->a0 = -1;
    80206610:	06f93823          	sd	a5,112(s2)

    filedup(f);
    tf->a0 = fd;

   // printf("%s %d %d\n", __FILE__, __LINE__, fd);
}
    80206614:	02813083          	ld	ra,40(sp)
    80206618:	02013403          	ld	s0,32(sp)
    8020661c:	01813483          	ld	s1,24(sp)
    80206620:	01013903          	ld	s2,16(sp)
    80206624:	00813983          	ld	s3,8(sp)
    80206628:	03010113          	addi	sp,sp,48
    8020662c:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206630:	00009097          	auipc	ra,0x9
    80206634:	3b8080e7          	jalr	952(ra) # 8020f9e8 <myProcess>
    80206638:	0004849b          	sext.w	s1,s1
    8020663c:	00e48493          	addi	s1,s1,14
    80206640:	00349493          	slli	s1,s1,0x3
    80206644:	00950533          	add	a0,a0,s1
    80206648:	00053983          	ld	s3,0(a0)
    8020664c:	fc0980e3          	beqz	s3,8020660c <syscallDup+0x38>
    if ((fd = fdalloc(f)) < 0) {
    80206650:	00098513          	mv	a0,s3
    80206654:	00000097          	auipc	ra,0x0
    80206658:	ef8080e7          	jalr	-264(ra) # 8020654c <fdalloc>
    8020665c:	00050493          	mv	s1,a0
    80206660:	fe800793          	li	a5,-24
    80206664:	fa0546e3          	bltz	a0,80206610 <syscallDup+0x3c>
    filedup(f);
    80206668:	00098513          	mv	a0,s3
    8020666c:	ffffe097          	auipc	ra,0xffffe
    80206670:	888080e7          	jalr	-1912(ra) # 80203ef4 <filedup>
    tf->a0 = fd;
    80206674:	00048793          	mv	a5,s1
    80206678:	f99ff06f          	j	80206610 <syscallDup+0x3c>

000000008020667c <syscallDupAndSet>:

void syscallDupAndSet(void) {
    8020667c:	fd010113          	addi	sp,sp,-48
    80206680:	02113423          	sd	ra,40(sp)
    80206684:	02813023          	sd	s0,32(sp)
    80206688:	00913c23          	sd	s1,24(sp)
    8020668c:	01213823          	sd	s2,16(sp)
    80206690:	01313423          	sd	s3,8(sp)
    80206694:	01413023          	sd	s4,0(sp)
    80206698:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    8020669c:	00004097          	auipc	ra,0x4
    802066a0:	b40080e7          	jalr	-1216(ra) # 8020a1dc <getHartTrapFrame>
    802066a4:	00050493          	mv	s1,a0
    struct File* f, *f2;
    int fd = tf->a0, fdnew = tf->a1;
    802066a8:	07053903          	ld	s2,112(a0)
    802066ac:	07853983          	ld	s3,120(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802066b0:	0009071b          	sext.w	a4,s2
    802066b4:	3ff00793          	li	a5,1023
    802066b8:	02e7f663          	bgeu	a5,a4,802066e4 <syscallDupAndSet+0x68>
        tf->a0 = -1;
        return;
    802066bc:	fff00793          	li	a5,-1
        tf->a0 = -1;
    802066c0:	06f4b823          	sd	a5,112(s1)
    }

    myProcess()->ofile[fdnew] = f;
    filedup(f);
    tf->a0 = fdnew;
}
    802066c4:	02813083          	ld	ra,40(sp)
    802066c8:	02013403          	ld	s0,32(sp)
    802066cc:	01813483          	ld	s1,24(sp)
    802066d0:	01013903          	ld	s2,16(sp)
    802066d4:	00813983          	ld	s3,8(sp)
    802066d8:	00013a03          	ld	s4,0(sp)
    802066dc:	03010113          	addi	sp,sp,48
    802066e0:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802066e4:	00009097          	auipc	ra,0x9
    802066e8:	304080e7          	jalr	772(ra) # 8020f9e8 <myProcess>
    802066ec:	0009091b          	sext.w	s2,s2
    802066f0:	00e90913          	addi	s2,s2,14
    802066f4:	00391913          	slli	s2,s2,0x3
    802066f8:	01250533          	add	a0,a0,s2
    802066fc:	00053a03          	ld	s4,0(a0)
    80206700:	fa0a0ee3          	beqz	s4,802066bc <syscallDupAndSet+0x40>
    if (fdnew < 0 || fdnew >= NOFILE) {
    80206704:	0009871b          	sext.w	a4,s3
    80206708:	3ff00693          	li	a3,1023
    8020670c:	fff00793          	li	a5,-1
    80206710:	fae6e8e3          	bltu	a3,a4,802066c0 <syscallDupAndSet+0x44>
    int fd = tf->a0, fdnew = tf->a1;
    80206714:	00070993          	mv	s3,a4
    if ((f2 = myProcess()->ofile[fdnew]) != NULL) {
    80206718:	00009097          	auipc	ra,0x9
    8020671c:	2d0080e7          	jalr	720(ra) # 8020f9e8 <myProcess>
    80206720:	00e98793          	addi	a5,s3,14
    80206724:	00379793          	slli	a5,a5,0x3
    80206728:	00f50533          	add	a0,a0,a5
    8020672c:	00053503          	ld	a0,0(a0)
    80206730:	00050663          	beqz	a0,8020673c <syscallDupAndSet+0xc0>
        fileclose(f2);
    80206734:	ffffe097          	auipc	ra,0xffffe
    80206738:	808080e7          	jalr	-2040(ra) # 80203f3c <fileclose>
    myProcess()->ofile[fdnew] = f;
    8020673c:	00009097          	auipc	ra,0x9
    80206740:	2ac080e7          	jalr	684(ra) # 8020f9e8 <myProcess>
    80206744:	00e98793          	addi	a5,s3,14
    80206748:	00379793          	slli	a5,a5,0x3
    8020674c:	00f50533          	add	a0,a0,a5
    80206750:	01453023          	sd	s4,0(a0)
    filedup(f);
    80206754:	000a0513          	mv	a0,s4
    80206758:	ffffd097          	auipc	ra,0xffffd
    8020675c:	79c080e7          	jalr	1948(ra) # 80203ef4 <filedup>
    tf->a0 = fdnew;
    80206760:	00098793          	mv	a5,s3
    80206764:	f5dff06f          	j	802066c0 <syscallDupAndSet+0x44>

0000000080206768 <syscall_fcntl>:

void syscall_fcntl(void){
    80206768:	fd010113          	addi	sp,sp,-48
    8020676c:	02113423          	sd	ra,40(sp)
    80206770:	02813023          	sd	s0,32(sp)
    80206774:	00913c23          	sd	s1,24(sp)
    80206778:	01213823          	sd	s2,16(sp)
    8020677c:	01313423          	sd	s3,8(sp)
    80206780:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    80206784:	00004097          	auipc	ra,0x4
    80206788:	a58080e7          	jalr	-1448(ra) # 8020a1dc <getHartTrapFrame>
    8020678c:	00050913          	mv	s2,a0
    struct File* f;
    int fd = tf->a0/*, cmd = tf->a1, flag = tf->a2*/;
    80206790:	07053483          	ld	s1,112(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206794:	0004871b          	sext.w	a4,s1
    80206798:	3ff00793          	li	a5,1023
    8020679c:	02e7f463          	bgeu	a5,a4,802067c4 <syscall_fcntl+0x5c>
        tf->a0 = -1;
        return;
    802067a0:	fff00493          	li	s1,-1
        tf->a0 = -1;
    802067a4:	06993823          	sd	s1,112(s2)
    }

    // printf("syscall_fcntl fd:%x cmd:%x flag:%x\n", fd, cmd, flag);
    tf->a0 = 0;
    return;
}
    802067a8:	02813083          	ld	ra,40(sp)
    802067ac:	02013403          	ld	s0,32(sp)
    802067b0:	01813483          	ld	s1,24(sp)
    802067b4:	01013903          	ld	s2,16(sp)
    802067b8:	00813983          	ld	s3,8(sp)
    802067bc:	03010113          	addi	sp,sp,48
    802067c0:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802067c4:	00009097          	auipc	ra,0x9
    802067c8:	224080e7          	jalr	548(ra) # 8020f9e8 <myProcess>
    802067cc:	0004849b          	sext.w	s1,s1
    802067d0:	00e48493          	addi	s1,s1,14
    802067d4:	00349493          	slli	s1,s1,0x3
    802067d8:	00950533          	add	a0,a0,s1
    802067dc:	00053983          	ld	s3,0(a0)
    802067e0:	fc0980e3          	beqz	s3,802067a0 <syscall_fcntl+0x38>
    switch (tf->a1)
    802067e4:	07893483          	ld	s1,120(s2)
    802067e8:	00300793          	li	a5,3
    802067ec:	0af48063          	beq	s1,a5,8020688c <syscall_fcntl+0x124>
    802067f0:	0097ee63          	bltu	a5,s1,8020680c <syscall_fcntl+0xa4>
    802067f4:	00100793          	li	a5,1
    802067f8:	faf486e3          	beq	s1,a5,802067a4 <syscall_fcntl+0x3c>
    802067fc:	00200793          	li	a5,2
    80206800:	06f49263          	bne	s1,a5,80206864 <syscall_fcntl+0xfc>
    80206804:	00000493          	li	s1,0
    80206808:	f9dff06f          	j	802067a4 <syscall_fcntl+0x3c>
    8020680c:	00400793          	li	a5,4
    80206810:	02f48663          	beq	s1,a5,8020683c <syscall_fcntl+0xd4>
    80206814:	40600793          	li	a5,1030
    80206818:	04f49663          	bne	s1,a5,80206864 <syscall_fcntl+0xfc>
        fd = fdalloc(f);
    8020681c:	00098513          	mv	a0,s3
    80206820:	00000097          	auipc	ra,0x0
    80206824:	d2c080e7          	jalr	-724(ra) # 8020654c <fdalloc>
    80206828:	00050493          	mv	s1,a0
        filedup(f);
    8020682c:	00098513          	mv	a0,s3
    80206830:	ffffd097          	auipc	ra,0xffffd
    80206834:	6c4080e7          	jalr	1732(ra) # 80203ef4 <filedup>
        return;
    80206838:	f6dff06f          	j	802067a4 <syscall_fcntl+0x3c>
        fd = fdalloc(f);
    8020683c:	00098513          	mv	a0,s3
    80206840:	00000097          	auipc	ra,0x0
    80206844:	d0c080e7          	jalr	-756(ra) # 8020654c <fdalloc>
        printf("set file flag, bug not impl. flag :%x\n",flag);
    80206848:	08092583          	lw	a1,128(s2)
    8020684c:	0000f517          	auipc	a0,0xf
    80206850:	fac50513          	addi	a0,a0,-84 # 802157f8 <__func__.5+0x10>
    80206854:	ffffa097          	auipc	ra,0xffffa
    80206858:	5fc080e7          	jalr	1532(ra) # 80200e50 <printf>
    return;
    8020685c:	00000493          	li	s1,0
    80206860:	f45ff06f          	j	802067a4 <syscall_fcntl+0x3c>
        panic("%d\n", tf->a1);
    80206864:	00048713          	mv	a4,s1
    80206868:	0000f697          	auipc	a3,0xf
    8020686c:	77868693          	addi	a3,a3,1912 # 80215fe0 <__func__.5+0x170>
    80206870:	0000f617          	auipc	a2,0xf
    80206874:	04060613          	addi	a2,a2,64 # 802158b0 <__func__.5>
    80206878:	08800593          	li	a1,136
    8020687c:	0000f517          	auipc	a0,0xf
    80206880:	fa450513          	addi	a0,a0,-92 # 80215820 <__func__.5+0x38>
    80206884:	ffffa097          	auipc	ra,0xffffa
    80206888:	664080e7          	jalr	1636(ra) # 80200ee8 <_panic_>
    switch (tf->a1)
    8020688c:	00001737          	lui	a4,0x1
    80206890:	80070493          	addi	s1,a4,-2048 # 800 <_start-0x801ff800>
    80206894:	f11ff06f          	j	802067a4 <syscall_fcntl+0x3c>

0000000080206898 <syscallRead>:

void syscallRead(void) {
    80206898:	fd010113          	addi	sp,sp,-48
    8020689c:	02113423          	sd	ra,40(sp)
    802068a0:	02813023          	sd	s0,32(sp)
    802068a4:	00913c23          	sd	s1,24(sp)
    802068a8:	01213823          	sd	s2,16(sp)
    802068ac:	01313423          	sd	s3,8(sp)
    802068b0:	01413023          	sd	s4,0(sp)
    802068b4:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    802068b8:	00004097          	auipc	ra,0x4
    802068bc:	924080e7          	jalr	-1756(ra) # 8020a1dc <getHartTrapFrame>
    802068c0:	00050493          	mv	s1,a0
    struct File* f;
    int len = tf->a2, fd = tf->a0;
    802068c4:	08053983          	ld	s3,128(a0)
    802068c8:	07053903          	ld	s2,112(a0)
    u64 uva = tf->a1;
    802068cc:	07853a03          	ld	s4,120(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802068d0:	0009071b          	sext.w	a4,s2
    802068d4:	3ff00793          	li	a5,1023
    802068d8:	02e7f663          	bgeu	a5,a4,80206904 <syscallRead+0x6c>
        tf->a0 = -1;
        return;
    802068dc:	fff00793          	li	a5,-1
        tf->a0 = -1;
    802068e0:	06f4b823          	sd	a5,112(s1)
        tf->a0 = -1;
        return;
    }

    tf->a0 = fileread(f, true, uva, len);
}
    802068e4:	02813083          	ld	ra,40(sp)
    802068e8:	02013403          	ld	s0,32(sp)
    802068ec:	01813483          	ld	s1,24(sp)
    802068f0:	01013903          	ld	s2,16(sp)
    802068f4:	00813983          	ld	s3,8(sp)
    802068f8:	00013a03          	ld	s4,0(sp)
    802068fc:	03010113          	addi	sp,sp,48
    80206900:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206904:	00009097          	auipc	ra,0x9
    80206908:	0e4080e7          	jalr	228(ra) # 8020f9e8 <myProcess>
    8020690c:	0009091b          	sext.w	s2,s2
    80206910:	00e90913          	addi	s2,s2,14
    80206914:	00391913          	slli	s2,s2,0x3
    80206918:	01250533          	add	a0,a0,s2
    8020691c:	00053503          	ld	a0,0(a0)
    80206920:	fa050ee3          	beqz	a0,802068dc <syscallRead+0x44>
    int len = tf->a2, fd = tf->a0;
    80206924:	0009869b          	sext.w	a3,s3
    if (len < 0) {
    80206928:	fff00793          	li	a5,-1
    8020692c:	fa06cae3          	bltz	a3,802068e0 <syscallRead+0x48>
    tf->a0 = fileread(f, true, uva, len);
    80206930:	000a0613          	mv	a2,s4
    80206934:	00100593          	li	a1,1
    80206938:	ffffd097          	auipc	ra,0xffffd
    8020693c:	768080e7          	jalr	1896(ra) # 802040a0 <fileread>
    80206940:	00050793          	mv	a5,a0
    80206944:	f9dff06f          	j	802068e0 <syscallRead+0x48>

0000000080206948 <syscallWrite>:

void syscallWrite(void) {
    80206948:	fd010113          	addi	sp,sp,-48
    8020694c:	02113423          	sd	ra,40(sp)
    80206950:	02813023          	sd	s0,32(sp)
    80206954:	00913c23          	sd	s1,24(sp)
    80206958:	01213823          	sd	s2,16(sp)
    8020695c:	01313423          	sd	s3,8(sp)
    80206960:	01413023          	sd	s4,0(sp)
    80206964:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    80206968:	00004097          	auipc	ra,0x4
    8020696c:	874080e7          	jalr	-1932(ra) # 8020a1dc <getHartTrapFrame>
    80206970:	00050493          	mv	s1,a0
    struct File* f;
    int len = tf->a2, fd = tf->a0;
    80206974:	08053983          	ld	s3,128(a0)
    80206978:	07053903          	ld	s2,112(a0)
    u64 uva = tf->a1;
    8020697c:	07853a03          	ld	s4,120(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206980:	0009071b          	sext.w	a4,s2
    80206984:	3ff00793          	li	a5,1023
    80206988:	02e7f663          	bgeu	a5,a4,802069b4 <syscallWrite+0x6c>
        tf->a0 = -1;
        return;
    8020698c:	fff00793          	li	a5,-1
        tf->a0 = -1;
    80206990:	06f4b823          	sd	a5,112(s1)
        tf->a0 = -1;
        return;
    }

    tf->a0 = filewrite(f, true, uva, len);
}
    80206994:	02813083          	ld	ra,40(sp)
    80206998:	02013403          	ld	s0,32(sp)
    8020699c:	01813483          	ld	s1,24(sp)
    802069a0:	01013903          	ld	s2,16(sp)
    802069a4:	00813983          	ld	s3,8(sp)
    802069a8:	00013a03          	ld	s4,0(sp)
    802069ac:	03010113          	addi	sp,sp,48
    802069b0:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    802069b4:	00009097          	auipc	ra,0x9
    802069b8:	034080e7          	jalr	52(ra) # 8020f9e8 <myProcess>
    802069bc:	0009091b          	sext.w	s2,s2
    802069c0:	00e90913          	addi	s2,s2,14
    802069c4:	00391913          	slli	s2,s2,0x3
    802069c8:	01250533          	add	a0,a0,s2
    802069cc:	00053503          	ld	a0,0(a0)
    802069d0:	fa050ee3          	beqz	a0,8020698c <syscallWrite+0x44>
    int len = tf->a2, fd = tf->a0;
    802069d4:	0009869b          	sext.w	a3,s3
    if (len < 0) {
    802069d8:	fff00793          	li	a5,-1
    802069dc:	fa06cae3          	bltz	a3,80206990 <syscallWrite+0x48>
    tf->a0 = filewrite(f, true, uva, len);
    802069e0:	000a0613          	mv	a2,s4
    802069e4:	00100593          	li	a1,1
    802069e8:	ffffd097          	auipc	ra,0xffffd
    802069ec:	7e0080e7          	jalr	2016(ra) # 802041c8 <filewrite>
    802069f0:	00050793          	mv	a5,a0
    802069f4:	f9dff06f          	j	80206990 <syscallWrite+0x48>

00000000802069f8 <syscallWriteVector>:

void syscallWriteVector() {
    802069f8:	bc010113          	addi	sp,sp,-1088
    802069fc:	42113c23          	sd	ra,1080(sp)
    80206a00:	42813823          	sd	s0,1072(sp)
    80206a04:	42913423          	sd	s1,1064(sp)
    80206a08:	43213023          	sd	s2,1056(sp)
    80206a0c:	41313c23          	sd	s3,1048(sp)
    80206a10:	41413823          	sd	s4,1040(sp)
    80206a14:	41513423          	sd	s5,1032(sp)
    80206a18:	44010413          	addi	s0,sp,1088
    Trapframe* tf = getHartTrapFrame();
    80206a1c:	00003097          	auipc	ra,0x3
    80206a20:	7c0080e7          	jalr	1984(ra) # 8020a1dc <getHartTrapFrame>
    80206a24:	00050493          	mv	s1,a0
    struct File* f;
    int fd = tf->a0;
    80206a28:	07053903          	ld	s2,112(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206a2c:	0009071b          	sext.w	a4,s2
    80206a30:	3ff00793          	li	a5,1023
    80206a34:	02e7f863          	bgeu	a5,a4,80206a64 <syscallWriteVector+0x6c>
    }
    tf->a0 = len;
    return;

bad:
    tf->a0 = -1;
    80206a38:	fff00993          	li	s3,-1
    80206a3c:	0734b823          	sd	s3,112(s1)
}
    80206a40:	43813083          	ld	ra,1080(sp)
    80206a44:	43013403          	ld	s0,1072(sp)
    80206a48:	42813483          	ld	s1,1064(sp)
    80206a4c:	42013903          	ld	s2,1056(sp)
    80206a50:	41813983          	ld	s3,1048(sp)
    80206a54:	41013a03          	ld	s4,1040(sp)
    80206a58:	40813a83          	ld	s5,1032(sp)
    80206a5c:	44010113          	addi	sp,sp,1088
    80206a60:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206a64:	00009097          	auipc	ra,0x9
    80206a68:	f84080e7          	jalr	-124(ra) # 8020f9e8 <myProcess>
    80206a6c:	0009091b          	sext.w	s2,s2
    80206a70:	00e90913          	addi	s2,s2,14
    80206a74:	00391913          	slli	s2,s2,0x3
    80206a78:	01250533          	add	a0,a0,s2
    80206a7c:	00053a83          	ld	s5,0(a0)
    80206a80:	fa0a8ce3          	beqz	s5,80206a38 <syscallWriteVector+0x40>
    int cnt = tf->a2;
    80206a84:	0804b783          	ld	a5,128(s1)
    if (cnt < 0 || cnt >= IOVMAX) {
    80206a88:	00078a1b          	sext.w	s4,a5
    80206a8c:	03f00713          	li	a4,63
    80206a90:	fb4764e3          	bltu	a4,s4,80206a38 <syscallWriteVector+0x40>
    struct Process* p = myProcess();
    80206a94:	00009097          	auipc	ra,0x9
    80206a98:	f54080e7          	jalr	-172(ra) # 8020f9e8 <myProcess>
    if (copyin(p->pgdir, (char*)vec, tf->a1, cnt * sizeof(struct Iovec)) != 0) {
    80206a9c:	004a1693          	slli	a3,s4,0x4
    80206aa0:	0784b603          	ld	a2,120(s1)
    80206aa4:	bc040593          	addi	a1,s0,-1088
    80206aa8:	04053503          	ld	a0,64(a0)
    80206aac:	00003097          	auipc	ra,0x3
    80206ab0:	f9c080e7          	jalr	-100(ra) # 80209a48 <copyin>
    80206ab4:	f80512e3          	bnez	a0,80206a38 <syscallWriteVector+0x40>
    for (int i = 0; i < cnt; i++) {
    80206ab8:	05405463          	blez	s4,80206b00 <syscallWriteVector+0x108>
    80206abc:	bc040913          	addi	s2,s0,-1088
    80206ac0:	fffa0a1b          	addiw	s4,s4,-1
    80206ac4:	020a1793          	slli	a5,s4,0x20
    80206ac8:	01c7da13          	srli	s4,a5,0x1c
    80206acc:	bd040793          	addi	a5,s0,-1072
    80206ad0:	00fa0a33          	add	s4,s4,a5
    u64 len = 0;
    80206ad4:	00000993          	li	s3,0
        len += filewrite(f, true, (u64)vec[i].iovBase, vec[i].iovLen);
    80206ad8:	00892683          	lw	a3,8(s2)
    80206adc:	00093603          	ld	a2,0(s2)
    80206ae0:	00100593          	li	a1,1
    80206ae4:	000a8513          	mv	a0,s5
    80206ae8:	ffffd097          	auipc	ra,0xffffd
    80206aec:	6e0080e7          	jalr	1760(ra) # 802041c8 <filewrite>
    80206af0:	00a989b3          	add	s3,s3,a0
    for (int i = 0; i < cnt; i++) {
    80206af4:	01090913          	addi	s2,s2,16
    80206af8:	ff4910e3          	bne	s2,s4,80206ad8 <syscallWriteVector+0xe0>
    80206afc:	f41ff06f          	j	80206a3c <syscallWriteVector+0x44>
    u64 len = 0;
    80206b00:	00000993          	li	s3,0
    return;
    80206b04:	f39ff06f          	j	80206a3c <syscallWriteVector+0x44>

0000000080206b08 <syscallReadVector>:

void syscallReadVector() {
    80206b08:	bc010113          	addi	sp,sp,-1088
    80206b0c:	42113c23          	sd	ra,1080(sp)
    80206b10:	42813823          	sd	s0,1072(sp)
    80206b14:	42913423          	sd	s1,1064(sp)
    80206b18:	43213023          	sd	s2,1056(sp)
    80206b1c:	41313c23          	sd	s3,1048(sp)
    80206b20:	41413823          	sd	s4,1040(sp)
    80206b24:	41513423          	sd	s5,1032(sp)
    80206b28:	44010413          	addi	s0,sp,1088
    Trapframe* tf = getHartTrapFrame();
    80206b2c:	00003097          	auipc	ra,0x3
    80206b30:	6b0080e7          	jalr	1712(ra) # 8020a1dc <getHartTrapFrame>
    80206b34:	00050493          	mv	s1,a0
    struct File* f;
    int fd = tf->a0;
    80206b38:	07053903          	ld	s2,112(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206b3c:	0009071b          	sext.w	a4,s2
    80206b40:	3ff00793          	li	a5,1023
    80206b44:	02e7f863          	bgeu	a5,a4,80206b74 <syscallReadVector+0x6c>
    }
    tf->a0 = len;
    return;

bad:
    tf->a0 = -1;
    80206b48:	fff00993          	li	s3,-1
    80206b4c:	0734b823          	sd	s3,112(s1)
}
    80206b50:	43813083          	ld	ra,1080(sp)
    80206b54:	43013403          	ld	s0,1072(sp)
    80206b58:	42813483          	ld	s1,1064(sp)
    80206b5c:	42013903          	ld	s2,1056(sp)
    80206b60:	41813983          	ld	s3,1048(sp)
    80206b64:	41013a03          	ld	s4,1040(sp)
    80206b68:	40813a83          	ld	s5,1032(sp)
    80206b6c:	44010113          	addi	sp,sp,1088
    80206b70:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206b74:	00009097          	auipc	ra,0x9
    80206b78:	e74080e7          	jalr	-396(ra) # 8020f9e8 <myProcess>
    80206b7c:	0009091b          	sext.w	s2,s2
    80206b80:	00e90913          	addi	s2,s2,14
    80206b84:	00391913          	slli	s2,s2,0x3
    80206b88:	01250533          	add	a0,a0,s2
    80206b8c:	00053a83          	ld	s5,0(a0)
    80206b90:	fa0a8ce3          	beqz	s5,80206b48 <syscallReadVector+0x40>
    int cnt = tf->a2;
    80206b94:	0804b783          	ld	a5,128(s1)
    if (cnt < 0 || cnt >= IOVMAX) {
    80206b98:	00078a1b          	sext.w	s4,a5
    80206b9c:	03f00713          	li	a4,63
    80206ba0:	fb4764e3          	bltu	a4,s4,80206b48 <syscallReadVector+0x40>
    struct Process* p = myProcess();
    80206ba4:	00009097          	auipc	ra,0x9
    80206ba8:	e44080e7          	jalr	-444(ra) # 8020f9e8 <myProcess>
    if (copyin(p->pgdir, (char*)vec, tf->a1, cnt * sizeof(struct Iovec)) != 0) {
    80206bac:	004a1693          	slli	a3,s4,0x4
    80206bb0:	0784b603          	ld	a2,120(s1)
    80206bb4:	bc040593          	addi	a1,s0,-1088
    80206bb8:	04053503          	ld	a0,64(a0)
    80206bbc:	00003097          	auipc	ra,0x3
    80206bc0:	e8c080e7          	jalr	-372(ra) # 80209a48 <copyin>
    80206bc4:	f80512e3          	bnez	a0,80206b48 <syscallReadVector+0x40>
    for (int i = 0; i < cnt; i++) {
    80206bc8:	05405463          	blez	s4,80206c10 <syscallReadVector+0x108>
    80206bcc:	bc040913          	addi	s2,s0,-1088
    80206bd0:	fffa0a1b          	addiw	s4,s4,-1
    80206bd4:	020a1793          	slli	a5,s4,0x20
    80206bd8:	01c7da13          	srli	s4,a5,0x1c
    80206bdc:	bd040793          	addi	a5,s0,-1072
    80206be0:	00fa0a33          	add	s4,s4,a5
    u64 len = 0;
    80206be4:	00000993          	li	s3,0
        len += fileread(f, true, (u64)vec[i].iovBase, vec[i].iovLen);
    80206be8:	00892683          	lw	a3,8(s2)
    80206bec:	00093603          	ld	a2,0(s2)
    80206bf0:	00100593          	li	a1,1
    80206bf4:	000a8513          	mv	a0,s5
    80206bf8:	ffffd097          	auipc	ra,0xffffd
    80206bfc:	4a8080e7          	jalr	1192(ra) # 802040a0 <fileread>
    80206c00:	00a989b3          	add	s3,s3,a0
    for (int i = 0; i < cnt; i++) {
    80206c04:	01090913          	addi	s2,s2,16
    80206c08:	ff4910e3          	bne	s2,s4,80206be8 <syscallReadVector+0xe0>
    80206c0c:	f41ff06f          	j	80206b4c <syscallReadVector+0x44>
    u64 len = 0;
    80206c10:	00000993          	li	s3,0
    return;
    80206c14:	f39ff06f          	j	80206b4c <syscallReadVector+0x44>

0000000080206c18 <syscallClose>:

void syscallClose(void) {
    80206c18:	fd010113          	addi	sp,sp,-48
    80206c1c:	02113423          	sd	ra,40(sp)
    80206c20:	02813023          	sd	s0,32(sp)
    80206c24:	00913c23          	sd	s1,24(sp)
    80206c28:	01213823          	sd	s2,16(sp)
    80206c2c:	01313423          	sd	s3,8(sp)
    80206c30:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    80206c34:	00003097          	auipc	ra,0x3
    80206c38:	5a8080e7          	jalr	1448(ra) # 8020a1dc <getHartTrapFrame>
    80206c3c:	00050913          	mv	s2,a0
    int fd = tf->a0;
    80206c40:	07053783          	ld	a5,112(a0)

    // if (fd == 0) {
    //     panic("");
    // }

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206c44:	0007869b          	sext.w	a3,a5
    80206c48:	3ff00713          	li	a4,1023
    80206c4c:	02d77463          	bgeu	a4,a3,80206c74 <syscallClose+0x5c>
        tf->a0 = -1;
        return;
    80206c50:	fff00793          	li	a5,-1
        tf->a0 = -1;
    80206c54:	06f93823          	sd	a5,112(s2)
    }
    
    myProcess()->ofile[fd] = 0;
    fileclose(f);
    tf->a0 = 0;
}
    80206c58:	02813083          	ld	ra,40(sp)
    80206c5c:	02013403          	ld	s0,32(sp)
    80206c60:	01813483          	ld	s1,24(sp)
    80206c64:	01013903          	ld	s2,16(sp)
    80206c68:	00813983          	ld	s3,8(sp)
    80206c6c:	03010113          	addi	sp,sp,48
    80206c70:	00008067          	ret
    int fd = tf->a0;
    80206c74:	00068493          	mv	s1,a3
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206c78:	00009097          	auipc	ra,0x9
    80206c7c:	d70080e7          	jalr	-656(ra) # 8020f9e8 <myProcess>
    80206c80:	00e48793          	addi	a5,s1,14
    80206c84:	00379793          	slli	a5,a5,0x3
    80206c88:	00f50533          	add	a0,a0,a5
    80206c8c:	00053983          	ld	s3,0(a0)
    80206c90:	fc0980e3          	beqz	s3,80206c50 <syscallClose+0x38>
    myProcess()->ofile[fd] = 0;
    80206c94:	00009097          	auipc	ra,0x9
    80206c98:	d54080e7          	jalr	-684(ra) # 8020f9e8 <myProcess>
    80206c9c:	00e48793          	addi	a5,s1,14
    80206ca0:	00379793          	slli	a5,a5,0x3
    80206ca4:	00f50533          	add	a0,a0,a5
    80206ca8:	00053023          	sd	zero,0(a0)
    fileclose(f);
    80206cac:	00098513          	mv	a0,s3
    80206cb0:	ffffd097          	auipc	ra,0xffffd
    80206cb4:	28c080e7          	jalr	652(ra) # 80203f3c <fileclose>
    80206cb8:	00000793          	li	a5,0
    80206cbc:	f99ff06f          	j	80206c54 <syscallClose+0x3c>

0000000080206cc0 <syscallGetFileState>:

void syscallGetFileState(void) {
    80206cc0:	fd010113          	addi	sp,sp,-48
    80206cc4:	02113423          	sd	ra,40(sp)
    80206cc8:	02813023          	sd	s0,32(sp)
    80206ccc:	00913c23          	sd	s1,24(sp)
    80206cd0:	01213823          	sd	s2,16(sp)
    80206cd4:	01313423          	sd	s3,8(sp)
    80206cd8:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    80206cdc:	00003097          	auipc	ra,0x3
    80206ce0:	500080e7          	jalr	1280(ra) # 8020a1dc <getHartTrapFrame>
    80206ce4:	00050493          	mv	s1,a0
    struct File* f;
    int fd = tf->a0;
    80206ce8:	07053903          	ld	s2,112(a0)
    u64 uva = tf->a1; 
    80206cec:	07853983          	ld	s3,120(a0)

    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206cf0:	0009071b          	sext.w	a4,s2
    80206cf4:	3ff00793          	li	a5,1023
    80206cf8:	02e7f463          	bgeu	a5,a4,80206d20 <syscallGetFileState+0x60>
        tf->a0 = -1;
        return;
    80206cfc:	fff00513          	li	a0,-1
        tf->a0 = -1;
    80206d00:	06a4b823          	sd	a0,112(s1)
    }

    tf->a0 = filestat(f, uva);
}
    80206d04:	02813083          	ld	ra,40(sp)
    80206d08:	02013403          	ld	s0,32(sp)
    80206d0c:	01813483          	ld	s1,24(sp)
    80206d10:	01013903          	ld	s2,16(sp)
    80206d14:	00813983          	ld	s3,8(sp)
    80206d18:	03010113          	addi	sp,sp,48
    80206d1c:	00008067          	ret
    if (fd < 0 || fd >= NOFILE || (f = myProcess()->ofile[fd]) == NULL) {
    80206d20:	00009097          	auipc	ra,0x9
    80206d24:	cc8080e7          	jalr	-824(ra) # 8020f9e8 <myProcess>
    80206d28:	0009091b          	sext.w	s2,s2
    80206d2c:	00e90913          	addi	s2,s2,14
    80206d30:	00391913          	slli	s2,s2,0x3
    80206d34:	01250533          	add	a0,a0,s2
    80206d38:	00053503          	ld	a0,0(a0)
    80206d3c:	fc0500e3          	beqz	a0,80206cfc <syscallGetFileState+0x3c>
    tf->a0 = filestat(f, uva);
    80206d40:	00098593          	mv	a1,s3
    80206d44:	ffffd097          	auipc	ra,0xffffd
    80206d48:	2b8080e7          	jalr	696(ra) # 80203ffc <filestat>
    80206d4c:	fb5ff06f          	j	80206d00 <syscallGetFileState+0x40>

0000000080206d50 <syscallGetFileStateAt>:

void syscallGetFileStateAt(void) {
    80206d50:	e4010113          	addi	sp,sp,-448
    80206d54:	1a113c23          	sd	ra,440(sp)
    80206d58:	1a813823          	sd	s0,432(sp)
    80206d5c:	1a913423          	sd	s1,424(sp)
    80206d60:	1b213023          	sd	s2,416(sp)
    80206d64:	19313c23          	sd	s3,408(sp)
    80206d68:	1c010413          	addi	s0,sp,448
    Trapframe* tf = getHartTrapFrame();
    80206d6c:	00003097          	auipc	ra,0x3
    80206d70:	470080e7          	jalr	1136(ra) # 8020a1dc <getHartTrapFrame>
    80206d74:	00050493          	mv	s1,a0
    int dirfd = tf->a0/*, flags = tf->a2*/;
    80206d78:	07053903          	ld	s2,112(a0)
    u64 uva = tf->a2; 
    80206d7c:	08053983          	ld	s3,128(a0)
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80206d80:	10400613          	li	a2,260
    80206d84:	ec840593          	addi	a1,s0,-312
    80206d88:	07853503          	ld	a0,120(a0)
    80206d8c:	00006097          	auipc	ra,0x6
    80206d90:	818080e7          	jalr	-2024(ra) # 8020c5a4 <fetchstr>
    80206d94:	06054863          	bltz	a0,80206e04 <syscallGetFileStateAt+0xb4>
        tf->a0 = -1;
        return;
    }
    // printf("path: %s\n", path);
    Dirent* entryPoint = ename(dirfd, path, true);
    80206d98:	00100613          	li	a2,1
    80206d9c:	ec840593          	addi	a1,s0,-312
    80206da0:	0009051b          	sext.w	a0,s2
    80206da4:	ffffd097          	auipc	ra,0xffffd
    80206da8:	c98080e7          	jalr	-872(ra) # 80203a3c <ename>
    80206dac:	00050913          	mv	s2,a0
    if (entryPoint == NULL) {
    80206db0:	06050c63          	beqz	a0,80206e28 <syscallGetFileStateAt+0xd8>
        tf->a0 = -ENOENT;
        return;
    }

    struct stat st;
    elock(entryPoint);
    80206db4:	ffffd097          	auipc	ra,0xffffd
    80206db8:	828080e7          	jalr	-2008(ra) # 802035dc <elock>
    estat(entryPoint, &st);
    80206dbc:	e4840593          	addi	a1,s0,-440
    80206dc0:	00090513          	mv	a0,s2
    80206dc4:	ffffd097          	auipc	ra,0xffffd
    80206dc8:	860080e7          	jalr	-1952(ra) # 80203624 <estat>
    eunlock(entryPoint);
    80206dcc:	00090513          	mv	a0,s2
    80206dd0:	ffffd097          	auipc	ra,0xffffd
    80206dd4:	824080e7          	jalr	-2012(ra) # 802035f4 <eunlock>
    if (copyout(myProcess()->pgdir, uva, (char*)&st, sizeof(struct stat)) < 0) {
    80206dd8:	00009097          	auipc	ra,0x9
    80206ddc:	c10080e7          	jalr	-1008(ra) # 8020f9e8 <myProcess>
    80206de0:	08000693          	li	a3,128
    80206de4:	e4840613          	addi	a2,s0,-440
    80206de8:	00098593          	mv	a1,s3
    80206dec:	04053503          	ld	a0,64(a0)
    80206df0:	00003097          	auipc	ra,0x3
    80206df4:	d48080e7          	jalr	-696(ra) # 80209b38 <copyout>
    80206df8:	02054c63          	bltz	a0,80206e30 <syscallGetFileStateAt+0xe0>
        tf->a0 = -1;
        return;
    }
    tf->a0 = 0;
    80206dfc:	0604b823          	sd	zero,112(s1)
    80206e00:	00c0006f          	j	80206e0c <syscallGetFileStateAt+0xbc>
    80206e04:	fff00793          	li	a5,-1
        tf->a0 = -1;
    80206e08:	06f4b823          	sd	a5,112(s1)
}
    80206e0c:	1b813083          	ld	ra,440(sp)
    80206e10:	1b013403          	ld	s0,432(sp)
    80206e14:	1a813483          	ld	s1,424(sp)
    80206e18:	1a013903          	ld	s2,416(sp)
    80206e1c:	19813983          	ld	s3,408(sp)
    80206e20:	1c010113          	addi	sp,sp,448
    80206e24:	00008067          	ret
    80206e28:	ffe00793          	li	a5,-2
    80206e2c:	fddff06f          	j	80206e08 <syscallGetFileStateAt+0xb8>
    80206e30:	fff00793          	li	a5,-1
    80206e34:	fd5ff06f          	j	80206e08 <syscallGetFileStateAt+0xb8>

0000000080206e38 <syscallGetDirent>:

#define DEBUG_FS
void syscallGetDirent() {
    80206e38:	ff010113          	addi	sp,sp,-16
    80206e3c:	00113423          	sd	ra,8(sp)
    80206e40:	00813023          	sd	s0,0(sp)
    80206e44:	01010413          	addi	s0,sp,16

        getHartTrapFrame()->a0 = nread;
        return;
    }
    #endif
    getHartTrapFrame()->a0 = -5;
    80206e48:	00003097          	auipc	ra,0x3
    80206e4c:	394080e7          	jalr	916(ra) # 8020a1dc <getHartTrapFrame>
    80206e50:	ffb00793          	li	a5,-5
    80206e54:	06f53823          	sd	a5,112(a0)
    return;
}
    80206e58:	00813083          	ld	ra,8(sp)
    80206e5c:	00013403          	ld	s0,0(sp)
    80206e60:	01010113          	addi	sp,sp,16
    80206e64:	00008067          	ret

0000000080206e68 <syscallOpenAt>:

//todo: support the mode
//todo: change the directory? whether we should add the ref(eput)
void syscallOpenAt(void) {
    80206e68:	eb010113          	addi	sp,sp,-336
    80206e6c:	14113423          	sd	ra,328(sp)
    80206e70:	14813023          	sd	s0,320(sp)
    80206e74:	12913c23          	sd	s1,312(sp)
    80206e78:	13213823          	sd	s2,304(sp)
    80206e7c:	13313423          	sd	s3,296(sp)
    80206e80:	13413023          	sd	s4,288(sp)
    80206e84:	11513c23          	sd	s5,280(sp)
    80206e88:	11613823          	sd	s6,272(sp)
    80206e8c:	15010413          	addi	s0,sp,336
    Trapframe* tf = getHartTrapFrame();
    80206e90:	00003097          	auipc	ra,0x3
    80206e94:	34c080e7          	jalr	844(ra) # 8020a1dc <getHartTrapFrame>
    80206e98:	00050493          	mv	s1,a0
    int startFd = tf->a0, flags = tf->a2, mode = tf->a3;
    80206e9c:	07053903          	ld	s2,112(a0)
    80206ea0:	08053a83          	ld	s5,128(a0)
    80206ea4:	08853983          	ld	s3,136(a0)
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80206ea8:	10400613          	li	a2,260
    80206eac:	eb840593          	addi	a1,s0,-328
    80206eb0:	07853503          	ld	a0,120(a0)
    80206eb4:	00005097          	auipc	ra,0x5
    80206eb8:	6f0080e7          	jalr	1776(ra) # 8020c5a4 <fetchstr>
    80206ebc:	fff00793          	li	a5,-1
    80206ec0:	0a054663          	bltz	a0,80206f6c <syscallOpenAt+0x104>
    int startFd = tf->a0, flags = tf->a2, mode = tf->a3;
    80206ec4:	0009051b          	sext.w	a0,s2
    80206ec8:	000a8b1b          	sext.w	s6,s5
    }

    Dirent* entryPoint;
    // printf("openat path: %s\n", path);
    // printf("startFd: %d, path: %s, flags: %x, mode: %x\n", startFd, path, flags, mode);
    if (flags & O_CREATE_GLIBC) {
    80206ecc:	040af793          	andi	a5,s5,64
    80206ed0:	0c078463          	beqz	a5,80206f98 <syscallOpenAt+0x130>
        entryPoint = create(startFd, path, T_FILE, mode);
    80206ed4:	0009869b          	sext.w	a3,s3
    80206ed8:	00200613          	li	a2,2
    80206edc:	eb840593          	addi	a1,s0,-328
    80206ee0:	ffffd097          	auipc	ra,0xffffd
    80206ee4:	e7c080e7          	jalr	-388(ra) # 80203d5c <create>
    80206ee8:	00050913          	mv	s2,a0
        if (entryPoint == NULL) {
    80206eec:	14050063          	beqz	a0,8020702c <syscallOpenAt+0x1c4>
            goto bad;
        }
    }
    struct File* file;
    int fd;
    if ((file = filealloc()) == NULL || (fd = fdalloc(file)) < 0) {
    80206ef0:	ffffd097          	auipc	ra,0xffffd
    80206ef4:	fbc080e7          	jalr	-68(ra) # 80203eac <filealloc>
    80206ef8:	00050a13          	mv	s4,a0
    80206efc:	14050263          	beqz	a0,80207040 <syscallOpenAt+0x1d8>
    80206f00:	fffff097          	auipc	ra,0xfffff
    80206f04:	64c080e7          	jalr	1612(ra) # 8020654c <fdalloc>
    80206f08:	00050993          	mv	s3,a0
    80206f0c:	12054463          	bltz	a0,80207034 <syscallOpenAt+0x1cc>
        eput(entryPoint);
        tf->a0 = -24;
        goto bad;
    }

    if (!(entryPoint->attribute & ATTR_DIRECTORY) && (flags & O_TRUNC)) {
    80206f10:	10094783          	lbu	a5,256(s2)
    80206f14:	0107f793          	andi	a5,a5,16
    80206f18:	00079663          	bnez	a5,80206f24 <syscallOpenAt+0xbc>
    80206f1c:	200b7793          	andi	a5,s6,512
    80206f20:	0e079e63          	bnez	a5,8020701c <syscallOpenAt+0x1b4>
        etrunc(entryPoint);
    }

    file->type = FD_ENTRY;
    80206f24:	00200793          	li	a5,2
    80206f28:	00fa2023          	sw	a5,0(s4)
    file->off = (flags & O_APPEND) ? entryPoint->file_size : 0;
    80206f2c:	400b7793          	andi	a5,s6,1024
    80206f30:	00000713          	li	a4,0
    80206f34:	00078463          	beqz	a5,80206f3c <syscallOpenAt+0xd4>
    80206f38:	10892703          	lw	a4,264(s2)
    80206f3c:	02ea2423          	sw	a4,40(s4)
    file->ep = entryPoint;
    80206f40:	012a3c23          	sd	s2,24(s4)
    file->readable = !(flags & O_WRONLY);
    80206f44:	001b4b13          	xori	s6,s6,1
    80206f48:	001b7b13          	andi	s6,s6,1
    80206f4c:	016a0423          	sb	s6,8(s4)
    file->writable = (flags & O_WRONLY) || (flags & O_RDWR);
    80206f50:	003afa93          	andi	s5,s5,3
    80206f54:	01503ab3          	snez	s5,s5
    80206f58:	015a04a3          	sb	s5,9(s4)

    eunlock(entryPoint);
    80206f5c:	00090513          	mv	a0,s2
    80206f60:	ffffc097          	auipc	ra,0xffffc
    80206f64:	694080e7          	jalr	1684(ra) # 802035f4 <eunlock>


    tf->a0 = fd;
    80206f68:	00098793          	mv	a5,s3
        tf->a0 = -1;
    80206f6c:	06f4b823          	sd	a5,112(s1)
    // printf("open at: %d\n", fd);
bad:
    return;
    // printf("open at: %d\n", tf->a0);
}
    80206f70:	14813083          	ld	ra,328(sp)
    80206f74:	14013403          	ld	s0,320(sp)
    80206f78:	13813483          	ld	s1,312(sp)
    80206f7c:	13013903          	ld	s2,304(sp)
    80206f80:	12813983          	ld	s3,296(sp)
    80206f84:	12013a03          	ld	s4,288(sp)
    80206f88:	11813a83          	ld	s5,280(sp)
    80206f8c:	11013b03          	ld	s6,272(sp)
    80206f90:	15010113          	addi	sp,sp,336
    80206f94:	00008067          	ret
        if ((entryPoint = ename(startFd, path, true)) == NULL) {
    80206f98:	00100613          	li	a2,1
    80206f9c:	eb840593          	addi	a1,s0,-328
    80206fa0:	ffffd097          	auipc	ra,0xffffd
    80206fa4:	a9c080e7          	jalr	-1380(ra) # 80203a3c <ename>
    80206fa8:	00050913          	mv	s2,a0
    80206fac:	ffe00793          	li	a5,-2
    80206fb0:	fa050ee3          	beqz	a0,80206f6c <syscallOpenAt+0x104>
        elock(entryPoint);
    80206fb4:	ffffc097          	auipc	ra,0xffffc
    80206fb8:	628080e7          	jalr	1576(ra) # 802035dc <elock>
        if (!(entryPoint->attribute & ATTR_DIRECTORY) && (flags & O_DIRECTORY)) {
    80206fbc:	10094783          	lbu	a5,256(s2)
    80206fc0:	0107f793          	andi	a5,a5,16
    80206fc4:	02079863          	bnez	a5,80206ff4 <syscallOpenAt+0x18c>
    80206fc8:	015b5793          	srli	a5,s6,0x15
    80206fcc:	0017f793          	andi	a5,a5,1
    80206fd0:	f20780e3          	beqz	a5,80206ef0 <syscallOpenAt+0x88>
            eunlock(entryPoint);
    80206fd4:	00090513          	mv	a0,s2
    80206fd8:	ffffc097          	auipc	ra,0xffffc
    80206fdc:	61c080e7          	jalr	1564(ra) # 802035f4 <eunlock>
            eput(entryPoint);
    80206fe0:	00090513          	mv	a0,s2
    80206fe4:	ffffc097          	auipc	ra,0xffffc
    80206fe8:	628080e7          	jalr	1576(ra) # 8020360c <eput>
            goto bad;
    80206fec:	fff00793          	li	a5,-1
    80206ff0:	f7dff06f          	j	80206f6c <syscallOpenAt+0x104>
        if ((entryPoint->attribute & ATTR_DIRECTORY) && (flags & 0xFFF) != O_RDONLY) { //todo
    80206ff4:	034b1793          	slli	a5,s6,0x34
    80206ff8:	ee078ce3          	beqz	a5,80206ef0 <syscallOpenAt+0x88>
            eunlock(entryPoint);
    80206ffc:	00090513          	mv	a0,s2
    80207000:	ffffc097          	auipc	ra,0xffffc
    80207004:	5f4080e7          	jalr	1524(ra) # 802035f4 <eunlock>
            eput(entryPoint);
    80207008:	00090513          	mv	a0,s2
    8020700c:	ffffc097          	auipc	ra,0xffffc
    80207010:	600080e7          	jalr	1536(ra) # 8020360c <eput>
            goto bad;
    80207014:	fff00793          	li	a5,-1
    80207018:	f55ff06f          	j	80206f6c <syscallOpenAt+0x104>
        etrunc(entryPoint);
    8020701c:	00090513          	mv	a0,s2
    80207020:	ffffc097          	auipc	ra,0xffffc
    80207024:	4a8080e7          	jalr	1192(ra) # 802034c8 <etrunc>
    80207028:	efdff06f          	j	80206f24 <syscallOpenAt+0xbc>
    8020702c:	fff00793          	li	a5,-1
    80207030:	f3dff06f          	j	80206f6c <syscallOpenAt+0x104>
            fileclose(file);
    80207034:	000a0513          	mv	a0,s4
    80207038:	ffffd097          	auipc	ra,0xffffd
    8020703c:	f04080e7          	jalr	-252(ra) # 80203f3c <fileclose>
        eunlock(entryPoint);
    80207040:	00090513          	mv	a0,s2
    80207044:	ffffc097          	auipc	ra,0xffffc
    80207048:	5b0080e7          	jalr	1456(ra) # 802035f4 <eunlock>
        eput(entryPoint);
    8020704c:	00090513          	mv	a0,s2
    80207050:	ffffc097          	auipc	ra,0xffffc
    80207054:	5bc080e7          	jalr	1468(ra) # 8020360c <eput>
        goto bad;
    80207058:	fe800793          	li	a5,-24
    8020705c:	f11ff06f          	j	80206f6c <syscallOpenAt+0x104>

0000000080207060 <syscallOpen>:

/* riscv-linux-gnu use this function */
void syscallOpen(void) {
    80207060:	ea010113          	addi	sp,sp,-352
    80207064:	14113c23          	sd	ra,344(sp)
    80207068:	14813823          	sd	s0,336(sp)
    8020706c:	14913423          	sd	s1,328(sp)
    80207070:	15213023          	sd	s2,320(sp)
    80207074:	13313c23          	sd	s3,312(sp)
    80207078:	13413823          	sd	s4,304(sp)
    8020707c:	13513423          	sd	s5,296(sp)
    80207080:	13613023          	sd	s6,288(sp)
    80207084:	11713c23          	sd	s7,280(sp)
    80207088:	16010413          	addi	s0,sp,352
    Trapframe* tf = getHartTrapFrame();
    8020708c:	00003097          	auipc	ra,0x3
    80207090:	150080e7          	jalr	336(ra) # 8020a1dc <getHartTrapFrame>
    80207094:	00050493          	mv	s1,a0
    char path[FAT32_MAX_PATH];
    int flags = tf->a1, mode = 0;
    80207098:	07853b03          	ld	s6,120(a0)
    if (fetchstr(tf->a0, path, FAT32_MAX_PATH) < 0) {
    8020709c:	10400613          	li	a2,260
    802070a0:	ea840593          	addi	a1,s0,-344
    802070a4:	07053503          	ld	a0,112(a0)
    802070a8:	00005097          	auipc	ra,0x5
    802070ac:	4fc080e7          	jalr	1276(ra) # 8020c5a4 <fetchstr>
    802070b0:	fff00793          	li	a5,-1
    802070b4:	0c054c63          	bltz	a0,8020718c <syscallOpen+0x12c>
    int flags = tf->a1, mode = 0;
    802070b8:	000b0a1b          	sext.w	s4,s6
        tf->a0 = -1;
        return;
    }
   
    Dirent* entryPoint;
    printf("open path: %s\n", path);
    802070bc:	ea840593          	addi	a1,s0,-344
    802070c0:	0000e517          	auipc	a0,0xe
    802070c4:	77050513          	addi	a0,a0,1904 # 80215830 <__func__.5+0x48>
    802070c8:	ffffa097          	auipc	ra,0xffffa
    802070cc:	d88080e7          	jalr	-632(ra) # 80200e50 <printf>
    printf("path: %s, flags: %x, mode: %x\n", path, flags, mode);
    802070d0:	00000693          	li	a3,0
    802070d4:	000a0613          	mv	a2,s4
    802070d8:	ea840593          	addi	a1,s0,-344
    802070dc:	0000e517          	auipc	a0,0xe
    802070e0:	76450513          	addi	a0,a0,1892 # 80215840 <__func__.5+0x58>
    802070e4:	ffffa097          	auipc	ra,0xffffa
    802070e8:	d6c080e7          	jalr	-660(ra) # 80200e50 <printf>
    if (flags & O_CREATE_GPP) {
    802070ec:	200a7b93          	andi	s7,s4,512
    802070f0:	0c0b8663          	beqz	s7,802071bc <syscallOpen+0x15c>
        entryPoint = create(AT_FDCWD, path, T_FILE, mode);
    802070f4:	00000693          	li	a3,0
    802070f8:	00200613          	li	a2,2
    802070fc:	ea840593          	addi	a1,s0,-344
    80207100:	f9c00513          	li	a0,-100
    80207104:	ffffd097          	auipc	ra,0xffffd
    80207108:	c58080e7          	jalr	-936(ra) # 80203d5c <create>
    8020710c:	00050993          	mv	s3,a0
        if (entryPoint == NULL) {
    80207110:	14050263          	beqz	a0,80207254 <syscallOpen+0x1f4>
            goto bad;
        }
    }
    struct File* file;
    int fd;
    if ((file = filealloc()) == NULL || (fd = fdalloc(file)) < 0) {
    80207114:	ffffd097          	auipc	ra,0xffffd
    80207118:	d98080e7          	jalr	-616(ra) # 80203eac <filealloc>
    8020711c:	00050a93          	mv	s5,a0
    80207120:	14050463          	beqz	a0,80207268 <syscallOpen+0x208>
    80207124:	fffff097          	auipc	ra,0xfffff
    80207128:	428080e7          	jalr	1064(ra) # 8020654c <fdalloc>
    8020712c:	00050913          	mv	s2,a0
    80207130:	12054663          	bltz	a0,8020725c <syscallOpen+0x1fc>
        eput(entryPoint);
        tf->a0 = -24;
        goto bad;
    }

    if (!(entryPoint->attribute & ATTR_DIRECTORY) && (flags & O_TRUNC)) {
    80207134:	1009c783          	lbu	a5,256(s3)
    80207138:	0107f793          	andi	a5,a5,16
    8020713c:	00079463          	bnez	a5,80207144 <syscallOpen+0xe4>
    80207140:	100b9263          	bnez	s7,80207244 <syscallOpen+0x1e4>
        etrunc(entryPoint);
    }

    file->type = FD_ENTRY;
    80207144:	00200793          	li	a5,2
    80207148:	00faa023          	sw	a5,0(s5) # 1000 <_start-0x801ff000>
    file->off = (flags & O_APPEND) ? entryPoint->file_size : 0;
    8020714c:	400a7793          	andi	a5,s4,1024
    80207150:	00000713          	li	a4,0
    80207154:	00078463          	beqz	a5,8020715c <syscallOpen+0xfc>
    80207158:	1089a703          	lw	a4,264(s3)
    8020715c:	02eaa423          	sw	a4,40(s5)
    file->ep = entryPoint;
    80207160:	013abc23          	sd	s3,24(s5)
    file->readable = !(flags & O_WRONLY);
    80207164:	001a4a13          	xori	s4,s4,1
    80207168:	001a7a13          	andi	s4,s4,1
    8020716c:	014a8423          	sb	s4,8(s5)
    file->writable = (flags & O_WRONLY) || (flags & O_RDWR);
    80207170:	003b7b13          	andi	s6,s6,3
    80207174:	01603b33          	snez	s6,s6
    80207178:	016a84a3          	sb	s6,9(s5)

    eunlock(entryPoint);
    8020717c:	00098513          	mv	a0,s3
    80207180:	ffffc097          	auipc	ra,0xffffc
    80207184:	474080e7          	jalr	1140(ra) # 802035f4 <eunlock>


    tf->a0 = fd;
    80207188:	00090793          	mv	a5,s2
        tf->a0 = -1;
    8020718c:	06f4b823          	sd	a5,112(s1)
    // printf("open at: %d\n", fd);
bad:
    return;
    // printf("open at: %d\n", tf->a0);
}
    80207190:	15813083          	ld	ra,344(sp)
    80207194:	15013403          	ld	s0,336(sp)
    80207198:	14813483          	ld	s1,328(sp)
    8020719c:	14013903          	ld	s2,320(sp)
    802071a0:	13813983          	ld	s3,312(sp)
    802071a4:	13013a03          	ld	s4,304(sp)
    802071a8:	12813a83          	ld	s5,296(sp)
    802071ac:	12013b03          	ld	s6,288(sp)
    802071b0:	11813b83          	ld	s7,280(sp)
    802071b4:	16010113          	addi	sp,sp,352
    802071b8:	00008067          	ret
        if ((entryPoint = ename(AT_FDCWD, path, true)) == NULL) {
    802071bc:	00100613          	li	a2,1
    802071c0:	ea840593          	addi	a1,s0,-344
    802071c4:	f9c00513          	li	a0,-100
    802071c8:	ffffd097          	auipc	ra,0xffffd
    802071cc:	874080e7          	jalr	-1932(ra) # 80203a3c <ename>
    802071d0:	00050993          	mv	s3,a0
    802071d4:	ffe00793          	li	a5,-2
    802071d8:	fa050ae3          	beqz	a0,8020718c <syscallOpen+0x12c>
        elock(entryPoint);
    802071dc:	ffffc097          	auipc	ra,0xffffc
    802071e0:	400080e7          	jalr	1024(ra) # 802035dc <elock>
        if (!(entryPoint->attribute & ATTR_DIRECTORY) && (flags & O_DIRECTORY)) {
    802071e4:	1009c783          	lbu	a5,256(s3)
    802071e8:	0107f793          	andi	a5,a5,16
    802071ec:	02079863          	bnez	a5,8020721c <syscallOpen+0x1bc>
    802071f0:	015a5793          	srli	a5,s4,0x15
    802071f4:	0017f793          	andi	a5,a5,1
    802071f8:	f0078ee3          	beqz	a5,80207114 <syscallOpen+0xb4>
            eunlock(entryPoint);
    802071fc:	00098513          	mv	a0,s3
    80207200:	ffffc097          	auipc	ra,0xffffc
    80207204:	3f4080e7          	jalr	1012(ra) # 802035f4 <eunlock>
            eput(entryPoint);
    80207208:	00098513          	mv	a0,s3
    8020720c:	ffffc097          	auipc	ra,0xffffc
    80207210:	400080e7          	jalr	1024(ra) # 8020360c <eput>
            goto bad;
    80207214:	fff00793          	li	a5,-1
    80207218:	f75ff06f          	j	8020718c <syscallOpen+0x12c>
        if ((entryPoint->attribute & ATTR_DIRECTORY) && (flags & 0xFFF) != O_RDONLY) { //todo
    8020721c:	034a1793          	slli	a5,s4,0x34
    80207220:	ee078ae3          	beqz	a5,80207114 <syscallOpen+0xb4>
            eunlock(entryPoint);
    80207224:	00098513          	mv	a0,s3
    80207228:	ffffc097          	auipc	ra,0xffffc
    8020722c:	3cc080e7          	jalr	972(ra) # 802035f4 <eunlock>
            eput(entryPoint);
    80207230:	00098513          	mv	a0,s3
    80207234:	ffffc097          	auipc	ra,0xffffc
    80207238:	3d8080e7          	jalr	984(ra) # 8020360c <eput>
            goto bad;
    8020723c:	fff00793          	li	a5,-1
    80207240:	f4dff06f          	j	8020718c <syscallOpen+0x12c>
        etrunc(entryPoint);
    80207244:	00098513          	mv	a0,s3
    80207248:	ffffc097          	auipc	ra,0xffffc
    8020724c:	280080e7          	jalr	640(ra) # 802034c8 <etrunc>
    80207250:	ef5ff06f          	j	80207144 <syscallOpen+0xe4>
    80207254:	fff00793          	li	a5,-1
    80207258:	f35ff06f          	j	8020718c <syscallOpen+0x12c>
            fileclose(file);
    8020725c:	000a8513          	mv	a0,s5
    80207260:	ffffd097          	auipc	ra,0xffffd
    80207264:	cdc080e7          	jalr	-804(ra) # 80203f3c <fileclose>
        eunlock(entryPoint);
    80207268:	00098513          	mv	a0,s3
    8020726c:	ffffc097          	auipc	ra,0xffffc
    80207270:	388080e7          	jalr	904(ra) # 802035f4 <eunlock>
        eput(entryPoint);
    80207274:	00098513          	mv	a0,s3
    80207278:	ffffc097          	auipc	ra,0xffffc
    8020727c:	394080e7          	jalr	916(ra) # 8020360c <eput>
        goto bad;
    80207280:	fe800793          	li	a5,-24
    80207284:	f09ff06f          	j	8020718c <syscallOpen+0x12c>

0000000080207288 <syscallMakeDirAt>:

//todo: support the mode
//todo: change the directory? whether we should add the ref(eput)
void syscallMakeDirAt(void) {
    80207288:	ec010113          	addi	sp,sp,-320
    8020728c:	12113c23          	sd	ra,312(sp)
    80207290:	12813823          	sd	s0,304(sp)
    80207294:	12913423          	sd	s1,296(sp)
    80207298:	13213023          	sd	s2,288(sp)
    8020729c:	11313c23          	sd	s3,280(sp)
    802072a0:	14010413          	addi	s0,sp,320
    Trapframe* tf = getHartTrapFrame();
    802072a4:	00003097          	auipc	ra,0x3
    802072a8:	f38080e7          	jalr	-200(ra) # 8020a1dc <getHartTrapFrame>
    802072ac:	00050493          	mv	s1,a0
    int dirFd = tf->a0, mode = tf->a2;
    802072b0:	07053903          	ld	s2,112(a0)
    802072b4:	08053983          	ld	s3,128(a0)
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    802072b8:	10400613          	li	a2,260
    802072bc:	ec840593          	addi	a1,s0,-312
    802072c0:	07853503          	ld	a0,120(a0)
    802072c4:	00005097          	auipc	ra,0x5
    802072c8:	2e0080e7          	jalr	736(ra) # 8020c5a4 <fetchstr>
    802072cc:	04054a63          	bltz	a0,80207320 <syscallMakeDirAt+0x98>
        tf->a0 = -1;
        return;
    }
    Dirent* entryPoint;
    bool flag = true;
    for (int i = 0; path[i]; i++) {
    802072d0:	ec844783          	lbu	a5,-312(s0)
    802072d4:	04078a63          	beqz	a5,80207328 <syscallMakeDirAt+0xa0>
    802072d8:	ec940713          	addi	a4,s0,-311
        if (path[i] != '/') {
    802072dc:	02f00693          	li	a3,47
    802072e0:	04d79863          	bne	a5,a3,80207330 <syscallMakeDirAt+0xa8>
    for (int i = 0; path[i]; i++) {
    802072e4:	00170713          	addi	a4,a4,1
    802072e8:	fff74783          	lbu	a5,-1(a4)
    802072ec:	fe079ae3          	bnez	a5,802072e0 <syscallMakeDirAt+0x58>
    802072f0:	fef00793          	li	a5,-17
        tf->a0 = -1;
    802072f4:	06f4b823          	sd	a5,112(s1)
    tf->a0 = 0;
    return;

bad:
    tf->a0 = -1;
}
    802072f8:	13813083          	ld	ra,312(sp)
    802072fc:	13013403          	ld	s0,304(sp)
    80207300:	12813483          	ld	s1,296(sp)
    80207304:	12013903          	ld	s2,288(sp)
    80207308:	11813983          	ld	s3,280(sp)
    8020730c:	14010113          	addi	sp,sp,320
    80207310:	00008067          	ret
    tf->a0 = -1;
    80207314:	fff00793          	li	a5,-1
    80207318:	06f4b823          	sd	a5,112(s1)
    8020731c:	fddff06f          	j	802072f8 <syscallMakeDirAt+0x70>
    80207320:	fff00793          	li	a5,-1
    80207324:	fd1ff06f          	j	802072f4 <syscallMakeDirAt+0x6c>
    for (int i = 0; path[i]; i++) {
    80207328:	fef00793          	li	a5,-17
    8020732c:	fc9ff06f          	j	802072f4 <syscallMakeDirAt+0x6c>
    if ((entryPoint = create(dirFd, path, T_DIR, mode)) == 0) {
    80207330:	0009869b          	sext.w	a3,s3
    80207334:	00100613          	li	a2,1
    80207338:	ec840593          	addi	a1,s0,-312
    8020733c:	0009051b          	sext.w	a0,s2
    80207340:	ffffd097          	auipc	ra,0xffffd
    80207344:	a1c080e7          	jalr	-1508(ra) # 80203d5c <create>
    80207348:	00050913          	mv	s2,a0
    8020734c:	fc0504e3          	beqz	a0,80207314 <syscallMakeDirAt+0x8c>
    eunlock(entryPoint);
    80207350:	00090513          	mv	a0,s2
    80207354:	ffffc097          	auipc	ra,0xffffc
    80207358:	2a0080e7          	jalr	672(ra) # 802035f4 <eunlock>
    eput(entryPoint);
    8020735c:	00090513          	mv	a0,s2
    80207360:	ffffc097          	auipc	ra,0xffffc
    80207364:	2ac080e7          	jalr	684(ra) # 8020360c <eput>
    return;
    80207368:	00000793          	li	a5,0
    8020736c:	f89ff06f          	j	802072f4 <syscallMakeDirAt+0x6c>

0000000080207370 <syscallChangeDir>:

void syscallChangeDir(void) {
    80207370:	ec010113          	addi	sp,sp,-320
    80207374:	12113c23          	sd	ra,312(sp)
    80207378:	12813823          	sd	s0,304(sp)
    8020737c:	12913423          	sd	s1,296(sp)
    80207380:	13213023          	sd	s2,288(sp)
    80207384:	11313c23          	sd	s3,280(sp)
    80207388:	14010413          	addi	s0,sp,320
    Trapframe* tf = getHartTrapFrame();
    8020738c:	00003097          	auipc	ra,0x3
    80207390:	e50080e7          	jalr	-432(ra) # 8020a1dc <getHartTrapFrame>
    80207394:	00050493          	mv	s1,a0
    char path[FAT32_MAX_PATH];
    Dirent* ep;

    struct Process* process = myProcess();
    80207398:	00008097          	auipc	ra,0x8
    8020739c:	650080e7          	jalr	1616(ra) # 8020f9e8 <myProcess>
    802073a0:	00050913          	mv	s2,a0
    
    if (fetchstr(tf->a0, path, FAT32_MAX_PATH) < 0 || (ep = ename(AT_FDCWD, path, true)) == NULL) {
    802073a4:	10400613          	li	a2,260
    802073a8:	ec840593          	addi	a1,s0,-312
    802073ac:	0704b503          	ld	a0,112(s1)
    802073b0:	00005097          	auipc	ra,0x5
    802073b4:	1f4080e7          	jalr	500(ra) # 8020c5a4 <fetchstr>
    802073b8:	06054c63          	bltz	a0,80207430 <syscallChangeDir+0xc0>
    802073bc:	00100613          	li	a2,1
    802073c0:	ec840593          	addi	a1,s0,-312
    802073c4:	f9c00513          	li	a0,-100
    802073c8:	ffffc097          	auipc	ra,0xffffc
    802073cc:	674080e7          	jalr	1652(ra) # 80203a3c <ename>
    802073d0:	00050993          	mv	s3,a0
    802073d4:	04050e63          	beqz	a0,80207430 <syscallChangeDir+0xc0>
        tf->a0 = -1;
        return;
    }

    elock(ep);
    802073d8:	ffffc097          	auipc	ra,0xffffc
    802073dc:	204080e7          	jalr	516(ra) # 802035dc <elock>
    if (!(ep->attribute & ATTR_DIRECTORY)) {
    802073e0:	1009c783          	lbu	a5,256(s3)
    802073e4:	0107f793          	andi	a5,a5,16
    802073e8:	02078863          	beqz	a5,80207418 <syscallChangeDir+0xa8>
        eput(ep);
        tf->a0 = -1;
        return;
    }    

    eunlock(ep);
    802073ec:	00098513          	mv	a0,s3
    802073f0:	ffffc097          	auipc	ra,0xffffc
    802073f4:	204080e7          	jalr	516(ra) # 802035f4 <eunlock>
    eput(process->cwd);
    802073f8:	000027b7          	lui	a5,0x2
    802073fc:	00f90933          	add	s2,s2,a5
    80207400:	08893503          	ld	a0,136(s2)
    80207404:	ffffc097          	auipc	ra,0xffffc
    80207408:	208080e7          	jalr	520(ra) # 8020360c <eput>
    process->cwd = ep;
    8020740c:	09393423          	sd	s3,136(s2)
    tf->a0 = 0;
    80207410:	0604b823          	sd	zero,112(s1)
    80207414:	0240006f          	j	80207438 <syscallChangeDir+0xc8>
        eunlock(ep);
    80207418:	00098513          	mv	a0,s3
    8020741c:	ffffc097          	auipc	ra,0xffffc
    80207420:	1d8080e7          	jalr	472(ra) # 802035f4 <eunlock>
        eput(ep);
    80207424:	00098513          	mv	a0,s3
    80207428:	ffffc097          	auipc	ra,0xffffc
    8020742c:	1e4080e7          	jalr	484(ra) # 8020360c <eput>
        tf->a0 = -1;
    80207430:	fff00793          	li	a5,-1
    80207434:	06f4b823          	sd	a5,112(s1)
}
    80207438:	13813083          	ld	ra,312(sp)
    8020743c:	13013403          	ld	s0,304(sp)
    80207440:	12813483          	ld	s1,296(sp)
    80207444:	12013903          	ld	s2,288(sp)
    80207448:	11813983          	ld	s3,280(sp)
    8020744c:	14010113          	addi	sp,sp,320
    80207450:	00008067          	ret

0000000080207454 <syscallPipe>:
    }
    
    tf->a0 = uva;
}

void syscallPipe(void) {
    80207454:	fb010113          	addi	sp,sp,-80
    80207458:	04113423          	sd	ra,72(sp)
    8020745c:	04813023          	sd	s0,64(sp)
    80207460:	02913c23          	sd	s1,56(sp)
    80207464:	03213823          	sd	s2,48(sp)
    80207468:	03313423          	sd	s3,40(sp)
    8020746c:	05010413          	addi	s0,sp,80
    Trapframe* tf = getHartTrapFrame();
    80207470:	00003097          	auipc	ra,0x3
    80207474:	d6c080e7          	jalr	-660(ra) # 8020a1dc <getHartTrapFrame>
    80207478:	00050493          	mv	s1,a0
    u64 fdarray = tf->a0;  // user pointer to array of two integers
    8020747c:	07053983          	ld	s3,112(a0)
    struct File *rf, *wf;
    int fd0, fd1;
    struct Process* p = myProcess();
    80207480:	00008097          	auipc	ra,0x8
    80207484:	568080e7          	jalr	1384(ra) # 8020f9e8 <myProcess>
    80207488:	00050913          	mv	s2,a0

    if (pipeNew(&rf, &wf) < 0) {
    8020748c:	fc040593          	addi	a1,s0,-64
    80207490:	fc840513          	addi	a0,s0,-56
    80207494:	ffffe097          	auipc	ra,0xffffe
    80207498:	d34080e7          	jalr	-716(ra) # 802051c8 <pipeNew>
    8020749c:	0e054263          	bltz	a0,80207580 <syscallPipe+0x12c>
        goto bad;
    }

    fd0 = -1;
    802074a0:	fff00793          	li	a5,-1
    802074a4:	faf42e23          	sw	a5,-68(s0)
    if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0) {
    802074a8:	fc843503          	ld	a0,-56(s0)
    802074ac:	fffff097          	auipc	ra,0xfffff
    802074b0:	0a0080e7          	jalr	160(ra) # 8020654c <fdalloc>
    802074b4:	faa42e23          	sw	a0,-68(s0)
    802074b8:	0a054863          	bltz	a0,80207568 <syscallPipe+0x114>
    802074bc:	fc043503          	ld	a0,-64(s0)
    802074c0:	fffff097          	auipc	ra,0xfffff
    802074c4:	08c080e7          	jalr	140(ra) # 8020654c <fdalloc>
    802074c8:	faa42c23          	sw	a0,-72(s0)
    802074cc:	08054263          	bltz	a0,80207550 <syscallPipe+0xfc>
        fileclose(rf);
        fileclose(wf);
        goto bad;
    }
    
    if (copyout(p->pgdir, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
    802074d0:	00400693          	li	a3,4
    802074d4:	fbc40613          	addi	a2,s0,-68
    802074d8:	00098593          	mv	a1,s3
    802074dc:	04093503          	ld	a0,64(s2)
    802074e0:	00002097          	auipc	ra,0x2
    802074e4:	658080e7          	jalr	1624(ra) # 80209b38 <copyout>
    802074e8:	02054263          	bltz	a0,8020750c <syscallPipe+0xb8>
        copyout(p->pgdir, fdarray + sizeof(fd0), (char*)&fd1, sizeof(fd1)) <
    802074ec:	00400693          	li	a3,4
    802074f0:	fb840613          	addi	a2,s0,-72
    802074f4:	00498593          	addi	a1,s3,4
    802074f8:	04093503          	ld	a0,64(s2)
    802074fc:	00002097          	auipc	ra,0x2
    80207500:	63c080e7          	jalr	1596(ra) # 80209b38 <copyout>
    80207504:	00000793          	li	a5,0
    if (copyout(p->pgdir, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
    80207508:	06055e63          	bgez	a0,80207584 <syscallPipe+0x130>
            0) {
        p->ofile[fd0] = 0;
    8020750c:	fbc42783          	lw	a5,-68(s0)
    80207510:	00e78793          	addi	a5,a5,14 # 200e <_start-0x801fdff2>
    80207514:	00379793          	slli	a5,a5,0x3
    80207518:	00f907b3          	add	a5,s2,a5
    8020751c:	0007b023          	sd	zero,0(a5)
        p->ofile[fd1] = 0;
    80207520:	fb842783          	lw	a5,-72(s0)
    80207524:	00e78793          	addi	a5,a5,14
    80207528:	00379793          	slli	a5,a5,0x3
    8020752c:	00f90533          	add	a0,s2,a5
    80207530:	00053023          	sd	zero,0(a0)
        fileclose(rf);
    80207534:	fc843503          	ld	a0,-56(s0)
    80207538:	ffffd097          	auipc	ra,0xffffd
    8020753c:	a04080e7          	jalr	-1532(ra) # 80203f3c <fileclose>
        fileclose(wf);
    80207540:	fc043503          	ld	a0,-64(s0)
    80207544:	ffffd097          	auipc	ra,0xffffd
    80207548:	9f8080e7          	jalr	-1544(ra) # 80203f3c <fileclose>
        goto bad;
    8020754c:	0340006f          	j	80207580 <syscallPipe+0x12c>
        if (fd0 >= 0)
    80207550:	fbc42783          	lw	a5,-68(s0)
    80207554:	0007ca63          	bltz	a5,80207568 <syscallPipe+0x114>
            p->ofile[fd0] = 0;
    80207558:	00e78793          	addi	a5,a5,14
    8020755c:	00379793          	slli	a5,a5,0x3
    80207560:	00f90533          	add	a0,s2,a5
    80207564:	00053023          	sd	zero,0(a0)
        fileclose(rf);
    80207568:	fc843503          	ld	a0,-56(s0)
    8020756c:	ffffd097          	auipc	ra,0xffffd
    80207570:	9d0080e7          	jalr	-1584(ra) # 80203f3c <fileclose>
        fileclose(wf);
    80207574:	fc043503          	ld	a0,-64(s0)
    80207578:	ffffd097          	auipc	ra,0xffffd
    8020757c:	9c4080e7          	jalr	-1596(ra) # 80203f3c <fileclose>
    
    tf->a0 = 0;
    return;

bad:
    tf->a0 = -1;
    80207580:	fff00793          	li	a5,-1
    80207584:	06f4b823          	sd	a5,112(s1)
}
    80207588:	04813083          	ld	ra,72(sp)
    8020758c:	04013403          	ld	s0,64(sp)
    80207590:	03813483          	ld	s1,56(sp)
    80207594:	03013903          	ld	s2,48(sp)
    80207598:	02813983          	ld	s3,40(sp)
    8020759c:	05010113          	addi	sp,sp,80
    802075a0:	00008067          	ret

00000000802075a4 <syscallDevice>:

void syscallDevice(void) {
    802075a4:	fc010113          	addi	sp,sp,-64
    802075a8:	02113c23          	sd	ra,56(sp)
    802075ac:	02813823          	sd	s0,48(sp)
    802075b0:	02913423          	sd	s1,40(sp)
    802075b4:	03213023          	sd	s2,32(sp)
    802075b8:	01313c23          	sd	s3,24(sp)
    802075bc:	01413823          	sd	s4,16(sp)
    802075c0:	01513423          	sd	s5,8(sp)
    802075c4:	04010413          	addi	s0,sp,64
    Trapframe* tf = getHartTrapFrame();
    802075c8:	00003097          	auipc	ra,0x3
    802075cc:	c14080e7          	jalr	-1004(ra) # 8020a1dc <getHartTrapFrame>
    int fd, omode = tf->a1;
    802075d0:	07853903          	ld	s2,120(a0)
    int major = tf->a0;
    802075d4:	07053a03          	ld	s4,112(a0)
    struct File* f;

    if (omode & O_CREATE_GLIBC) {
    802075d8:	04097793          	andi	a5,s2,64
    802075dc:	04079263          	bnez	a5,80207620 <syscallDevice+0x7c>
    802075e0:	00050493          	mv	s1,a0
    802075e4:	00090a9b          	sext.w	s5,s2
        panic("dev file on FAT");
    }

    if (major < 0 || major >= NDEV) {
    802075e8:	000a079b          	sext.w	a5,s4
    802075ec:	00300713          	li	a4,3
    802075f0:	04f77a63          	bgeu	a4,a5,80207644 <syscallDevice+0xa0>
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);

    tf->a0 = fd;
    return;

bad:
    802075f4:	fff00513          	li	a0,-1
    tf->a0 = fd;
    802075f8:	06a4b823          	sd	a0,112(s1)
    tf->a0 = -1;
}
    802075fc:	03813083          	ld	ra,56(sp)
    80207600:	03013403          	ld	s0,48(sp)
    80207604:	02813483          	ld	s1,40(sp)
    80207608:	02013903          	ld	s2,32(sp)
    8020760c:	01813983          	ld	s3,24(sp)
    80207610:	01013a03          	ld	s4,16(sp)
    80207614:	00813a83          	ld	s5,8(sp)
    80207618:	04010113          	addi	sp,sp,64
    8020761c:	00008067          	ret
        panic("dev file on FAT");
    80207620:	0000e697          	auipc	a3,0xe
    80207624:	24068693          	addi	a3,a3,576 # 80215860 <__func__.5+0x78>
    80207628:	0000e617          	auipc	a2,0xe
    8020762c:	29860613          	addi	a2,a2,664 # 802158c0 <__func__.3>
    80207630:	28100593          	li	a1,641
    80207634:	0000e517          	auipc	a0,0xe
    80207638:	1ec50513          	addi	a0,a0,492 # 80215820 <__func__.5+0x38>
    8020763c:	ffffa097          	auipc	ra,0xffffa
    80207640:	8ac080e7          	jalr	-1876(ra) # 80200ee8 <_panic_>
    if ((f = filealloc()) == NULL || (fd = fdalloc(f)) < 0) {
    80207644:	ffffd097          	auipc	ra,0xffffd
    80207648:	868080e7          	jalr	-1944(ra) # 80203eac <filealloc>
    8020764c:	00050993          	mv	s3,a0
    80207650:	fa0502e3          	beqz	a0,802075f4 <syscallDevice+0x50>
    80207654:	fffff097          	auipc	ra,0xfffff
    80207658:	ef8080e7          	jalr	-264(ra) # 8020654c <fdalloc>
    8020765c:	02054a63          	bltz	a0,80207690 <syscallDevice+0xec>
    f->type = FD_DEVICE;
    80207660:	00300793          	li	a5,3
    80207664:	00f9a023          	sw	a5,0(s3)
    f->off = 0;
    80207668:	0209a423          	sw	zero,40(s3)
    f->ep = 0;
    8020766c:	0009bc23          	sd	zero,24(s3)
    f->major = major;
    80207670:	03499623          	sh	s4,44(s3)
    f->readable = !(omode & O_WRONLY);
    80207674:	001aca93          	xori	s5,s5,1
    80207678:	001afa93          	andi	s5,s5,1
    8020767c:	01598423          	sb	s5,8(s3)
    f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
    80207680:	00397913          	andi	s2,s2,3
    80207684:	01203933          	snez	s2,s2
    80207688:	012984a3          	sb	s2,9(s3)
    return;
    8020768c:	f6dff06f          	j	802075f8 <syscallDevice+0x54>
            fileclose(f);
    80207690:	00098513          	mv	a0,s3
    80207694:	ffffd097          	auipc	ra,0xffffd
    80207698:	8a8080e7          	jalr	-1880(ra) # 80203f3c <fileclose>
    8020769c:	f59ff06f          	j	802075f4 <syscallDevice+0x50>

00000000802076a0 <syscallRenameAt>:
    ep.valid = 0;
    return enext(dp, &ep, 2 * 32, &count) == -1; // skip the "." and ".."
}
#endif

void syscallRenameAt(void) {
    802076a0:	ff010113          	addi	sp,sp,-16
    802076a4:	00113423          	sd	ra,8(sp)
    802076a8:	00813023          	sd	s0,0(sp)
    802076ac:	01010413          	addi	s0,sp,16
    Trapframe* tf = getHartTrapFrame();
    802076b0:	00003097          	auipc	ra,0x3
    802076b4:	b2c080e7          	jalr	-1236(ra) # 8020a1dc <getHartTrapFrame>
        eput(dst);
    }
    eput(pdst);
    eput(src);
    #endif
    tf->a0 = 0;
    802076b8:	06053823          	sd	zero,112(a0)
    #ifndef DEBUG_FS
fail:
    tf->a0 = -1;
    return;
    #endif
}
    802076bc:	00813083          	ld	ra,8(sp)
    802076c0:	00013403          	ld	s0,0(sp)
    802076c4:	01010113          	addi	sp,sp,16
    802076c8:	00008067          	ret

00000000802076cc <syscallMount>:

void syscallMount() {
    802076cc:	d9010113          	addi	sp,sp,-624
    802076d0:	26113423          	sd	ra,616(sp)
    802076d4:	26813023          	sd	s0,608(sp)
    802076d8:	24913c23          	sd	s1,600(sp)
    802076dc:	25213823          	sd	s2,592(sp)
    802076e0:	25313423          	sd	s3,584(sp)
    802076e4:	25413023          	sd	s4,576(sp)
    802076e8:	23513c23          	sd	s5,568(sp)
    802076ec:	27010413          	addi	s0,sp,624
    Trapframe *tf = getHartTrapFrame();
    802076f0:	00003097          	auipc	ra,0x3
    802076f4:	aec080e7          	jalr	-1300(ra) # 8020a1dc <getHartTrapFrame>
    802076f8:	00050493          	mv	s1,a0
    u64 imagePathUva = tf->a0, mountPathUva = tf->a1, typeUva = tf->a2, dataUva = tf->a4;
    802076fc:	07053903          	ld	s2,112(a0)
    80207700:	07853a03          	ld	s4,120(a0)
    80207704:	09053a83          	ld	s5,144(a0)
    int flag = tf->a3;
    80207708:	08853983          	ld	s3,136(a0)
    char imagePath[FAT32_MAX_FILENAME], mountPath[FAT32_MAX_FILENAME], type[10], data[10];
    if (fetchstr(typeUva, type, 10) < 0 || strncmp(type, "vfat", 4)) {
    8020770c:	00a00613          	li	a2,10
    80207710:	db040593          	addi	a1,s0,-592
    80207714:	08053503          	ld	a0,128(a0)
    80207718:	00005097          	auipc	ra,0x5
    8020771c:	e8c080e7          	jalr	-372(ra) # 8020c5a4 <fetchstr>
    80207720:	02054063          	bltz	a0,80207740 <syscallMount+0x74>
    80207724:	00400613          	li	a2,4
    80207728:	0000e597          	auipc	a1,0xe
    8020772c:	14858593          	addi	a1,a1,328 # 80215870 <__func__.5+0x88>
    80207730:	db040513          	addi	a0,s0,-592
    80207734:	00007097          	auipc	ra,0x7
    80207738:	73c080e7          	jalr	1852(ra) # 8020ee70 <strncmp>
    8020773c:	02050863          	beqz	a0,8020776c <syscallMount+0xa0>
        tf->a0 = -1;
    80207740:	fff00793          	li	a5,-1
    80207744:	06f4b823          	sd	a5,112(s1)
    fs->read = mountBlockRead;
    fatInit(fs);
    fs->next = dp->head;
    dp->head = fs;
    tf->a0 = 0;
}
    80207748:	26813083          	ld	ra,616(sp)
    8020774c:	26013403          	ld	s0,608(sp)
    80207750:	25813483          	ld	s1,600(sp)
    80207754:	25013903          	ld	s2,592(sp)
    80207758:	24813983          	ld	s3,584(sp)
    8020775c:	24013a03          	ld	s4,576(sp)
    80207760:	23813a83          	ld	s5,568(sp)
    80207764:	27010113          	addi	sp,sp,624
    80207768:	00008067          	ret
    if (fetchstr(imagePathUva, imagePath, FAT32_MAX_PATH) < 0 || (ep = ename(AT_FDCWD, imagePath, true)) == NULL) {
    8020776c:	10400613          	li	a2,260
    80207770:	ec040593          	addi	a1,s0,-320
    80207774:	00090513          	mv	a0,s2
    80207778:	00005097          	auipc	ra,0x5
    8020777c:	e2c080e7          	jalr	-468(ra) # 8020c5a4 <fetchstr>
    80207780:	fc0540e3          	bltz	a0,80207740 <syscallMount+0x74>
    80207784:	00100613          	li	a2,1
    80207788:	ec040593          	addi	a1,s0,-320
    8020778c:	f9c00513          	li	a0,-100
    80207790:	ffffc097          	auipc	ra,0xffffc
    80207794:	2ac080e7          	jalr	684(ra) # 80203a3c <ename>
    80207798:	00050913          	mv	s2,a0
    8020779c:	fa0502e3          	beqz	a0,80207740 <syscallMount+0x74>
    if (fetchstr(mountPathUva, mountPath, FAT32_MAX_PATH) < 0 || (dp = ename(AT_FDCWD, mountPath, true)) == NULL) {
    802077a0:	10400613          	li	a2,260
    802077a4:	dc040593          	addi	a1,s0,-576
    802077a8:	000a0513          	mv	a0,s4
    802077ac:	00005097          	auipc	ra,0x5
    802077b0:	df8080e7          	jalr	-520(ra) # 8020c5a4 <fetchstr>
    802077b4:	f80546e3          	bltz	a0,80207740 <syscallMount+0x74>
    802077b8:	00100613          	li	a2,1
    802077bc:	dc040593          	addi	a1,s0,-576
    802077c0:	f9c00513          	li	a0,-100
    802077c4:	ffffc097          	auipc	ra,0xffffc
    802077c8:	278080e7          	jalr	632(ra) # 80203a3c <ename>
    802077cc:	00050a13          	mv	s4,a0
    802077d0:	f60508e3          	beqz	a0,80207740 <syscallMount+0x74>
    if (dataUva && fetchstr(dataUva, data, 10) < 0) {
    802077d4:	000a8e63          	beqz	s5,802077f0 <syscallMount+0x124>
    802077d8:	00a00613          	li	a2,10
    802077dc:	da040593          	addi	a1,s0,-608
    802077e0:	000a8513          	mv	a0,s5
    802077e4:	00005097          	auipc	ra,0x5
    802077e8:	dc0080e7          	jalr	-576(ra) # 8020c5a4 <fetchstr>
    802077ec:	f4054ae3          	bltz	a0,80207740 <syscallMount+0x74>
    assert(flag == 0);
    802077f0:	0009869b          	sext.w	a3,s3
    802077f4:	0016b693          	seqz	a3,a3
    802077f8:	0000e617          	auipc	a2,0xe
    802077fc:	0d860613          	addi	a2,a2,216 # 802158d0 <__func__.2>
    80207800:	30d00593          	li	a1,781
    80207804:	0000e517          	auipc	a0,0xe
    80207808:	01c50513          	addi	a0,a0,28 # 80215820 <__func__.5+0x38>
    8020780c:	ffff9097          	auipc	ra,0xffff9
    80207810:	74c080e7          	jalr	1868(ra) # 80200f58 <_assert_>
    if (fsAlloc(&fs) < 0) {
    80207814:	d9840513          	addi	a0,s0,-616
    80207818:	ffffd097          	auipc	ra,0xffffd
    8020781c:	e8c080e7          	jalr	-372(ra) # 802046a4 <fsAlloc>
    80207820:	f20540e3          	bltz	a0,80207740 <syscallMount+0x74>
    struct File *file = filealloc();
    80207824:	ffffc097          	auipc	ra,0xffffc
    80207828:	688080e7          	jalr	1672(ra) # 80203eac <filealloc>
    8020782c:	00050793          	mv	a5,a0
    file->off = 0;
    80207830:	02052423          	sw	zero,40(a0)
    file->readable = true;
    80207834:	00100713          	li	a4,1
    80207838:	00e50423          	sb	a4,8(a0)
    file->writable = true;
    8020783c:	00e504a3          	sb	a4,9(a0)
    if (ep->head) {
    80207840:	23093703          	ld	a4,560(s2)
    80207844:	06070463          	beqz	a4,802078ac <syscallMount+0x1e0>
        file->type = ep->head->image->type;
    80207848:	2c873703          	ld	a4,712(a4)
    8020784c:	00072703          	lw	a4,0(a4)
    80207850:	00e52023          	sw	a4,0(a0)
        file->ep = ep->head->image->ep;
    80207854:	23093703          	ld	a4,560(s2)
    80207858:	2c873703          	ld	a4,712(a4)
    8020785c:	01873903          	ld	s2,24(a4)
    80207860:	0127bc23          	sd	s2,24(a5)
    fs->name[0] = 'm';
    80207864:	d9843703          	ld	a4,-616(s0)
    80207868:	06d00693          	li	a3,109
    8020786c:	00d700a3          	sb	a3,1(a4)
    fs->name[1] = 0;
    80207870:	d9843703          	ld	a4,-616(s0)
    80207874:	00070123          	sb	zero,2(a4)
    fs->image = file;
    80207878:	d9843503          	ld	a0,-616(s0)
    8020787c:	2cf53423          	sd	a5,712(a0)
    fs->read = mountBlockRead;
    80207880:	ffffa797          	auipc	a5,0xffffa
    80207884:	58478793          	addi	a5,a5,1412 # 80201e04 <mountBlockRead>
    80207888:	2ef53023          	sd	a5,736(a0)
    fatInit(fs);
    8020788c:	ffffd097          	auipc	ra,0xffffd
    80207890:	170080e7          	jalr	368(ra) # 802049fc <fatInit>
    fs->next = dp->head;
    80207894:	d9843783          	ld	a5,-616(s0)
    80207898:	230a3703          	ld	a4,560(s4)
    8020789c:	2ce7b823          	sd	a4,720(a5)
    dp->head = fs;
    802078a0:	22fa3823          	sd	a5,560(s4)
    tf->a0 = 0;
    802078a4:	0604b823          	sd	zero,112(s1)
    802078a8:	ea1ff06f          	j	80207748 <syscallMount+0x7c>
        file->type = FD_ENTRY;
    802078ac:	00200713          	li	a4,2
    802078b0:	00e52023          	sw	a4,0(a0)
        file->ep = ep;
    802078b4:	fadff06f          	j	80207860 <syscallMount+0x194>

00000000802078b8 <syscallUmount>:

void syscallUmount() {
    802078b8:	ed010113          	addi	sp,sp,-304
    802078bc:	12113423          	sd	ra,296(sp)
    802078c0:	12813023          	sd	s0,288(sp)
    802078c4:	10913c23          	sd	s1,280(sp)
    802078c8:	11213823          	sd	s2,272(sp)
    802078cc:	11313423          	sd	s3,264(sp)
    802078d0:	13010413          	addi	s0,sp,304
    Trapframe *tf = getHartTrapFrame();
    802078d4:	00003097          	auipc	ra,0x3
    802078d8:	908080e7          	jalr	-1784(ra) # 8020a1dc <getHartTrapFrame>
    802078dc:	00050493          	mv	s1,a0
    u64 mountPathUva = tf->a0;
    int flag = tf->a1;
    802078e0:	07853983          	ld	s3,120(a0)
    char mountPath[FAT32_MAX_FILENAME];
    Dirent *ep;

    if (fetchstr(mountPathUva, mountPath, FAT32_MAX_PATH) < 0 || (ep = ename(AT_FDCWD, mountPath, true)) == NULL) {
    802078e4:	10400613          	li	a2,260
    802078e8:	ed040593          	addi	a1,s0,-304
    802078ec:	07053503          	ld	a0,112(a0)
    802078f0:	00005097          	auipc	ra,0x5
    802078f4:	cb4080e7          	jalr	-844(ra) # 8020c5a4 <fetchstr>
    802078f8:	06054263          	bltz	a0,8020795c <syscallUmount+0xa4>
    802078fc:	00100613          	li	a2,1
    80207900:	ed040593          	addi	a1,s0,-304
    80207904:	f9c00513          	li	a0,-100
    80207908:	ffffc097          	auipc	ra,0xffffc
    8020790c:	134080e7          	jalr	308(ra) # 80203a3c <ename>
    80207910:	00050913          	mv	s2,a0
    80207914:	04050463          	beqz	a0,8020795c <syscallUmount+0xa4>
        tf->a0 = -1;
        return;
    }

    assert(flag == 0);
    80207918:	0009869b          	sext.w	a3,s3
    8020791c:	0016b693          	seqz	a3,a3
    80207920:	0000e617          	auipc	a2,0xe
    80207924:	fc060613          	addi	a2,a2,-64 # 802158e0 <__func__.1>
    80207928:	33500593          	li	a1,821
    8020792c:	0000e517          	auipc	a0,0xe
    80207930:	ef450513          	addi	a0,a0,-268 # 80215820 <__func__.5+0x38>
    80207934:	ffff9097          	auipc	ra,0xffff9
    80207938:	624080e7          	jalr	1572(ra) # 80200f58 <_assert_>

    if (ep->head == NULL) {
    8020793c:	23093783          	ld	a5,560(s2)
    80207940:	00078e63          	beqz	a5,8020795c <syscallUmount+0xa4>
        tf->a0 = -1;
        return;
    }

    ep->head->valid = 0;
    80207944:	00078023          	sb	zero,0(a5)
    ep->head = ep->head->next;
    80207948:	23093783          	ld	a5,560(s2)
    8020794c:	2d07b783          	ld	a5,720(a5)
    80207950:	22f93823          	sd	a5,560(s2)

    tf->a0 = 0;
    80207954:	0604b823          	sd	zero,112(s1)
    80207958:	00c0006f          	j	80207964 <syscallUmount+0xac>
        tf->a0 = -1;
    8020795c:	fff00793          	li	a5,-1
    80207960:	06f4b823          	sd	a5,112(s1)
}
    80207964:	12813083          	ld	ra,296(sp)
    80207968:	12013403          	ld	s0,288(sp)
    8020796c:	11813483          	ld	s1,280(sp)
    80207970:	11013903          	ld	s2,272(sp)
    80207974:	10813983          	ld	s3,264(sp)
    80207978:	13010113          	addi	sp,sp,304
    8020797c:	00008067          	ret

0000000080207980 <do_unlinkat>:
    }

    tf->a0 = do_linkat(oldDirFd, oldPath, newDirFd, newPath);
}

int do_unlinkat(int fd, char* path) {
    80207980:	fe010113          	addi	sp,sp,-32
    80207984:	00113c23          	sd	ra,24(sp)
    80207988:	00813823          	sd	s0,16(sp)
    8020798c:	00913423          	sd	s1,8(sp)
    80207990:	02010413          	addi	s0,sp,32
    Dirent* entryPoint;
    if((entryPoint = ename(fd, path, true)) == NULL) {
    80207994:	00100613          	li	a2,1
    80207998:	ffffc097          	auipc	ra,0xffffc
    8020799c:	0a4080e7          	jalr	164(ra) # 80203a3c <ename>
    802079a0:	02050c63          	beqz	a0,802079d8 <do_unlinkat+0x58>
    802079a4:	00050493          	mv	s1,a0
        goto bad;
    }

    etrunc(entryPoint);
    802079a8:	ffffc097          	auipc	ra,0xffffc
    802079ac:	b20080e7          	jalr	-1248(ra) # 802034c8 <etrunc>
    entryPoint->_nt_res = 0;
    802079b0:	20048c23          	sb	zero,536(s1)
    eremove(entryPoint);
    802079b4:	00048513          	mv	a0,s1
    802079b8:	ffffc097          	auipc	ra,0xffffc
    802079bc:	ab8080e7          	jalr	-1352(ra) # 80203470 <eremove>

    return 0;
    802079c0:	00000513          	li	a0,0

bad:
    return -1;
}
    802079c4:	01813083          	ld	ra,24(sp)
    802079c8:	01013403          	ld	s0,16(sp)
    802079cc:	00813483          	ld	s1,8(sp)
    802079d0:	02010113          	addi	sp,sp,32
    802079d4:	00008067          	ret
    return -1;
    802079d8:	fff00513          	li	a0,-1
    802079dc:	fe9ff06f          	j	802079c4 <do_unlinkat+0x44>

00000000802079e0 <syscallUnlinkAt>:

void syscallUnlinkAt() {
    802079e0:	ed010113          	addi	sp,sp,-304
    802079e4:	12113423          	sd	ra,296(sp)
    802079e8:	12813023          	sd	s0,288(sp)
    802079ec:	10913c23          	sd	s1,280(sp)
    802079f0:	11213823          	sd	s2,272(sp)
    802079f4:	13010413          	addi	s0,sp,304
    Trapframe *tf = getHartTrapFrame();
    802079f8:	00002097          	auipc	ra,0x2
    802079fc:	7e4080e7          	jalr	2020(ra) # 8020a1dc <getHartTrapFrame>
    80207a00:	00050493          	mv	s1,a0
    int dirFd = tf->a0/*, flags = tf->a2*/;
    80207a04:	07053903          	ld	s2,112(a0)
    
    // assert(flags == 0);
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80207a08:	10400613          	li	a2,260
    80207a0c:	ed840593          	addi	a1,s0,-296
    80207a10:	07853503          	ld	a0,120(a0)
    80207a14:	00005097          	auipc	ra,0x5
    80207a18:	b90080e7          	jalr	-1136(ra) # 8020c5a4 <fetchstr>
    80207a1c:	fff00793          	li	a5,-1
    80207a20:	00054c63          	bltz	a0,80207a38 <syscallUnlinkAt+0x58>
        tf->a0 = -1;
        return;
    }
    
    tf->a0 = do_unlinkat(dirFd, path);
    80207a24:	ed840593          	addi	a1,s0,-296
    80207a28:	0009051b          	sext.w	a0,s2
    80207a2c:	00000097          	auipc	ra,0x0
    80207a30:	f54080e7          	jalr	-172(ra) # 80207980 <do_unlinkat>
    80207a34:	00050793          	mv	a5,a0
    80207a38:	06f4b823          	sd	a5,112(s1)
}
    80207a3c:	12813083          	ld	ra,296(sp)
    80207a40:	12013403          	ld	s0,288(sp)
    80207a44:	11813483          	ld	s1,280(sp)
    80207a48:	11013903          	ld	s2,272(sp)
    80207a4c:	13010113          	addi	sp,sp,304
    80207a50:	00008067          	ret

0000000080207a54 <syscallLSeek>:

void syscallLSeek() {
    80207a54:	fd010113          	addi	sp,sp,-48
    80207a58:	02113423          	sd	ra,40(sp)
    80207a5c:	02813023          	sd	s0,32(sp)
    80207a60:	00913c23          	sd	s1,24(sp)
    80207a64:	01213823          	sd	s2,16(sp)
    80207a68:	01313423          	sd	s3,8(sp)
    80207a6c:	01413023          	sd	s4,0(sp)
    80207a70:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    80207a74:	00002097          	auipc	ra,0x2
    80207a78:	768080e7          	jalr	1896(ra) # 8020a1dc <getHartTrapFrame>
    80207a7c:	00050493          	mv	s1,a0
    int fd = tf->a0, mode = tf->a2;
    80207a80:	07053903          	ld	s2,112(a0)
    80207a84:	08053983          	ld	s3,128(a0)
    u64 offset = tf->a1;
    80207a88:	07853a03          	ld	s4,120(a0)
    if (fd < 0 || fd >= NOFILE) {
    80207a8c:	0009071b          	sext.w	a4,s2
    80207a90:	3ff00793          	li	a5,1023
    80207a94:	02e7f663          	bgeu	a5,a4,80207ac0 <syscallLSeek+0x6c>
    // } else {
    //     file->off = (off >= file->ep->file_size ? file->ep->file_size : off);
    // }
    tf->a0 = off;
    return;
bad:
    80207a98:	fff00a13          	li	s4,-1
    tf->a0 = off;
    80207a9c:	0744b823          	sd	s4,112(s1)
    tf->a0 = -1;
}
    80207aa0:	02813083          	ld	ra,40(sp)
    80207aa4:	02013403          	ld	s0,32(sp)
    80207aa8:	01813483          	ld	s1,24(sp)
    80207aac:	01013903          	ld	s2,16(sp)
    80207ab0:	00813983          	ld	s3,8(sp)
    80207ab4:	00013a03          	ld	s4,0(sp)
    80207ab8:	03010113          	addi	sp,sp,48
    80207abc:	00008067          	ret
    struct File* file = myProcess()->ofile[fd];
    80207ac0:	00008097          	auipc	ra,0x8
    80207ac4:	f28080e7          	jalr	-216(ra) # 8020f9e8 <myProcess>
    80207ac8:	0009091b          	sext.w	s2,s2
    80207acc:	00e90913          	addi	s2,s2,14
    80207ad0:	00391913          	slli	s2,s2,0x3
    80207ad4:	01250533          	add	a0,a0,s2
    80207ad8:	00053703          	ld	a4,0(a0)
    if (file == 0) {
    80207adc:	fa070ee3          	beqz	a4,80207a98 <syscallLSeek+0x44>
    int fd = tf->a0, mode = tf->a2;
    80207ae0:	0009879b          	sext.w	a5,s3
    switch (mode) {
    80207ae4:	00100693          	li	a3,1
    80207ae8:	00d78c63          	beq	a5,a3,80207b00 <syscallLSeek+0xac>
    80207aec:	00200693          	li	a3,2
    80207af0:	00d78e63          	beq	a5,a3,80207b0c <syscallLSeek+0xb8>
    80207af4:	fa0792e3          	bnez	a5,80207a98 <syscallLSeek+0x44>
    file->off = off;
    80207af8:	03472423          	sw	s4,40(a4)
    return;
    80207afc:	fa1ff06f          	j	80207a9c <syscallLSeek+0x48>
            off += file->off;
    80207b00:	02876783          	lwu	a5,40(a4)
    80207b04:	00fa0a33          	add	s4,s4,a5
            break;
    80207b08:	ff1ff06f          	j	80207af8 <syscallLSeek+0xa4>
            off += file->ep->file_size;
    80207b0c:	01873783          	ld	a5,24(a4)
    80207b10:	1087e783          	lwu	a5,264(a5)
    80207b14:	00fa0a33          	add	s4,s4,a5
            break;
    80207b18:	fe1ff06f          	j	80207af8 <syscallLSeek+0xa4>

0000000080207b1c <syscallPRead>:

void syscallPRead() {
    80207b1c:	fd010113          	addi	sp,sp,-48
    80207b20:	02113423          	sd	ra,40(sp)
    80207b24:	02813023          	sd	s0,32(sp)
    80207b28:	00913c23          	sd	s1,24(sp)
    80207b2c:	01213823          	sd	s2,16(sp)
    80207b30:	01313423          	sd	s3,8(sp)
    80207b34:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    80207b38:	00002097          	auipc	ra,0x2
    80207b3c:	6a4080e7          	jalr	1700(ra) # 8020a1dc <getHartTrapFrame>
    80207b40:	00050493          	mv	s1,a0
    int fd = tf->a0;
    80207b44:	07052903          	lw	s2,112(a0)
    struct File* file = myProcess()->ofile[fd];
    80207b48:	00008097          	auipc	ra,0x8
    80207b4c:	ea0080e7          	jalr	-352(ra) # 8020f9e8 <myProcess>
    80207b50:	00e90913          	addi	s2,s2,14
    80207b54:	00391913          	slli	s2,s2,0x3
    80207b58:	01250533          	add	a0,a0,s2
    80207b5c:	00053903          	ld	s2,0(a0)
    if (file == 0) {
    80207b60:	04090463          	beqz	s2,80207ba8 <syscallPRead+0x8c>
        goto bad;
    }
    u32 off = file->off;
    80207b64:	02892983          	lw	s3,40(s2)
    tf->a0 = eread(file->ep, true, tf->a1, tf->a3, tf->a2);
    80207b68:	0804a703          	lw	a4,128(s1)
    80207b6c:	0884a683          	lw	a3,136(s1)
    80207b70:	0784b603          	ld	a2,120(s1)
    80207b74:	00100593          	li	a1,1
    80207b78:	01893503          	ld	a0,24(s2)
    80207b7c:	ffffb097          	auipc	ra,0xffffb
    80207b80:	220080e7          	jalr	544(ra) # 80202d9c <eread>
    80207b84:	06a4b823          	sd	a0,112(s1)
    file->off = off;
    80207b88:	03392423          	sw	s3,40(s2)
    return;
bad:
    tf->a0 = -1;
}
    80207b8c:	02813083          	ld	ra,40(sp)
    80207b90:	02013403          	ld	s0,32(sp)
    80207b94:	01813483          	ld	s1,24(sp)
    80207b98:	01013903          	ld	s2,16(sp)
    80207b9c:	00813983          	ld	s3,8(sp)
    80207ba0:	03010113          	addi	sp,sp,48
    80207ba4:	00008067          	ret
    tf->a0 = -1;
    80207ba8:	fff00793          	li	a5,-1
    80207bac:	06f4b823          	sd	a5,112(s1)
    80207bb0:	fddff06f          	j	80207b8c <syscallPRead+0x70>

0000000080207bb4 <syscallUtimensat>:

void syscallUtimensat() {
    80207bb4:	eb010113          	addi	sp,sp,-336
    80207bb8:	14113423          	sd	ra,328(sp)
    80207bbc:	14813023          	sd	s0,320(sp)
    80207bc0:	12913c23          	sd	s1,312(sp)
    80207bc4:	13213823          	sd	s2,304(sp)
    80207bc8:	15010413          	addi	s0,sp,336
    Trapframe *tf = getHartTrapFrame();
    80207bcc:	00002097          	auipc	ra,0x2
    80207bd0:	610080e7          	jalr	1552(ra) # 8020a1dc <getHartTrapFrame>
    80207bd4:	00050493          	mv	s1,a0
    char path[FAT32_MAX_PATH];
    int dirFd = tf->a0;
    80207bd8:	07053783          	ld	a5,112(a0)
    80207bdc:	0007891b          	sext.w	s2,a5
    Dirent *de;
    if (tf->a1) {
    80207be0:	07853503          	ld	a0,120(a0)
    80207be4:	02051863          	bnez	a0,80207c14 <syscallUtimensat+0x60>
            tf->a0 = -ENOENT;
            return;
        }
    } else {
        File *f;
        if (dirFd < 0 || dirFd >= NOFILE || (f = myProcess()->ofile[dirFd]) == NULL) {
    80207be8:	0007879b          	sext.w	a5,a5
    80207bec:	3ff00713          	li	a4,1023
    80207bf0:	06f77c63          	bgeu	a4,a5,80207c68 <syscallUtimensat+0xb4>
            tf->a0 = -EBADF;
            return;
    80207bf4:	ff700793          	li	a5,-9
            tf->a0 = -1;
    80207bf8:	06f4b823          	sd	a5,112(s1)
        TimeSpec ts[2];
        copyin(myProcess()->pgdir, (char*)ts, tf->a2, sizeof(ts));
        eSetTime(de, ts);
    }
    tf->a0 = 0;
}
    80207bfc:	14813083          	ld	ra,328(sp)
    80207c00:	14013403          	ld	s0,320(sp)
    80207c04:	13813483          	ld	s1,312(sp)
    80207c08:	13013903          	ld	s2,304(sp)
    80207c0c:	15010113          	addi	sp,sp,336
    80207c10:	00008067          	ret
        if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80207c14:	10400613          	li	a2,260
    80207c18:	ed840593          	addi	a1,s0,-296
    80207c1c:	00005097          	auipc	ra,0x5
    80207c20:	988080e7          	jalr	-1656(ra) # 8020c5a4 <fetchstr>
    80207c24:	0a054463          	bltz	a0,80207ccc <syscallUtimensat+0x118>
        if ((dirFd < 0 && dirFd != AT_FDCWD) || dirFd >= NOFILE) {
    80207c28:	00094a63          	bltz	s2,80207c3c <syscallUtimensat+0x88>
    80207c2c:	3ff00713          	li	a4,1023
    80207c30:	ff700793          	li	a5,-9
    80207c34:	fd2742e3          	blt	a4,s2,80207bf8 <syscallUtimensat+0x44>
    80207c38:	00c0006f          	j	80207c44 <syscallUtimensat+0x90>
    80207c3c:	f9c00793          	li	a5,-100
    80207c40:	08f91a63          	bne	s2,a5,80207cd4 <syscallUtimensat+0x120>
        if((de = ename(dirFd, path, true)) == NULL) {
    80207c44:	00100613          	li	a2,1
    80207c48:	ed840593          	addi	a1,s0,-296
    80207c4c:	00090513          	mv	a0,s2
    80207c50:	ffffc097          	auipc	ra,0xffffc
    80207c54:	dec080e7          	jalr	-532(ra) # 80203a3c <ename>
    80207c58:	00050913          	mv	s2,a0
    80207c5c:	02051663          	bnez	a0,80207c88 <syscallUtimensat+0xd4>
    80207c60:	ffe00793          	li	a5,-2
    80207c64:	f95ff06f          	j	80207bf8 <syscallUtimensat+0x44>
        if (dirFd < 0 || dirFd >= NOFILE || (f = myProcess()->ofile[dirFd]) == NULL) {
    80207c68:	00008097          	auipc	ra,0x8
    80207c6c:	d80080e7          	jalr	-640(ra) # 8020f9e8 <myProcess>
    80207c70:	00e90913          	addi	s2,s2,14
    80207c74:	00391913          	slli	s2,s2,0x3
    80207c78:	01250533          	add	a0,a0,s2
    80207c7c:	00053783          	ld	a5,0(a0)
    80207c80:	f6078ae3          	beqz	a5,80207bf4 <syscallUtimensat+0x40>
        de = f->ep;
    80207c84:	0187b903          	ld	s2,24(a5)
    if (tf->a2) {
    80207c88:	0804b783          	ld	a5,128(s1)
    80207c8c:	00079663          	bnez	a5,80207c98 <syscallUtimensat+0xe4>
    tf->a0 = 0;
    80207c90:	0604b823          	sd	zero,112(s1)
    80207c94:	f69ff06f          	j	80207bfc <syscallUtimensat+0x48>
        copyin(myProcess()->pgdir, (char*)ts, tf->a2, sizeof(ts));
    80207c98:	00008097          	auipc	ra,0x8
    80207c9c:	d50080e7          	jalr	-688(ra) # 8020f9e8 <myProcess>
    80207ca0:	02000693          	li	a3,32
    80207ca4:	0804b603          	ld	a2,128(s1)
    80207ca8:	eb840593          	addi	a1,s0,-328
    80207cac:	04053503          	ld	a0,64(a0)
    80207cb0:	00002097          	auipc	ra,0x2
    80207cb4:	d98080e7          	jalr	-616(ra) # 80209a48 <copyin>
        eSetTime(de, ts);
    80207cb8:	eb840593          	addi	a1,s0,-328
    80207cbc:	00090513          	mv	a0,s2
    80207cc0:	ffffb097          	auipc	ra,0xffffb
    80207cc4:	614080e7          	jalr	1556(ra) # 802032d4 <eSetTime>
    80207cc8:	fc9ff06f          	j	80207c90 <syscallUtimensat+0xdc>
    80207ccc:	fff00793          	li	a5,-1
    80207cd0:	f29ff06f          	j	80207bf8 <syscallUtimensat+0x44>
    80207cd4:	ff700793          	li	a5,-9
    80207cd8:	f21ff06f          	j	80207bf8 <syscallUtimensat+0x44>

0000000080207cdc <syscallSendFile>:

void syscallSendFile() {
    80207cdc:	d9010113          	addi	sp,sp,-624
    80207ce0:	26113423          	sd	ra,616(sp)
    80207ce4:	26813023          	sd	s0,608(sp)
    80207ce8:	24913c23          	sd	s1,600(sp)
    80207cec:	25213823          	sd	s2,592(sp)
    80207cf0:	25313423          	sd	s3,584(sp)
    80207cf4:	25413023          	sd	s4,576(sp)
    80207cf8:	23513c23          	sd	s5,568(sp)
    80207cfc:	23613823          	sd	s6,560(sp)
    80207d00:	23713423          	sd	s7,552(sp)
    80207d04:	23813023          	sd	s8,544(sp)
    80207d08:	21913c23          	sd	s9,536(sp)
    80207d0c:	27010413          	addi	s0,sp,624
    Trapframe *tf = getHartTrapFrame();
    80207d10:	00002097          	auipc	ra,0x2
    80207d14:	4cc080e7          	jalr	1228(ra) # 8020a1dc <getHartTrapFrame>
    80207d18:	00050993          	mv	s3,a0
    int outFd = tf->a0, inFd = tf->a1;
    80207d1c:	07053903          	ld	s2,112(a0)
    80207d20:	07853483          	ld	s1,120(a0)
    if (outFd < 0 || outFd >= NOFILE) {
        goto bad;
    }
    if (inFd < 0 || inFd >= NOFILE) {
    80207d24:	009967b3          	or	a5,s2,s1
    80207d28:	0007879b          	sext.w	a5,a5
    80207d2c:	3ff00713          	li	a4,1023
    80207d30:	04f77063          	bgeu	a4,a5,80207d70 <syscallSendFile+0x94>
    }
    tf->a0 = size;
    return;
bad:
    tf->a0 = -1;
    return;
    80207d34:	fff00a13          	li	s4,-1
    tf->a0 = size;
    80207d38:	0749b823          	sd	s4,112(s3)
}
    80207d3c:	26813083          	ld	ra,616(sp)
    80207d40:	26013403          	ld	s0,608(sp)
    80207d44:	25813483          	ld	s1,600(sp)
    80207d48:	25013903          	ld	s2,592(sp)
    80207d4c:	24813983          	ld	s3,584(sp)
    80207d50:	24013a03          	ld	s4,576(sp)
    80207d54:	23813a83          	ld	s5,568(sp)
    80207d58:	23013b03          	ld	s6,560(sp)
    80207d5c:	22813b83          	ld	s7,552(sp)
    80207d60:	22013c03          	ld	s8,544(sp)
    80207d64:	21813c83          	ld	s9,536(sp)
    80207d68:	27010113          	addi	sp,sp,624
    80207d6c:	00008067          	ret
    struct File *outFile = myProcess()->ofile[outFd];
    80207d70:	00008097          	auipc	ra,0x8
    80207d74:	c78080e7          	jalr	-904(ra) # 8020f9e8 <myProcess>
    80207d78:	0009091b          	sext.w	s2,s2
    80207d7c:	00e90913          	addi	s2,s2,14
    80207d80:	00391913          	slli	s2,s2,0x3
    80207d84:	01250533          	add	a0,a0,s2
    80207d88:	00053c03          	ld	s8,0(a0)
    struct File *inFile = myProcess()->ofile[inFd];
    80207d8c:	00008097          	auipc	ra,0x8
    80207d90:	c5c080e7          	jalr	-932(ra) # 8020f9e8 <myProcess>
    80207d94:	0004849b          	sext.w	s1,s1
    80207d98:	00e48493          	addi	s1,s1,14
    80207d9c:	00349493          	slli	s1,s1,0x3
    80207da0:	00950533          	add	a0,a0,s1
    80207da4:	00053b03          	ld	s6,0(a0)
    if (outFile == NULL || inFile == NULL) {
    80207da8:	f80c06e3          	beqz	s8,80207d34 <syscallSendFile+0x58>
    80207dac:	f80b04e3          	beqz	s6,80207d34 <syscallSendFile+0x58>
    if (tf->a2) {
    80207db0:	0809b783          	ld	a5,128(s3)
    80207db4:	02079063          	bnez	a5,80207dd4 <syscallSendFile+0xf8>
    u32 count = tf->a3, size = 0;
    80207db8:	0889a903          	lw	s2,136(s3)
    80207dbc:	00090a13          	mv	s4,s2
    while (count > 0) {
    80207dc0:	04090863          	beqz	s2,80207e10 <syscallSendFile+0x134>
    u32 count = tf->a3, size = 0;
    80207dc4:	00000a13          	li	s4,0
        int len = MIN(count, 512);
    80207dc8:	20000b93          	li	s7,512
    80207dcc:	20000c93          	li	s9,512
    80207dd0:	0800006f          	j	80207e50 <syscallSendFile+0x174>
        copyin(myProcess()->pgdir, (char*) &offset, tf->a2, sizeof(u32));
    80207dd4:	00008097          	auipc	ra,0x8
    80207dd8:	c14080e7          	jalr	-1004(ra) # 8020f9e8 <myProcess>
    80207ddc:	00400693          	li	a3,4
    80207de0:	0809b603          	ld	a2,128(s3)
    80207de4:	f9c40593          	addi	a1,s0,-100
    80207de8:	04053503          	ld	a0,64(a0)
    80207dec:	00002097          	auipc	ra,0x2
    80207df0:	c5c080e7          	jalr	-932(ra) # 80209a48 <copyin>
        inFile->off = offset;
    80207df4:	f9c42783          	lw	a5,-100(s0)
    80207df8:	02fb2423          	sw	a5,40(s6)
    u32 count = tf->a3, size = 0;
    80207dfc:	0889a903          	lw	s2,136(s3)
    while (count > 0) {
    80207e00:	fc0912e3          	bnez	s2,80207dc4 <syscallSendFile+0xe8>
    u32 count = tf->a3, size = 0;
    80207e04:	00090a13          	mv	s4,s2
    if (tf->a2) {
    80207e08:	0809b783          	ld	a5,128(s3)
    80207e0c:	06079863          	bnez	a5,80207e7c <syscallSendFile+0x1a0>
    tf->a0 = size;
    80207e10:	020a1a13          	slli	s4,s4,0x20
    80207e14:	020a5a13          	srli	s4,s4,0x20
    return;
    80207e18:	f21ff06f          	j	80207d38 <syscallSendFile+0x5c>
        int len = MIN(count, 512);
    80207e1c:	00048a9b          	sext.w	s5,s1
    80207e20:	000a8493          	mv	s1,s5
        int r = fileread(inFile, false, (u64)buf, len);
    80207e24:	000a8693          	mv	a3,s5
    80207e28:	d9840613          	addi	a2,s0,-616
    80207e2c:	00000593          	li	a1,0
    80207e30:	000b0513          	mv	a0,s6
    80207e34:	ffffc097          	auipc	ra,0xffffc
    80207e38:	26c080e7          	jalr	620(ra) # 802040a0 <fileread>
        if (r > 0)
    80207e3c:	02a04263          	bgtz	a0,80207e60 <syscallSendFile+0x184>
        size += r;
    80207e40:	01450a3b          	addw	s4,a0,s4
        if (r != len) {
    80207e44:	fc9512e3          	bne	a0,s1,80207e08 <syscallSendFile+0x12c>
        count -= len; 
    80207e48:	4159093b          	subw	s2,s2,s5
    while (count > 0) {
    80207e4c:	fa090ee3          	beqz	s2,80207e08 <syscallSendFile+0x12c>
        int len = MIN(count, 512);
    80207e50:	00090493          	mv	s1,s2
    80207e54:	fd2bf4e3          	bgeu	s7,s2,80207e1c <syscallSendFile+0x140>
    80207e58:	000c8493          	mv	s1,s9
    80207e5c:	fc1ff06f          	j	80207e1c <syscallSendFile+0x140>
            r = filewrite(outFile, false, (u64)buf, r);
    80207e60:	00050693          	mv	a3,a0
    80207e64:	d9840613          	addi	a2,s0,-616
    80207e68:	00000593          	li	a1,0
    80207e6c:	000c0513          	mv	a0,s8
    80207e70:	ffffc097          	auipc	ra,0xffffc
    80207e74:	358080e7          	jalr	856(ra) # 802041c8 <filewrite>
    80207e78:	fc9ff06f          	j	80207e40 <syscallSendFile+0x164>
        copyout(myProcess()->pgdir, tf->a2, (char*) &inFile->off, sizeof(u32));
    80207e7c:	00008097          	auipc	ra,0x8
    80207e80:	b6c080e7          	jalr	-1172(ra) # 8020f9e8 <myProcess>
    80207e84:	00400693          	li	a3,4
    80207e88:	028b0613          	addi	a2,s6,40
    80207e8c:	0809b583          	ld	a1,128(s3)
    80207e90:	04053503          	ld	a0,64(a0)
    80207e94:	00002097          	auipc	ra,0x2
    80207e98:	ca4080e7          	jalr	-860(ra) # 80209b38 <copyout>
    80207e9c:	f75ff06f          	j	80207e10 <syscallSendFile+0x134>

0000000080207ea0 <syscallAccess>:

void syscallAccess() {
    80207ea0:	ed010113          	addi	sp,sp,-304
    80207ea4:	12113423          	sd	ra,296(sp)
    80207ea8:	12813023          	sd	s0,288(sp)
    80207eac:	10913c23          	sd	s1,280(sp)
    80207eb0:	11213823          	sd	s2,272(sp)
    80207eb4:	13010413          	addi	s0,sp,304
    Trapframe *tf = getHartTrapFrame();
    80207eb8:	00002097          	auipc	ra,0x2
    80207ebc:	324080e7          	jalr	804(ra) # 8020a1dc <getHartTrapFrame>
    80207ec0:	00050493          	mv	s1,a0
    int dirfd = tf->a0;
    80207ec4:	07053903          	ld	s2,112(a0)
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80207ec8:	10400613          	li	a2,260
    80207ecc:	ed840593          	addi	a1,s0,-296
    80207ed0:	07853503          	ld	a0,120(a0)
    80207ed4:	00004097          	auipc	ra,0x4
    80207ed8:	6d0080e7          	jalr	1744(ra) # 8020c5a4 <fetchstr>
    80207edc:	02054263          	bltz	a0,80207f00 <syscallAccess+0x60>
        tf->a0 = -1;
        return;
    }
    Dirent* entryPoint = ename(dirfd, path, true);
    80207ee0:	00100613          	li	a2,1
    80207ee4:	ed840593          	addi	a1,s0,-296
    80207ee8:	0009051b          	sext.w	a0,s2
    80207eec:	ffffc097          	auipc	ra,0xffffc
    80207ef0:	b50080e7          	jalr	-1200(ra) # 80203a3c <ename>
    if (entryPoint == NULL) {
    80207ef4:	00050663          	beqz	a0,80207f00 <syscallAccess+0x60>
        tf->a0 = -1;
        return;
    }
    tf->a0 = 0;
    80207ef8:	0604b823          	sd	zero,112(s1)
    80207efc:	00c0006f          	j	80207f08 <syscallAccess+0x68>
        tf->a0 = -1;
    80207f00:	fff00793          	li	a5,-1
    80207f04:	06f4b823          	sd	a5,112(s1)
}
    80207f08:	12813083          	ld	ra,296(sp)
    80207f0c:	12013403          	ld	s0,288(sp)
    80207f10:	11813483          	ld	s1,280(sp)
    80207f14:	11013903          	ld	s2,272(sp)
    80207f18:	13010113          	addi	sp,sp,304
    80207f1c:	00008067          	ret

0000000080207f20 <syscallReadLinkAt>:

void syscallReadLinkAt() {
    80207f20:	dc010113          	addi	sp,sp,-576
    80207f24:	22113c23          	sd	ra,568(sp)
    80207f28:	22813823          	sd	s0,560(sp)
    80207f2c:	22913423          	sd	s1,552(sp)
    80207f30:	23213023          	sd	s2,544(sp)
    80207f34:	21313c23          	sd	s3,536(sp)
    80207f38:	21413823          	sd	s4,528(sp)
    80207f3c:	24010413          	addi	s0,sp,576
    Trapframe *tf = getHartTrapFrame();
    80207f40:	00002097          	auipc	ra,0x2
    80207f44:	29c080e7          	jalr	668(ra) # 8020a1dc <getHartTrapFrame>
    80207f48:	00050493          	mv	s1,a0
    int dirFd = tf->a0;
    80207f4c:	07053903          	ld	s2,112(a0)
    char path[FAT32_MAX_PATH];
    if (fetchstr(tf->a1, path, FAT32_MAX_PATH) < 0) {
    80207f50:	10400613          	li	a2,260
    80207f54:	ec840593          	addi	a1,s0,-312
    80207f58:	07853503          	ld	a0,120(a0)
    80207f5c:	00004097          	auipc	ra,0x4
    80207f60:	648080e7          	jalr	1608(ra) # 8020c5a4 <fetchstr>
    80207f64:	08054463          	bltz	a0,80207fec <syscallReadLinkAt+0xcc>
    int dirFd = tf->a0;
    80207f68:	0009091b          	sext.w	s2,s2
        tf->a0 = -1;
        return;
    }
    u64 buf = tf->a3;
    80207f6c:	0884b983          	ld	s3,136(s1)
    u32 size = tf->a4;
    80207f70:	0904ba03          	ld	s4,144(s1)
    tf->a0 = -1;
    80207f74:	fff00793          	li	a5,-1
    80207f78:	06f4b823          	sd	a5,112(s1)
    Dirent* entryPoint = ename(dirFd, path, false);
    80207f7c:	00000613          	li	a2,0
    80207f80:	ec840593          	addi	a1,s0,-312
    80207f84:	00090513          	mv	a0,s2
    80207f88:	ffffc097          	auipc	ra,0xffffc
    80207f8c:	ab4080e7          	jalr	-1356(ra) # 80203a3c <ename>
    if (entryPoint == NULL || entryPoint->_nt_res != DT_LNK ) {
    80207f90:	00050863          	beqz	a0,80207fa0 <syscallReadLinkAt+0x80>
    80207f94:	21854703          	lbu	a4,536(a0)
    80207f98:	00a00793          	li	a5,10
    80207f9c:	02f70863          	beq	a4,a5,80207fcc <syscallReadLinkAt+0xac>
    char kbuf[FAT32_MAX_FILENAME];
    eread(entryPoint, false, (u64)kbuf, 0, entryPoint->file_size);
    tf->a0 = 0;
    return;
bad:
    tf->a0 = -1;
    80207fa0:	fff00793          	li	a5,-1
    80207fa4:	06f4b823          	sd	a5,112(s1)
    printf("%d %s %lx %lx\n", dirFd, path, buf, size);
    80207fa8:	000a071b          	sext.w	a4,s4
    80207fac:	00098693          	mv	a3,s3
    80207fb0:	ec840613          	addi	a2,s0,-312
    80207fb4:	00090593          	mv	a1,s2
    80207fb8:	0000e517          	auipc	a0,0xe
    80207fbc:	8c050513          	addi	a0,a0,-1856 # 80215878 <__func__.5+0x90>
    80207fc0:	ffff9097          	auipc	ra,0xffff9
    80207fc4:	e90080e7          	jalr	-368(ra) # 80200e50 <printf>
    80207fc8:	02c0006f          	j	80207ff4 <syscallReadLinkAt+0xd4>
    eread(entryPoint, false, (u64)kbuf, 0, entryPoint->file_size);
    80207fcc:	10852703          	lw	a4,264(a0)
    80207fd0:	00000693          	li	a3,0
    80207fd4:	dc840613          	addi	a2,s0,-568
    80207fd8:	00000593          	li	a1,0
    80207fdc:	ffffb097          	auipc	ra,0xffffb
    80207fe0:	dc0080e7          	jalr	-576(ra) # 80202d9c <eread>
    return;
    80207fe4:	00000793          	li	a5,0
    80207fe8:	0080006f          	j	80207ff0 <syscallReadLinkAt+0xd0>
    80207fec:	fff00793          	li	a5,-1
        tf->a0 = -1;
    80207ff0:	06f4b823          	sd	a5,112(s1)
}
    80207ff4:	23813083          	ld	ra,568(sp)
    80207ff8:	23013403          	ld	s0,560(sp)
    80207ffc:	22813483          	ld	s1,552(sp)
    80208000:	22013903          	ld	s2,544(sp)
    80208004:	21813983          	ld	s3,536(sp)
    80208008:	21013a03          	ld	s4,528(sp)
    8020800c:	24010113          	addi	sp,sp,576
    80208010:	00008067          	ret

0000000080208014 <getAbsolutePath>:

int getAbsolutePath(Dirent* d, int isUser, u64 buf, int maxLen) {
    80208014:	e9010113          	addi	sp,sp,-368
    80208018:	16113423          	sd	ra,360(sp)
    8020801c:	16813023          	sd	s0,352(sp)
    80208020:	14913c23          	sd	s1,344(sp)
    80208024:	15213823          	sd	s2,336(sp)
    80208028:	15313423          	sd	s3,328(sp)
    8020802c:	15413023          	sd	s4,320(sp)
    80208030:	13513c23          	sd	s5,312(sp)
    80208034:	13613823          	sd	s6,304(sp)
    80208038:	13713423          	sd	s7,296(sp)
    8020803c:	13813023          	sd	s8,288(sp)
    80208040:	11913c23          	sd	s9,280(sp)
    80208044:	17010413          	addi	s0,sp,368
    80208048:	00058c13          	mv	s8,a1
    8020804c:	00060c93          	mv	s9,a2
    char path[FAT32_MAX_PATH];
    
    if (d->parent == NULL) {
    80208050:	24053783          	ld	a5,576(a0)
    80208054:	0a078e63          	beqz	a5,80208110 <getAbsolutePath+0xfc>
    80208058:	00050913          	mv	s2,a0
        return either_copyout(isUser, buf, "/", 2);
    }
    char *s = path + FAT32_MAX_PATH - 1;
    *s = '\0';
    8020805c:	f8040da3          	sb	zero,-101(s0)
    char *s = path + FAT32_MAX_PATH - 1;
    80208060:	f9b40993          	addi	s3,s0,-101
    while (d->parent) {
        int len = strlen(d->filename);
        s -= len;
        if (s <= path || s - path <= FAT32_MAX_PATH - maxLen)  // can't reach root "/"
    80208064:	e9840a13          	addi	s4,s0,-360
    80208068:	10400b13          	li	s6,260
    8020806c:	40db0b3b          	subw	s6,s6,a3
            return -1;
        strncpy(s, d->filename, len);
        *--s = '/';
    80208070:	02f00b93          	li	s7,47
        int len = strlen(d->filename);
    80208074:	00090513          	mv	a0,s2
    80208078:	00007097          	auipc	ra,0x7
    8020807c:	f04080e7          	jalr	-252(ra) # 8020ef7c <strlen>
    80208080:	00050613          	mv	a2,a0
        s -= len;
    80208084:	40a984b3          	sub	s1,s3,a0
        if (s <= path || s - path <= FAT32_MAX_PATH - maxLen)  // can't reach root "/"
    80208088:	0a9a7463          	bgeu	s4,s1,80208130 <getAbsolutePath+0x11c>
    8020808c:	414487b3          	sub	a5,s1,s4
    80208090:	0afb5463          	bge	s6,a5,80208138 <getAbsolutePath+0x124>
        strncpy(s, d->filename, len);
    80208094:	00090593          	mv	a1,s2
    80208098:	00048513          	mv	a0,s1
    8020809c:	00007097          	auipc	ra,0x7
    802080a0:	e38080e7          	jalr	-456(ra) # 8020eed4 <strncpy>
        *--s = '/';
    802080a4:	fff48993          	addi	s3,s1,-1
    802080a8:	ff748fa3          	sb	s7,-1(s1)
        d = d->parent;
    802080ac:	24093903          	ld	s2,576(s2)
    while (d->parent) {
    802080b0:	24093783          	ld	a5,576(s2)
    802080b4:	fc0790e3          	bnez	a5,80208074 <getAbsolutePath+0x60>
    }
    return either_copyout(isUser, buf, (void*)s, strlen(s) + 1);
    802080b8:	00098513          	mv	a0,s3
    802080bc:	00007097          	auipc	ra,0x7
    802080c0:	ec0080e7          	jalr	-320(ra) # 8020ef7c <strlen>
    802080c4:	0015069b          	addiw	a3,a0,1
    802080c8:	00098613          	mv	a2,s3
    802080cc:	000c8593          	mv	a1,s9
    802080d0:	000c0513          	mv	a0,s8
    802080d4:	00008097          	auipc	ra,0x8
    802080d8:	29c080e7          	jalr	668(ra) # 80210370 <either_copyout>
}
    802080dc:	16813083          	ld	ra,360(sp)
    802080e0:	16013403          	ld	s0,352(sp)
    802080e4:	15813483          	ld	s1,344(sp)
    802080e8:	15013903          	ld	s2,336(sp)
    802080ec:	14813983          	ld	s3,328(sp)
    802080f0:	14013a03          	ld	s4,320(sp)
    802080f4:	13813a83          	ld	s5,312(sp)
    802080f8:	13013b03          	ld	s6,304(sp)
    802080fc:	12813b83          	ld	s7,296(sp)
    80208100:	12013c03          	ld	s8,288(sp)
    80208104:	11813c83          	ld	s9,280(sp)
    80208108:	17010113          	addi	sp,sp,368
    8020810c:	00008067          	ret
        return either_copyout(isUser, buf, "/", 2);
    80208110:	00200693          	li	a3,2
    80208114:	0000e617          	auipc	a2,0xe
    80208118:	d3c60613          	addi	a2,a2,-708 # 80215e50 <__func__.0+0x1d0>
    8020811c:	000c8593          	mv	a1,s9
    80208120:	000c0513          	mv	a0,s8
    80208124:	00008097          	auipc	ra,0x8
    80208128:	24c080e7          	jalr	588(ra) # 80210370 <either_copyout>
    8020812c:	fb1ff06f          	j	802080dc <getAbsolutePath+0xc8>
            return -1;
    80208130:	fff00513          	li	a0,-1
    80208134:	fa9ff06f          	j	802080dc <getAbsolutePath+0xc8>
    80208138:	fff00513          	li	a0,-1
    8020813c:	fa1ff06f          	j	802080dc <getAbsolutePath+0xc8>

0000000080208140 <syscallGetWorkDir>:
void syscallGetWorkDir(void) {
    80208140:	fd010113          	addi	sp,sp,-48
    80208144:	02113423          	sd	ra,40(sp)
    80208148:	02813023          	sd	s0,32(sp)
    8020814c:	00913c23          	sd	s1,24(sp)
    80208150:	01213823          	sd	s2,16(sp)
    80208154:	01313423          	sd	s3,8(sp)
    80208158:	03010413          	addi	s0,sp,48
    Trapframe* tf = getHartTrapFrame();
    8020815c:	00002097          	auipc	ra,0x2
    80208160:	080080e7          	jalr	128(ra) # 8020a1dc <getHartTrapFrame>
    u64 uva = tf->a0;
    80208164:	07053903          	ld	s2,112(a0)
    int n = tf->a1;
    80208168:	07852983          	lw	s3,120(a0)
    if (uva == 0) {
    8020816c:	04090a63          	beqz	s2,802081c0 <syscallGetWorkDir+0x80>
    80208170:	00050493          	mv	s1,a0
    int len = getAbsolutePath(myProcess()->cwd, 1, uva, n);
    80208174:	00008097          	auipc	ra,0x8
    80208178:	874080e7          	jalr	-1932(ra) # 8020f9e8 <myProcess>
    8020817c:	000027b7          	lui	a5,0x2
    80208180:	00f50533          	add	a0,a0,a5
    80208184:	00098693          	mv	a3,s3
    80208188:	00090613          	mv	a2,s2
    8020818c:	00100593          	li	a1,1
    80208190:	08853503          	ld	a0,136(a0)
    80208194:	00000097          	auipc	ra,0x0
    80208198:	e80080e7          	jalr	-384(ra) # 80208014 <getAbsolutePath>
    if (len < 0) {
    8020819c:	04054463          	bltz	a0,802081e4 <syscallGetWorkDir+0xa4>
    802081a0:	0724b823          	sd	s2,112(s1)
}
    802081a4:	02813083          	ld	ra,40(sp)
    802081a8:	02013403          	ld	s0,32(sp)
    802081ac:	01813483          	ld	s1,24(sp)
    802081b0:	01013903          	ld	s2,16(sp)
    802081b4:	00813983          	ld	s3,8(sp)
    802081b8:	03010113          	addi	sp,sp,48
    802081bc:	00008067          	ret
        panic("Alloc addr not implement for cwd\n");
    802081c0:	0000d697          	auipc	a3,0xd
    802081c4:	6c868693          	addi	a3,a3,1736 # 80215888 <__func__.5+0xa0>
    802081c8:	0000d617          	auipc	a2,0xd
    802081cc:	72860613          	addi	a2,a2,1832 # 802158f0 <__func__.4>
    802081d0:	24800593          	li	a1,584
    802081d4:	0000d517          	auipc	a0,0xd
    802081d8:	64c50513          	addi	a0,a0,1612 # 80215820 <__func__.5+0x38>
    802081dc:	ffff9097          	auipc	ra,0xffff9
    802081e0:	d0c080e7          	jalr	-756(ra) # 80200ee8 <_panic_>
        tf->a0 = -1;
    802081e4:	fff00913          	li	s2,-1
    802081e8:	fb9ff06f          	j	802081a0 <syscallGetWorkDir+0x60>

00000000802081ec <do_linkat>:
int do_linkat(int oldDirFd, char* oldPath, int newDirFd, char* newPath) {
    802081ec:	ec010113          	addi	sp,sp,-320
    802081f0:	12113c23          	sd	ra,312(sp)
    802081f4:	12813823          	sd	s0,304(sp)
    802081f8:	12913423          	sd	s1,296(sp)
    802081fc:	13213023          	sd	s2,288(sp)
    80208200:	11313c23          	sd	s3,280(sp)
    80208204:	14010413          	addi	s0,sp,320
    80208208:	00060493          	mv	s1,a2
    8020820c:	00068993          	mv	s3,a3
    if ((entryPoint = ename(oldDirFd, oldPath, true)) == NULL) {
    80208210:	00100613          	li	a2,1
    80208214:	ffffc097          	auipc	ra,0xffffc
    80208218:	828080e7          	jalr	-2008(ra) # 80203a3c <ename>
    8020821c:	08050663          	beqz	a0,802082a8 <do_linkat+0xbc>
    80208220:	00050913          	mv	s2,a0
    if ((targetPoint = create(newDirFd, newPath, T_FILE, O_RDWR)) == NULL) {
    80208224:	00200693          	li	a3,2
    80208228:	00200613          	li	a2,2
    8020822c:	00098593          	mv	a1,s3
    80208230:	00048513          	mv	a0,s1
    80208234:	ffffc097          	auipc	ra,0xffffc
    80208238:	b28080e7          	jalr	-1240(ra) # 80203d5c <create>
    8020823c:	00050493          	mv	s1,a0
    return -1;
    80208240:	fff00513          	li	a0,-1
    if ((targetPoint = create(newDirFd, newPath, T_FILE, O_RDWR)) == NULL) {
    80208244:	06048e63          	beqz	s1,802082c0 <do_linkat+0xd4>
    if (getAbsolutePath(entryPoint, 0, (u64)buf, FAT32_MAX_PATH) < 0) {
    80208248:	10400693          	li	a3,260
    8020824c:	ec840613          	addi	a2,s0,-312
    80208250:	00000593          	li	a1,0
    80208254:	00090513          	mv	a0,s2
    80208258:	00000097          	auipc	ra,0x0
    8020825c:	dbc080e7          	jalr	-580(ra) # 80208014 <getAbsolutePath>
    80208260:	04054863          	bltz	a0,802082b0 <do_linkat+0xc4>
    int len = strlen(buf);
    80208264:	ec840513          	addi	a0,s0,-312
    80208268:	00007097          	auipc	ra,0x7
    8020826c:	d14080e7          	jalr	-748(ra) # 8020ef7c <strlen>
    if (ewrite(targetPoint, 0, (u64)buf, 0, len + 1) != len + 1) {
    80208270:	0015071b          	addiw	a4,a0,1
    80208274:	0007091b          	sext.w	s2,a4
    80208278:	00090713          	mv	a4,s2
    8020827c:	00000693          	li	a3,0
    80208280:	ec840613          	addi	a2,s0,-312
    80208284:	00000593          	li	a1,0
    80208288:	00048513          	mv	a0,s1
    8020828c:	ffffb097          	auipc	ra,0xffffb
    80208290:	d44080e7          	jalr	-700(ra) # 80202fd0 <ewrite>
    80208294:	00a91e63          	bne	s2,a0,802082b0 <do_linkat+0xc4>
    targetPoint->_nt_res = DT_LNK;
    80208298:	00a00793          	li	a5,10
    8020829c:	20f48c23          	sb	a5,536(s1)
    return 0;
    802082a0:	00000513          	li	a0,0
    802082a4:	01c0006f          	j	802082c0 <do_linkat+0xd4>
    return -1;
    802082a8:	fff00513          	li	a0,-1
    802082ac:	0140006f          	j	802082c0 <do_linkat+0xd4>
        eremove(targetPoint);
    802082b0:	00048513          	mv	a0,s1
    802082b4:	ffffb097          	auipc	ra,0xffffb
    802082b8:	1bc080e7          	jalr	444(ra) # 80203470 <eremove>
    return -1;
    802082bc:	fff00513          	li	a0,-1
}
    802082c0:	13813083          	ld	ra,312(sp)
    802082c4:	13013403          	ld	s0,304(sp)
    802082c8:	12813483          	ld	s1,296(sp)
    802082cc:	12013903          	ld	s2,288(sp)
    802082d0:	11813983          	ld	s3,280(sp)
    802082d4:	14010113          	addi	sp,sp,320
    802082d8:	00008067          	ret

00000000802082dc <syscallLinkAt>:
void syscallLinkAt() {
    802082dc:	dc010113          	addi	sp,sp,-576
    802082e0:	22113c23          	sd	ra,568(sp)
    802082e4:	22813823          	sd	s0,560(sp)
    802082e8:	22913423          	sd	s1,552(sp)
    802082ec:	23213023          	sd	s2,544(sp)
    802082f0:	21313c23          	sd	s3,536(sp)
    802082f4:	24010413          	addi	s0,sp,576
    Trapframe* tf = getHartTrapFrame();
    802082f8:	00002097          	auipc	ra,0x2
    802082fc:	ee4080e7          	jalr	-284(ra) # 8020a1dc <getHartTrapFrame>
    80208300:	00050493          	mv	s1,a0
    int oldDirFd = tf->a0, newDirFd = tf->a2, flags = tf->a4;
    80208304:	07053903          	ld	s2,112(a0)
    80208308:	08053983          	ld	s3,128(a0)
    assert(flags == 0);
    8020830c:	09052683          	lw	a3,144(a0)
    80208310:	0016b693          	seqz	a3,a3
    80208314:	0000d617          	auipc	a2,0xd
    80208318:	5f460613          	addi	a2,a2,1524 # 80215908 <__func__.0>
    8020831c:	36500593          	li	a1,869
    80208320:	0000d517          	auipc	a0,0xd
    80208324:	50050513          	addi	a0,a0,1280 # 80215820 <__func__.5+0x38>
    80208328:	ffff9097          	auipc	ra,0xffff9
    8020832c:	c30080e7          	jalr	-976(ra) # 80200f58 <_assert_>
    if (fetchstr(tf->a1, oldPath, FAT32_MAX_PATH) < 0) {
    80208330:	10400613          	li	a2,260
    80208334:	ec840593          	addi	a1,s0,-312
    80208338:	0784b503          	ld	a0,120(s1)
    8020833c:	00004097          	auipc	ra,0x4
    80208340:	268080e7          	jalr	616(ra) # 8020c5a4 <fetchstr>
    80208344:	02054e63          	bltz	a0,80208380 <syscallLinkAt+0xa4>
    if (fetchstr(tf->a3, newPath, FAT32_MAX_PATH) < 0) {
    80208348:	10400613          	li	a2,260
    8020834c:	dc040593          	addi	a1,s0,-576
    80208350:	0884b503          	ld	a0,136(s1)
    80208354:	00004097          	auipc	ra,0x4
    80208358:	250080e7          	jalr	592(ra) # 8020c5a4 <fetchstr>
    8020835c:	02054263          	bltz	a0,80208380 <syscallLinkAt+0xa4>
    tf->a0 = do_linkat(oldDirFd, oldPath, newDirFd, newPath);
    80208360:	dc040693          	addi	a3,s0,-576
    80208364:	0009861b          	sext.w	a2,s3
    80208368:	ec840593          	addi	a1,s0,-312
    8020836c:	0009051b          	sext.w	a0,s2
    80208370:	00000097          	auipc	ra,0x0
    80208374:	e7c080e7          	jalr	-388(ra) # 802081ec <do_linkat>
    80208378:	06a4b823          	sd	a0,112(s1)
    8020837c:	00c0006f          	j	80208388 <syscallLinkAt+0xac>
        tf->a0 = -1;
    80208380:	fff00793          	li	a5,-1
    80208384:	06f4b823          	sd	a5,112(s1)
}
    80208388:	23813083          	ld	ra,568(sp)
    8020838c:	23013403          	ld	s0,560(sp)
    80208390:	22813483          	ld	s1,552(sp)
    80208394:	22013903          	ld	s2,544(sp)
    80208398:	21813983          	ld	s3,536(sp)
    8020839c:	24010113          	addi	sp,sp,576
    802083a0:	00008067          	ret

00000000802083a4 <syscallUmask>:

void syscallUmask() {
    802083a4:	ff010113          	addi	sp,sp,-16
    802083a8:	00113423          	sd	ra,8(sp)
    802083ac:	00813023          	sd	s0,0(sp)
    802083b0:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    802083b4:	00002097          	auipc	ra,0x2
    802083b8:	e28080e7          	jalr	-472(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    802083bc:	06053823          	sd	zero,112(a0)
}
    802083c0:	00813083          	ld	ra,8(sp)
    802083c4:	00013403          	ld	s0,0(sp)
    802083c8:	01010113          	addi	sp,sp,16
    802083cc:	00008067          	ret

00000000802083d0 <syscallFileSychornize>:


void syscallFileSychornize() {
    802083d0:	ff010113          	addi	sp,sp,-16
    802083d4:	00113423          	sd	ra,8(sp)
    802083d8:	00813023          	sd	s0,0(sp)
    802083dc:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    802083e0:	00002097          	auipc	ra,0x2
    802083e4:	dfc080e7          	jalr	-516(ra) # 8020a1dc <getHartTrapFrame>
    //todo
    tf->a0 = 0;
    802083e8:	06053823          	sd	zero,112(a0)
    802083ec:	00813083          	ld	ra,8(sp)
    802083f0:	00013403          	ld	s0,0(sp)
    802083f4:	01010113          	addi	sp,sp,16
    802083f8:	00008067          	ret

00000000802083fc <testfat>:
#include <Debug.h>

char test_content_to_write[10] = "abcdefghi";
char test_content_to_read[10] = {0};

void testfat() {
    802083fc:	fe010113          	addi	sp,sp,-32
    80208400:	00113c23          	sd	ra,24(sp)
    80208404:	00813823          	sd	s0,16(sp)
    80208408:	00913423          	sd	s1,8(sp)
    8020840c:	02010413          	addi	s0,sp,32
    printf("[testfat] testing fat.......\n");
    80208410:	0000d517          	auipc	a0,0xd
    80208414:	50850513          	addi	a0,a0,1288 # 80215918 <__func__.0+0x10>
    80208418:	ffff9097          	auipc	ra,0xffff9
    8020841c:	a38080e7          	jalr	-1480(ra) # 80200e50 <printf>
    Dirent* testfile = create(AT_FDCWD, "/testfile", T_FILE, O_CREATE_GLIBC | O_RDWR);
    80208420:	04200693          	li	a3,66
    80208424:	00200613          	li	a2,2
    80208428:	0000d597          	auipc	a1,0xd
    8020842c:	51058593          	addi	a1,a1,1296 # 80215938 <__func__.0+0x30>
    80208430:	f9c00513          	li	a0,-100
    80208434:	ffffc097          	auipc	ra,0xffffc
    80208438:	928080e7          	jalr	-1752(ra) # 80203d5c <create>
    if (testfile == NULL) {
    8020843c:	0c050863          	beqz	a0,8020850c <testfat+0x110>
    80208440:	00050493          	mv	s1,a0
        panic("[testfat] create file error\n");
    }
    printf("create file finish\n");
    80208444:	0000d517          	auipc	a0,0xd
    80208448:	53450513          	addi	a0,a0,1332 # 80215978 <__func__.0+0x70>
    8020844c:	ffff9097          	auipc	ra,0xffff9
    80208450:	a04080e7          	jalr	-1532(ra) # 80200e50 <printf>
    int ret = ewrite(testfile, 0, (u64)test_content_to_write, 0, 9);
    80208454:	00900713          	li	a4,9
    80208458:	00000693          	li	a3,0
    8020845c:	0000f617          	auipc	a2,0xf
    80208460:	bb460613          	addi	a2,a2,-1100 # 80217010 <test_content_to_write>
    80208464:	00000593          	li	a1,0
    80208468:	00048513          	mv	a0,s1
    8020846c:	ffffb097          	auipc	ra,0xffffb
    80208470:	b64080e7          	jalr	-1180(ra) # 80202fd0 <ewrite>
    if (ret != 9) {
    80208474:	00900793          	li	a5,9
    80208478:	0af51c63          	bne	a0,a5,80208530 <testfat+0x134>
        panic("[testfat] write file error\n");
    }

    printf("write file finish\n");
    8020847c:	0000d517          	auipc	a0,0xd
    80208480:	53450513          	addi	a0,a0,1332 # 802159b0 <__func__.0+0xa8>
    80208484:	ffff9097          	auipc	ra,0xffff9
    80208488:	9cc080e7          	jalr	-1588(ra) # 80200e50 <printf>
    testfile = ename(AT_FDCWD, "/testfile", true);
    8020848c:	00100613          	li	a2,1
    80208490:	0000d597          	auipc	a1,0xd
    80208494:	4a858593          	addi	a1,a1,1192 # 80215938 <__func__.0+0x30>
    80208498:	f9c00513          	li	a0,-100
    8020849c:	ffffb097          	auipc	ra,0xffffb
    802084a0:	5a0080e7          	jalr	1440(ra) # 80203a3c <ename>
    if (testfile == NULL) {
    802084a4:	0a050863          	beqz	a0,80208554 <testfat+0x158>
        panic("[testfat] open file error\n");
    }
    eread(testfile, 0, (u64)test_content_to_read, 0, 9);
    802084a8:	018ff497          	auipc	s1,0x18ff
    802084ac:	a4848493          	addi	s1,s1,-1464 # 81b06ef0 <test_content_to_read>
    802084b0:	00900713          	li	a4,9
    802084b4:	00000693          	li	a3,0
    802084b8:	00048613          	mv	a2,s1
    802084bc:	00000593          	li	a1,0
    802084c0:	ffffb097          	auipc	ra,0xffffb
    802084c4:	8dc080e7          	jalr	-1828(ra) # 80202d9c <eread>
    if (strncmp(test_content_to_write, test_content_to_read, 114514)==0) {
    802084c8:	0001c637          	lui	a2,0x1c
    802084cc:	f5260613          	addi	a2,a2,-174 # 1bf52 <_start-0x801e40ae>
    802084d0:	00048593          	mv	a1,s1
    802084d4:	0000f517          	auipc	a0,0xf
    802084d8:	b3c50513          	addi	a0,a0,-1220 # 80217010 <test_content_to_write>
    802084dc:	00007097          	auipc	ra,0x7
    802084e0:	994080e7          	jalr	-1644(ra) # 8020ee70 <strncmp>
    802084e4:	08051a63          	bnez	a0,80208578 <testfat+0x17c>
        printf("[testfat]  testfat passed\n");
    802084e8:	0000d517          	auipc	a0,0xd
    802084ec:	50050513          	addi	a0,a0,1280 # 802159e8 <__func__.0+0xe0>
    802084f0:	ffff9097          	auipc	ra,0xffff9
    802084f4:	960080e7          	jalr	-1696(ra) # 80200e50 <printf>
    } else {
        panic("[testfat]  testfat failed\n");
    }
    802084f8:	01813083          	ld	ra,24(sp)
    802084fc:	01013403          	ld	s0,16(sp)
    80208500:	00813483          	ld	s1,8(sp)
    80208504:	02010113          	addi	sp,sp,32
    80208508:	00008067          	ret
        panic("[testfat] create file error\n");
    8020850c:	0000d697          	auipc	a3,0xd
    80208510:	43c68693          	addi	a3,a3,1084 # 80215948 <__func__.0+0x40>
    80208514:	0000e617          	auipc	a2,0xe
    80208518:	29c60613          	addi	a2,a2,668 # 802167b0 <__func__.0>
    8020851c:	00d00593          	li	a1,13
    80208520:	0000d517          	auipc	a0,0xd
    80208524:	44850513          	addi	a0,a0,1096 # 80215968 <__func__.0+0x60>
    80208528:	ffff9097          	auipc	ra,0xffff9
    8020852c:	9c0080e7          	jalr	-1600(ra) # 80200ee8 <_panic_>
        panic("[testfat] write file error\n");
    80208530:	0000d697          	auipc	a3,0xd
    80208534:	46068693          	addi	a3,a3,1120 # 80215990 <__func__.0+0x88>
    80208538:	0000e617          	auipc	a2,0xe
    8020853c:	27860613          	addi	a2,a2,632 # 802167b0 <__func__.0>
    80208540:	01200593          	li	a1,18
    80208544:	0000d517          	auipc	a0,0xd
    80208548:	42450513          	addi	a0,a0,1060 # 80215968 <__func__.0+0x60>
    8020854c:	ffff9097          	auipc	ra,0xffff9
    80208550:	99c080e7          	jalr	-1636(ra) # 80200ee8 <_panic_>
        panic("[testfat] open file error\n");
    80208554:	0000d697          	auipc	a3,0xd
    80208558:	47468693          	addi	a3,a3,1140 # 802159c8 <__func__.0+0xc0>
    8020855c:	0000e617          	auipc	a2,0xe
    80208560:	25460613          	addi	a2,a2,596 # 802167b0 <__func__.0>
    80208564:	01800593          	li	a1,24
    80208568:	0000d517          	auipc	a0,0xd
    8020856c:	40050513          	addi	a0,a0,1024 # 80215968 <__func__.0+0x60>
    80208570:	ffff9097          	auipc	ra,0xffff9
    80208574:	978080e7          	jalr	-1672(ra) # 80200ee8 <_panic_>
        panic("[testfat]  testfat failed\n");
    80208578:	0000d697          	auipc	a3,0xd
    8020857c:	49068693          	addi	a3,a3,1168 # 80215a08 <__func__.0+0x100>
    80208580:	0000e617          	auipc	a2,0xe
    80208584:	23060613          	addi	a2,a2,560 # 802167b0 <__func__.0>
    80208588:	01e00593          	li	a1,30
    8020858c:	0000d517          	auipc	a0,0xd
    80208590:	3dc50513          	addi	a0,a0,988 # 80215968 <__func__.0+0x60>
    80208594:	ffff9097          	auipc	ra,0xffff9
    80208598:	954080e7          	jalr	-1708(ra) # 80200ee8 <_panic_>

000000008020859c <interruptPush>:
#include "Interrupt.h"
#include "Riscv.h"
#include "Hart.h"
#include "Driver.h"

void interruptPush(void) {
    8020859c:	fe010113          	addi	sp,sp,-32
    802085a0:	00113c23          	sd	ra,24(sp)
    802085a4:	00813823          	sd	s0,16(sp)
    802085a8:	00913423          	sd	s1,8(sp)
    802085ac:	02010413          	addi	s0,sp,32
#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable

static inline u64 r_sstatus() {
    u64 x;
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    802085b0:	100024f3          	csrr	s1,sstatus
    802085b4:	100027f3          	csrr	a5,sstatus
	w_sstatus(r_sstatus() | SSTATUS_SIE);
}

// disable device interrupts
static inline void intr_off() {
	w_sstatus(r_sstatus() & ~SSTATUS_SIE);
    802085b8:	ffd7f793          	andi	a5,a5,-3
    asm volatile("csrw sstatus, %0" : : "r" (x));
    802085bc:	10079073          	csrw	sstatus,a5
    int oldInterruptEnable = intr_get();
    intr_off();

    struct Hart* hart = myHart();
    802085c0:	00002097          	auipc	ra,0x2
    802085c4:	bec080e7          	jalr	-1044(ra) # 8020a1ac <myHart>
    if (hart->interruptLayer == 0)
    802085c8:	00052783          	lw	a5,0(a0)
    802085cc:	00079863          	bnez	a5,802085dc <interruptPush+0x40>
}

// are device interrupts enabled?
static inline bool intr_get() {
	u64 x = r_sstatus();
	return (x & SSTATUS_SIE) != 0;
    802085d0:	0014d493          	srli	s1,s1,0x1
    802085d4:	0014f493          	andi	s1,s1,1
        hart->lastInterruptEnable = oldInterruptEnable;
    802085d8:	00952223          	sw	s1,4(a0)
    hart->interruptLayer++;
    802085dc:	0017879b          	addiw	a5,a5,1
    802085e0:	00f52023          	sw	a5,0(a0)
}
    802085e4:	01813083          	ld	ra,24(sp)
    802085e8:	01013403          	ld	s0,16(sp)
    802085ec:	00813483          	ld	s1,8(sp)
    802085f0:	02010113          	addi	sp,sp,32
    802085f4:	00008067          	ret

00000000802085f8 <interruptPop>:

void interruptPop(void) {
    802085f8:	ff010113          	addi	sp,sp,-16
    802085fc:	00113423          	sd	ra,8(sp)
    80208600:	00813023          	sd	s0,0(sp)
    80208604:	01010413          	addi	s0,sp,16
    struct Hart* hart = myHart();
    80208608:	00002097          	auipc	ra,0x2
    8020860c:	ba4080e7          	jalr	-1116(ra) # 8020a1ac <myHart>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    80208610:	100027f3          	csrr	a5,sstatus
	return (x & SSTATUS_SIE) != 0;
    80208614:	0027f793          	andi	a5,a5,2
    if (intr_get()) {
    80208618:	04079063          	bnez	a5,80208658 <interruptPop+0x60>
        panic("Interrupt bit still have!\n");
    }

    if (hart->interruptLayer < 0) {
    8020861c:	00052783          	lw	a5,0(a0)
    80208620:	0407ce63          	bltz	a5,8020867c <interruptPop+0x84>
        panic("Interrupt close error! Not match!\n");
    }

    hart->interruptLayer--;
    80208624:	fff7879b          	addiw	a5,a5,-1
    80208628:	0007871b          	sext.w	a4,a5
    8020862c:	00f52023          	sw	a5,0(a0)
    if (hart->interruptLayer == 0 && hart->lastInterruptEnable)
    80208630:	00071c63          	bnez	a4,80208648 <interruptPop+0x50>
    80208634:	00452783          	lw	a5,4(a0)
    80208638:	00078863          	beqz	a5,80208648 <interruptPop+0x50>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020863c:	100027f3          	csrr	a5,sstatus
	w_sstatus(r_sstatus() | SSTATUS_SIE);
    80208640:	0027e793          	ori	a5,a5,2
    asm volatile("csrw sstatus, %0" : : "r" (x));
    80208644:	10079073          	csrw	sstatus,a5
        intr_on();
    80208648:	00813083          	ld	ra,8(sp)
    8020864c:	00013403          	ld	s0,0(sp)
    80208650:	01010113          	addi	sp,sp,16
    80208654:	00008067          	ret
        panic("Interrupt bit still have!\n");
    80208658:	0000d697          	auipc	a3,0xd
    8020865c:	3d068693          	addi	a3,a3,976 # 80215a28 <__func__.0+0x120>
    80208660:	0000d617          	auipc	a2,0xd
    80208664:	42060613          	addi	a2,a2,1056 # 80215a80 <__func__.0>
    80208668:	01300593          	li	a1,19
    8020866c:	0000d517          	auipc	a0,0xd
    80208670:	3dc50513          	addi	a0,a0,988 # 80215a48 <__func__.0+0x140>
    80208674:	ffff9097          	auipc	ra,0xffff9
    80208678:	874080e7          	jalr	-1932(ra) # 80200ee8 <_panic_>
        panic("Interrupt close error! Not match!\n");
    8020867c:	0000d697          	auipc	a3,0xd
    80208680:	3dc68693          	addi	a3,a3,988 # 80215a58 <__func__.0+0x150>
    80208684:	0000d617          	auipc	a2,0xd
    80208688:	3fc60613          	addi	a2,a2,1020 # 80215a80 <__func__.0>
    8020868c:	01700593          	li	a1,23
    80208690:	0000d517          	auipc	a0,0xd
    80208694:	3b850513          	addi	a0,a0,952 # 80215a48 <__func__.0+0x140>
    80208698:	ffff9097          	auipc	ra,0xffff9
    8020869c:	850080e7          	jalr	-1968(ra) # 80200ee8 <_panic_>

00000000802086a0 <initsleeplock>:
#include "Spinlock.h"
#include "Driver.h"
#include <Debug.h>
#include <Thread.h>

void initsleeplock(struct Sleeplock* lk, char* name) {
    802086a0:	fe010113          	addi	sp,sp,-32
    802086a4:	00113c23          	sd	ra,24(sp)
    802086a8:	00813823          	sd	s0,16(sp)
    802086ac:	00913423          	sd	s1,8(sp)
    802086b0:	01213023          	sd	s2,0(sp)
    802086b4:	02010413          	addi	s0,sp,32
    802086b8:	00050493          	mv	s1,a0
    802086bc:	00058913          	mv	s2,a1
    initLock(&lk->lk, "sleep lock");
    802086c0:	0000d597          	auipc	a1,0xd
    802086c4:	3d058593          	addi	a1,a1,976 # 80215a90 <__func__.0+0x10>
    802086c8:	00850513          	addi	a0,a0,8
    802086cc:	00000097          	auipc	ra,0x0
    802086d0:	11c080e7          	jalr	284(ra) # 802087e8 <initLock>
    lk->name = name;
    802086d4:	0324b023          	sd	s2,32(s1)
    lk->locked = 0;
    802086d8:	0004a023          	sw	zero,0(s1)
    lk->tid = 0;
    802086dc:	0204a423          	sw	zero,40(s1)
}
    802086e0:	01813083          	ld	ra,24(sp)
    802086e4:	01013403          	ld	s0,16(sp)
    802086e8:	00813483          	ld	s1,8(sp)
    802086ec:	00013903          	ld	s2,0(sp)
    802086f0:	02010113          	addi	sp,sp,32
    802086f4:	00008067          	ret

00000000802086f8 <acquiresleep>:

void acquiresleep(struct Sleeplock* lk) {
    802086f8:	fe010113          	addi	sp,sp,-32
    802086fc:	00113c23          	sd	ra,24(sp)
    80208700:	00813823          	sd	s0,16(sp)
    80208704:	00913423          	sd	s1,8(sp)
    80208708:	01213023          	sd	s2,0(sp)
    8020870c:	02010413          	addi	s0,sp,32
    80208710:	00050493          	mv	s1,a0
    // acquireLock(&lk->lk);
    while (lk->locked) {
    80208714:	00052783          	lw	a5,0(a0)
    80208718:	02078063          	beqz	a5,80208738 <acquiresleep+0x40>
        // MSG_PRINT("in while");
        sleep(lk, &lk->lk);
    8020871c:	00850913          	addi	s2,a0,8
    80208720:	00090593          	mv	a1,s2
    80208724:	00048513          	mv	a0,s1
    80208728:	00009097          	auipc	ra,0x9
    8020872c:	4c0080e7          	jalr	1216(ra) # 80211be8 <sleep>
    while (lk->locked) {
    80208730:	0004a783          	lw	a5,0(s1)
    80208734:	fe0796e3          	bnez	a5,80208720 <acquiresleep+0x28>
    }
    lk->locked = 1;
    80208738:	00100793          	li	a5,1
    8020873c:	00f4a023          	sw	a5,0(s1)
    lk->tid = myThread()->id;
    80208740:	00008097          	auipc	ra,0x8
    80208744:	e00080e7          	jalr	-512(ra) # 80210540 <myThread>
    80208748:	23852783          	lw	a5,568(a0)
    8020874c:	02f4a423          	sw	a5,40(s1)
    // releaseLock(&lk->lk);
}
    80208750:	01813083          	ld	ra,24(sp)
    80208754:	01013403          	ld	s0,16(sp)
    80208758:	00813483          	ld	s1,8(sp)
    8020875c:	00013903          	ld	s2,0(sp)
    80208760:	02010113          	addi	sp,sp,32
    80208764:	00008067          	ret

0000000080208768 <releasesleep>:

void releasesleep(struct Sleeplock* lk) {
    80208768:	ff010113          	addi	sp,sp,-16
    8020876c:	00113423          	sd	ra,8(sp)
    80208770:	00813023          	sd	s0,0(sp)
    80208774:	01010413          	addi	s0,sp,16
    // acquireLock(&lk->lk);
    lk->locked = 0;
    80208778:	00052023          	sw	zero,0(a0)
    lk->tid = 0;
    8020877c:	02052423          	sw	zero,40(a0)
    wakeup(lk);
    80208780:	00009097          	auipc	ra,0x9
    80208784:	524080e7          	jalr	1316(ra) # 80211ca4 <wakeup>
    // releaseLock(&lk->lk);
}
    80208788:	00813083          	ld	ra,8(sp)
    8020878c:	00013403          	ld	s0,0(sp)
    80208790:	01010113          	addi	sp,sp,16
    80208794:	00008067          	ret

0000000080208798 <holdingsleep>:

int holdingsleep(struct Sleeplock* lk) {
    int r;

    // acquireLock(&lk->lk);
    r = lk->locked && (lk->tid == myThread()->id);
    80208798:	00052783          	lw	a5,0(a0)
    8020879c:	00079663          	bnez	a5,802087a8 <holdingsleep+0x10>
    802087a0:	00000513          	li	a0,0
    // releaseLock(&lk->lk);
    return r;
    802087a4:	00008067          	ret
int holdingsleep(struct Sleeplock* lk) {
    802087a8:	fe010113          	addi	sp,sp,-32
    802087ac:	00113c23          	sd	ra,24(sp)
    802087b0:	00813823          	sd	s0,16(sp)
    802087b4:	00913423          	sd	s1,8(sp)
    802087b8:	02010413          	addi	s0,sp,32
    r = lk->locked && (lk->tid == myThread()->id);
    802087bc:	02852483          	lw	s1,40(a0)
    802087c0:	00008097          	auipc	ra,0x8
    802087c4:	d80080e7          	jalr	-640(ra) # 80210540 <myThread>
    802087c8:	23852503          	lw	a0,568(a0)
    802087cc:	40950533          	sub	a0,a0,s1
    802087d0:	00153513          	seqz	a0,a0
    802087d4:	01813083          	ld	ra,24(sp)
    802087d8:	01013403          	ld	s0,16(sp)
    802087dc:	00813483          	ld	s1,8(sp)
    802087e0:	02010113          	addi	sp,sp,32
    802087e4:	00008067          	ret

00000000802087e8 <initLock>:
#include "Spinlock.h"
#include "Hart.h"
#include "Interrupt.h"
#include "Driver.h"

void initLock(struct Spinlock* lock, char* name) {
    802087e8:	ff010113          	addi	sp,sp,-16
    802087ec:	00813423          	sd	s0,8(sp)
    802087f0:	01010413          	addi	s0,sp,16
    lock->name = name;
    802087f4:	00b53423          	sd	a1,8(a0)
    lock->locked = 0;
    802087f8:	00050023          	sb	zero,0(a0)
    lock->hart = 0;
    802087fc:	00053823          	sd	zero,16(a0)
    lock->times = 0;
    80208800:	00052223          	sw	zero,4(a0)
}
    80208804:	00813403          	ld	s0,8(sp)
    80208808:	01010113          	addi	sp,sp,16
    8020880c:	00008067          	ret

0000000080208810 <acquireLock>:

void acquireLock(struct Spinlock* lock) {
    80208810:	ff010113          	addi	sp,sp,-16
    80208814:	00813423          	sd	s0,8(sp)
    80208818:	01010413          	addi	s0,sp,16
    // On RISC-V, this emits a fence instruction.
    __sync_synchronize();

    lock->hart = myHart();
    // lock->times++;
}
    8020881c:	00813403          	ld	s0,8(sp)
    80208820:	01010113          	addi	sp,sp,16
    80208824:	00008067          	ret

0000000080208828 <releaseLock>:

void releaseLock(struct Spinlock* lock) {
    80208828:	ff010113          	addi	sp,sp,-16
    8020882c:	00813423          	sd	s0,8(sp)
    80208830:	01010413          	addi	s0,sp,16
    // On RISC-V, sync_lock_release turns into an atomic swap:
    //   s1 = &lk->locked
    //   amoswap.w zero, zero, (s1)
    __sync_lock_release(&lock->locked);
    interruptPop();
}
    80208834:	00813403          	ld	s0,8(sp)
    80208838:	01010113          	addi	sp,sp,16
    8020883c:	00008067          	ret

0000000080208840 <holding>:

int holding(struct Spinlock* lock) {
    int r;
    r = (lock->locked && lock->hart == myHart());
    80208840:	00054783          	lbu	a5,0(a0)
    80208844:	00079663          	bnez	a5,80208850 <holding+0x10>
    80208848:	00000513          	li	a0,0
    return r;
    8020884c:	00008067          	ret
int holding(struct Spinlock* lock) {
    80208850:	fe010113          	addi	sp,sp,-32
    80208854:	00113c23          	sd	ra,24(sp)
    80208858:	00813823          	sd	s0,16(sp)
    8020885c:	00913423          	sd	s1,8(sp)
    80208860:	02010413          	addi	s0,sp,32
    r = (lock->locked && lock->hart == myHart());
    80208864:	01053483          	ld	s1,16(a0)
    80208868:	00002097          	auipc	ra,0x2
    8020886c:	944080e7          	jalr	-1724(ra) # 8020a1ac <myHart>
    80208870:	40a48533          	sub	a0,s1,a0
    80208874:	00153513          	seqz	a0,a0
    80208878:	01813083          	ld	ra,24(sp)
    8020887c:	01013403          	ld	s0,16(sp)
    80208880:	00813483          	ld	s1,8(sp)
    80208884:	02010113          	addi	sp,sp,32
    80208888:	00008067          	ret

000000008020888c <startPage>:
        PTE_READ | PTE_WRITE | PTE_EXECUTE | PTE_ACCESSED | PTE_DIRTY);
    pageInsert(kernelPageDirectory, TRAMPOLINE_BASE + PAGE_SIZE, (u64)trampoline + PAGE_SIZE, 
        PTE_READ | PTE_WRITE | PTE_EXECUTE | PTE_ACCESSED | PTE_DIRTY);
}

void startPage() {
    8020888c:	ff010113          	addi	sp,sp,-16
    80208890:	00813423          	sd	s0,8(sp)
    80208894:	01010413          	addi	s0,sp,16
    w_satp(MAKE_SATP(kernelPageDirectory));
    80208898:	02166797          	auipc	a5,0x2166
    8020889c:	76878793          	addi	a5,a5,1896 # 8236f000 <_pgdir>
    802088a0:	00c7d793          	srli	a5,a5,0xc
    802088a4:	fff00713          	li	a4,-1
    802088a8:	03f71713          	slli	a4,a4,0x3f
    802088ac:	00e7e7b3          	or	a5,a5,a4
#define MAKE_SATP(pagetable) (SATP_SV39 | (((u64)pagetable) >> 12))

// supervisor address translation and protection;
// holds the address of the page table.
static inline void w_satp(u64 x) {
	asm volatile("csrw satp, %0" : : "r" (x));
    802088b0:	18079073          	csrw	satp,a5

// flush the TLB.
static inline void sfence_vma() {
	// the zero, zero means flush all TLB entries.
	// asm volatile("sfence.vma zero, zero");
	asm volatile("sfence.vma");
    802088b4:	12000073          	sfence.vma
    sfence_vma();
}
    802088b8:	00813403          	ld	s0,8(sp)
    802088bc:	01010113          	addi	sp,sp,16
    802088c0:	00008067          	ret

00000000802088c4 <memoryInit>:

void memoryInit() {
    802088c4:	fc010113          	addi	sp,sp,-64
    802088c8:	02113c23          	sd	ra,56(sp)
    802088cc:	02813823          	sd	s0,48(sp)
    802088d0:	02913423          	sd	s1,40(sp)
    802088d4:	03213023          	sd	s2,32(sp)
    802088d8:	01313c23          	sd	s3,24(sp)
    802088dc:	01413823          	sd	s4,16(sp)
    802088e0:	01513423          	sd	s5,8(sp)
    802088e4:	01613023          	sd	s6,0(sp)
    802088e8:	04010413          	addi	s0,sp,64
    printf("Memory init start...\n");
    802088ec:	0000d517          	auipc	a0,0xd
    802088f0:	1b450513          	addi	a0,a0,436 # 80215aa0 <__func__.0+0x20>
    802088f4:	ffff8097          	auipc	ra,0xffff8
    802088f8:	55c080e7          	jalr	1372(ra) # 80200e50 <printf>
    u64 n = PA2PPN(kernelEnd);
    802088fc:	82167997          	auipc	s3,0x82167
    80208900:	70498993          	addi	s3,s3,1796 # 2370000 <_start-0x7de90000>
    80208904:	00c9d993          	srli	s3,s3,0xc
    for (i = 0; i < n; i++) {
    80208908:	38098463          	beqz	s3,80208c90 <memoryInit+0x3cc>
    8020890c:	018fe797          	auipc	a5,0x18fe
    80208910:	60478793          	addi	a5,a5,1540 # 81b06f10 <pages+0x10>
    80208914:	00199713          	slli	a4,s3,0x1
    80208918:	01370733          	add	a4,a4,s3
    8020891c:	00371713          	slli	a4,a4,0x3
    80208920:	00f70733          	add	a4,a4,a5
        pages[i].ref = 1;
    80208924:	00100693          	li	a3,1
    80208928:	00d7a023          	sw	a3,0(a5)
    for (i = 0; i < n; i++) {
    8020892c:	01878793          	addi	a5,a5,24
    80208930:	fee79ce3          	bne	a5,a4,80208928 <memoryInit+0x64>
    LIST_INIT(&freePages);
    80208934:	01a7e797          	auipc	a5,0x1a7e
    80208938:	5c07b623          	sd	zero,1484(a5) # 81c86f00 <freePages>
    for (; i < n; i++) {
    8020893c:	000107b7          	lui	a5,0x10
    80208940:	0ef9f063          	bgeu	s3,a5,80208a20 <memoryInit+0x15c>
    for (i = 0; i < n; i++) {
    80208944:	00098813          	mv	a6,s3
    80208948:	01a7e617          	auipc	a2,0x1a7e
    8020894c:	5b863603          	ld	a2,1464(a2) # 81c86f00 <freePages>
    80208950:	00181893          	slli	a7,a6,0x1
    80208954:	010888b3          	add	a7,a7,a6
    80208958:	00389893          	slli	a7,a7,0x3
    8020895c:	018fe797          	auipc	a5,0x18fe
    80208960:	5a478793          	addi	a5,a5,1444 # 81b06f00 <pages>
    80208964:	011787b3          	add	a5,a5,a7
    80208968:	00080693          	mv	a3,a6
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    8020896c:	01a7e517          	auipc	a0,0x1a7e
    80208970:	59450513          	addi	a0,a0,1428 # 81c86f00 <freePages>
    for (; i < n; i++) {
    80208974:	000105b7          	lui	a1,0x10
    80208978:	0180006f          	j	80208990 <memoryInit+0xcc>
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    8020897c:	00f73423          	sd	a5,8(a4)
    80208980:	00a63423          	sd	a0,8(a2)
    for (; i < n; i++) {
    80208984:	00168693          	addi	a3,a3,1
    80208988:	01878793          	addi	a5,a5,24
    8020898c:	00b6fe63          	bgeu	a3,a1,802089a8 <memoryInit+0xe4>
        pages[i].ref = 0;
    80208990:	00060713          	mv	a4,a2
    80208994:	00078613          	mv	a2,a5
    80208998:	0007a823          	sw	zero,16(a5)
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    8020899c:	00e7b023          	sd	a4,0(a5)
    802089a0:	fc071ee3          	bnez	a4,8020897c <memoryInit+0xb8>
    802089a4:	fddff06f          	j	80208980 <memoryInit+0xbc>
    802089a8:	00180693          	addi	a3,a6,1
    802089ac:	00010737          	lui	a4,0x10
    802089b0:	00000793          	li	a5,0
    802089b4:	00d76863          	bltu	a4,a3,802089c4 <memoryInit+0x100>
    802089b8:	000107b7          	lui	a5,0x10
    802089bc:	fff78793          	addi	a5,a5,-1 # ffff <_start-0x801f0001>
    802089c0:	410787b3          	sub	a5,a5,a6
    802089c4:	00010637          	lui	a2,0x10
    802089c8:	00000713          	li	a4,0
    802089cc:	00d66e63          	bltu	a2,a3,802089e8 <memoryInit+0x124>
    802089d0:	00281713          	slli	a4,a6,0x2
    802089d4:	40e80733          	sub	a4,a6,a4
    802089d8:	00371713          	slli	a4,a4,0x3
    802089dc:	001806b7          	lui	a3,0x180
    802089e0:	fe868693          	addi	a3,a3,-24 # 17ffe8 <_start-0x80080018>
    802089e4:	00d70733          	add	a4,a4,a3
    802089e8:	01170733          	add	a4,a4,a7
    802089ec:	018fe697          	auipc	a3,0x18fe
    802089f0:	51468693          	addi	a3,a3,1300 # 81b06f00 <pages>
    802089f4:	00d70733          	add	a4,a4,a3
    802089f8:	01a7e617          	auipc	a2,0x1a7e
    802089fc:	50e63423          	sd	a4,1288(a2) # 81c86f00 <freePages>
    80208a00:	00f807b3          	add	a5,a6,a5
    80208a04:	00179713          	slli	a4,a5,0x1
    80208a08:	00f707b3          	add	a5,a4,a5
    80208a0c:	00379793          	slli	a5,a5,0x3
    80208a10:	00f686b3          	add	a3,a3,a5
    80208a14:	01a7e797          	auipc	a5,0x1a7e
    80208a18:	4ec78793          	addi	a5,a5,1260 # 81c86f00 <freePages>
    80208a1c:	00f6b423          	sd	a5,8(a3)
    pageInsert(kernelPageDirectory, UART_V, UART, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208a20:	0c600693          	li	a3,198
    80208a24:	10000637          	lui	a2,0x10000
    80208a28:	3f100593          	li	a1,1009
    80208a2c:	01c59593          	slli	a1,a1,0x1c
    80208a30:	02166517          	auipc	a0,0x2166
    80208a34:	5d050513          	addi	a0,a0,1488 # 8236f000 <_pgdir>
    80208a38:	00001097          	auipc	ra,0x1
    80208a3c:	838080e7          	jalr	-1992(ra) # 80209270 <pageInsert>
    80208a40:	01f814b7          	lui	s1,0x1f81
    80208a44:	00d49493          	slli	s1,s1,0xd
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208a48:	fc100a13          	li	s4,-63
    80208a4c:	020a1a13          	slli	s4,s4,0x20
    80208a50:	02166b17          	auipc	s6,0x2166
    80208a54:	5b0b0b13          	addi	s6,s6,1456 # 8236f000 <_pgdir>
    for (u64 i = 0; i < 0x10000; i += PAGE_SIZE) {
    80208a58:	00001ab7          	lui	s5,0x1
    80208a5c:	003f0937          	lui	s2,0x3f0
    80208a60:	20190913          	addi	s2,s2,513 # 3f0201 <_start-0x7fe0fdff>
    80208a64:	01091913          	slli	s2,s2,0x10
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208a68:	0c600693          	li	a3,198
    80208a6c:	01448633          	add	a2,s1,s4
    80208a70:	00048593          	mv	a1,s1
    80208a74:	000b0513          	mv	a0,s6
    80208a78:	00000097          	auipc	ra,0x0
    80208a7c:	7f8080e7          	jalr	2040(ra) # 80209270 <pageInsert>
    for (u64 i = 0; i < 0x10000; i += PAGE_SIZE) {
    80208a80:	015484b3          	add	s1,s1,s5
    80208a84:	ff2492e3          	bne	s1,s2,80208a68 <memoryInit+0x1a4>
    80208a88:	00fc34b7          	lui	s1,0xfc3
    80208a8c:	00e49493          	slli	s1,s1,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208a90:	fc100a13          	li	s4,-63
    80208a94:	020a1a13          	slli	s4,s4,0x20
    80208a98:	02166b17          	auipc	s6,0x2166
    80208a9c:	568b0b13          	addi	s6,s6,1384 # 8236f000 <_pgdir>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80208aa0:	00001ab7          	lui	s5,0x1
    80208aa4:	00fc3937          	lui	s2,0xfc3
    80208aa8:	00190913          	addi	s2,s2,1 # fc3001 <_start-0x7f23cfff>
    80208aac:	00e91913          	slli	s2,s2,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208ab0:	0c600693          	li	a3,198
    80208ab4:	01448633          	add	a2,s1,s4
    80208ab8:	00048593          	mv	a1,s1
    80208abc:	000b0513          	mv	a0,s6
    80208ac0:	00000097          	auipc	ra,0x0
    80208ac4:	7b0080e7          	jalr	1968(ra) # 80209270 <pageInsert>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80208ac8:	015484b3          	add	s1,s1,s5
    80208acc:	ff2492e3          	bne	s1,s2,80208ab0 <memoryInit+0x1ec>
    80208ad0:	1f8614b7          	lui	s1,0x1f861
    80208ad4:	00949493          	slli	s1,s1,0x9
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208ad8:	fc100a13          	li	s4,-63
    80208adc:	020a1a13          	slli	s4,s4,0x20
    80208ae0:	02166b17          	auipc	s6,0x2166
    80208ae4:	520b0b13          	addi	s6,s6,1312 # 8236f000 <_pgdir>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80208ae8:	00001ab7          	lui	s5,0x1
    80208aec:	00fc3937          	lui	s2,0xfc3
    80208af0:	08190913          	addi	s2,s2,129 # fc3081 <_start-0x7f23cf7f>
    80208af4:	00e91913          	slli	s2,s2,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208af8:	0c600693          	li	a3,198
    80208afc:	01448633          	add	a2,s1,s4
    80208b00:	00048593          	mv	a1,s1
    80208b04:	000b0513          	mv	a0,s6
    80208b08:	00000097          	auipc	ra,0x0
    80208b0c:	768080e7          	jalr	1896(ra) # 80209270 <pageInsert>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80208b10:	015484b3          	add	s1,s1,s5
    80208b14:	ff2492e3          	bne	s1,s2,80208af8 <memoryInit+0x234>
    pageInsert(kernelPageDirectory, SPI_CTRL_ADDR, SPI_CTRL_ADDR, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208b18:	0c600693          	li	a3,198
    80208b1c:	10050637          	lui	a2,0x10050
    80208b20:	100505b7          	lui	a1,0x10050
    80208b24:	02166517          	auipc	a0,0x2166
    80208b28:	4dc50513          	addi	a0,a0,1244 # 8236f000 <_pgdir>
    80208b2c:	00000097          	auipc	ra,0x0
    80208b30:	744080e7          	jalr	1860(ra) # 80209270 <pageInsert>
    pageInsert(kernelPageDirectory, UART_CTRL_ADDR, UART_CTRL_ADDR, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208b34:	0c600693          	li	a3,198
    80208b38:	10010637          	lui	a2,0x10010
    80208b3c:	100105b7          	lui	a1,0x10010
    80208b40:	02166517          	auipc	a0,0x2166
    80208b44:	4c050513          	addi	a0,a0,1216 # 8236f000 <_pgdir>
    80208b48:	00000097          	auipc	ra,0x0
    80208b4c:	728080e7          	jalr	1832(ra) # 80209270 <pageInsert>
    va = pa = (u64)kernelStart;
    80208b50:	ffff7917          	auipc	s2,0xffff7
    80208b54:	4b090913          	addi	s2,s2,1200 # 80200000 <_start>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80208b58:	0000c497          	auipc	s1,0xc
    80208b5c:	4a848493          	addi	s1,s1,1192 # 80215000 <textEnd>
    80208b60:	02997863          	bgeu	s2,s1,80208b90 <memoryInit+0x2cc>
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_EXECUTE | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208b64:	02166a97          	auipc	s5,0x2166
    80208b68:	49ca8a93          	addi	s5,s5,1180 # 8236f000 <_pgdir>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80208b6c:	00001a37          	lui	s4,0x1
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_EXECUTE | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208b70:	0ce00693          	li	a3,206
    80208b74:	00090613          	mv	a2,s2
    80208b78:	00090593          	mv	a1,s2
    80208b7c:	000a8513          	mv	a0,s5
    80208b80:	00000097          	auipc	ra,0x0
    80208b84:	6f0080e7          	jalr	1776(ra) # 80209270 <pageInsert>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80208b88:	01490933          	add	s2,s2,s4
    80208b8c:	fe9962e3          	bltu	s2,s1,80208b70 <memoryInit+0x2ac>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80208b90:	00900793          	li	a5,9
    80208b94:	01c79793          	slli	a5,a5,0x1c
    80208b98:	02f4fa63          	bgeu	s1,a5,80208bcc <memoryInit+0x308>
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208b9c:	02166a97          	auipc	s5,0x2166
    80208ba0:	464a8a93          	addi	s5,s5,1124 # 8236f000 <_pgdir>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80208ba4:	00001a37          	lui	s4,0x1
    80208ba8:	00078913          	mv	s2,a5
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80208bac:	0c600693          	li	a3,198
    80208bb0:	00048613          	mv	a2,s1
    80208bb4:	00048593          	mv	a1,s1
    80208bb8:	000a8513          	mv	a0,s5
    80208bbc:	00000097          	auipc	ra,0x0
    80208bc0:	6b4080e7          	jalr	1716(ra) # 80209270 <pageInsert>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80208bc4:	014484b3          	add	s1,s1,s4
    80208bc8:	ff24e2e3          	bltu	s1,s2,80208bac <memoryInit+0x2e8>
    pageInsert(kernelPageDirectory, TRAMPOLINE_BASE, (u64)trampoline, 
    80208bcc:	0ce00693          	li	a3,206
    80208bd0:	00009617          	auipc	a2,0x9
    80208bd4:	43060613          	addi	a2,a2,1072 # 80212000 <_trampoline>
    80208bd8:	020005b7          	lui	a1,0x2000
    80208bdc:	fff58593          	addi	a1,a1,-1 # 1ffffff <_start-0x7e200001>
    80208be0:	00d59593          	slli	a1,a1,0xd
    80208be4:	02166517          	auipc	a0,0x2166
    80208be8:	41c50513          	addi	a0,a0,1052 # 8236f000 <_pgdir>
    80208bec:	00000097          	auipc	ra,0x0
    80208bf0:	684080e7          	jalr	1668(ra) # 80209270 <pageInsert>
    pageInsert(kernelPageDirectory, TRAMPOLINE_BASE + PAGE_SIZE, (u64)trampoline + PAGE_SIZE, 
    80208bf4:	0ce00693          	li	a3,206
    80208bf8:	0000a617          	auipc	a2,0xa
    80208bfc:	40860613          	addi	a2,a2,1032 # 80213000 <trapframe>
    80208c00:	040005b7          	lui	a1,0x4000
    80208c04:	fff58593          	addi	a1,a1,-1 # 3ffffff <_start-0x7c200001>
    80208c08:	00c59593          	slli	a1,a1,0xc
    80208c0c:	02166517          	auipc	a0,0x2166
    80208c10:	3f450513          	addi	a0,a0,1012 # 8236f000 <_pgdir>
    80208c14:	00000097          	auipc	ra,0x0
    80208c18:	65c080e7          	jalr	1628(ra) # 80209270 <pageInsert>
    for (; i < n; i++) {
    80208c1c:	000107b7          	lui	a5,0x10
    80208c20:	02f9f863          	bgeu	s3,a5,80208c50 <memoryInit+0x38c>
    80208c24:	00199793          	slli	a5,s3,0x1
    80208c28:	013787b3          	add	a5,a5,s3
    80208c2c:	00379793          	slli	a5,a5,0x3
    80208c30:	018fe717          	auipc	a4,0x18fe
    80208c34:	2e070713          	addi	a4,a4,736 # 81b06f10 <pages+0x10>
    80208c38:	00e787b3          	add	a5,a5,a4
    80208c3c:	01a7e717          	auipc	a4,0x1a7e
    80208c40:	2d470713          	addi	a4,a4,724 # 81c86f10 <pageListLock+0x8>
        pages[i].ref = 0;
    80208c44:	0007a023          	sw	zero,0(a5) # 10000 <_start-0x801f0000>
    for (; i < n; i++) {
    80208c48:	01878793          	addi	a5,a5,24
    80208c4c:	fee79ce3          	bne	a5,a4,80208c44 <memoryInit+0x380>
    initFreePages();
    virtualMemory();
    resetRef();
    startPage();
    80208c50:	00000097          	auipc	ra,0x0
    80208c54:	c3c080e7          	jalr	-964(ra) # 8020888c <startPage>
    printf("Memory init finish!\n");
    80208c58:	0000d517          	auipc	a0,0xd
    80208c5c:	e6050513          	addi	a0,a0,-416 # 80215ab8 <__func__.0+0x38>
    80208c60:	ffff8097          	auipc	ra,0xffff8
    80208c64:	1f0080e7          	jalr	496(ra) # 80200e50 <printf>
}
    80208c68:	03813083          	ld	ra,56(sp)
    80208c6c:	03013403          	ld	s0,48(sp)
    80208c70:	02813483          	ld	s1,40(sp)
    80208c74:	02013903          	ld	s2,32(sp)
    80208c78:	01813983          	ld	s3,24(sp)
    80208c7c:	01013a03          	ld	s4,16(sp)
    80208c80:	00813a83          	ld	s5,8(sp)
    80208c84:	00013b03          	ld	s6,0(sp)
    80208c88:	04010113          	addi	sp,sp,64
    80208c8c:	00008067          	ret
    LIST_INIT(&freePages);
    80208c90:	01a7e797          	auipc	a5,0x1a7e
    80208c94:	2607b823          	sd	zero,624(a5) # 81c86f00 <freePages>
    for (i = 0; i < n; i++) {
    80208c98:	00098813          	mv	a6,s3
    80208c9c:	cadff06f          	j	80208948 <memoryInit+0x84>

0000000080208ca0 <bcopy>:

void bcopy(void *src, void *dst, u32 len) {
    80208ca0:	ff010113          	addi	sp,sp,-16
    80208ca4:	00813423          	sd	s0,8(sp)
    80208ca8:	01010413          	addi	s0,sp,16
    void *finish = src + len;
    80208cac:	02061613          	slli	a2,a2,0x20
    80208cb0:	02065613          	srli	a2,a2,0x20
    80208cb4:	00c50633          	add	a2,a0,a2

    while (src < finish) {
    80208cb8:	00c57c63          	bgeu	a0,a2,80208cd0 <bcopy+0x30>
        *(u8*)dst = *(u8*)src;
    80208cbc:	00054783          	lbu	a5,0(a0)
    80208cc0:	00f58023          	sb	a5,0(a1)
        src++;
    80208cc4:	00150513          	addi	a0,a0,1
        dst++;
    80208cc8:	00158593          	addi	a1,a1,1
    while (src < finish) {
    80208ccc:	fea618e3          	bne	a2,a0,80208cbc <bcopy+0x1c>
    }
}
    80208cd0:	00813403          	ld	s0,8(sp)
    80208cd4:	01010113          	addi	sp,sp,16
    80208cd8:	00008067          	ret

0000000080208cdc <bzero>:

void bzero(void *start, u32 len) {
    80208cdc:	ff010113          	addi	sp,sp,-16
    80208ce0:	00813423          	sd	s0,8(sp)
    80208ce4:	01010413          	addi	s0,sp,16
    void *finish = start + len;
    80208ce8:	02059713          	slli	a4,a1,0x20
    80208cec:	02075713          	srli	a4,a4,0x20
    80208cf0:	00e50733          	add	a4,a0,a4

    if (len <= 7) {
    80208cf4:	00700793          	li	a5,7
    80208cf8:	06b7f063          	bgeu	a5,a1,80208d58 <bzero+0x7c>
        while (start < finish) {
            *(u8*)start++ = 0;
        }
        return;
    }
    while (((u64) start) & 7) {
    80208cfc:	00757793          	andi	a5,a0,7
    80208d00:	00078a63          	beqz	a5,80208d14 <bzero+0x38>
        *(u8*)start++ = 0;
    80208d04:	00150513          	addi	a0,a0,1
    80208d08:	fe050fa3          	sb	zero,-1(a0)
    while (((u64) start) & 7) {
    80208d0c:	00757793          	andi	a5,a0,7
    80208d10:	fe079ae3          	bnez	a5,80208d04 <bzero+0x28>
    }
    while (start + 7 < finish) {
    80208d14:	00750793          	addi	a5,a0,7
    80208d18:	04e7fa63          	bgeu	a5,a4,80208d6c <bzero+0x90>
    80208d1c:	ff870793          	addi	a5,a4,-8
    80208d20:	40a787b3          	sub	a5,a5,a0
    80208d24:	ff87f793          	andi	a5,a5,-8
    80208d28:	00878793          	addi	a5,a5,8
    80208d2c:	00f507b3          	add	a5,a0,a5
        *(u64*)start = 0;
    80208d30:	00053023          	sd	zero,0(a0)
        start += 8;
    80208d34:	00850513          	addi	a0,a0,8
    while (start + 7 < finish) {
    80208d38:	fef51ce3          	bne	a0,a5,80208d30 <bzero+0x54>
    }
    while (start < finish) {
    80208d3c:	00e7f863          	bgeu	a5,a4,80208d4c <bzero+0x70>
        *(u8*)start++ = 0;
    80208d40:	00178793          	addi	a5,a5,1
    80208d44:	fe078fa3          	sb	zero,-1(a5)
    while (start < finish) {
    80208d48:	fef71ce3          	bne	a4,a5,80208d40 <bzero+0x64>
    }
    80208d4c:	00813403          	ld	s0,8(sp)
    80208d50:	01010113          	addi	sp,sp,16
    80208d54:	00008067          	ret
        while (start < finish) {
    80208d58:	fee57ae3          	bgeu	a0,a4,80208d4c <bzero+0x70>
            *(u8*)start++ = 0;
    80208d5c:	00150513          	addi	a0,a0,1
    80208d60:	fe050fa3          	sb	zero,-1(a0)
        while (start < finish) {
    80208d64:	fea71ce3          	bne	a4,a0,80208d5c <bzero+0x80>
    80208d68:	fe5ff06f          	j	80208d4c <bzero+0x70>
    while (start + 7 < finish) {
    80208d6c:	00050793          	mv	a5,a0
    80208d70:	fcdff06f          	j	80208d3c <bzero+0x60>

0000000080208d74 <paDecreaseRef>:
        LIST_INSERT_HEAD(&freePages, page, link);
        // releaseLock(&pageListLock);
    }
}

static void paDecreaseRef(u64 pa) {
    80208d74:	fe010113          	addi	sp,sp,-32
    80208d78:	00113c23          	sd	ra,24(sp)
    80208d7c:	00813823          	sd	s0,16(sp)
    80208d80:	00913423          	sd	s1,8(sp)
    80208d84:	02010413          	addi	s0,sp,32
inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
}

inline PhysicalPage* pa2page(u64 pa) {
    if (pa == 0)
    80208d88:	0a050063          	beqz	a0,80208e28 <paDecreaseRef+0xb4>
        return NULL;
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    80208d8c:	800007b7          	lui	a5,0x80000
    80208d90:	00f50533          	add	a0,a0,a5
    80208d94:	00c55513          	srli	a0,a0,0xc
    return pages + ppn;
    80208d98:	02051513          	slli	a0,a0,0x20
    80208d9c:	02055513          	srli	a0,a0,0x20
    80208da0:	00151493          	slli	s1,a0,0x1
    80208da4:	00a484b3          	add	s1,s1,a0
    80208da8:	00349493          	slli	s1,s1,0x3
    80208dac:	018fe797          	auipc	a5,0x18fe
    80208db0:	15478793          	addi	a5,a5,340 # 81b06f00 <pages>
    80208db4:	00f484b3          	add	s1,s1,a5
    PhysicalPage *page = pa2page(pa);
    page->ref--;
    80208db8:	0104a783          	lw	a5,16(s1)
    80208dbc:	fff7879b          	addiw	a5,a5,-1
    80208dc0:	0007869b          	sext.w	a3,a5
    80208dc4:	00f4a823          	sw	a5,16(s1)
    assert(page->ref==0);
    80208dc8:	0016b693          	seqz	a3,a3
    80208dcc:	0000d617          	auipc	a2,0xd
    80208dd0:	d7460613          	addi	a2,a2,-652 # 80215b40 <__func__.4>
    80208dd4:	07d00593          	li	a1,125
    80208dd8:	0000d517          	auipc	a0,0xd
    80208ddc:	cf850513          	addi	a0,a0,-776 # 80215ad0 <__func__.0+0x50>
    80208de0:	ffff8097          	auipc	ra,0xffff8
    80208de4:	178080e7          	jalr	376(ra) # 80200f58 <_assert_>
    if (page->ref == 0) {
    80208de8:	0104a783          	lw	a5,16(s1)
    80208dec:	02079463          	bnez	a5,80208e14 <paDecreaseRef+0xa0>
        // acquireLock(&pageListLock);
        LIST_INSERT_HEAD(&freePages, page, link);
    80208df0:	01a7e797          	auipc	a5,0x1a7e
    80208df4:	1107b783          	ld	a5,272(a5) # 81c86f00 <freePages>
    80208df8:	00f4b023          	sd	a5,0(s1)
    80208dfc:	00078463          	beqz	a5,80208e04 <paDecreaseRef+0x90>
    80208e00:	0097b423          	sd	s1,8(a5)
    80208e04:	01a7e797          	auipc	a5,0x1a7e
    80208e08:	0fc78793          	addi	a5,a5,252 # 81c86f00 <freePages>
    80208e0c:	0097b023          	sd	s1,0(a5)
    80208e10:	00f4b423          	sd	a5,8(s1)
        // releaseLock(&pageListLock);
    }
}
    80208e14:	01813083          	ld	ra,24(sp)
    80208e18:	01013403          	ld	s0,16(sp)
    80208e1c:	00813483          	ld	s1,8(sp)
    80208e20:	02010113          	addi	sp,sp,32
    80208e24:	00008067          	ret
        return NULL;
    80208e28:	00000493          	li	s1,0
    80208e2c:	f8dff06f          	j	80208db8 <paDecreaseRef+0x44>

0000000080208e30 <pageLockInit>:
inline void pageLockInit(void) {
    80208e30:	ff010113          	addi	sp,sp,-16
    80208e34:	00113423          	sd	ra,8(sp)
    80208e38:	00813023          	sd	s0,0(sp)
    80208e3c:	01010413          	addi	s0,sp,16
    initLock(&pageListLock, "pageListLock");
    80208e40:	0000d597          	auipc	a1,0xd
    80208e44:	c9858593          	addi	a1,a1,-872 # 80215ad8 <__func__.0+0x58>
    80208e48:	01a7e517          	auipc	a0,0x1a7e
    80208e4c:	0c050513          	addi	a0,a0,192 # 81c86f08 <pageListLock>
    80208e50:	00000097          	auipc	ra,0x0
    80208e54:	998080e7          	jalr	-1640(ra) # 802087e8 <initLock>
    initLock(&cowBufferLock, "cowBufferLock");
    80208e58:	0000d597          	auipc	a1,0xd
    80208e5c:	c9058593          	addi	a1,a1,-880 # 80215ae8 <__func__.0+0x68>
    80208e60:	01a7e517          	auipc	a0,0x1a7e
    80208e64:	0c050513          	addi	a0,a0,192 # 81c86f20 <cowBufferLock>
    80208e68:	00000097          	auipc	ra,0x0
    80208e6c:	980080e7          	jalr	-1664(ra) # 802087e8 <initLock>
}
    80208e70:	00813083          	ld	ra,8(sp)
    80208e74:	00013403          	ld	s0,0(sp)
    80208e78:	01010113          	addi	sp,sp,16
    80208e7c:	00008067          	ret

0000000080208e80 <countFreePages>:
int countFreePages() {
    80208e80:	ff010113          	addi	sp,sp,-16
    80208e84:	00813423          	sd	s0,8(sp)
    80208e88:	01010413          	addi	s0,sp,16
    LIST_FOREACH(page, &freePages, link)
    80208e8c:	01a7e797          	auipc	a5,0x1a7e
    80208e90:	0747b783          	ld	a5,116(a5) # 81c86f00 <freePages>
    80208e94:	02078063          	beqz	a5,80208eb4 <countFreePages+0x34>
    int count = 0;
    80208e98:	00000513          	li	a0,0
        count++;
    80208e9c:	0015051b          	addiw	a0,a0,1
    LIST_FOREACH(page, &freePages, link)
    80208ea0:	0007b783          	ld	a5,0(a5)
    80208ea4:	fe079ce3          	bnez	a5,80208e9c <countFreePages+0x1c>
}
    80208ea8:	00813403          	ld	s0,8(sp)
    80208eac:	01010113          	addi	sp,sp,16
    80208eb0:	00008067          	ret
    int count = 0;
    80208eb4:	00000513          	li	a0,0
    80208eb8:	ff1ff06f          	j	80208ea8 <countFreePages+0x28>

0000000080208ebc <pageAlloc>:
int pageAlloc(PhysicalPage **pp) {
    80208ebc:	ff010113          	addi	sp,sp,-16
    80208ec0:	00113423          	sd	ra,8(sp)
    80208ec4:	00813023          	sd	s0,0(sp)
    80208ec8:	01010413          	addi	s0,sp,16
    if ((page = LIST_FIRST(&freePages)) != NULL) {
    80208ecc:	01a7e797          	auipc	a5,0x1a7e
    80208ed0:	0347b783          	ld	a5,52(a5) # 81c86f00 <freePages>
    80208ed4:	08078063          	beqz	a5,80208f54 <pageAlloc+0x98>
        *pp = page;
    80208ed8:	00f53023          	sd	a5,0(a0)
    asm volatile("mv %0, tp" : "=r" (x) );
    80208edc:	00020713          	mv	a4,tp
        page->hartId = r_hartid();
    80208ee0:	00e7aa23          	sw	a4,20(a5)
        LIST_REMOVE(page, link);
    80208ee4:	0007b703          	ld	a4,0(a5)
    80208ee8:	00070663          	beqz	a4,80208ef4 <pageAlloc+0x38>
    80208eec:	0087b683          	ld	a3,8(a5)
    80208ef0:	00d73423          	sd	a3,8(a4)
    80208ef4:	0087b703          	ld	a4,8(a5)
    80208ef8:	0007b683          	ld	a3,0(a5)
    80208efc:	00d73023          	sd	a3,0(a4)
    return page - pages;
    80208f00:	018fe717          	auipc	a4,0x18fe
    80208f04:	00070713          	mv	a4,a4
    80208f08:	40e787b3          	sub	a5,a5,a4
    80208f0c:	4037d793          	srai	a5,a5,0x3
    80208f10:	0000e717          	auipc	a4,0xe
    80208f14:	8e873703          	ld	a4,-1816(a4) # 802167f8 <__func__.0+0x20>
    80208f18:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80208f1c:	00c7979b          	slliw	a5,a5,0xc
    80208f20:	02079793          	slli	a5,a5,0x20
    80208f24:	0207d793          	srli	a5,a5,0x20
        bzero((void*)page2pa(page), PAGE_SIZE);
    80208f28:	000015b7          	lui	a1,0x1
    80208f2c:	00100513          	li	a0,1
    80208f30:	01f51513          	slli	a0,a0,0x1f
    80208f34:	00a78533          	add	a0,a5,a0
    80208f38:	00000097          	auipc	ra,0x0
    80208f3c:	da4080e7          	jalr	-604(ra) # 80208cdc <bzero>
}
    80208f40:	00000513          	li	a0,0
    80208f44:	00813083          	ld	ra,8(sp)
    80208f48:	00013403          	ld	s0,0(sp)
    80208f4c:	01010113          	addi	sp,sp,16
    80208f50:	00008067          	ret
    panic("");
    80208f54:	0000d697          	auipc	a3,0xd
    80208f58:	c9468693          	addi	a3,a3,-876 # 80215be8 <__func__.0+0x48>
    80208f5c:	0000d617          	auipc	a2,0xd
    80208f60:	bf460613          	addi	a2,a2,-1036 # 80215b50 <__func__.5>
    80208f64:	03c00593          	li	a1,60
    80208f68:	0000d517          	auipc	a0,0xd
    80208f6c:	b6850513          	addi	a0,a0,-1176 # 80215ad0 <__func__.0+0x50>
    80208f70:	ffff8097          	auipc	ra,0xffff8
    80208f74:	f78080e7          	jalr	-136(ra) # 80200ee8 <_panic_>

0000000080208f78 <pageLookup>:
u64 pageLookup(u64 *pgdir, u64 va, u64 **pte) {
    80208f78:	ff010113          	addi	sp,sp,-16
    80208f7c:	00813423          	sd	s0,8(sp)
    80208f80:	01010413          	addi	s0,sp,16
    addr += GET_PAGE_TABLE_INDEX(va, 2);
    80208f84:	01e5d793          	srli	a5,a1,0x1e
    80208f88:	1ff7f793          	andi	a5,a5,511
    if (!(*addr) & PTE_VALID) {
    80208f8c:	00379793          	slli	a5,a5,0x3
    80208f90:	00f50533          	add	a0,a0,a5
    80208f94:	00053503          	ld	a0,0(a0)
    80208f98:	06050c63          	beqz	a0,80209010 <pageLookup+0x98>
    addr = (u64*)PTE2PA(*addr);
    80208f9c:	00251513          	slli	a0,a0,0x2
    80208fa0:	fff007b7          	lui	a5,0xfff00
    80208fa4:	0087d793          	srli	a5,a5,0x8
    80208fa8:	00f57533          	and	a0,a0,a5
    addr += GET_PAGE_TABLE_INDEX(va, 1);
    80208fac:	0155d793          	srli	a5,a1,0x15
    80208fb0:	1ff7f793          	andi	a5,a5,511
    if (!(*addr) & PTE_VALID) {
    80208fb4:	00379793          	slli	a5,a5,0x3
    80208fb8:	00f50533          	add	a0,a0,a5
    80208fbc:	00053503          	ld	a0,0(a0)
    80208fc0:	04050863          	beqz	a0,80209010 <pageLookup+0x98>
    addr = (u64*)PTE2PA(*addr);
    80208fc4:	00251513          	slli	a0,a0,0x2
    80208fc8:	fff007b7          	lui	a5,0xfff00
    80208fcc:	0087d793          	srli	a5,a5,0x8
    80208fd0:	00f57533          	and	a0,a0,a5
    *pte = addr + GET_PAGE_TABLE_INDEX(va, 0);
    80208fd4:	00c5d793          	srli	a5,a1,0xc
    80208fd8:	1ff7f793          	andi	a5,a5,511
    80208fdc:	00379793          	slli	a5,a5,0x3
    80208fe0:	00f507b3          	add	a5,a0,a5
    if (entry == NULL || !(*entry & PTE_VALID)) {
    80208fe4:	02078c63          	beqz	a5,8020901c <pageLookup+0xa4>
    80208fe8:	0007b503          	ld	a0,0(a5) # fffffffffff00000 <bssEnd+0xffffffff7db90000>
    80208fec:	00157513          	andi	a0,a0,1
    80208ff0:	02050063          	beqz	a0,80209010 <pageLookup+0x98>
    if (pte) {
    80208ff4:	00060463          	beqz	a2,80208ffc <pageLookup+0x84>
        *pte = entry;
    80208ff8:	00f63023          	sd	a5,0(a2)
    return PTE2PA(*entry);
    80208ffc:	0007b503          	ld	a0,0(a5)
    80209000:	00251513          	slli	a0,a0,0x2
    80209004:	fff007b7          	lui	a5,0xfff00
    80209008:	0087d793          	srli	a5,a5,0x8
    8020900c:	00f57533          	and	a0,a0,a5
}
    80209010:	00813403          	ld	s0,8(sp)
    80209014:	01010113          	addi	sp,sp,16
    80209018:	00008067          	ret
        return 0;
    8020901c:	00000513          	li	a0,0
    80209020:	ff1ff06f          	j	80209010 <pageLookup+0x98>

0000000080209024 <pageFree>:
void pageFree(PhysicalPage *page) {
    80209024:	ff010113          	addi	sp,sp,-16
    80209028:	00813423          	sd	s0,8(sp)
    8020902c:	01010413          	addi	s0,sp,16
    if (page->ref > 0) {
    80209030:	01052783          	lw	a5,16(a0)
    80209034:	02079463          	bnez	a5,8020905c <pageFree+0x38>
        LIST_INSERT_HEAD(&freePages, page, link);
    80209038:	01a7e797          	auipc	a5,0x1a7e
    8020903c:	ec87b783          	ld	a5,-312(a5) # 81c86f00 <freePages>
    80209040:	00f53023          	sd	a5,0(a0)
    80209044:	00078463          	beqz	a5,8020904c <pageFree+0x28>
    80209048:	00a7b423          	sd	a0,8(a5)
    8020904c:	01a7e797          	auipc	a5,0x1a7e
    80209050:	eb478793          	addi	a5,a5,-332 # 81c86f00 <freePages>
    80209054:	00a7b023          	sd	a0,0(a5)
    80209058:	00f53423          	sd	a5,8(a0)
}
    8020905c:	00813403          	ld	s0,8(sp)
    80209060:	01010113          	addi	sp,sp,16
    80209064:	00008067          	ret

0000000080209068 <pageRemove>:
int pageRemove(u64 *pgdir, u64 va) {
    80209068:	fd010113          	addi	sp,sp,-48
    8020906c:	02113423          	sd	ra,40(sp)
    80209070:	02813023          	sd	s0,32(sp)
    80209074:	00913c23          	sd	s1,24(sp)
    80209078:	03010413          	addi	s0,sp,48
    u64 pa = pageLookup(pgdir, va, &pte);
    8020907c:	fd840613          	addi	a2,s0,-40
    80209080:	00000097          	auipc	ra,0x0
    80209084:	ef8080e7          	jalr	-264(ra) # 80208f78 <pageLookup>
    if (!pte) {
    80209088:	fd843483          	ld	s1,-40(s0)
    8020908c:	06048063          	beqz	s1,802090ec <pageRemove+0x84>
    if (pa < PHYSICAL_ADDRESS_BASE || pa >= PHYSICAL_MEMORY_TOP) {
    80209090:	800007b7          	lui	a5,0x80000
    80209094:	00f50533          	add	a0,a0,a5
    80209098:	100007b7          	lui	a5,0x10000
    8020909c:	04f57c63          	bgeu	a0,a5,802090f4 <pageRemove+0x8c>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    802090a0:	00c55513          	srli	a0,a0,0xc
    return pages + ppn;
    802090a4:	00151793          	slli	a5,a0,0x1
    802090a8:	00a78533          	add	a0,a5,a0
    802090ac:	00351513          	slli	a0,a0,0x3
    802090b0:	018fe797          	auipc	a5,0x18fe
    802090b4:	e5078793          	addi	a5,a5,-432 # 81b06f00 <pages>
    802090b8:	00f50533          	add	a0,a0,a5
    page->ref--;
    802090bc:	01052783          	lw	a5,16(a0)
    802090c0:	fff7879b          	addiw	a5,a5,-1
    802090c4:	00f52823          	sw	a5,16(a0)
    pageFree(page);
    802090c8:	00000097          	auipc	ra,0x0
    802090cc:	f5c080e7          	jalr	-164(ra) # 80209024 <pageFree>
    *pte = 0;
    802090d0:	0004b023          	sd	zero,0(s1)
    return 0;
    802090d4:	00000513          	li	a0,0
}
    802090d8:	02813083          	ld	ra,40(sp)
    802090dc:	02013403          	ld	s0,32(sp)
    802090e0:	01813483          	ld	s1,24(sp)
    802090e4:	03010113          	addi	sp,sp,48
    802090e8:	00008067          	ret
        return -1;
    802090ec:	fff00513          	li	a0,-1
    802090f0:	fe9ff06f          	j	802090d8 <pageRemove+0x70>
        return -1;
    802090f4:	fff00513          	li	a0,-1
    802090f8:	fe1ff06f          	j	802090d8 <pageRemove+0x70>

00000000802090fc <pgdirFree>:

void pgdirFree(u64* pgdir) {
    802090fc:	f8010113          	addi	sp,sp,-128
    80209100:	06113c23          	sd	ra,120(sp)
    80209104:	06813823          	sd	s0,112(sp)
    80209108:	06913423          	sd	s1,104(sp)
    8020910c:	07213023          	sd	s2,96(sp)
    80209110:	05313c23          	sd	s3,88(sp)
    80209114:	05413823          	sd	s4,80(sp)
    80209118:	05513423          	sd	s5,72(sp)
    8020911c:	05613023          	sd	s6,64(sp)
    80209120:	03713c23          	sd	s7,56(sp)
    80209124:	03813823          	sd	s8,48(sp)
    80209128:	03913423          	sd	s9,40(sp)
    8020912c:	03a13023          	sd	s10,32(sp)
    80209130:	01b13c23          	sd	s11,24(sp)
    80209134:	08010413          	addi	s0,sp,128
    80209138:	00050b13          	mv	s6,a0
    // printf("jaoeifherigh   %lx\n", (u64)pgdir);
    u64 i, j, k;
    u64* pageTable;
    for (i = 0; i < PTE2PT; i++) {
    8020913c:	000017b7          	lui	a5,0x1
    80209140:	00f507b3          	add	a5,a0,a5
    80209144:	f8f43023          	sd	a5,-128(s0)
void pgdirFree(u64* pgdir) {
    80209148:	f8a43423          	sd	a0,-120(s0)
    8020914c:	00000d93          	li	s11,0
        if (!(pgdir[i] & PTE_VALID))
            continue;
        pageTable = pgdir + i;
        u64* pa = (u64*) PTE2PA(*pageTable);
    80209150:	fff00d37          	lui	s10,0xfff00
    80209154:	008d5d13          	srli	s10,s10,0x8
        for (j = 0; j < PTE2PT; j++) {
            if (!(pa[j] & PTE_VALID)) 
                continue;
            pageTable = (u64*) pa + j;
            u64* pa2 = (u64*) PTE2PA(*pageTable);
            for (k = 0; k < PTE2PT; k++) {
    80209158:	000019b7          	lui	s3,0x1
    8020915c:	00200a37          	lui	s4,0x200
    80209160:	0a80006f          	j	80209208 <pgdirFree+0x10c>
    80209164:	00890913          	addi	s2,s2,8
    80209168:	013484b3          	add	s1,s1,s3
    8020916c:	03448263          	beq	s1,s4,80209190 <pgdirFree+0x94>
                if (!(pa2[k] & PTE_VALID)) 
    80209170:	00093783          	ld	a5,0(s2)
    80209174:	0017f793          	andi	a5,a5,1
    80209178:	fe0786e3          	beqz	a5,80209164 <pgdirFree+0x68>
                    continue;
                u64 addr = (i << 30) | (j << 21) | (k << 12);
                pageRemove(pgdir, addr);
    8020917c:	009ae5b3          	or	a1,s5,s1
    80209180:	000b0513          	mv	a0,s6
    80209184:	00000097          	auipc	ra,0x0
    80209188:	ee4080e7          	jalr	-284(ra) # 80209068 <pageRemove>
    8020918c:	fd9ff06f          	j	80209164 <pgdirFree+0x68>
            }
            pa2[j] = 0;
    80209190:	018b87b3          	add	a5,s7,s8
    80209194:	0007b023          	sd	zero,0(a5) # 1000 <_start-0x801ff000>
            paDecreaseRef((u64) pa2);
    80209198:	000b8513          	mv	a0,s7
    8020919c:	00000097          	auipc	ra,0x0
    802091a0:	bd8080e7          	jalr	-1064(ra) # 80208d74 <paDecreaseRef>
        for (j = 0; j < PTE2PT; j++) {
    802091a4:	008c0c13          	addi	s8,s8,8
    802091a8:	033c0863          	beq	s8,s3,802091d8 <pgdirFree+0xdc>
            if (!(pa[j] & PTE_VALID)) 
    802091ac:	018c87b3          	add	a5,s9,s8
    802091b0:	0007b783          	ld	a5,0(a5)
    802091b4:	0017f713          	andi	a4,a5,1
    802091b8:	fe0706e3          	beqz	a4,802091a4 <pgdirFree+0xa8>
            u64* pa2 = (u64*) PTE2PA(*pageTable);
    802091bc:	00279793          	slli	a5,a5,0x2
    802091c0:	01a7fbb3          	and	s7,a5,s10
                u64 addr = (i << 30) | (j << 21) | (k << 12);
    802091c4:	012c1a93          	slli	s5,s8,0x12
    802091c8:	01baeab3          	or	s5,s5,s11
    802091cc:	000b8913          	mv	s2,s7
    802091d0:	00000493          	li	s1,0
    802091d4:	f9dff06f          	j	80209170 <pgdirFree+0x74>
        }
        paDecreaseRef((u64) pa);
    802091d8:	000c8513          	mv	a0,s9
    802091dc:	00000097          	auipc	ra,0x0
    802091e0:	b98080e7          	jalr	-1128(ra) # 80208d74 <paDecreaseRef>
    for (i = 0; i < PTE2PT; i++) {
    802091e4:	f8843783          	ld	a5,-120(s0)
    802091e8:	00878793          	addi	a5,a5,8
    802091ec:	00078713          	mv	a4,a5
    802091f0:	f8f43423          	sd	a5,-120(s0)
    802091f4:	400007b7          	lui	a5,0x40000
    802091f8:	00fd8db3          	add	s11,s11,a5
    802091fc:	00070793          	mv	a5,a4
    80209200:	f8043703          	ld	a4,-128(s0)
    80209204:	02e78263          	beq	a5,a4,80209228 <pgdirFree+0x12c>
        if (!(pgdir[i] & PTE_VALID))
    80209208:	f8843783          	ld	a5,-120(s0)
    8020920c:	0007b783          	ld	a5,0(a5) # 40000000 <_start-0x40200000>
    80209210:	0017f713          	andi	a4,a5,1
    80209214:	fc0708e3          	beqz	a4,802091e4 <pgdirFree+0xe8>
        u64* pa = (u64*) PTE2PA(*pageTable);
    80209218:	00279793          	slli	a5,a5,0x2
    8020921c:	01a7fcb3          	and	s9,a5,s10
    80209220:	00000c13          	li	s8,0
    80209224:	f89ff06f          	j	802091ac <pgdirFree+0xb0>
    }
    paDecreaseRef((u64) pgdir);
    80209228:	000b0513          	mv	a0,s6
    8020922c:	00000097          	auipc	ra,0x0
    80209230:	b48080e7          	jalr	-1208(ra) # 80208d74 <paDecreaseRef>
}
    80209234:	07813083          	ld	ra,120(sp)
    80209238:	07013403          	ld	s0,112(sp)
    8020923c:	06813483          	ld	s1,104(sp)
    80209240:	06013903          	ld	s2,96(sp)
    80209244:	05813983          	ld	s3,88(sp)
    80209248:	05013a03          	ld	s4,80(sp)
    8020924c:	04813a83          	ld	s5,72(sp)
    80209250:	04013b03          	ld	s6,64(sp)
    80209254:	03813b83          	ld	s7,56(sp)
    80209258:	03013c03          	ld	s8,48(sp)
    8020925c:	02813c83          	ld	s9,40(sp)
    80209260:	02013d03          	ld	s10,32(sp)
    80209264:	01813d83          	ld	s11,24(sp)
    80209268:	08010113          	addi	sp,sp,128
    8020926c:	00008067          	ret

0000000080209270 <pageInsert>:

int pageInsert(u64 *pgdir, u64 va, u64 pa, u64 perm) {
    80209270:	fc010113          	addi	sp,sp,-64
    80209274:	02113c23          	sd	ra,56(sp)
    80209278:	02813823          	sd	s0,48(sp)
    8020927c:	02913423          	sd	s1,40(sp)
    80209280:	03213023          	sd	s2,32(sp)
    80209284:	01313c23          	sd	s3,24(sp)
    80209288:	01413823          	sd	s4,16(sp)
    8020928c:	04010413          	addi	s0,sp,64
    80209290:	00060a13          	mv	s4,a2
    80209294:	00068993          	mv	s3,a3
    u64 *pte;
    va = DOWN_ALIGN(va, PAGE_SIZE);
    80209298:	fffff7b7          	lui	a5,0xfffff
    8020929c:	00f5f4b3          	and	s1,a1,a5
    addr += GET_PAGE_TABLE_INDEX(va, 2);
    802092a0:	01e4d913          	srli	s2,s1,0x1e
    802092a4:	1ff97913          	andi	s2,s2,511
    802092a8:	00391913          	slli	s2,s2,0x3
    802092ac:	01250933          	add	s2,a0,s2
    if (!(*addr) & PTE_VALID) {
    802092b0:	00093783          	ld	a5,0(s2)
    802092b4:	06078863          	beqz	a5,80209324 <pageInsert+0xb4>
    addr = (u64*)PTE2PA(*addr);
    802092b8:	00279793          	slli	a5,a5,0x2
    802092bc:	fff00737          	lui	a4,0xfff00
    802092c0:	00875713          	srli	a4,a4,0x8
    802092c4:	00e7f7b3          	and	a5,a5,a4
    addr += GET_PAGE_TABLE_INDEX(va, 1);
    802092c8:	0154d713          	srli	a4,s1,0x15
    802092cc:	1ff77713          	andi	a4,a4,511
    if (!(*addr) & PTE_VALID) {
    802092d0:	00371713          	slli	a4,a4,0x3
    802092d4:	00e787b3          	add	a5,a5,a4
    802092d8:	0007b783          	ld	a5,0(a5) # fffffffffffff000 <bssEnd+0xffffffff7dc8f000>
    802092dc:	0a078263          	beqz	a5,80209380 <pageInsert+0x110>
    addr = (u64*)PTE2PA(*addr);
    802092e0:	00279793          	slli	a5,a5,0x2
    802092e4:	fff00737          	lui	a4,0xfff00
    802092e8:	00875713          	srli	a4,a4,0x8
    802092ec:	00e7f7b3          	and	a5,a5,a4
    *pte = addr + GET_PAGE_TABLE_INDEX(va, 0);
    802092f0:	00c4d713          	srli	a4,s1,0xc
    802092f4:	1ff77713          	andi	a4,a4,511
    802092f8:	00371713          	slli	a4,a4,0x3
    802092fc:	00e787b3          	add	a5,a5,a4
    perm |= PTE_ACCESSED | PTE_DIRTY;
    int ret = pageWalk(pgdir, va, false, &pte);
    if (ret < 0) {
        return ret;
    }
    if (pte != NULL && (*pte & PTE_VALID)) {
    80209300:	1a078063          	beqz	a5,802094a0 <pageInsert+0x230>
    80209304:	0007b783          	ld	a5,0(a5)
    80209308:	0017f793          	andi	a5,a5,1
    8020930c:	06078a63          	beqz	a5,80209380 <pageInsert+0x110>
        pageRemove(pgdir, va);
    80209310:	00048593          	mv	a1,s1
    80209314:	00000097          	auipc	ra,0x0
    80209318:	d54080e7          	jalr	-684(ra) # 80209068 <pageRemove>
    if (!(*addr) & PTE_VALID) {
    8020931c:	00093783          	ld	a5,0(s2)
    80209320:	06079063          	bnez	a5,80209380 <pageInsert+0x110>
        pageAlloc(&pp);
    80209324:	fc840513          	addi	a0,s0,-56
    80209328:	00000097          	auipc	ra,0x0
    8020932c:	b94080e7          	jalr	-1132(ra) # 80208ebc <pageAlloc>
        (*addr) = page2pte(pp) | PTE_VALID;
    80209330:	fc843703          	ld	a4,-56(s0)
    return page - pages;
    80209334:	018fe797          	auipc	a5,0x18fe
    80209338:	bcc78793          	addi	a5,a5,-1076 # 81b06f00 <pages>
    8020933c:	40f707b3          	sub	a5,a4,a5
    80209340:	4037d793          	srai	a5,a5,0x3
    80209344:	0000d697          	auipc	a3,0xd
    80209348:	4b46b683          	ld	a3,1204(a3) # 802167f8 <__func__.0+0x20>
    8020934c:	02d787b3          	mul	a5,a5,a3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209350:	00c7979b          	slliw	a5,a5,0xc
    80209354:	02079793          	slli	a5,a5,0x20
    80209358:	0207d793          	srli	a5,a5,0x20
    8020935c:	00100693          	li	a3,1
    80209360:	01f69693          	slli	a3,a3,0x1f
    80209364:	00d787b3          	add	a5,a5,a3
#define PTE2PERM(pte) (((u64)(pte)) & ~((1ull << 54) - (1ull << 10)))
#define PTE2PA(pte) (((((u64)(pte)) & ((1ull << 54) - (1ull << 10))) >> PERM_WIDTH) << PAGE_SHIFT)
#define PA2PTE(pa) ((((u64)(pa)) >> PAGE_SHIFT) << PERM_WIDTH)

inline u64 page2pte(PhysicalPage *page) {
    return (page2pa(page) >> PAGE_SHIFT) << PERM_WIDTH;
    80209368:	0027d793          	srli	a5,a5,0x2
    8020936c:	0017e793          	ori	a5,a5,1
    80209370:	00f93023          	sd	a5,0(s2)
        pp->ref++;
    80209374:	01072783          	lw	a5,16(a4) # fffffffffff00010 <bssEnd+0xffffffff7db90010>
    80209378:	0017879b          	addiw	a5,a5,1
    8020937c:	00f72823          	sw	a5,16(a4)
    addr = (u64*)PTE2PA(*addr);
    80209380:	00093903          	ld	s2,0(s2)
    80209384:	00291913          	slli	s2,s2,0x2
    80209388:	fff007b7          	lui	a5,0xfff00
    8020938c:	0087d793          	srli	a5,a5,0x8
    80209390:	00f97933          	and	s2,s2,a5
    addr += GET_PAGE_TABLE_INDEX(va, 1);
    80209394:	0154d793          	srli	a5,s1,0x15
    80209398:	1ff7f793          	andi	a5,a5,511
    8020939c:	00379793          	slli	a5,a5,0x3
    802093a0:	00f90933          	add	s2,s2,a5
    if (!(*addr) & PTE_VALID) {
    802093a4:	00093783          	ld	a5,0(s2)
    802093a8:	06079063          	bnez	a5,80209408 <pageInsert+0x198>
        pageAlloc(&pp);
    802093ac:	fc840513          	addi	a0,s0,-56
    802093b0:	00000097          	auipc	ra,0x0
    802093b4:	b0c080e7          	jalr	-1268(ra) # 80208ebc <pageAlloc>
        (*addr) = page2pte(pp) | PTE_VALID;
    802093b8:	fc843703          	ld	a4,-56(s0)
    return page - pages;
    802093bc:	018fe797          	auipc	a5,0x18fe
    802093c0:	b4478793          	addi	a5,a5,-1212 # 81b06f00 <pages>
    802093c4:	40f707b3          	sub	a5,a4,a5
    802093c8:	4037d793          	srai	a5,a5,0x3
    802093cc:	0000d697          	auipc	a3,0xd
    802093d0:	42c6b683          	ld	a3,1068(a3) # 802167f8 <__func__.0+0x20>
    802093d4:	02d787b3          	mul	a5,a5,a3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802093d8:	00c7979b          	slliw	a5,a5,0xc
    802093dc:	02079793          	slli	a5,a5,0x20
    802093e0:	0207d793          	srli	a5,a5,0x20
    802093e4:	00100693          	li	a3,1
    802093e8:	01f69693          	slli	a3,a3,0x1f
    802093ec:	00d787b3          	add	a5,a5,a3
    return (page2pa(page) >> PAGE_SHIFT) << PERM_WIDTH;
    802093f0:	0027d793          	srli	a5,a5,0x2
    802093f4:	0017e793          	ori	a5,a5,1
    802093f8:	00f93023          	sd	a5,0(s2)
        pp->ref++;
    802093fc:	01072783          	lw	a5,16(a4)
    80209400:	0017879b          	addiw	a5,a5,1
    80209404:	00f72823          	sw	a5,16(a4)
    pa = DOWN_ALIGN(pa, PAGE_SIZE);
    80209408:	fffff7b7          	lui	a5,0xfffff
    8020940c:	00fa7633          	and	a2,s4,a5
    addr = (u64*)PTE2PA(*addr);
    80209410:	00093783          	ld	a5,0(s2)
    80209414:	00279793          	slli	a5,a5,0x2
    80209418:	fff00737          	lui	a4,0xfff00
    8020941c:	00875713          	srli	a4,a4,0x8
    80209420:	00e7f7b3          	and	a5,a5,a4
    *pte = addr + GET_PAGE_TABLE_INDEX(va, 0);
    80209424:	00c4d493          	srli	s1,s1,0xc
    80209428:	1ff4f493          	andi	s1,s1,511
    }
    ret = pageWalk(pgdir, va, true, &pte);
    if (ret < 0) {
        return ret;
    }
    *pte = PA2PTE(pa) | perm | PTE_VALID;
    8020942c:	00349493          	slli	s1,s1,0x3
    80209430:	00f484b3          	add	s1,s1,a5
    80209434:	00265793          	srli	a5,a2,0x2
    80209438:	0137e7b3          	or	a5,a5,s3
    8020943c:	0c17e793          	ori	a5,a5,193
    80209440:	00f4b023          	sd	a5,0(s1)
    if (pa >= PHYSICAL_ADDRESS_BASE && pa < PHYSICAL_MEMORY_TOP)
    80209444:	800007b7          	lui	a5,0x80000
    80209448:	00f60633          	add	a2,a2,a5
    8020944c:	100007b7          	lui	a5,0x10000
    80209450:	02f67663          	bgeu	a2,a5,8020947c <pageInsert+0x20c>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    80209454:	00c65793          	srli	a5,a2,0xc
    return pages + ppn;
    80209458:	00b65613          	srli	a2,a2,0xb
    8020945c:	00f60633          	add	a2,a2,a5
    80209460:	00361613          	slli	a2,a2,0x3
    80209464:	018fe797          	auipc	a5,0x18fe
    80209468:	a9c78793          	addi	a5,a5,-1380 # 81b06f00 <pages>
    8020946c:	00f60633          	add	a2,a2,a5
        pa2page(pa)->ref++;
    80209470:	01062783          	lw	a5,16(a2)
    80209474:	0017879b          	addiw	a5,a5,1
    80209478:	00f62823          	sw	a5,16(a2)
    // sfence_vma();
    return 0;
}
    8020947c:	00000513          	li	a0,0
    80209480:	03813083          	ld	ra,56(sp)
    80209484:	03013403          	ld	s0,48(sp)
    80209488:	02813483          	ld	s1,40(sp)
    8020948c:	02013903          	ld	s2,32(sp)
    80209490:	01813983          	ld	s3,24(sp)
    80209494:	01013a03          	ld	s4,16(sp)
    80209498:	04010113          	addi	sp,sp,64
    8020949c:	00008067          	ret
    addr = (u64*)PTE2PA(*addr);
    802094a0:	00093903          	ld	s2,0(s2)
    802094a4:	00291913          	slli	s2,s2,0x2
    802094a8:	fff007b7          	lui	a5,0xfff00
    802094ac:	0087d793          	srli	a5,a5,0x8
    802094b0:	00f97933          	and	s2,s2,a5
    addr += GET_PAGE_TABLE_INDEX(va, 1);
    802094b4:	0154d793          	srli	a5,s1,0x15
    802094b8:	1ff7f793          	andi	a5,a5,511
    802094bc:	00379793          	slli	a5,a5,0x3
    802094c0:	00f90933          	add	s2,s2,a5
    if (!(*addr) & PTE_VALID) {
    802094c4:	f45ff06f          	j	80209408 <pageInsert+0x198>

00000000802094c8 <allocPgdir>:

int allocPgdir(PhysicalPage **page) {
    802094c8:	fe010113          	addi	sp,sp,-32
    802094cc:	00113c23          	sd	ra,24(sp)
    802094d0:	00813823          	sd	s0,16(sp)
    802094d4:	00913423          	sd	s1,8(sp)
    802094d8:	02010413          	addi	s0,sp,32
    802094dc:	00050493          	mv	s1,a0
    int r;
    if ((r = pageAlloc(page)) < 0) {
    802094e0:	00000097          	auipc	ra,0x0
    802094e4:	9dc080e7          	jalr	-1572(ra) # 80208ebc <pageAlloc>
    802094e8:	00054c63          	bltz	a0,80209500 <allocPgdir+0x38>
        return r;
    }
    (*page)->ref++;
    802094ec:	0004b703          	ld	a4,0(s1)
    802094f0:	01072783          	lw	a5,16(a4) # fffffffffff00010 <bssEnd+0xffffffff7db90010>
    802094f4:	0017879b          	addiw	a5,a5,1
    802094f8:	00f72823          	sw	a5,16(a4)
    return 0;
    802094fc:	00000513          	li	a0,0
}
    80209500:	01813083          	ld	ra,24(sp)
    80209504:	01013403          	ld	s0,16(sp)
    80209508:	00813483          	ld	s1,8(sp)
    8020950c:	02010113          	addi	sp,sp,32
    80209510:	00008067          	ret

0000000080209514 <pageout>:

u64 pageout(u64 *pgdir, u64 badAddr) {
    80209514:	f7010113          	addi	sp,sp,-144
    80209518:	08113423          	sd	ra,136(sp)
    8020951c:	08813023          	sd	s0,128(sp)
    80209520:	06913c23          	sd	s1,120(sp)
    80209524:	07213823          	sd	s2,112(sp)
    80209528:	07313423          	sd	s3,104(sp)
    8020952c:	07413023          	sd	s4,96(sp)
    80209530:	05513c23          	sd	s5,88(sp)
    80209534:	05613823          	sd	s6,80(sp)
    80209538:	05713423          	sd	s7,72(sp)
    8020953c:	05813023          	sd	s8,64(sp)
    80209540:	03913c23          	sd	s9,56(sp)
    80209544:	03a13823          	sd	s10,48(sp)
    80209548:	03b13423          	sd	s11,40(sp)
    8020954c:	09010413          	addi	s0,sp,144
    80209550:	f6a43c23          	sd	a0,-136(s0)
    if (badAddr <= PAGE_SIZE) {
    80209554:	000017b7          	lui	a5,0x1
    80209558:	08b7fc63          	bgeu	a5,a1,802095f0 <pageout+0xdc>
    8020955c:	00058993          	mv	s3,a1
        panic("^^^^^^^^^^TOO LOW^^^^^^^^^^^\n");
    }
    PhysicalPage *page = NULL;
    80209560:	f8043423          	sd	zero,-120(s0)
    // printf("[Page out]Process Id: %lx, pageout at %lx, bottom: %lx\n", myProcess()->processId, badAddr, USER_STACK_BOTTOM);
    if (badAddr >= USER_STACK_BOTTOM && badAddr < USER_STACK_TOP) {
    80209564:	fc0407b7          	lui	a5,0xfc040
    80209568:	00378793          	addi	a5,a5,3 # fffffffffc040003 <bssEnd+0xffffffff79cd0003>
    8020956c:	00c79793          	slli	a5,a5,0xc
    80209570:	00f587b3          	add	a5,a1,a5
    80209574:	40000737          	lui	a4,0x40000
    80209578:	0ee7f263          	bgeu	a5,a4,8020965c <pageout+0x148>
        if (pageAlloc(&page) < 0) {
    8020957c:	f8840513          	addi	a0,s0,-120
    80209580:	00000097          	auipc	ra,0x0
    80209584:	93c080e7          	jalr	-1732(ra) # 80208ebc <pageAlloc>
    80209588:	08054663          	bltz	a0,80209614 <pageout+0x100>
    return page - pages;
    8020958c:	f8843483          	ld	s1,-120(s0)
    80209590:	018fe797          	auipc	a5,0x18fe
    80209594:	97078793          	addi	a5,a5,-1680 # 81b06f00 <pages>
    80209598:	40f484b3          	sub	s1,s1,a5
    8020959c:	4034d493          	srai	s1,s1,0x3
    802095a0:	0000d797          	auipc	a5,0xd
    802095a4:	2587b783          	ld	a5,600(a5) # 802167f8 <__func__.0+0x20>
    802095a8:	02f484b3          	mul	s1,s1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802095ac:	00c4949b          	slliw	s1,s1,0xc
    802095b0:	02049493          	slli	s1,s1,0x20
    802095b4:	0204d493          	srli	s1,s1,0x20
    802095b8:	00100793          	li	a5,1
    802095bc:	01f79793          	slli	a5,a5,0x1f
    802095c0:	00f484b3          	add	s1,s1,a5
            panic("");
        }
        if (pageInsert(pgdir, badAddr, page2pa(page), 
    802095c4:	01600693          	li	a3,22
    802095c8:	00048613          	mv	a2,s1
    802095cc:	00098593          	mv	a1,s3
    802095d0:	f7843503          	ld	a0,-136(s0)
    802095d4:	00000097          	auipc	ra,0x0
    802095d8:	c9c080e7          	jalr	-868(ra) # 80209270 <pageInsert>
    802095dc:	04054e63          	bltz	a0,80209638 <pageout+0x124>
            PTE_USER | PTE_READ | PTE_WRITE) < 0) {
            panic("");
        }
        return page2pa(page) + (badAddr & 0xFFF);
    802095e0:	03499513          	slli	a0,s3,0x34
    802095e4:	03455513          	srli	a0,a0,0x34
    802095e8:	00950533          	add	a0,a0,s1
    802095ec:	1d80006f          	j	802097c4 <pageout+0x2b0>
        panic("^^^^^^^^^^TOO LOW^^^^^^^^^^^\n");
    802095f0:	0000c697          	auipc	a3,0xc
    802095f4:	50868693          	addi	a3,a3,1288 # 80215af8 <__func__.0+0x78>
    802095f8:	0000d617          	auipc	a2,0xd
    802095fc:	1c060613          	addi	a2,a2,448 # 802167b8 <__func__.3>
    80209600:	0c300593          	li	a1,195
    80209604:	0000c517          	auipc	a0,0xc
    80209608:	4cc50513          	addi	a0,a0,1228 # 80215ad0 <__func__.0+0x50>
    8020960c:	ffff8097          	auipc	ra,0xffff8
    80209610:	8dc080e7          	jalr	-1828(ra) # 80200ee8 <_panic_>
            panic("");
    80209614:	0000c697          	auipc	a3,0xc
    80209618:	5d468693          	addi	a3,a3,1492 # 80215be8 <__func__.0+0x48>
    8020961c:	0000d617          	auipc	a2,0xd
    80209620:	19c60613          	addi	a2,a2,412 # 802167b8 <__func__.3>
    80209624:	0c900593          	li	a1,201
    80209628:	0000c517          	auipc	a0,0xc
    8020962c:	4a850513          	addi	a0,a0,1192 # 80215ad0 <__func__.0+0x50>
    80209630:	ffff8097          	auipc	ra,0xffff8
    80209634:	8b8080e7          	jalr	-1864(ra) # 80200ee8 <_panic_>
            panic("");
    80209638:	0000c697          	auipc	a3,0xc
    8020963c:	5b068693          	addi	a3,a3,1456 # 80215be8 <__func__.0+0x48>
    80209640:	0000d617          	auipc	a2,0xd
    80209644:	17860613          	addi	a2,a2,376 # 802167b8 <__func__.3>
    80209648:	0cd00593          	li	a1,205
    8020964c:	0000c517          	auipc	a0,0xc
    80209650:	48450513          	addi	a0,a0,1156 # 80215ad0 <__func__.0+0x50>
    80209654:	ffff8097          	auipc	ra,0xffff8
    80209658:	894080e7          	jalr	-1900(ra) # 80200ee8 <_panic_>
    }
    u64 perm = 0;
    Process *p = myProcess();
    8020965c:	00006097          	auipc	ra,0x6
    80209660:	38c080e7          	jalr	908(ra) # 8020f9e8 <myProcess>
    u64 pageStart = DOWN_ALIGN(badAddr, PAGE_SIZE);
    80209664:	fffffab7          	lui	s5,0xfffff
    80209668:	0159fab3          	and	s5,s3,s5
    u64 pageFinish = pageStart + PAGE_SIZE;
    8020966c:	00001b37          	lui	s6,0x1
    80209670:	016a8b33          	add	s6,s5,s6
    for (ProcessSegmentMap *psm = p->segmentMapHead; psm; psm = psm->next) {
    80209674:	000027b7          	lui	a5,0x2
    80209678:	00f50533          	add	a0,a0,a5
    8020967c:	0a853483          	ld	s1,168(a0)
    80209680:	18048063          	beqz	s1,80209800 <pageout+0x2ec>
    u64 perm = 0;
    80209684:	00000b93          	li	s7,0
    return page - pages;
    80209688:	018fed97          	auipc	s11,0x18fe
    8020968c:	878d8d93          	addi	s11,s11,-1928 # 81b06f00 <pages>
    80209690:	0000dd17          	auipc	s10,0xd
    80209694:	168d0d13          	addi	s10,s10,360 # 802167f8 <__func__.0+0x20>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209698:	00100c93          	li	s9,1
    8020969c:	01fc9c93          	slli	s9,s9,0x1f
        if (start < finish) {
            if (page == NULL) {
                pageAlloc(&page);
            }
            if (!(psm->flag & MAP_ZERO)) {
                eread(psm->sourceFile, false, page2pa(page) + PAGE_OFFSET(start, PAGE_SIZE), psm->fileOffset + start - psm->va, finish - start);
    802096a0:	000017b7          	lui	a5,0x1
    802096a4:	fff78c13          	addi	s8,a5,-1 # fff <_start-0x801ff001>
    802096a8:	0300006f          	j	802096d8 <pageout+0x1c4>
                pageAlloc(&page);
    802096ac:	f8840513          	addi	a0,s0,-120
    802096b0:	00000097          	auipc	ra,0x0
    802096b4:	80c080e7          	jalr	-2036(ra) # 80208ebc <pageAlloc>
    802096b8:	04c0006f          	j	80209704 <pageout+0x1f0>
            }
            perm |= (psm->flag & ~MAP_ZERO);
    802096bc:	01c4a783          	lw	a5,28(s1)
    802096c0:	ffe7f793          	andi	a5,a5,-2
    802096c4:	02079793          	slli	a5,a5,0x20
    802096c8:	0207d793          	srli	a5,a5,0x20
    802096cc:	00fbebb3          	or	s7,s7,a5
    for (ProcessSegmentMap *psm = p->segmentMapHead; psm; psm = psm->next) {
    802096d0:	0204b483          	ld	s1,32(s1)
    802096d4:	08048863          	beqz	s1,80209764 <pageout+0x250>
        u64 start = MAX(psm->va, pageStart);
    802096d8:	0084b783          	ld	a5,8(s1)
    802096dc:	000a8a13          	mv	s4,s5
    802096e0:	00faf463          	bgeu	s5,a5,802096e8 <pageout+0x1d4>
    802096e4:	00078a13          	mv	s4,a5
        u64 finish = MIN(psm->va + psm->len, pageFinish);
    802096e8:	0184e903          	lwu	s2,24(s1)
    802096ec:	00f90933          	add	s2,s2,a5
    802096f0:	012b7463          	bgeu	s6,s2,802096f8 <pageout+0x1e4>
    802096f4:	000b0913          	mv	s2,s6
        if (start < finish) {
    802096f8:	fd2a7ce3          	bgeu	s4,s2,802096d0 <pageout+0x1bc>
            if (page == NULL) {
    802096fc:	f8843783          	ld	a5,-120(s0)
    80209700:	fa0786e3          	beqz	a5,802096ac <pageout+0x198>
            if (!(psm->flag & MAP_ZERO)) {
    80209704:	01c4a783          	lw	a5,28(s1)
    80209708:	0017f793          	andi	a5,a5,1
    8020970c:	fa0798e3          	bnez	a5,802096bc <pageout+0x1a8>
                eread(psm->sourceFile, false, page2pa(page) + PAGE_OFFSET(start, PAGE_SIZE), psm->fileOffset + start - psm->va, finish - start);
    80209710:	0084b683          	ld	a3,8(s1)
    80209714:	40da06bb          	subw	a3,s4,a3
    80209718:	0104b583          	ld	a1,16(s1)
    return page - pages;
    8020971c:	f8843783          	ld	a5,-120(s0)
    80209720:	41b787b3          	sub	a5,a5,s11
    80209724:	4037d793          	srai	a5,a5,0x3
    80209728:	000d3703          	ld	a4,0(s10)
    8020972c:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209730:	00c7979b          	slliw	a5,a5,0xc
    80209734:	02079793          	slli	a5,a5,0x20
    80209738:	0207d793          	srli	a5,a5,0x20
    8020973c:	019787b3          	add	a5,a5,s9
    80209740:	018a7633          	and	a2,s4,s8
    80209744:	4149073b          	subw	a4,s2,s4
    80209748:	00b686bb          	addw	a3,a3,a1
    8020974c:	00c78633          	add	a2,a5,a2
    80209750:	00000593          	li	a1,0
    80209754:	0004b503          	ld	a0,0(s1)
    80209758:	ffff9097          	auipc	ra,0xffff9
    8020975c:	644080e7          	jalr	1604(ra) # 80202d9c <eread>
    80209760:	f5dff06f          	j	802096bc <pageout+0x1a8>
        }
    }
    if (page == NULL) {
    80209764:	f8843783          	ld	a5,-120(s0)
    80209768:	08078c63          	beqz	a5,80209800 <pageout+0x2ec>
    return page - pages;
    8020976c:	018fd717          	auipc	a4,0x18fd
    80209770:	79470713          	addi	a4,a4,1940 # 81b06f00 <pages>
    80209774:	40e784b3          	sub	s1,a5,a4
    80209778:	4034d493          	srai	s1,s1,0x3
    8020977c:	0000d797          	auipc	a5,0xd
    80209780:	07c7b783          	ld	a5,124(a5) # 802167f8 <__func__.0+0x20>
    80209784:	02f484b3          	mul	s1,s1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209788:	00c4949b          	slliw	s1,s1,0xc
    8020978c:	02049493          	slli	s1,s1,0x20
    80209790:	0204d493          	srli	s1,s1,0x20
    80209794:	00100793          	li	a5,1
    80209798:	01f79793          	slli	a5,a5,0x1f
    8020979c:	00f484b3          	add	s1,s1,a5
        panic("");
    }
    pageInsert(pgdir, badAddr, page2pa(page), PTE_USER | perm);
    802097a0:	010be693          	ori	a3,s7,16
    802097a4:	00048613          	mv	a2,s1
    802097a8:	00098593          	mv	a1,s3
    802097ac:	f7843503          	ld	a0,-136(s0)
    802097b0:	00000097          	auipc	ra,0x0
    802097b4:	ac0080e7          	jalr	-1344(ra) # 80209270 <pageInsert>
    return page2pa(page) + (badAddr & 0xFFF);
    802097b8:	03499513          	slli	a0,s3,0x34
    802097bc:	03455513          	srli	a0,a0,0x34
    802097c0:	00950533          	add	a0,a0,s1
}
    802097c4:	08813083          	ld	ra,136(sp)
    802097c8:	08013403          	ld	s0,128(sp)
    802097cc:	07813483          	ld	s1,120(sp)
    802097d0:	07013903          	ld	s2,112(sp)
    802097d4:	06813983          	ld	s3,104(sp)
    802097d8:	06013a03          	ld	s4,96(sp)
    802097dc:	05813a83          	ld	s5,88(sp)
    802097e0:	05013b03          	ld	s6,80(sp)
    802097e4:	04813b83          	ld	s7,72(sp)
    802097e8:	04013c03          	ld	s8,64(sp)
    802097ec:	03813c83          	ld	s9,56(sp)
    802097f0:	03013d03          	ld	s10,48(sp)
    802097f4:	02813d83          	ld	s11,40(sp)
    802097f8:	09010113          	addi	sp,sp,144
    802097fc:	00008067          	ret
        panic("");
    80209800:	0000c697          	auipc	a3,0xc
    80209804:	3e868693          	addi	a3,a3,1000 # 80215be8 <__func__.0+0x48>
    80209808:	0000d617          	auipc	a2,0xd
    8020980c:	fb060613          	addi	a2,a2,-80 # 802167b8 <__func__.3>
    80209810:	0e300593          	li	a1,227
    80209814:	0000c517          	auipc	a0,0xc
    80209818:	2bc50513          	addi	a0,a0,700 # 80215ad0 <__func__.0+0x50>
    8020981c:	ffff7097          	auipc	ra,0xffff7
    80209820:	6cc080e7          	jalr	1740(ra) # 80200ee8 <_panic_>

0000000080209824 <cowHandler>:

// u8 cowBuffer[PAGE_SIZE];
u64 cowHandler(u64 *pgdir, u64 badAddr) {
    80209824:	fc010113          	addi	sp,sp,-64
    80209828:	02113c23          	sd	ra,56(sp)
    8020982c:	02813823          	sd	s0,48(sp)
    80209830:	02913423          	sd	s1,40(sp)
    80209834:	03213023          	sd	s2,32(sp)
    80209838:	01313c23          	sd	s3,24(sp)
    8020983c:	04010413          	addi	s0,sp,64
    80209840:	00050993          	mv	s3,a0
    80209844:	00058913          	mv	s2,a1
    u64 pa;
    u64 *pte = NULL;
    80209848:	fc043423          	sd	zero,-56(s0)
    pa = pageLookup(pgdir, badAddr, &pte);
    8020984c:	fc840613          	addi	a2,s0,-56
    80209850:	fffff097          	auipc	ra,0xfffff
    80209854:	728080e7          	jalr	1832(ra) # 80208f78 <pageLookup>
    // printf("[COW] %x to cow %lx %lx\n", myProcess()->processId, badAddr, pa);
    if (!(*pte & PTE_COW)) {
    80209858:	fc843783          	ld	a5,-56(s0)
    8020985c:	0007b783          	ld	a5,0(a5)
    80209860:	1007f793          	andi	a5,a5,256
    80209864:	0c078463          	beqz	a5,8020992c <cowHandler+0x108>
        panic("access denied\n");
        return 0;
    }
    PhysicalPage *page;
    int r = pageAlloc(&page);
    80209868:	fc040513          	addi	a0,s0,-64
    8020986c:	fffff097          	auipc	ra,0xfffff
    80209870:	650080e7          	jalr	1616(ra) # 80208ebc <pageAlloc>
    if (r < 0) {
    80209874:	0c054e63          	bltz	a0,80209950 <cowHandler+0x12c>
        panic("cow handler error");
        return 0;
    }
    // acquireLock(&cowBufferLock);
    pa = pageLookup(pgdir, badAddr, &pte);
    80209878:	fc840613          	addi	a2,s0,-56
    8020987c:	00090593          	mv	a1,s2
    80209880:	00098513          	mv	a0,s3
    80209884:	fffff097          	auipc	ra,0xfffff
    80209888:	6f4080e7          	jalr	1780(ra) # 80208f78 <pageLookup>
    return page - pages;
    8020988c:	fc043483          	ld	s1,-64(s0)
    80209890:	018fd797          	auipc	a5,0x18fd
    80209894:	67078793          	addi	a5,a5,1648 # 81b06f00 <pages>
    80209898:	40f484b3          	sub	s1,s1,a5
    8020989c:	4034d493          	srai	s1,s1,0x3
    802098a0:	0000d797          	auipc	a5,0xd
    802098a4:	f587b783          	ld	a5,-168(a5) # 802167f8 <__func__.0+0x20>
    802098a8:	02f484b3          	mul	s1,s1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802098ac:	00c4949b          	slliw	s1,s1,0xc
    802098b0:	02049493          	slli	s1,s1,0x20
    802098b4:	0204d493          	srli	s1,s1,0x20
    802098b8:	00100793          	li	a5,1
    802098bc:	01f79793          	slli	a5,a5,0x1f
    802098c0:	00f484b3          	add	s1,s1,a5
    bcopy((void *)pa, (void*)page2pa(page), PAGE_SIZE);
    802098c4:	00001637          	lui	a2,0x1
    802098c8:	00048593          	mv	a1,s1
    802098cc:	fffff097          	auipc	ra,0xfffff
    802098d0:	3d4080e7          	jalr	980(ra) # 80208ca0 <bcopy>
    pageInsert(pgdir, badAddr, page2pa(page), (PTE2PERM(*pte) | PTE_WRITE) & ~PTE_COW);
    802098d4:	fc843783          	ld	a5,-56(s0)
    802098d8:	0007b683          	ld	a3,0(a5)
    802098dc:	fff00793          	li	a5,-1
    802098e0:	03679793          	slli	a5,a5,0x36
    802098e4:	2fb78793          	addi	a5,a5,763
    802098e8:	00f6f6b3          	and	a3,a3,a5
    802098ec:	0046e693          	ori	a3,a3,4
    802098f0:	00048613          	mv	a2,s1
    802098f4:	00090593          	mv	a1,s2
    802098f8:	00098513          	mv	a0,s3
    802098fc:	00000097          	auipc	ra,0x0
    80209900:	974080e7          	jalr	-1676(ra) # 80209270 <pageInsert>
    return page2pa(page) + (badAddr & 0xFFF); 
    80209904:	03491513          	slli	a0,s2,0x34
    80209908:	03455513          	srli	a0,a0,0x34
    // bcopy((void*) cowBuffer, (void*) page2pa(page), PAGE_SIZE);
    // releaseLock(&cowBufferLock);
}
    8020990c:	00950533          	add	a0,a0,s1
    80209910:	03813083          	ld	ra,56(sp)
    80209914:	03013403          	ld	s0,48(sp)
    80209918:	02813483          	ld	s1,40(sp)
    8020991c:	02013903          	ld	s2,32(sp)
    80209920:	01813983          	ld	s3,24(sp)
    80209924:	04010113          	addi	sp,sp,64
    80209928:	00008067          	ret
        panic("access denied\n");
    8020992c:	0000c697          	auipc	a3,0xc
    80209930:	1ec68693          	addi	a3,a3,492 # 80215b18 <__func__.0+0x98>
    80209934:	0000c617          	auipc	a2,0xc
    80209938:	22c60613          	addi	a2,a2,556 # 80215b60 <__func__.2>
    8020993c:	0f000593          	li	a1,240
    80209940:	0000c517          	auipc	a0,0xc
    80209944:	19050513          	addi	a0,a0,400 # 80215ad0 <__func__.0+0x50>
    80209948:	ffff7097          	auipc	ra,0xffff7
    8020994c:	5a0080e7          	jalr	1440(ra) # 80200ee8 <_panic_>
        panic("cow handler error");
    80209950:	0000c697          	auipc	a3,0xc
    80209954:	1d868693          	addi	a3,a3,472 # 80215b28 <__func__.0+0xa8>
    80209958:	0000c617          	auipc	a2,0xc
    8020995c:	20860613          	addi	a2,a2,520 # 80215b60 <__func__.2>
    80209960:	0f600593          	li	a1,246
    80209964:	0000c517          	auipc	a0,0xc
    80209968:	16c50513          	addi	a0,a0,364 # 80215ad0 <__func__.0+0x50>
    8020996c:	ffff7097          	auipc	ra,0xffff7
    80209970:	57c080e7          	jalr	1404(ra) # 80200ee8 <_panic_>

0000000080209974 <vir2phy>:

// Look up a virtual address, return the physical address,
// or 0 if not mapped.
// Can only be used to look up user pages.
u64 vir2phy(u64* pagetable, u64 va, int* cow) {
    80209974:	ff010113          	addi	sp,sp,-16
    80209978:	00813423          	sd	s0,8(sp)
    8020997c:	01010413          	addi	s0,sp,16
    u64* pte;
    u64 pa;

    if (va >= MAXVA)
    80209980:	fff00793          	li	a5,-1
    80209984:	01a7d793          	srli	a5,a5,0x1a
    80209988:	00b7fa63          	bgeu	a5,a1,8020999c <vir2phy+0x28>
        return NULL;
    8020998c:	00000513          	li	a0,0
        return NULL;
    if (cow)
        *cow = (*pte & PTE_COW) > 0;
    pa = PTE2PA(*pte) + (va&0xfff);
    return pa;
}
    80209990:	00813403          	ld	s0,8(sp)
    80209994:	01010113          	addi	sp,sp,16
    80209998:	00008067          	ret
    addr += GET_PAGE_TABLE_INDEX(va, 2);
    8020999c:	01e5d793          	srli	a5,a1,0x1e
    if (!(*addr) & PTE_VALID) {
    802099a0:	00379793          	slli	a5,a5,0x3
    802099a4:	00f50533          	add	a0,a0,a5
    802099a8:	00053783          	ld	a5,0(a0)
            *pte = NULL;
    802099ac:	00000713          	li	a4,0
    if (!(*addr) & PTE_VALID) {
    802099b0:	04078863          	beqz	a5,80209a00 <vir2phy+0x8c>
    addr = (u64*)PTE2PA(*addr);
    802099b4:	00279793          	slli	a5,a5,0x2
    802099b8:	fff00737          	lui	a4,0xfff00
    802099bc:	00875713          	srli	a4,a4,0x8
    802099c0:	00e7f7b3          	and	a5,a5,a4
    addr += GET_PAGE_TABLE_INDEX(va, 1);
    802099c4:	0155d713          	srli	a4,a1,0x15
    802099c8:	1ff77713          	andi	a4,a4,511
    if (!(*addr) & PTE_VALID) {
    802099cc:	00371713          	slli	a4,a4,0x3
    802099d0:	00e787b3          	add	a5,a5,a4
    802099d4:	0007b783          	ld	a5,0(a5)
            *pte = NULL;
    802099d8:	00000713          	li	a4,0
    if (!(*addr) & PTE_VALID) {
    802099dc:	02078263          	beqz	a5,80209a00 <vir2phy+0x8c>
    addr = (u64*)PTE2PA(*addr);
    802099e0:	00279793          	slli	a5,a5,0x2
    802099e4:	fff00737          	lui	a4,0xfff00
    802099e8:	00875713          	srli	a4,a4,0x8
    802099ec:	00e7f7b3          	and	a5,a5,a4
    *pte = addr + GET_PAGE_TABLE_INDEX(va, 0);
    802099f0:	00c5d713          	srli	a4,a1,0xc
    802099f4:	1ff77713          	andi	a4,a4,511
    802099f8:	00371713          	slli	a4,a4,0x3
    802099fc:	00e78733          	add	a4,a5,a4
    if ((*pte & PTE_VALID) == 0)
    80209a00:	00073783          	ld	a5,0(a4) # fffffffffff00000 <bssEnd+0xffffffff7db90000>
    if ((*pte & PTE_USER) == 0)
    80209a04:	0117f813          	andi	a6,a5,17
    80209a08:	01100693          	li	a3,17
        return NULL;
    80209a0c:	00000513          	li	a0,0
    if ((*pte & PTE_USER) == 0)
    80209a10:	f8d810e3          	bne	a6,a3,80209990 <vir2phy+0x1c>
    if (cow)
    80209a14:	00060863          	beqz	a2,80209a24 <vir2phy+0xb0>
        *cow = (*pte & PTE_COW) > 0;
    80209a18:	0087d793          	srli	a5,a5,0x8
    80209a1c:	0017f793          	andi	a5,a5,1
    80209a20:	00f62023          	sw	a5,0(a2)
    pa = PTE2PA(*pte) + (va&0xfff);
    80209a24:	00073503          	ld	a0,0(a4)
    80209a28:	00251513          	slli	a0,a0,0x2
    80209a2c:	fff007b7          	lui	a5,0xfff00
    80209a30:	0087d793          	srli	a5,a5,0x8
    80209a34:	00f57533          	and	a0,a0,a5
    80209a38:	03459593          	slli	a1,a1,0x34
    80209a3c:	0345d593          	srli	a1,a1,0x34
    80209a40:	00b56533          	or	a0,a0,a1
    return pa;
    80209a44:	f4dff06f          	j	80209990 <vir2phy+0x1c>

0000000080209a48 <copyin>:
// Return 0 on success, -1 on error.
int copyin(u64* pagetable, char* dst, u64 srcva, u64 len) {
    u64 n, va0, pa0;
    int cow;

    while (len > 0) {
    80209a48:	0e068463          	beqz	a3,80209b30 <copyin+0xe8>
int copyin(u64* pagetable, char* dst, u64 srcva, u64 len) {
    80209a4c:	fa010113          	addi	sp,sp,-96
    80209a50:	04113c23          	sd	ra,88(sp)
    80209a54:	04813823          	sd	s0,80(sp)
    80209a58:	04913423          	sd	s1,72(sp)
    80209a5c:	05213023          	sd	s2,64(sp)
    80209a60:	03313c23          	sd	s3,56(sp)
    80209a64:	03413823          	sd	s4,48(sp)
    80209a68:	03513423          	sd	s5,40(sp)
    80209a6c:	03613023          	sd	s6,32(sp)
    80209a70:	01713c23          	sd	s7,24(sp)
    80209a74:	06010413          	addi	s0,sp,96
    80209a78:	00050b13          	mv	s6,a0
    80209a7c:	00058993          	mv	s3,a1
    80209a80:	00060493          	mv	s1,a2
    80209a84:	00068913          	mv	s2,a3
        va0 = DOWN_ALIGN(srcva, PGSIZE);
    80209a88:	fffffbb7          	lui	s7,0xfffff
        pa0 = vir2phy(pagetable, srcva, &cow);
        if (pa0 == NULL) {
            pa0 = pageout(pagetable, srcva);
        }
        n = PGSIZE - (srcva - va0);
    80209a8c:	00001ab7          	lui	s5,0x1
    80209a90:	03c0006f          	j	80209acc <copyin+0x84>
            pa0 = pageout(pagetable, srcva);
    80209a94:	00048593          	mv	a1,s1
    80209a98:	000b0513          	mv	a0,s6
    80209a9c:	00000097          	auipc	ra,0x0
    80209aa0:	a78080e7          	jalr	-1416(ra) # 80209514 <pageout>
    80209aa4:	00050593          	mv	a1,a0
    80209aa8:	0440006f          	j	80209aec <copyin+0xa4>
        if (n > len)
            n = len;
        memmove(dst, (void*)pa0, n);
    80209aac:	0004861b          	sext.w	a2,s1
    80209ab0:	00098513          	mv	a0,s3
    80209ab4:	00005097          	auipc	ra,0x5
    80209ab8:	34c080e7          	jalr	844(ra) # 8020ee00 <memmove>

        len -= n;
    80209abc:	40990933          	sub	s2,s2,s1
        dst += n;
    80209ac0:	009989b3          	add	s3,s3,s1
        srcva = va0 + PGSIZE;
    80209ac4:	015a04b3          	add	s1,s4,s5
    while (len > 0) {
    80209ac8:	02090c63          	beqz	s2,80209b00 <copyin+0xb8>
        va0 = DOWN_ALIGN(srcva, PGSIZE);
    80209acc:	0174fa33          	and	s4,s1,s7
        pa0 = vir2phy(pagetable, srcva, &cow);
    80209ad0:	fac40613          	addi	a2,s0,-84
    80209ad4:	00048593          	mv	a1,s1
    80209ad8:	000b0513          	mv	a0,s6
    80209adc:	00000097          	auipc	ra,0x0
    80209ae0:	e98080e7          	jalr	-360(ra) # 80209974 <vir2phy>
    80209ae4:	00050593          	mv	a1,a0
        if (pa0 == NULL) {
    80209ae8:	fa0506e3          	beqz	a0,80209a94 <copyin+0x4c>
        n = PGSIZE - (srcva - va0);
    80209aec:	409a04b3          	sub	s1,s4,s1
    80209af0:	015484b3          	add	s1,s1,s5
    80209af4:	fa997ce3          	bgeu	s2,s1,80209aac <copyin+0x64>
    80209af8:	00090493          	mv	s1,s2
    80209afc:	fb1ff06f          	j	80209aac <copyin+0x64>
    }
    return 0;
}
    80209b00:	00000513          	li	a0,0
    80209b04:	05813083          	ld	ra,88(sp)
    80209b08:	05013403          	ld	s0,80(sp)
    80209b0c:	04813483          	ld	s1,72(sp)
    80209b10:	04013903          	ld	s2,64(sp)
    80209b14:	03813983          	ld	s3,56(sp)
    80209b18:	03013a03          	ld	s4,48(sp)
    80209b1c:	02813a83          	ld	s5,40(sp)
    80209b20:	02013b03          	ld	s6,32(sp)
    80209b24:	01813b83          	ld	s7,24(sp)
    80209b28:	06010113          	addi	sp,sp,96
    80209b2c:	00008067          	ret
    80209b30:	00000513          	li	a0,0
    80209b34:	00008067          	ret

0000000080209b38 <copyout>:
// Return 0 on success, -1 on error.
int copyout(u64* pagetable, u64 dstva, char* src, u64 len) {
    u64 n, va0, pa0;
    int cow;

    while (len > 0) {
    80209b38:	10068063          	beqz	a3,80209c38 <copyout+0x100>
int copyout(u64* pagetable, u64 dstva, char* src, u64 len) {
    80209b3c:	fa010113          	addi	sp,sp,-96
    80209b40:	04113c23          	sd	ra,88(sp)
    80209b44:	04813823          	sd	s0,80(sp)
    80209b48:	04913423          	sd	s1,72(sp)
    80209b4c:	05213023          	sd	s2,64(sp)
    80209b50:	03313c23          	sd	s3,56(sp)
    80209b54:	03413823          	sd	s4,48(sp)
    80209b58:	03513423          	sd	s5,40(sp)
    80209b5c:	03613023          	sd	s6,32(sp)
    80209b60:	01713c23          	sd	s7,24(sp)
    80209b64:	06010413          	addi	s0,sp,96
    80209b68:	00050b13          	mv	s6,a0
    80209b6c:	00058493          	mv	s1,a1
    80209b70:	00060993          	mv	s3,a2
    80209b74:	00068913          	mv	s2,a3
        va0 = DOWN_ALIGN(dstva, PGSIZE);
    80209b78:	fffffbb7          	lui	s7,0xfffff
        }
        if (cow) {
            pa0 = cowHandler(pagetable, dstva);
            // pa0 = vir2phy(pagetable, dstva, NULL);
        }
        n = PGSIZE - (dstva - va0);
    80209b7c:	00001ab7          	lui	s5,0x1
    80209b80:	0500006f          	j	80209bd0 <copyout+0x98>
            cow = 0;
    80209b84:	fa042623          	sw	zero,-84(s0)
            pa0 = pageout(pagetable, dstva);
    80209b88:	00048593          	mv	a1,s1
    80209b8c:	000b0513          	mv	a0,s6
    80209b90:	00000097          	auipc	ra,0x0
    80209b94:	984080e7          	jalr	-1660(ra) # 80209514 <pageout>
    80209b98:	0540006f          	j	80209bec <copyout+0xb4>
            pa0 = cowHandler(pagetable, dstva);
    80209b9c:	00048593          	mv	a1,s1
    80209ba0:	000b0513          	mv	a0,s6
    80209ba4:	00000097          	auipc	ra,0x0
    80209ba8:	c80080e7          	jalr	-896(ra) # 80209824 <cowHandler>
    80209bac:	0480006f          	j	80209bf4 <copyout+0xbc>
        if (n > len)
            n = len;
        memmove((void*)pa0, src, n);
    80209bb0:	0004861b          	sext.w	a2,s1
    80209bb4:	00098593          	mv	a1,s3
    80209bb8:	00005097          	auipc	ra,0x5
    80209bbc:	248080e7          	jalr	584(ra) # 8020ee00 <memmove>
        len -= n;
    80209bc0:	40990933          	sub	s2,s2,s1
        src += n;
    80209bc4:	009989b3          	add	s3,s3,s1
        dstva = va0 + PGSIZE;
    80209bc8:	015a04b3          	add	s1,s4,s5
    while (len > 0) {
    80209bcc:	02090e63          	beqz	s2,80209c08 <copyout+0xd0>
        va0 = DOWN_ALIGN(dstva, PGSIZE);
    80209bd0:	0174fa33          	and	s4,s1,s7
        pa0 = vir2phy(pagetable, dstva, &cow);
    80209bd4:	fac40613          	addi	a2,s0,-84
    80209bd8:	00048593          	mv	a1,s1
    80209bdc:	000b0513          	mv	a0,s6
    80209be0:	00000097          	auipc	ra,0x0
    80209be4:	d94080e7          	jalr	-620(ra) # 80209974 <vir2phy>
        if (pa0 == NULL) {
    80209be8:	f8050ee3          	beqz	a0,80209b84 <copyout+0x4c>
        if (cow) {
    80209bec:	fac42783          	lw	a5,-84(s0)
    80209bf0:	fa0796e3          	bnez	a5,80209b9c <copyout+0x64>
        n = PGSIZE - (dstva - va0);
    80209bf4:	409a04b3          	sub	s1,s4,s1
    80209bf8:	015484b3          	add	s1,s1,s5
    80209bfc:	fa997ae3          	bgeu	s2,s1,80209bb0 <copyout+0x78>
    80209c00:	00090493          	mv	s1,s2
    80209c04:	fadff06f          	j	80209bb0 <copyout+0x78>
    }
    return 0;
}
    80209c08:	00000513          	li	a0,0
    80209c0c:	05813083          	ld	ra,88(sp)
    80209c10:	05013403          	ld	s0,80(sp)
    80209c14:	04813483          	ld	s1,72(sp)
    80209c18:	04013903          	ld	s2,64(sp)
    80209c1c:	03813983          	ld	s3,56(sp)
    80209c20:	03013a03          	ld	s4,48(sp)
    80209c24:	02813a83          	ld	s5,40(sp)
    80209c28:	02013b03          	ld	s6,32(sp)
    80209c2c:	01813b83          	ld	s7,24(sp)
    80209c30:	06010113          	addi	sp,sp,96
    80209c34:	00008067          	ret
    80209c38:	00000513          	li	a0,0
    80209c3c:	00008067          	ret

0000000080209c40 <memsetOut>:

int memsetOut(u64 *pgdir, u64 dst, u8 value, u64 len) {
    u64 n, va0, pa0;
    int cow;

    while (len > 0) {
    80209c40:	0e068e63          	beqz	a3,80209d3c <memsetOut+0xfc>
int memsetOut(u64 *pgdir, u64 dst, u8 value, u64 len) {
    80209c44:	fa010113          	addi	sp,sp,-96
    80209c48:	04113c23          	sd	ra,88(sp)
    80209c4c:	04813823          	sd	s0,80(sp)
    80209c50:	04913423          	sd	s1,72(sp)
    80209c54:	05213023          	sd	s2,64(sp)
    80209c58:	03313c23          	sd	s3,56(sp)
    80209c5c:	03413823          	sd	s4,48(sp)
    80209c60:	03513423          	sd	s5,40(sp)
    80209c64:	03613023          	sd	s6,32(sp)
    80209c68:	01713c23          	sd	s7,24(sp)
    80209c6c:	06010413          	addi	s0,sp,96
    80209c70:	00050a93          	mv	s5,a0
    80209c74:	00058493          	mv	s1,a1
    80209c78:	00068913          	mv	s2,a3
        va0 = DOWN_ALIGN(dst, PGSIZE);
    80209c7c:	fffffbb7          	lui	s7,0xfffff
        }
        if (cow) {
            pa0 = cowHandler(pgdir, dst);
            // pa0 = vir2phy(pgdir, dst, NULL);
        }
        n = PGSIZE - (dst - va0);
    80209c80:	00001a37          	lui	s4,0x1
        if (n > len)
            n = len;
        memset((void*)pa0, value, n);
    80209c84:	00060b1b          	sext.w	s6,a2
    80209c88:	04c0006f          	j	80209cd4 <memsetOut+0x94>
            cow = 0;
    80209c8c:	fa042623          	sw	zero,-84(s0)
            pa0 = pageout(pgdir, dst);
    80209c90:	00048593          	mv	a1,s1
    80209c94:	000a8513          	mv	a0,s5
    80209c98:	00000097          	auipc	ra,0x0
    80209c9c:	87c080e7          	jalr	-1924(ra) # 80209514 <pageout>
    80209ca0:	0500006f          	j	80209cf0 <memsetOut+0xb0>
            pa0 = cowHandler(pgdir, dst);
    80209ca4:	00048593          	mv	a1,s1
    80209ca8:	000a8513          	mv	a0,s5
    80209cac:	00000097          	auipc	ra,0x0
    80209cb0:	b78080e7          	jalr	-1160(ra) # 80209824 <cowHandler>
    80209cb4:	0440006f          	j	80209cf8 <memsetOut+0xb8>
        memset((void*)pa0, value, n);
    80209cb8:	0004861b          	sext.w	a2,s1
    80209cbc:	000b0593          	mv	a1,s6
    80209cc0:	00005097          	auipc	ra,0x5
    80209cc4:	0ac080e7          	jalr	172(ra) # 8020ed6c <memset>
        len -= n;
    80209cc8:	40990933          	sub	s2,s2,s1
        dst = va0 + PGSIZE;
    80209ccc:	014984b3          	add	s1,s3,s4
    while (len > 0) {
    80209cd0:	02090e63          	beqz	s2,80209d0c <memsetOut+0xcc>
        va0 = DOWN_ALIGN(dst, PGSIZE);
    80209cd4:	0174f9b3          	and	s3,s1,s7
        pa0 = vir2phy(pgdir, dst, &cow);
    80209cd8:	fac40613          	addi	a2,s0,-84
    80209cdc:	00048593          	mv	a1,s1
    80209ce0:	000a8513          	mv	a0,s5
    80209ce4:	00000097          	auipc	ra,0x0
    80209ce8:	c90080e7          	jalr	-880(ra) # 80209974 <vir2phy>
        if (pa0 == NULL) {
    80209cec:	fa0500e3          	beqz	a0,80209c8c <memsetOut+0x4c>
        if (cow) {
    80209cf0:	fac42783          	lw	a5,-84(s0)
    80209cf4:	fa0798e3          	bnez	a5,80209ca4 <memsetOut+0x64>
        n = PGSIZE - (dst - va0);
    80209cf8:	409984b3          	sub	s1,s3,s1
    80209cfc:	014484b3          	add	s1,s1,s4
    80209d00:	fa997ce3          	bgeu	s2,s1,80209cb8 <memsetOut+0x78>
    80209d04:	00090493          	mv	s1,s2
    80209d08:	fb1ff06f          	j	80209cb8 <memsetOut+0x78>
    }
    return 0;
}
    80209d0c:	00000513          	li	a0,0
    80209d10:	05813083          	ld	ra,88(sp)
    80209d14:	05013403          	ld	s0,80(sp)
    80209d18:	04813483          	ld	s1,72(sp)
    80209d1c:	04013903          	ld	s2,64(sp)
    80209d20:	03813983          	ld	s3,56(sp)
    80209d24:	03013a03          	ld	s4,48(sp)
    80209d28:	02813a83          	ld	s5,40(sp)
    80209d2c:	02013b03          	ld	s6,32(sp)
    80209d30:	01813b83          	ld	s7,24(sp)
    80209d34:	06010113          	addi	sp,sp,96
    80209d38:	00008067          	ret
    80209d3c:	00000513          	li	a0,0
    80209d40:	00008067          	ret

0000000080209d44 <growproc>:

int growproc(int n) {
    80209d44:	fb010113          	addi	sp,sp,-80
    80209d48:	04113423          	sd	ra,72(sp)
    80209d4c:	04813023          	sd	s0,64(sp)
    80209d50:	02913c23          	sd	s1,56(sp)
    80209d54:	03213823          	sd	s2,48(sp)
    80209d58:	03313423          	sd	s3,40(sp)
    80209d5c:	03413023          	sd	s4,32(sp)
    80209d60:	01513c23          	sd	s5,24(sp)
    80209d64:	01613823          	sd	s6,16(sp)
    80209d68:	05010413          	addi	s0,sp,80
    80209d6c:	00050913          	mv	s2,a0
    if (myProcess()->heapBottom + n >= USER_HEAP_TOP)
    80209d70:	00006097          	auipc	ra,0x6
    80209d74:	c78080e7          	jalr	-904(ra) # 8020f9e8 <myProcess>
    80209d78:	000027b7          	lui	a5,0x2
    80209d7c:	00f50533          	add	a0,a0,a5
    80209d80:	07853783          	ld	a5,120(a0)
    80209d84:	00f907b3          	add	a5,s2,a5
    80209d88:	0000d717          	auipc	a4,0xd
    80209d8c:	a6873703          	ld	a4,-1432(a4) # 802167f0 <__func__.0+0x18>
    80209d90:	18f76663          	bltu	a4,a5,80209f1c <growproc+0x1d8>
        return -1;
    u64 start = UP_ALIGN(myProcess()->heapBottom, PAGE_SIZE);
    80209d94:	00006097          	auipc	ra,0x6
    80209d98:	c54080e7          	jalr	-940(ra) # 8020f9e8 <myProcess>
    80209d9c:	00002ab7          	lui	s5,0x2
    80209da0:	01550533          	add	a0,a0,s5
    80209da4:	07853483          	ld	s1,120(a0)
    80209da8:	fff48493          	addi	s1,s1,-1
    80209dac:	fffffa37          	lui	s4,0xfffff
    80209db0:	0144f4b3          	and	s1,s1,s4
    80209db4:	000019b7          	lui	s3,0x1
    80209db8:	013484b3          	add	s1,s1,s3
    u64 end = UP_ALIGN(myProcess()->heapBottom + n, PAGE_SIZE);
    80209dbc:	00006097          	auipc	ra,0x6
    80209dc0:	c2c080e7          	jalr	-980(ra) # 8020f9e8 <myProcess>
    80209dc4:	01550533          	add	a0,a0,s5
    80209dc8:	fff90913          	addi	s2,s2,-1
    80209dcc:	07853783          	ld	a5,120(a0)
    80209dd0:	00f90933          	add	s2,s2,a5
    80209dd4:	01497933          	and	s2,s2,s4
    80209dd8:	01390933          	add	s2,s2,s3
    assert(end < USER_STACK_BOTTOM);
    80209ddc:	0000d697          	auipc	a3,0xd
    80209de0:	a146b683          	ld	a3,-1516(a3) # 802167f0 <__func__.0+0x18>
    80209de4:	0126b6b3          	sltu	a3,a3,s2
    80209de8:	0016c693          	xori	a3,a3,1
    80209dec:	0016f693          	andi	a3,a3,1
    80209df0:	0000c617          	auipc	a2,0xc
    80209df4:	d8060613          	addi	a2,a2,-640 # 80215b70 <__func__.0>
    80209df8:	16e00593          	li	a1,366
    80209dfc:	0000c517          	auipc	a0,0xc
    80209e00:	cd450513          	addi	a0,a0,-812 # 80215ad0 <__func__.0+0x50>
    80209e04:	ffff7097          	auipc	ra,0xffff7
    80209e08:	154080e7          	jalr	340(ra) # 80200f58 <_assert_>
    while (start < end) {
    80209e0c:	0d24f863          	bgeu	s1,s2,80209edc <growproc+0x198>
    return page - pages;
    80209e10:	018fdb17          	auipc	s6,0x18fd
    80209e14:	0f0b0b13          	addi	s6,s6,240 # 81b06f00 <pages>
    80209e18:	0000da97          	auipc	s5,0xd
    80209e1c:	9e0a8a93          	addi	s5,s5,-1568 # 802167f8 <__func__.0+0x20>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209e20:	00100993          	li	s3,1
    80209e24:	01f99993          	slli	s3,s3,0x1f
        PhysicalPage* page;
        if (pageAlloc(&page) < 0) {
            return -1;
        }
        pageInsert(myProcess()->pgdir, start, page2pa(page), PTE_USER | PTE_READ | PTE_WRITE | PTE_EXECUTE);
        start += PGSIZE;
    80209e28:	00001a37          	lui	s4,0x1
    80209e2c:	05c0006f          	j	80209e88 <growproc+0x144>
        if (pageAlloc(&page) < 0) {
    80209e30:	fb840513          	addi	a0,s0,-72
    80209e34:	fffff097          	auipc	ra,0xfffff
    80209e38:	088080e7          	jalr	136(ra) # 80208ebc <pageAlloc>
    80209e3c:	08054c63          	bltz	a0,80209ed4 <growproc+0x190>
        pageInsert(myProcess()->pgdir, start, page2pa(page), PTE_USER | PTE_READ | PTE_WRITE | PTE_EXECUTE);
    80209e40:	00006097          	auipc	ra,0x6
    80209e44:	ba8080e7          	jalr	-1112(ra) # 8020f9e8 <myProcess>
    return page - pages;
    80209e48:	fb843603          	ld	a2,-72(s0)
    80209e4c:	41660633          	sub	a2,a2,s6
    80209e50:	40365613          	srai	a2,a2,0x3
    80209e54:	000ab783          	ld	a5,0(s5)
    80209e58:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80209e5c:	00c6161b          	slliw	a2,a2,0xc
    80209e60:	02061613          	slli	a2,a2,0x20
    80209e64:	02065613          	srli	a2,a2,0x20
    80209e68:	01e00693          	li	a3,30
    80209e6c:	01360633          	add	a2,a2,s3
    80209e70:	00048593          	mv	a1,s1
    80209e74:	04053503          	ld	a0,64(a0)
    80209e78:	fffff097          	auipc	ra,0xfffff
    80209e7c:	3f8080e7          	jalr	1016(ra) # 80209270 <pageInsert>
        start += PGSIZE;
    80209e80:	014484b3          	add	s1,s1,s4
    while (start < end) {
    80209e84:	0524fc63          	bgeu	s1,s2,80209edc <growproc+0x198>
        u64 pa = pageLookup(myProcess()->pgdir, start, &pte);
    80209e88:	00006097          	auipc	ra,0x6
    80209e8c:	b60080e7          	jalr	-1184(ra) # 8020f9e8 <myProcess>
    80209e90:	fb040613          	addi	a2,s0,-80
    80209e94:	00048593          	mv	a1,s1
    80209e98:	04053503          	ld	a0,64(a0)
    80209e9c:	fffff097          	auipc	ra,0xfffff
    80209ea0:	0dc080e7          	jalr	220(ra) # 80208f78 <pageLookup>
        if (pa > 0 && (*pte & PTE_COW)) {
    80209ea4:	f80506e3          	beqz	a0,80209e30 <growproc+0xec>
    80209ea8:	fb043783          	ld	a5,-80(s0)
    80209eac:	0007b783          	ld	a5,0(a5) # 2000 <_start-0x801fe000>
    80209eb0:	1007f793          	andi	a5,a5,256
    80209eb4:	f6078ee3          	beqz	a5,80209e30 <growproc+0xec>
            cowHandler(myProcess()->pgdir, start);
    80209eb8:	00006097          	auipc	ra,0x6
    80209ebc:	b30080e7          	jalr	-1232(ra) # 8020f9e8 <myProcess>
    80209ec0:	00048593          	mv	a1,s1
    80209ec4:	04053503          	ld	a0,64(a0)
    80209ec8:	00000097          	auipc	ra,0x0
    80209ecc:	95c080e7          	jalr	-1700(ra) # 80209824 <cowHandler>
    80209ed0:	f61ff06f          	j	80209e30 <growproc+0xec>
            return -1;
    80209ed4:	fff00513          	li	a0,-1
    80209ed8:	01c0006f          	j	80209ef4 <growproc+0x1b0>
    }

    myProcess()->heapBottom = end;
    80209edc:	00006097          	auipc	ra,0x6
    80209ee0:	b0c080e7          	jalr	-1268(ra) # 8020f9e8 <myProcess>
    80209ee4:	000027b7          	lui	a5,0x2
    80209ee8:	00f50533          	add	a0,a0,a5
    80209eec:	07253c23          	sd	s2,120(a0)
    return 0;
    80209ef0:	00000513          	li	a0,0
}
    80209ef4:	04813083          	ld	ra,72(sp)
    80209ef8:	04013403          	ld	s0,64(sp)
    80209efc:	03813483          	ld	s1,56(sp)
    80209f00:	03013903          	ld	s2,48(sp)
    80209f04:	02813983          	ld	s3,40(sp)
    80209f08:	02013a03          	ld	s4,32(sp)
    80209f0c:	01813a83          	ld	s5,24(sp)
    80209f10:	01013b03          	ld	s6,16(sp)
    80209f14:	05010113          	addi	sp,sp,80
    80209f18:	00008067          	ret
        return -1;
    80209f1c:	fff00513          	li	a0,-1
    80209f20:	fd5ff06f          	j	80209ef4 <growproc+0x1b0>

0000000080209f24 <sys_sbrk>:

u64 sys_sbrk(u32 len) {
    80209f24:	fe010113          	addi	sp,sp,-32
    80209f28:	00113c23          	sd	ra,24(sp)
    80209f2c:	00813823          	sd	s0,16(sp)
    80209f30:	00913423          	sd	s1,8(sp)
    80209f34:	01213023          	sd	s2,0(sp)
    80209f38:	02010413          	addi	s0,sp,32
    80209f3c:	00050493          	mv	s1,a0
    u64 addr = myProcess()->heapBottom;
    80209f40:	00006097          	auipc	ra,0x6
    80209f44:	aa8080e7          	jalr	-1368(ra) # 8020f9e8 <myProcess>
    80209f48:	000027b7          	lui	a5,0x2
    80209f4c:	00f50533          	add	a0,a0,a5
    80209f50:	07853903          	ld	s2,120(a0)
    if (growproc(len) < 0)
    80209f54:	00048513          	mv	a0,s1
    80209f58:	00000097          	auipc	ra,0x0
    80209f5c:	dec080e7          	jalr	-532(ra) # 80209d44 <growproc>
    80209f60:	02054063          	bltz	a0,80209f80 <sys_sbrk+0x5c>
        return -1;
    return addr;
    80209f64:	00090513          	mv	a0,s2
    80209f68:	01813083          	ld	ra,24(sp)
    80209f6c:	01013403          	ld	s0,16(sp)
    80209f70:	00813483          	ld	s1,8(sp)
    80209f74:	00013903          	ld	s2,0(sp)
    80209f78:	02010113          	addi	sp,sp,32
    80209f7c:	00008067          	ret
        return -1;
    80209f80:	fff00913          	li	s2,-1
    80209f84:	fe1ff06f          	j	80209f64 <sys_sbrk+0x40>

0000000080209f88 <futexWait>:
    u8 valid;
} FutexQueue;

FutexQueue futexQueue[FUTEX_COUNT];

void futexWait(u64 addr, Thread* th, TimeSpec* ts) {
    80209f88:	fb010113          	addi	sp,sp,-80
    80209f8c:	04113423          	sd	ra,72(sp)
    80209f90:	04813023          	sd	s0,64(sp)
    80209f94:	02913c23          	sd	s1,56(sp)
    80209f98:	03213823          	sd	s2,48(sp)
    80209f9c:	03313423          	sd	s3,40(sp)
    80209fa0:	03413023          	sd	s4,32(sp)
    80209fa4:	01513c23          	sd	s5,24(sp)
    80209fa8:	01613823          	sd	s6,16(sp)
    80209fac:	01713423          	sd	s7,8(sp)
    80209fb0:	01813023          	sd	s8,0(sp)
    80209fb4:	05010413          	addi	s0,sp,80
    80209fb8:	00050b13          	mv	s6,a0
    80209fbc:	00058993          	mv	s3,a1
    80209fc0:	00060913          	mv	s2,a2
    for (int i = 0; i < FUTEX_COUNT; i++) {
    80209fc4:	01a7d497          	auipc	s1,0x1a7d
    80209fc8:	f7448493          	addi	s1,s1,-140 # 81c86f38 <futexQueue>
    80209fcc:	01a7da17          	auipc	s4,0x1a7d
    80209fd0:	56ca0a13          	addi	s4,s4,1388 # 81c87538 <harts>
        if (!futexQueue[i].valid) {
            futexQueue[i].valid = true;
    80209fd4:	00100a93          	li	s5,1
            futexQueue[i].addr = addr;
            futexQueue[i].thread = th;
            if (ts) {
                th->awakeTime = ts->second * 1000000 + ts->nanoSecond / 1000;
    80209fd8:	000f4bb7          	lui	s7,0xf4
    80209fdc:	240b8b93          	addi	s7,s7,576 # f4240 <_start-0x8010bdc0>
    80209fe0:	3e800c13          	li	s8,1000
    80209fe4:	0180006f          	j	80209ffc <futexWait+0x74>
            } else {
                th->state = SLEEPING;
    80209fe8:	2559a823          	sw	s5,592(s3) # 1250 <_start-0x801fedb0>
            }
            yield();
    80209fec:	00008097          	auipc	ra,0x8
    80209ff0:	d4c080e7          	jalr	-692(ra) # 80211d38 <yield>
    for (int i = 0; i < FUTEX_COUNT; i++) {
    80209ff4:	01848493          	addi	s1,s1,24
    80209ff8:	03448c63          	beq	s1,s4,8020a030 <futexWait+0xa8>
        if (!futexQueue[i].valid) {
    80209ffc:	0104c783          	lbu	a5,16(s1)
    8020a000:	fe079ae3          	bnez	a5,80209ff4 <futexWait+0x6c>
            futexQueue[i].valid = true;
    8020a004:	01548823          	sb	s5,16(s1)
            futexQueue[i].addr = addr;
    8020a008:	0164b023          	sd	s6,0(s1)
            futexQueue[i].thread = th;
    8020a00c:	0134b423          	sd	s3,8(s1)
            if (ts) {
    8020a010:	fc090ce3          	beqz	s2,80209fe8 <futexWait+0x60>
                th->awakeTime = ts->second * 1000000 + ts->nanoSecond / 1000;
    8020a014:	00093783          	ld	a5,0(s2)
    8020a018:	037787b3          	mul	a5,a5,s7
    8020a01c:	00893703          	ld	a4,8(s2)
    8020a020:	03874733          	div	a4,a4,s8
    8020a024:	00e787b3          	add	a5,a5,a4
    8020a028:	22f9b823          	sd	a5,560(s3)
    8020a02c:	fc1ff06f          	j	80209fec <futexWait+0x64>
            // not reach here!!!
        }
    }
    panic("No futex Resource!\n");
    8020a030:	0000c697          	auipc	a3,0xc
    8020a034:	b5068693          	addi	a3,a3,-1200 # 80215b80 <__func__.0+0x10>
    8020a038:	0000c617          	auipc	a2,0xc
    8020a03c:	b6860613          	addi	a2,a2,-1176 # 80215ba0 <__func__.0>
    8020a040:	01d00593          	li	a1,29
    8020a044:	0000c517          	auipc	a0,0xc
    8020a048:	b5450513          	addi	a0,a0,-1196 # 80215b98 <__func__.0+0x28>
    8020a04c:	ffff7097          	auipc	ra,0xffff7
    8020a050:	e9c080e7          	jalr	-356(ra) # 80200ee8 <_panic_>

000000008020a054 <futexWake>:
}

void futexWake(u64 addr, int n) {
    8020a054:	ff010113          	addi	sp,sp,-16
    8020a058:	00813423          	sd	s0,8(sp)
    8020a05c:	01010413          	addi	s0,sp,16
    for (int i = 0; i < FUTEX_COUNT && n; i++) {
    8020a060:	04058a63          	beqz	a1,8020a0b4 <futexWake+0x60>
    8020a064:	01a7d797          	auipc	a5,0x1a7d
    8020a068:	ed478793          	addi	a5,a5,-300 # 81c86f38 <futexQueue>
    8020a06c:	01a7d617          	auipc	a2,0x1a7d
    8020a070:	4b460613          	addi	a2,a2,1204 # 81c87520 <futexQueue+0x5e8>
        if (futexQueue[i].valid && futexQueue[i].addr == addr) {
            futexQueue[i].thread->state = RUNNABLE;
    8020a074:	00200813          	li	a6,2
    8020a078:	0100006f          	j	8020a088 <futexWake+0x34>
    for (int i = 0; i < FUTEX_COUNT && n; i++) {
    8020a07c:	02c78c63          	beq	a5,a2,8020a0b4 <futexWake+0x60>
    8020a080:	01878793          	addi	a5,a5,24
    8020a084:	02058863          	beqz	a1,8020a0b4 <futexWake+0x60>
        if (futexQueue[i].valid && futexQueue[i].addr == addr) {
    8020a088:	0107c703          	lbu	a4,16(a5)
    8020a08c:	fe0708e3          	beqz	a4,8020a07c <futexWake+0x28>
    8020a090:	0007b703          	ld	a4,0(a5)
    8020a094:	fea714e3          	bne	a4,a0,8020a07c <futexWake+0x28>
            futexQueue[i].thread->state = RUNNABLE;
    8020a098:	0087b703          	ld	a4,8(a5)
    8020a09c:	25072823          	sw	a6,592(a4)
            futexQueue[i].thread->trapframe.a0 = 0; // set next yield accept!
    8020a0a0:	0087b703          	ld	a4,8(a5)
    8020a0a4:	06073823          	sd	zero,112(a4)
            futexQueue[i].valid = false;
    8020a0a8:	00078823          	sb	zero,16(a5)
            n--;
    8020a0ac:	fff5859b          	addiw	a1,a1,-1
    8020a0b0:	fcdff06f          	j	8020a07c <futexWake+0x28>
        }
    }
    //yield();
}
    8020a0b4:	00813403          	ld	s0,8(sp)
    8020a0b8:	01010113          	addi	sp,sp,16
    8020a0bc:	00008067          	ret

000000008020a0c0 <futexRequeue>:

void futexRequeue(u64 addr, int n, u64 newAddr) {
    8020a0c0:	ff010113          	addi	sp,sp,-16
    8020a0c4:	00813423          	sd	s0,8(sp)
    8020a0c8:	01010413          	addi	s0,sp,16
    for (int i = 0; i < FUTEX_COUNT && n; i++) {
    8020a0cc:	04058a63          	beqz	a1,8020a120 <futexRequeue+0x60>
    8020a0d0:	01a7d797          	auipc	a5,0x1a7d
    8020a0d4:	e6878793          	addi	a5,a5,-408 # 81c86f38 <futexQueue>
    8020a0d8:	01a7d817          	auipc	a6,0x1a7d
    8020a0dc:	44880813          	addi	a6,a6,1096 # 81c87520 <futexQueue+0x5e8>
        if (futexQueue[i].valid && futexQueue[i].addr == addr) {
            futexQueue[i].thread->state = RUNNABLE;
    8020a0e0:	00200893          	li	a7,2
    8020a0e4:	0100006f          	j	8020a0f4 <futexRequeue+0x34>
    for (int i = 0; i < FUTEX_COUNT && n; i++) {
    8020a0e8:	03078c63          	beq	a5,a6,8020a120 <futexRequeue+0x60>
    8020a0ec:	01878793          	addi	a5,a5,24
    8020a0f0:	02058863          	beqz	a1,8020a120 <futexRequeue+0x60>
        if (futexQueue[i].valid && futexQueue[i].addr == addr) {
    8020a0f4:	0107c703          	lbu	a4,16(a5)
    8020a0f8:	fe0708e3          	beqz	a4,8020a0e8 <futexRequeue+0x28>
    8020a0fc:	0007b703          	ld	a4,0(a5)
    8020a100:	fea714e3          	bne	a4,a0,8020a0e8 <futexRequeue+0x28>
            futexQueue[i].thread->state = RUNNABLE;
    8020a104:	0087b703          	ld	a4,8(a5)
    8020a108:	25172823          	sw	a7,592(a4)
            futexQueue[i].thread->trapframe.a0 = 0; // set next yield accept!
    8020a10c:	0087b703          	ld	a4,8(a5)
    8020a110:	06073823          	sd	zero,112(a4)
            futexQueue[i].valid = false;
    8020a114:	00078823          	sb	zero,16(a5)
            n--;
    8020a118:	fff5859b          	addiw	a1,a1,-1
    8020a11c:	fcdff06f          	j	8020a0e8 <futexRequeue+0x28>
        }
    }
    for (int i = 0; i < FUTEX_COUNT; i++) {
    8020a120:	01a7d797          	auipc	a5,0x1a7d
    8020a124:	e1878793          	addi	a5,a5,-488 # 81c86f38 <futexQueue>
    8020a128:	01a7d597          	auipc	a1,0x1a7d
    8020a12c:	41058593          	addi	a1,a1,1040 # 81c87538 <harts>
    8020a130:	00c0006f          	j	8020a13c <futexRequeue+0x7c>
    8020a134:	01878793          	addi	a5,a5,24
    8020a138:	00b78e63          	beq	a5,a1,8020a154 <futexRequeue+0x94>
        if (futexQueue[i].valid && futexQueue[i].addr == addr) {
    8020a13c:	0107c703          	lbu	a4,16(a5)
    8020a140:	fe070ae3          	beqz	a4,8020a134 <futexRequeue+0x74>
    8020a144:	0007b703          	ld	a4,0(a5)
    8020a148:	fea716e3          	bne	a4,a0,8020a134 <futexRequeue+0x74>
            futexQueue[i].addr = newAddr;
    8020a14c:	00c7b023          	sd	a2,0(a5)
    8020a150:	fe5ff06f          	j	8020a134 <futexRequeue+0x74>
        }
    }
}
    8020a154:	00813403          	ld	s0,8(sp)
    8020a158:	01010113          	addi	sp,sp,16
    8020a15c:	00008067          	ret

000000008020a160 <futexClear>:

void futexClear(Thread* thread) {
    8020a160:	ff010113          	addi	sp,sp,-16
    8020a164:	00813423          	sd	s0,8(sp)
    8020a168:	01010413          	addi	s0,sp,16
    for (int i = 0; i < FUTEX_COUNT; i++) {
    8020a16c:	01a7d797          	auipc	a5,0x1a7d
    8020a170:	ddc78793          	addi	a5,a5,-548 # 81c86f48 <futexQueue+0x10>
    8020a174:	01a7d617          	auipc	a2,0x1a7d
    8020a178:	3d460613          	addi	a2,a2,980 # 81c87548 <harts+0x10>
    8020a17c:	0100006f          	j	8020a18c <futexClear+0x2c>
        if (futexQueue[i].valid && futexQueue[i].thread == thread) {
            futexQueue[i].valid = false;
    8020a180:	00078023          	sb	zero,0(a5)
    for (int i = 0; i < FUTEX_COUNT; i++) {
    8020a184:	01878793          	addi	a5,a5,24
    8020a188:	00c78c63          	beq	a5,a2,8020a1a0 <futexClear+0x40>
        if (futexQueue[i].valid && futexQueue[i].thread == thread) {
    8020a18c:	0007c703          	lbu	a4,0(a5)
    8020a190:	fe070ae3          	beqz	a4,8020a184 <futexClear+0x24>
    8020a194:	ff87b703          	ld	a4,-8(a5)
    8020a198:	fea716e3          	bne	a4,a0,8020a184 <futexClear+0x24>
    8020a19c:	fe5ff06f          	j	8020a180 <futexClear+0x20>
        }
    }
    8020a1a0:	00813403          	ld	s0,8(sp)
    8020a1a4:	01010113          	addi	sp,sp,16
    8020a1a8:	00008067          	ret

000000008020a1ac <myHart>:
#include "Process.h"
#include "MemoryConfig.h"

struct Hart harts[HART_TOTAL_NUMBER];

inline struct Hart* myHart() {
    8020a1ac:	ff010113          	addi	sp,sp,-16
    8020a1b0:	00813423          	sd	s0,8(sp)
    8020a1b4:	01010413          	addi	s0,sp,16
#define HART_TOTAL_NUMBER 5

// which hart (core) is this?
static inline u64 r_hartid() {
    u64 x;
    asm volatile("mv %0, tp" : "=r" (x) );
    8020a1b8:	00020793          	mv	a5,tp
    int r = r_hartid();
    return &harts[r];
    8020a1bc:	0007879b          	sext.w	a5,a5
    8020a1c0:	00379793          	slli	a5,a5,0x3
}
    8020a1c4:	01a7d517          	auipc	a0,0x1a7d
    8020a1c8:	37450513          	addi	a0,a0,884 # 81c87538 <harts>
    8020a1cc:	00f50533          	add	a0,a0,a5
    8020a1d0:	00813403          	ld	s0,8(sp)
    8020a1d4:	01010113          	addi	sp,sp,16
    8020a1d8:	00008067          	ret

000000008020a1dc <getHartTrapFrame>:

Trapframe* getHartTrapFrame() {
    8020a1dc:	ff010113          	addi	sp,sp,-16
    8020a1e0:	00813423          	sd	s0,8(sp)
    8020a1e4:	01010413          	addi	s0,sp,16
    8020a1e8:	00020793          	mv	a5,tp
    return (Trapframe*)(TRAMPOLINE_BASE + PAGE_SIZE + r_hartid() * sizeof(Trapframe)); 
    8020a1ec:	00479513          	slli	a0,a5,0x4
    8020a1f0:	00f50533          	add	a0,a0,a5
    8020a1f4:	00551513          	slli	a0,a0,0x5
    8020a1f8:	040007b7          	lui	a5,0x4000
}
    8020a1fc:	fff78793          	addi	a5,a5,-1 # 3ffffff <_start-0x7c200001>
    8020a200:	00c79793          	slli	a5,a5,0xc
    8020a204:	00f50533          	add	a0,a0,a5
    8020a208:	00813403          	ld	s0,8(sp)
    8020a20c:	01010113          	addi	sp,sp,16
    8020a210:	00008067          	ret

000000008020a214 <getHartKernelTopSp>:

u64 getHartKernelTopSp() {
    8020a214:	ff010113          	addi	sp,sp,-16
    8020a218:	00813423          	sd	s0,8(sp)
    8020a21c:	01010413          	addi	s0,sp,16
    8020a220:	00020793          	mv	a5,tp
    extern char kernelStack[];
    return (u64)kernelStack + KERNEL_STACK_SIZE * (r_hartid() + 1);
    8020a224:	00178793          	addi	a5,a5,1
    8020a228:	01079793          	slli	a5,a5,0x10
    8020a22c:	001a5517          	auipc	a0,0x1a5
    8020a230:	dd450513          	addi	a0,a0,-556 # 803af000 <_stack>
    8020a234:	00f50533          	add	a0,a0,a5
    8020a238:	00813403          	ld	s0,8(sp)
    8020a23c:	01010113          	addi	sp,sp,16
    8020a240:	00008067          	ret

000000008020a244 <signalInit>:

SignalContext freeSignalContext[SIGNAL_CONTEXT_COUNT]; 
struct SignalContextList freeSignalContextList;
struct Spinlock signalContextListLock;

void signalInit() {
    8020a244:	ff010113          	addi	sp,sp,-16
    8020a248:	00113423          	sd	ra,8(sp)
    8020a24c:	00813023          	sd	s0,0(sp)
    8020a250:	01010413          	addi	s0,sp,16
    initLock(&signalContextListLock, "signalContextLock");
    8020a254:	0000c597          	auipc	a1,0xc
    8020a258:	95c58593          	addi	a1,a1,-1700 # 80215bb0 <__func__.0+0x10>
    8020a25c:	01a7d517          	auipc	a0,0x1a7d
    8020a260:	30450513          	addi	a0,a0,772 # 81c87560 <signalContextListLock>
    8020a264:	ffffe097          	auipc	ra,0xffffe
    8020a268:	584080e7          	jalr	1412(ra) # 802087e8 <initLock>
    for (int i = 0; i < SIGNAL_CONTEXT_COUNT; i++) {
    8020a26c:	01cbd717          	auipc	a4,0x1cbd
    8020a270:	30c73703          	ld	a4,780(a4) # 81ec7578 <freeSignalContextList>
    8020a274:	01a7d797          	auipc	a5,0x1a7d
    8020a278:	53478793          	addi	a5,a5,1332 # 81c877a8 <freeSignalContext+0x230>
    8020a27c:	01cbd597          	auipc	a1,0x1cbd
    8020a280:	52c58593          	addi	a1,a1,1324 # 81ec77a8 <segmentMaps+0x1a8>
        LIST_INSERT_HEAD(&freeSignalContextList, &freeSignalContext[i], link);
    8020a284:	01cbd617          	auipc	a2,0x1cbd
    8020a288:	2f460613          	addi	a2,a2,756 # 81ec7578 <freeSignalContextList>
    8020a28c:	0140006f          	j	8020a2a0 <signalInit+0x5c>
    8020a290:	dd078713          	addi	a4,a5,-560
    8020a294:	00c6b423          	sd	a2,8(a3)
    for (int i = 0; i < SIGNAL_CONTEXT_COUNT; i++) {
    8020a298:	24078793          	addi	a5,a5,576
    8020a29c:	00b78c63          	beq	a5,a1,8020a2b4 <signalInit+0x70>
        LIST_INSERT_HEAD(&freeSignalContextList, &freeSignalContext[i], link);
    8020a2a0:	00078693          	mv	a3,a5
    8020a2a4:	00e7b023          	sd	a4,0(a5)
    8020a2a8:	fe0704e3          	beqz	a4,8020a290 <signalInit+0x4c>
    8020a2ac:	22f73c23          	sd	a5,568(a4)
    8020a2b0:	fe1ff06f          	j	8020a290 <signalInit+0x4c>
    8020a2b4:	01cbd797          	auipc	a5,0x1cbd
    8020a2b8:	2c478793          	addi	a5,a5,708 # 81ec7578 <freeSignalContextList>
    8020a2bc:	01cbd717          	auipc	a4,0x1cbd
    8020a2c0:	07c70713          	addi	a4,a4,124 # 81ec7338 <freeSignalContext+0x23fdc0>
    8020a2c4:	00e7b023          	sd	a4,0(a5)
    8020a2c8:	01cbd717          	auipc	a4,0x1cbd
    8020a2cc:	2af73423          	sd	a5,680(a4) # 81ec7570 <freeSignalContext+0x23fff8>
    } 
}
    8020a2d0:	00813083          	ld	ra,8(sp)
    8020a2d4:	00013403          	ld	s0,0(sp)
    8020a2d8:	01010113          	addi	sp,sp,16
    8020a2dc:	00008067          	ret

000000008020a2e0 <signalContextFree>:

void signalContextFree(SignalContext* sc) {
    8020a2e0:	ff010113          	addi	sp,sp,-16
    8020a2e4:	00813423          	sd	s0,8(sp)
    8020a2e8:	01010413          	addi	s0,sp,16
    // acquireLock(&signalContextListLock);
    LIST_INSERT_HEAD(&freeSignalContextList, sc, link);
    8020a2ec:	01cbd797          	auipc	a5,0x1cbd
    8020a2f0:	28c7b783          	ld	a5,652(a5) # 81ec7578 <freeSignalContextList>
    8020a2f4:	22f53823          	sd	a5,560(a0)
    8020a2f8:	00078663          	beqz	a5,8020a304 <signalContextFree+0x24>
    8020a2fc:	23050713          	addi	a4,a0,560
    8020a300:	22e7bc23          	sd	a4,568(a5)
    8020a304:	01cbd797          	auipc	a5,0x1cbd
    8020a308:	27478793          	addi	a5,a5,628 # 81ec7578 <freeSignalContextList>
    8020a30c:	00a7b023          	sd	a0,0(a5)
    8020a310:	22f53c23          	sd	a5,568(a0)
    // releaseLock(&signalContextListLock);
}
    8020a314:	00813403          	ld	s0,8(sp)
    8020a318:	01010113          	addi	sp,sp,16
    8020a31c:	00008067          	ret

000000008020a320 <signalContextAlloc>:

int signalContextAlloc(SignalContext **signalContext) {
    8020a320:	fe010113          	addi	sp,sp,-32
    8020a324:	00113c23          	sd	ra,24(sp)
    8020a328:	00813823          	sd	s0,16(sp)
    8020a32c:	00913423          	sd	s1,8(sp)
    8020a330:	02010413          	addi	s0,sp,32
    8020a334:	00050493          	mv	s1,a0
    // acquireLock(&signalContextListLock);
    SignalContext *sc;
    if ((sc = LIST_FIRST(&freeSignalContextList)) != NULL) {
    8020a338:	01cbd797          	auipc	a5,0x1cbd
    8020a33c:	2407b783          	ld	a5,576(a5) # 81ec7578 <freeSignalContextList>
    8020a340:	04078063          	beqz	a5,8020a380 <signalContextAlloc+0x60>
        *signalContext = sc;
    8020a344:	00f53023          	sd	a5,0(a0)
        LIST_REMOVE(sc, link);
    8020a348:	2307b703          	ld	a4,560(a5)
    8020a34c:	00070663          	beqz	a4,8020a358 <signalContextAlloc+0x38>
    8020a350:	2387b683          	ld	a3,568(a5)
    8020a354:	22d73c23          	sd	a3,568(a4)
    8020a358:	2387b703          	ld	a4,568(a5)
    8020a35c:	2307b683          	ld	a3,560(a5)
    8020a360:	00d73023          	sd	a3,0(a4)
        sc->start = false;
    8020a364:	22078023          	sb	zero,544(a5)
        // releaseLock(&signalContextListLock);
        return 0;
    8020a368:	00000513          	li	a0,0
    }
    // releaseLock(&signalContextListLock);
    printf("there's no signal context left!\n");
    *signalContext = NULL;
    return -1;
}
    8020a36c:	01813083          	ld	ra,24(sp)
    8020a370:	01013403          	ld	s0,16(sp)
    8020a374:	00813483          	ld	s1,8(sp)
    8020a378:	02010113          	addi	sp,sp,32
    8020a37c:	00008067          	ret
    printf("there's no signal context left!\n");
    8020a380:	0000c517          	auipc	a0,0xc
    8020a384:	84850513          	addi	a0,a0,-1976 # 80215bc8 <__func__.0+0x28>
    8020a388:	ffff7097          	auipc	ra,0xffff7
    8020a38c:	ac8080e7          	jalr	-1336(ra) # 80200e50 <printf>
    *signalContext = NULL;
    8020a390:	0004b023          	sd	zero,0(s1)
    return -1;
    8020a394:	fff00513          	li	a0,-1
    8020a398:	fd5ff06f          	j	8020a36c <signalContextAlloc+0x4c>

000000008020a39c <signalSend>:

int signalSend(int tgid, int tid, int sig) {
    8020a39c:	fd010113          	addi	sp,sp,-48
    8020a3a0:	02113423          	sd	ra,40(sp)
    8020a3a4:	02813023          	sd	s0,32(sp)
    8020a3a8:	00913c23          	sd	s1,24(sp)
    8020a3ac:	01213823          	sd	s2,16(sp)
    8020a3b0:	03010413          	addi	s0,sp,48
/* if tgid != 0, we will check if tid is belong to tgid. tgid is the same as processId */
    if (tid == -1) {
    8020a3b4:	fff00793          	li	a5,-1
    8020a3b8:	08f58e63          	beq	a1,a5,8020a454 <signalSend+0xb8>
    8020a3bc:	00050913          	mv	s2,a0
    8020a3c0:	00058513          	mv	a0,a1
    8020a3c4:	00060493          	mv	s1,a2
        panic("thread to group not support!\n");
    }
    Thread* thread;
    int r = tid2Thread(tid, &thread, 0);
    8020a3c8:	00000613          	li	a2,0
    8020a3cc:	fd840593          	addi	a1,s0,-40
    8020a3d0:	00006097          	auipc	ra,0x6
    8020a3d4:	4fc080e7          	jalr	1276(ra) # 802108cc <tid2Thread>
    if (r < 0) {
    8020a3d8:	0a054063          	bltz	a0,8020a478 <signalSend+0xdc>
        panic("");
        return -EINVAL;
    }
    if (tgid != 0 && thread->process->processId != tgid) {
    8020a3dc:	00090a63          	beqz	s2,8020a3f0 <signalSend+0x54>
    8020a3e0:	fd843783          	ld	a5,-40(s0)
    8020a3e4:	4187b783          	ld	a5,1048(a5)
    8020a3e8:	0487a783          	lw	a5,72(a5)
    8020a3ec:	0f279263          	bne	a5,s2,8020a4d0 <signalSend+0x134>
    // if (!LIST_EMPTY(&thread->waitingSignal)) {
    //     // dangerous
    //     return 0;
    // }
    SignalContext* sc;
    r = signalContextAlloc(&sc);
    8020a3f0:	fd040513          	addi	a0,s0,-48
    8020a3f4:	00000097          	auipc	ra,0x0
    8020a3f8:	f2c080e7          	jalr	-212(ra) # 8020a320 <signalContextAlloc>
    if (r < 0) {
    8020a3fc:	0a054063          	bltz	a0,8020a49c <signalSend+0x100>
        panic("");
    }
    // acquireLock(&thread->lock);
    sc->signal = sig;
    8020a400:	fd043703          	ld	a4,-48(s0)
    8020a404:	229700a3          	sb	s1,545(a4)
    if (sig == SIGKILL) {
    8020a408:	00900793          	li	a5,9
    8020a40c:	0af48a63          	beq	s1,a5,8020a4c0 <signalSend+0x124>
        thread->state = RUNNABLE;
    }
    LIST_INSERT_HEAD(&thread->waitingSignal, sc, link);
    8020a410:	fd843783          	ld	a5,-40(s0)
    8020a414:	4287b683          	ld	a3,1064(a5)
    8020a418:	22d73823          	sd	a3,560(a4)
    8020a41c:	00068863          	beqz	a3,8020a42c <signalSend+0x90>
    8020a420:	4287b683          	ld	a3,1064(a5)
    8020a424:	23070613          	addi	a2,a4,560
    8020a428:	22c6bc23          	sd	a2,568(a3)
    8020a42c:	42e7b423          	sd	a4,1064(a5)
    8020a430:	42878793          	addi	a5,a5,1064
    8020a434:	22f73c23          	sd	a5,568(a4)
    // releaseLock(&thread->lock);
    return 0;
    8020a438:	00000513          	li	a0,0
}
    8020a43c:	02813083          	ld	ra,40(sp)
    8020a440:	02013403          	ld	s0,32(sp)
    8020a444:	01813483          	ld	s1,24(sp)
    8020a448:	01013903          	ld	s2,16(sp)
    8020a44c:	03010113          	addi	sp,sp,48
    8020a450:	00008067          	ret
        panic("thread to group not support!\n");
    8020a454:	0000b697          	auipc	a3,0xb
    8020a458:	79c68693          	addi	a3,a3,1948 # 80215bf0 <__func__.0+0x50>
    8020a45c:	0000b617          	auipc	a2,0xb
    8020a460:	7dc60613          	addi	a2,a2,2012 # 80215c38 <__func__.4>
    8020a464:	02c00593          	li	a1,44
    8020a468:	0000b517          	auipc	a0,0xb
    8020a46c:	7a850513          	addi	a0,a0,1960 # 80215c10 <__func__.0+0x70>
    8020a470:	ffff7097          	auipc	ra,0xffff7
    8020a474:	a78080e7          	jalr	-1416(ra) # 80200ee8 <_panic_>
        panic("");
    8020a478:	0000b697          	auipc	a3,0xb
    8020a47c:	77068693          	addi	a3,a3,1904 # 80215be8 <__func__.0+0x48>
    8020a480:	0000b617          	auipc	a2,0xb
    8020a484:	7b860613          	addi	a2,a2,1976 # 80215c38 <__func__.4>
    8020a488:	03100593          	li	a1,49
    8020a48c:	0000b517          	auipc	a0,0xb
    8020a490:	78450513          	addi	a0,a0,1924 # 80215c10 <__func__.0+0x70>
    8020a494:	ffff7097          	auipc	ra,0xffff7
    8020a498:	a54080e7          	jalr	-1452(ra) # 80200ee8 <_panic_>
        panic("");
    8020a49c:	0000b697          	auipc	a3,0xb
    8020a4a0:	74c68693          	addi	a3,a3,1868 # 80215be8 <__func__.0+0x48>
    8020a4a4:	0000b617          	auipc	a2,0xb
    8020a4a8:	79460613          	addi	a2,a2,1940 # 80215c38 <__func__.4>
    8020a4ac:	03f00593          	li	a1,63
    8020a4b0:	0000b517          	auipc	a0,0xb
    8020a4b4:	76050513          	addi	a0,a0,1888 # 80215c10 <__func__.0+0x70>
    8020a4b8:	ffff7097          	auipc	ra,0xffff7
    8020a4bc:	a30080e7          	jalr	-1488(ra) # 80200ee8 <_panic_>
        thread->state = RUNNABLE;
    8020a4c0:	fd843783          	ld	a5,-40(s0)
    8020a4c4:	00200693          	li	a3,2
    8020a4c8:	24d7a823          	sw	a3,592(a5)
    8020a4cc:	f45ff06f          	j	8020a410 <signalSend+0x74>
        return -ESRCH; // tid所代表的线程已经结束了
    8020a4d0:	ffd00513          	li	a0,-3
    8020a4d4:	f69ff06f          	j	8020a43c <signalSend+0xa0>

000000008020a4d8 <processSignalSend>:

int processSignalSend(int pid, int sig) {
    8020a4d8:	fc010113          	addi	sp,sp,-64
    8020a4dc:	02113c23          	sd	ra,56(sp)
    8020a4e0:	02813823          	sd	s0,48(sp)
    8020a4e4:	02913423          	sd	s1,40(sp)
    8020a4e8:	03213023          	sd	s2,32(sp)
    8020a4ec:	01313c23          	sd	s3,24(sp)
    8020a4f0:	01413823          	sd	s4,16(sp)
    8020a4f4:	01513423          	sd	s5,8(sp)
    8020a4f8:	01613023          	sd	s6,0(sp)
    8020a4fc:	04010413          	addi	s0,sp,64
    8020a500:	00050a93          	mv	s5,a0
    8020a504:	00058b13          	mv	s6,a1
    extern Thread threads[];
    int ret = -ESRCH;
    for (int i = 0; i < PROCESS_TOTAL_NUMBER; i++) {
    8020a508:	020de497          	auipc	s1,0x20de
    8020a50c:	44848493          	addi	s1,s1,1096 # 822e8950 <threads+0x238>
    8020a510:	02164917          	auipc	s2,0x2164
    8020a514:	44090913          	addi	s2,s2,1088 # 8236e950 <processBelongList+0x210>
    int ret = -ESRCH;
    8020a518:	ffd00513          	li	a0,-3
        // acquireLock(&threads[i].lock);
        if (threads[i].state != UNUSED) {
            if (pid == 0 || pid == -1 || pid == threads[i].process->processId) {
    8020a51c:	001a8a1b          	addiw	s4,s5,1
    8020a520:	00100993          	li	s3,1
    8020a524:	0200006f          	j	8020a544 <processSignalSend+0x6c>
                // releaseLock(&threads[i].lock);
                ret = signalSend(0, threads[i].id, sig);
    8020a528:	000b0613          	mv	a2,s6
    8020a52c:	00072583          	lw	a1,0(a4)
    8020a530:	00000513          	li	a0,0
    8020a534:	00000097          	auipc	ra,0x0
    8020a538:	e68080e7          	jalr	-408(ra) # 8020a39c <signalSend>
    for (int i = 0; i < PROCESS_TOTAL_NUMBER; i++) {
    8020a53c:	43048493          	addi	s1,s1,1072
    8020a540:	03248263          	beq	s1,s2,8020a564 <processSignalSend+0x8c>
        if (threads[i].state != UNUSED) {
    8020a544:	00048713          	mv	a4,s1
    8020a548:	0184a783          	lw	a5,24(s1)
    8020a54c:	fe0788e3          	beqz	a5,8020a53c <processSignalSend+0x64>
            if (pid == 0 || pid == -1 || pid == threads[i].process->processId) {
    8020a550:	fd49fce3          	bgeu	s3,s4,8020a528 <processSignalSend+0x50>
    8020a554:	1e04b783          	ld	a5,480(s1)
    8020a558:	0487a783          	lw	a5,72(a5)
    8020a55c:	ff5790e3          	bne	a5,s5,8020a53c <processSignalSend+0x64>
    8020a560:	fc9ff06f          	j	8020a528 <processSignalSend+0x50>
            }
        }
        // releaseLock(&threads[i].lock);
    }
    return ret;
}
    8020a564:	03813083          	ld	ra,56(sp)
    8020a568:	03013403          	ld	s0,48(sp)
    8020a56c:	02813483          	ld	s1,40(sp)
    8020a570:	02013903          	ld	s2,32(sp)
    8020a574:	01813983          	ld	s3,24(sp)
    8020a578:	01013a03          	ld	s4,16(sp)
    8020a57c:	00813a83          	ld	s5,8(sp)
    8020a580:	00013b03          	ld	s6,0(sp)
    8020a584:	04010113          	addi	sp,sp,64
    8020a588:	00008067          	ret

000000008020a58c <signProccessMask>:

int signProccessMask(u64 how, SignalSet *newSet) {
    8020a58c:	fe010113          	addi	sp,sp,-32
    8020a590:	00113c23          	sd	ra,24(sp)
    8020a594:	00813823          	sd	s0,16(sp)
    8020a598:	00913423          	sd	s1,8(sp)
    8020a59c:	01213023          	sd	s2,0(sp)
    8020a5a0:	02010413          	addi	s0,sp,32
    8020a5a4:	00050493          	mv	s1,a0
    8020a5a8:	00058913          	mv	s2,a1
    Thread* th = myThread();
    8020a5ac:	00006097          	auipc	ra,0x6
    8020a5b0:	f94080e7          	jalr	-108(ra) # 80210540 <myThread>
    8020a5b4:	00050793          	mv	a5,a0
    switch (how) {
    8020a5b8:	00100713          	li	a4,1
    8020a5bc:	04e48263          	beq	s1,a4,8020a600 <signProccessMask+0x74>
    8020a5c0:	00200713          	li	a4,2
    8020a5c4:	04e48c63          	beq	s1,a4,8020a61c <signProccessMask+0x90>
    8020a5c8:	fff00513          	li	a0,-1
    8020a5cc:	00048e63          	beqz	s1,8020a5e8 <signProccessMask+0x5c>
        th->blocked.signal[0] = newSet->signal[0];
        return 0;
    default:
        return -1;
    }
}
    8020a5d0:	01813083          	ld	ra,24(sp)
    8020a5d4:	01013403          	ld	s0,16(sp)
    8020a5d8:	00813483          	ld	s1,8(sp)
    8020a5dc:	00013903          	ld	s2,0(sp)
    8020a5e0:	02010113          	addi	sp,sp,32
    8020a5e4:	00008067          	ret
        th->blocked.signal[0] |= newSet->signal[0];
    8020a5e8:	2887b703          	ld	a4,648(a5)
    8020a5ec:	00093683          	ld	a3,0(s2)
    8020a5f0:	00d76733          	or	a4,a4,a3
    8020a5f4:	28e7b423          	sd	a4,648(a5)
        return 0;
    8020a5f8:	00000513          	li	a0,0
    8020a5fc:	fd5ff06f          	j	8020a5d0 <signProccessMask+0x44>
        th->blocked.signal[0] &= ~(newSet->signal[0]);
    8020a600:	00093683          	ld	a3,0(s2)
    8020a604:	fff6c693          	not	a3,a3
    8020a608:	28853703          	ld	a4,648(a0)
    8020a60c:	00d77733          	and	a4,a4,a3
    8020a610:	28e53423          	sd	a4,648(a0)
        return 0;
    8020a614:	00000513          	li	a0,0
    8020a618:	fb9ff06f          	j	8020a5d0 <signProccessMask+0x44>
        th->blocked.signal[0] = newSet->signal[0];
    8020a61c:	00093703          	ld	a4,0(s2)
    8020a620:	28e53423          	sd	a4,648(a0)
        return 0;
    8020a624:	00000513          	li	a0,0
    8020a628:	fa9ff06f          	j	8020a5d0 <signProccessMask+0x44>

000000008020a62c <doSignalAction>:

int doSignalAction(int sig, u64 act, u64 oldAction) {
    8020a62c:	fd010113          	addi	sp,sp,-48
    8020a630:	02113423          	sd	ra,40(sp)
    8020a634:	02813023          	sd	s0,32(sp)
    8020a638:	00913c23          	sd	s1,24(sp)
    8020a63c:	01213823          	sd	s2,16(sp)
    8020a640:	01313423          	sd	s3,8(sp)
    8020a644:	03010413          	addi	s0,sp,48
    8020a648:	00050493          	mv	s1,a0
    8020a64c:	00058913          	mv	s2,a1
    8020a650:	00060993          	mv	s3,a2
    Thread* th = myThread();
    8020a654:	00006097          	auipc	ra,0x6
    8020a658:	eec080e7          	jalr	-276(ra) # 80210540 <myThread>
    if (sig < 1 || sig > SIGNAL_COUNT) {
    8020a65c:	fff4871b          	addiw	a4,s1,-1
    8020a660:	07f00793          	li	a5,127
    8020a664:	08e7e863          	bltu	a5,a4,8020a6f4 <doSignalAction+0xc8>
        return -1;
    }
	SignalAction *k = getSignalHandler(th->process) + (sig - 1);
    8020a668:	41853503          	ld	a0,1048(a0)
    8020a66c:	00005097          	auipc	ra,0x5
    8020a670:	3b4080e7          	jalr	948(ra) # 8020fa20 <getSignalHandler>
    8020a674:	00549493          	slli	s1,s1,0x5
    8020a678:	fe048493          	addi	s1,s1,-32
    8020a67c:	009504b3          	add	s1,a0,s1
    if (oldAction) {
    8020a680:	02099463          	bnez	s3,8020a6a8 <doSignalAction+0x7c>
        copyout(myProcess()->pgdir, oldAction, (char*)k, sizeof(SignalAction));
    }
	if (act) {
		copyin(myProcess()->pgdir, (char *)k, act, sizeof(SignalAction));
	}
	return 0;
    8020a684:	00000513          	li	a0,0
	if (act) {
    8020a688:	04091263          	bnez	s2,8020a6cc <doSignalAction+0xa0>
}
    8020a68c:	02813083          	ld	ra,40(sp)
    8020a690:	02013403          	ld	s0,32(sp)
    8020a694:	01813483          	ld	s1,24(sp)
    8020a698:	01013903          	ld	s2,16(sp)
    8020a69c:	00813983          	ld	s3,8(sp)
    8020a6a0:	03010113          	addi	sp,sp,48
    8020a6a4:	00008067          	ret
        copyout(myProcess()->pgdir, oldAction, (char*)k, sizeof(SignalAction));
    8020a6a8:	00005097          	auipc	ra,0x5
    8020a6ac:	340080e7          	jalr	832(ra) # 8020f9e8 <myProcess>
    8020a6b0:	02000693          	li	a3,32
    8020a6b4:	00048613          	mv	a2,s1
    8020a6b8:	00098593          	mv	a1,s3
    8020a6bc:	04053503          	ld	a0,64(a0)
    8020a6c0:	fffff097          	auipc	ra,0xfffff
    8020a6c4:	478080e7          	jalr	1144(ra) # 80209b38 <copyout>
    8020a6c8:	fbdff06f          	j	8020a684 <doSignalAction+0x58>
		copyin(myProcess()->pgdir, (char *)k, act, sizeof(SignalAction));
    8020a6cc:	00005097          	auipc	ra,0x5
    8020a6d0:	31c080e7          	jalr	796(ra) # 8020f9e8 <myProcess>
    8020a6d4:	02000693          	li	a3,32
    8020a6d8:	00090613          	mv	a2,s2
    8020a6dc:	00048593          	mv	a1,s1
    8020a6e0:	04053503          	ld	a0,64(a0)
    8020a6e4:	fffff097          	auipc	ra,0xfffff
    8020a6e8:	364080e7          	jalr	868(ra) # 80209a48 <copyin>
	return 0;
    8020a6ec:	00000513          	li	a0,0
    8020a6f0:	f9dff06f          	j	8020a68c <doSignalAction+0x60>
        return -1;
    8020a6f4:	fff00513          	li	a0,-1
    8020a6f8:	f95ff06f          	j	8020a68c <doSignalAction+0x60>

000000008020a6fc <getFirstSignalContext>:

SignalContext* getFirstSignalContext(Thread* thread) {
    8020a6fc:	00050693          	mv	a3,a0
    SignalContext* sc = NULL;
    // acquireLock(&thread->lock);
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a700:	42853503          	ld	a0,1064(a0)
    8020a704:	08050063          	beqz	a0,8020a784 <getFirstSignalContext+0x88>
typedef struct SignalSet {
    u64 signal[SIGNAL_COUNT / sizeof(u64)];
} SignalSet;

inline static bool signalSetAnd(int signal, SignalSet *ss) {
    if (signal > 64) {
    8020a708:	04000613          	li	a2,64
    8020a70c:	0400006f          	j	8020a74c <getFirstSignalContext+0x50>
SignalContext* getFirstSignalContext(Thread* thread) {
    8020a710:	ff010113          	addi	sp,sp,-16
    8020a714:	00113423          	sd	ra,8(sp)
    8020a718:	00813023          	sd	s0,0(sp)
    8020a71c:	01010413          	addi	s0,sp,16
        panic("");
    8020a720:	0000b697          	auipc	a3,0xb
    8020a724:	4c868693          	addi	a3,a3,1224 # 80215be8 <__func__.0+0x48>
    8020a728:	0000b617          	auipc	a2,0xb
    8020a72c:	52060613          	addi	a2,a2,1312 # 80215c48 <__func__.3>
    8020a730:	01200593          	li	a1,18
    8020a734:	0000b517          	auipc	a0,0xb
    8020a738:	4ec50513          	addi	a0,a0,1260 # 80215c20 <__func__.0+0x80>
    8020a73c:	ffff6097          	auipc	ra,0xffff6
    8020a740:	7ac080e7          	jalr	1964(ra) # 80200ee8 <_panic_>
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a744:	23053503          	ld	a0,560(a0)
    8020a748:	02050e63          	beqz	a0,8020a784 <getFirstSignalContext+0x88>
        if (!sc->start && (signalSetAnd(sc->signal, &thread->blocked) || signalSetAnd(sc->signal, &thread->processing))) {
    8020a74c:	22054783          	lbu	a5,544(a0)
    8020a750:	02079a63          	bnez	a5,8020a784 <getFirstSignalContext+0x88>
    8020a754:	22154783          	lbu	a5,545(a0)
    8020a758:	0007871b          	sext.w	a4,a5
    if (signal > 64) {
    8020a75c:	fae64ae3          	blt	a2,a4,8020a710 <getFirstSignalContext+0x14>
    }
    return (ss->signal[0] & (1UL << (signal - 1))) != 0;
    8020a760:	fff7871b          	addiw	a4,a5,-1
    8020a764:	2886b783          	ld	a5,648(a3)
    8020a768:	00e7d7b3          	srl	a5,a5,a4
    8020a76c:	0017f793          	andi	a5,a5,1
    8020a770:	fc079ae3          	bnez	a5,8020a744 <getFirstSignalContext+0x48>
    8020a774:	3886b783          	ld	a5,904(a3)
    8020a778:	00e7d7b3          	srl	a5,a5,a4
    8020a77c:	0017f793          	andi	a5,a5,1
    8020a780:	fc0792e3          	bnez	a5,8020a744 <getFirstSignalContext+0x48>
        }
        break;
    }
    // releaseLock(&thread->lock);
    return sc;
}
    8020a784:	00008067          	ret

000000008020a788 <getHandlingSignal>:

SignalContext* getHandlingSignal(Thread* thread) {
    8020a788:	fe010113          	addi	sp,sp,-32
    8020a78c:	00113c23          	sd	ra,24(sp)
    8020a790:	00813823          	sd	s0,16(sp)
    8020a794:	00913423          	sd	s1,8(sp)
    8020a798:	02010413          	addi	s0,sp,32
    SignalContext* sc = NULL;
    // acquireLock(&thread->lock);
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a79c:	42853483          	ld	s1,1064(a0)
    8020a7a0:	00048a63          	beqz	s1,8020a7b4 <getHandlingSignal+0x2c>
        if (sc->start) {
    8020a7a4:	2204c783          	lbu	a5,544(s1)
    8020a7a8:	00079663          	bnez	a5,8020a7b4 <getHandlingSignal+0x2c>
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a7ac:	2304b483          	ld	s1,560(s1)
    8020a7b0:	fe049ae3          	bnez	s1,8020a7a4 <getHandlingSignal+0x1c>
            break;
        }
    }
    // releaseLock(&thread->lock);
    assert(sc != NULL);
    8020a7b4:	009036b3          	snez	a3,s1
    8020a7b8:	0000b617          	auipc	a2,0xb
    8020a7bc:	4a060613          	addi	a2,a2,1184 # 80215c58 <__func__.2>
    8020a7c0:	09300593          	li	a1,147
    8020a7c4:	0000b517          	auipc	a0,0xb
    8020a7c8:	44c50513          	addi	a0,a0,1100 # 80215c10 <__func__.0+0x70>
    8020a7cc:	ffff6097          	auipc	ra,0xffff6
    8020a7d0:	78c080e7          	jalr	1932(ra) # 80200f58 <_assert_>
    return sc;
}
    8020a7d4:	00048513          	mv	a0,s1
    8020a7d8:	01813083          	ld	ra,24(sp)
    8020a7dc:	01013403          	ld	s0,16(sp)
    8020a7e0:	00813483          	ld	s1,8(sp)
    8020a7e4:	02010113          	addi	sp,sp,32
    8020a7e8:	00008067          	ret

000000008020a7ec <hasKillSignal>:

bool hasKillSignal(Thread* thread) {
    8020a7ec:	ff010113          	addi	sp,sp,-16
    8020a7f0:	00813423          	sd	s0,8(sp)
    8020a7f4:	01010413          	addi	s0,sp,16
    SignalContext* sc = NULL;
    // acquireLock(&thread->lock);
    bool find = false;
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a7f8:	42853783          	ld	a5,1064(a0)
    8020a7fc:	02078063          	beqz	a5,8020a81c <hasKillSignal+0x30>
        if (sc->signal == SIGKILL) {
    8020a800:	00900693          	li	a3,9
    8020a804:	2217c703          	lbu	a4,545(a5)
    8020a808:	00d70e63          	beq	a4,a3,8020a824 <hasKillSignal+0x38>
    LIST_FOREACH(sc, &thread->waitingSignal, link) {
    8020a80c:	2307b783          	ld	a5,560(a5)
    8020a810:	fe079ae3          	bnez	a5,8020a804 <hasKillSignal+0x18>
    bool find = false;
    8020a814:	00000513          	li	a0,0
    8020a818:	0100006f          	j	8020a828 <hasKillSignal+0x3c>
    8020a81c:	00000513          	li	a0,0
    8020a820:	0080006f          	j	8020a828 <hasKillSignal+0x3c>
            find = true;
    8020a824:	00100513          	li	a0,1
            break;
        }
    }
    // releaseLock(&thread->lock);
    return find;
}
    8020a828:	00813403          	ld	s0,8(sp)
    8020a82c:	01010113          	addi	sp,sp,16
    8020a830:	00008067          	ret

000000008020a834 <initFrame>:


void initFrame(SignalContext* sc, Thread* thread) {
    8020a834:	b6010113          	addi	sp,sp,-1184
    8020a838:	48113c23          	sd	ra,1176(sp)
    8020a83c:	48813823          	sd	s0,1168(sp)
    8020a840:	48913423          	sd	s1,1160(sp)
    8020a844:	49213023          	sd	s2,1152(sp)
    8020a848:	47313c23          	sd	s3,1144(sp)
    8020a84c:	47413823          	sd	s4,1136(sp)
    8020a850:	47513423          	sd	s5,1128(sp)
    8020a854:	47613023          	sd	s6,1120(sp)
    8020a858:	45713c23          	sd	s7,1112(sp)
    8020a85c:	4a010413          	addi	s0,sp,1184
    8020a860:	00050a93          	mv	s5,a0
    8020a864:	00058a13          	mv	s4,a1
    Trapframe* tf = getHartTrapFrame();
    8020a868:	00000097          	auipc	ra,0x0
    8020a86c:	974080e7          	jalr	-1676(ra) # 8020a1dc <getHartTrapFrame>
    8020a870:	00050993          	mv	s3,a0
    u64 sp = DOWN_ALIGN(tf->sp - PAGE_SIZE, PAGE_SIZE);
    8020a874:	fffff7b7          	lui	a5,0xfffff
    8020a878:	03053903          	ld	s2,48(a0)
    8020a87c:	01278933          	add	s2,a5,s2
    8020a880:	00f97933          	and	s2,s2,a5
    PhysicalPage *page;
    int r;
    if ((r = pageAlloc(&page)) < 0) {
    8020a884:	fa840513          	addi	a0,s0,-88
    8020a888:	ffffe097          	auipc	ra,0xffffe
    8020a88c:	634080e7          	jalr	1588(ra) # 80208ebc <pageAlloc>
    8020a890:	18054e63          	bltz	a0,8020aa2c <initFrame+0x1f8>
        panic("");
    }
    pageInsert(myProcess()->pgdir, sp - PAGE_SIZE, page2pa(page), PTE_USER | PTE_READ | PTE_WRITE);
    8020a894:	00005097          	auipc	ra,0x5
    8020a898:	154080e7          	jalr	340(ra) # 8020f9e8 <myProcess>
    int hartId;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    8020a89c:	018fcb97          	auipc	s7,0x18fc
    8020a8a0:	664b8b93          	addi	s7,s7,1636 # 81b06f00 <pages>
    8020a8a4:	fa843783          	ld	a5,-88(s0)
    8020a8a8:	417787b3          	sub	a5,a5,s7
    8020a8ac:	4037d793          	srai	a5,a5,0x3
    8020a8b0:	0000cb17          	auipc	s6,0xc
    8020a8b4:	f48b3b03          	ld	s6,-184(s6) # 802167f8 <__func__.0+0x20>
    8020a8b8:	036787b3          	mul	a5,a5,s6
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020a8bc:	00c7979b          	slliw	a5,a5,0xc
    8020a8c0:	02079793          	slli	a5,a5,0x20
    8020a8c4:	0207d793          	srli	a5,a5,0x20
    8020a8c8:	01600693          	li	a3,22
    8020a8cc:	00100613          	li	a2,1
    8020a8d0:	01f61613          	slli	a2,a2,0x1f
    8020a8d4:	00c78633          	add	a2,a5,a2
    8020a8d8:	fffff5b7          	lui	a1,0xfffff
    8020a8dc:	00b905b3          	add	a1,s2,a1
    8020a8e0:	04053503          	ld	a0,64(a0)
    8020a8e4:	fffff097          	auipc	ra,0xfffff
    8020a8e8:	98c080e7          	jalr	-1652(ra) # 80209270 <pageInsert>
    u32 pageTop = PAGE_SIZE;
    pageTop -= sizeof(SignalInfo);
    u64 sigInfo;
    sigInfo = pageTop = DOWN_ALIGN(pageTop, 16);
    SignalInfo si = {0};
    8020a8ec:	08000613          	li	a2,128
    8020a8f0:	00000593          	li	a1,0
    8020a8f4:	f2840513          	addi	a0,s0,-216
    8020a8f8:	00004097          	auipc	ra,0x4
    8020a8fc:	474080e7          	jalr	1140(ra) # 8020ed6c <memset>
    return page - pages;
    8020a900:	fa843783          	ld	a5,-88(s0)
    8020a904:	417787b3          	sub	a5,a5,s7
    8020a908:	4037d793          	srai	a5,a5,0x3
    8020a90c:	036787b3          	mul	a5,a5,s6
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020a910:	00c7979b          	slliw	a5,a5,0xc
    8020a914:	02079793          	slli	a5,a5,0x20
    8020a918:	0207d793          	srli	a5,a5,0x20
    bcopy(&si, (void*)page2pa(page) + pageTop, sizeof(SignalInfo));
    8020a91c:	010005b7          	lui	a1,0x1000
    8020a920:	08000613          	li	a2,128
    8020a924:	01f58593          	addi	a1,a1,31 # 100001f <_start-0x7f1fffe1>
    8020a928:	00759593          	slli	a1,a1,0x7
    8020a92c:	00b785b3          	add	a1,a5,a1
    8020a930:	f2840513          	addi	a0,s0,-216
    8020a934:	ffffe097          	auipc	ra,0xffffe
    8020a938:	36c080e7          	jalr	876(ra) # 80208ca0 <bcopy>
    return page - pages;
    8020a93c:	fa843483          	ld	s1,-88(s0)
    8020a940:	417484b3          	sub	s1,s1,s7
    8020a944:	4034d493          	srai	s1,s1,0x3
    8020a948:	036484b3          	mul	s1,s1,s6
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020a94c:	00c4949b          	slliw	s1,s1,0xc
    8020a950:	02049493          	slli	s1,s1,0x20
    8020a954:	0204d493          	srli	s1,s1,0x20
    pageTop -= sizeof(ucontext);
    u64 uContext;
    uContext = pageTop = DOWN_ALIGN(pageTop, 16);
    sc->uContext = (ucontext*) (uContext + page2pa(page));
    8020a958:	020007b7          	lui	a5,0x2000
    8020a95c:	02f78793          	addi	a5,a5,47 # 200002f <_start-0x7e1fffd1>
    8020a960:	00679793          	slli	a5,a5,0x6
    8020a964:	00f484b3          	add	s1,s1,a5
    8020a968:	229ab423          	sd	s1,552(s5)
    ucontext uc = {0};
    8020a96c:	3c000613          	li	a2,960
    8020a970:	00000593          	li	a1,0
    8020a974:	b6040513          	addi	a0,s0,-1184
    8020a978:	00004097          	auipc	ra,0x4
    8020a97c:	3f4080e7          	jalr	1012(ra) # 8020ed6c <memset>
    uc.uc_sigmask = thread->blocked;
    8020a980:	288a0793          	addi	a5,s4,648
    8020a984:	b8840713          	addi	a4,s0,-1144
    8020a988:	308a0a13          	addi	s4,s4,776
    8020a98c:	0007b503          	ld	a0,0(a5)
    8020a990:	0087b583          	ld	a1,8(a5)
    8020a994:	0107b603          	ld	a2,16(a5)
    8020a998:	0187b683          	ld	a3,24(a5)
    8020a99c:	00a73023          	sd	a0,0(a4)
    8020a9a0:	00b73423          	sd	a1,8(a4)
    8020a9a4:	00c73823          	sd	a2,16(a4)
    8020a9a8:	00d73c23          	sd	a3,24(a4)
    8020a9ac:	02078793          	addi	a5,a5,32
    8020a9b0:	02070713          	addi	a4,a4,32
    8020a9b4:	fd479ce3          	bne	a5,s4,8020a98c <initFrame+0x158>
    uc.uc_mcontext.MC_PC = tf->epc;
    8020a9b8:	0189b783          	ld	a5,24(s3)
    8020a9bc:	c0f43823          	sd	a5,-1008(s0)
    bcopy(&uc, (void*)page2pa(page) + pageTop, sizeof(ucontext));
    8020a9c0:	3c000613          	li	a2,960
    8020a9c4:	00048593          	mv	a1,s1
    8020a9c8:	b6040513          	addi	a0,s0,-1184
    8020a9cc:	ffffe097          	auipc	ra,0xffffe
    8020a9d0:	2d4080e7          	jalr	724(ra) # 80208ca0 <bcopy>
    tf->a0 = sc->signal;
    8020a9d4:	221ac783          	lbu	a5,545(s5)
    8020a9d8:	06f9b823          	sd	a5,112(s3)
    tf->a1 = sigInfo + sp - PAGE_SIZE;
    8020a9dc:	f8090793          	addi	a5,s2,-128
    8020a9e0:	06f9bc23          	sd	a5,120(s3)
    tf->a2 = uContext + sp - PAGE_SIZE;
    8020a9e4:	bc090913          	addi	s2,s2,-1088
    8020a9e8:	0929b023          	sd	s2,128(s3)
    tf->sp = pageTop + sp - PAGE_SIZE;
    8020a9ec:	0329b823          	sd	s2,48(s3)
    tf->ra = SIGNAL_TRAMPOLINE_BASE;
    8020a9f0:	040007b7          	lui	a5,0x4000
    8020a9f4:	ffd78793          	addi	a5,a5,-3 # 3fffffd <_start-0x7c200003>
    8020a9f8:	00c79793          	slli	a5,a5,0xc
    8020a9fc:	02f9b423          	sd	a5,40(s3)
}
    8020aa00:	49813083          	ld	ra,1176(sp)
    8020aa04:	49013403          	ld	s0,1168(sp)
    8020aa08:	48813483          	ld	s1,1160(sp)
    8020aa0c:	48013903          	ld	s2,1152(sp)
    8020aa10:	47813983          	ld	s3,1144(sp)
    8020aa14:	47013a03          	ld	s4,1136(sp)
    8020aa18:	46813a83          	ld	s5,1128(sp)
    8020aa1c:	46013b03          	ld	s6,1120(sp)
    8020aa20:	45813b83          	ld	s7,1112(sp)
    8020aa24:	4a010113          	addi	sp,sp,1184
    8020aa28:	00008067          	ret
        panic("");
    8020aa2c:	0000b697          	auipc	a3,0xb
    8020aa30:	1bc68693          	addi	a3,a3,444 # 80215be8 <__func__.0+0x48>
    8020aa34:	0000b617          	auipc	a2,0xb
    8020aa38:	23c60613          	addi	a2,a2,572 # 80215c70 <__func__.1>
    8020aa3c:	0ac00593          	li	a1,172
    8020aa40:	0000b517          	auipc	a0,0xb
    8020aa44:	1d050513          	addi	a0,a0,464 # 80215c10 <__func__.0+0x70>
    8020aa48:	ffff6097          	auipc	ra,0xffff6
    8020aa4c:	4a0080e7          	jalr	1184(ra) # 80200ee8 <_panic_>

000000008020aa50 <signalFinish>:

void signalFinish(Thread* thread, SignalContext* sc) {
    8020aa50:	ff010113          	addi	sp,sp,-16
    8020aa54:	00113423          	sd	ra,8(sp)
    8020aa58:	00813023          	sd	s0,0(sp)
    8020aa5c:	01010413          	addi	s0,sp,16
    8020aa60:	00058513          	mv	a0,a1
    // acquireLock(&thread->lock);
    LIST_REMOVE(sc, link);
    8020aa64:	2305b783          	ld	a5,560(a1)
    8020aa68:	00078663          	beqz	a5,8020aa74 <signalFinish+0x24>
    8020aa6c:	2385b703          	ld	a4,568(a1)
    8020aa70:	22e7bc23          	sd	a4,568(a5)
    8020aa74:	23853783          	ld	a5,568(a0)
    8020aa78:	23053703          	ld	a4,560(a0)
    8020aa7c:	00e7b023          	sd	a4,0(a5)
    // releaseLock(&thread->lock);
    signalContextFree(sc);
    8020aa80:	00000097          	auipc	ra,0x0
    8020aa84:	860080e7          	jalr	-1952(ra) # 8020a2e0 <signalContextFree>
}
    8020aa88:	00813083          	ld	ra,8(sp)
    8020aa8c:	00013403          	ld	s0,0(sp)
    8020aa90:	01010113          	addi	sp,sp,16
    8020aa94:	00008067          	ret

000000008020aa98 <handleSignal>:

void handleSignal(Thread* thread) {
    8020aa98:	ef010113          	addi	sp,sp,-272
    8020aa9c:	10113423          	sd	ra,264(sp)
    8020aaa0:	10813023          	sd	s0,256(sp)
    8020aaa4:	0e913c23          	sd	s1,248(sp)
    8020aaa8:	0f213823          	sd	s2,240(sp)
    8020aaac:	0f313423          	sd	s3,232(sp)
    8020aab0:	0f413023          	sd	s4,224(sp)
    8020aab4:	11010413          	addi	s0,sp,272
    8020aab8:	00050493          	mv	s1,a0
    SignalContext* sc;
    while (1) {
        sc = getFirstSignalContext(thread);
    8020aabc:	00048513          	mv	a0,s1
    8020aac0:	00000097          	auipc	ra,0x0
    8020aac4:	c3c080e7          	jalr	-964(ra) # 8020a6fc <getFirstSignalContext>
    8020aac8:	00050913          	mv	s2,a0
        if (sc == NULL) {
    8020aacc:	0c050063          	beqz	a0,8020ab8c <handleSignal+0xf4>
            return;
        }
        if (hasKillSignal(thread)) {
    8020aad0:	00048513          	mv	a0,s1
    8020aad4:	00000097          	auipc	ra,0x0
    8020aad8:	d18080e7          	jalr	-744(ra) # 8020a7ec <hasKillSignal>
    8020aadc:	0c051863          	bnez	a0,8020abac <handleSignal+0x114>
            threadDestroy(thread);
            return;
        }
        if (sc->start) {
    8020aae0:	22094783          	lbu	a5,544(s2)
    8020aae4:	0a079463          	bnez	a5,8020ab8c <handleSignal+0xf4>
            return;
        }
        SignalAction *sa = getSignalHandler(thread->process) + (sc->signal - 1);
    8020aae8:	4184b503          	ld	a0,1048(s1)
    8020aaec:	00005097          	auipc	ra,0x5
    8020aaf0:	f34080e7          	jalr	-204(ra) # 8020fa20 <getSignalHandler>
    8020aaf4:	22194783          	lbu	a5,545(s2)
    8020aaf8:	00579713          	slli	a4,a5,0x5
    8020aafc:	fe070713          	addi	a4,a4,-32
    8020ab00:	00e509b3          	add	s3,a0,a4
        if (sa->handler == NULL) {
    8020ab04:	0009b703          	ld	a4,0(s3)
    8020ab08:	0a070a63          	beqz	a4,8020abbc <handleSignal+0x124>
            signalFinish(thread, sc);
            continue;
        }
        sc->start = true;
    8020ab0c:	00100713          	li	a4,1
    8020ab10:	22e90023          	sb	a4,544(s2)
        signalProcessStart(sc->signal, &thread->processing);
    8020ab14:	0007879b          	sext.w	a5,a5
}

inline static void signalProcessStart(int signal, SignalSet *ss) {
    if (signal > 64) {
    8020ab18:	04000713          	li	a4,64
    8020ab1c:	0af74a63          	blt	a4,a5,8020abd0 <handleSignal+0x138>
        panic("");
    }
    ss->signal[0] |= (1UL << (signal - 1));
    8020ab20:	fff7879b          	addiw	a5,a5,-1
    8020ab24:	00100713          	li	a4,1
    8020ab28:	00f71733          	sll	a4,a4,a5
    8020ab2c:	3884b783          	ld	a5,904(s1)
    8020ab30:	00e7e7b3          	or	a5,a5,a4
    8020ab34:	38f4b423          	sd	a5,904(s1)
        Trapframe* tf = getHartTrapFrame();
    8020ab38:	fffff097          	auipc	ra,0xfffff
    8020ab3c:	6a4080e7          	jalr	1700(ra) # 8020a1dc <getHartTrapFrame>
    8020ab40:	00050a13          	mv	s4,a0
        bcopy(tf, &sc->contextRecover, sizeof(Trapframe));
    8020ab44:	22000613          	li	a2,544
    8020ab48:	00090593          	mv	a1,s2
    8020ab4c:	ffffe097          	auipc	ra,0xffffe
    8020ab50:	154080e7          	jalr	340(ra) # 80208ca0 <bcopy>
        struct pthread self;
        copyin(thread->process->pgdir, (char*)&self, thread->trapframe.tp - sizeof(struct pthread), sizeof(struct pthread));
    8020ab54:	0404b603          	ld	a2,64(s1)
    8020ab58:	4184b783          	ld	a5,1048(s1)
    8020ab5c:	0e000693          	li	a3,224
    8020ab60:	f2060613          	addi	a2,a2,-224
    8020ab64:	ef040593          	addi	a1,s0,-272
    8020ab68:	0407b503          	ld	a0,64(a5)
    8020ab6c:	fffff097          	auipc	ra,0xfffff
    8020ab70:	edc080e7          	jalr	-292(ra) # 80209a48 <copyin>
        initFrame(sc, thread);
    8020ab74:	00048593          	mv	a1,s1
    8020ab78:	00090513          	mv	a0,s2
    8020ab7c:	00000097          	auipc	ra,0x0
    8020ab80:	cb8080e7          	jalr	-840(ra) # 8020a834 <initFrame>
        tf->epc = (u64)sa->handler;
    8020ab84:	0009b783          	ld	a5,0(s3)
    8020ab88:	00fa3c23          	sd	a5,24(s4)
        return;
    }
}
    8020ab8c:	10813083          	ld	ra,264(sp)
    8020ab90:	10013403          	ld	s0,256(sp)
    8020ab94:	0f813483          	ld	s1,248(sp)
    8020ab98:	0f013903          	ld	s2,240(sp)
    8020ab9c:	0e813983          	ld	s3,232(sp)
    8020aba0:	0e013a03          	ld	s4,224(sp)
    8020aba4:	11010113          	addi	sp,sp,272
    8020aba8:	00008067          	ret
            threadDestroy(thread);
    8020abac:	00048513          	mv	a0,s1
    8020abb0:	00006097          	auipc	ra,0x6
    8020abb4:	c8c080e7          	jalr	-884(ra) # 8021083c <threadDestroy>
            return;
    8020abb8:	fd5ff06f          	j	8020ab8c <handleSignal+0xf4>
            signalFinish(thread, sc);
    8020abbc:	00090593          	mv	a1,s2
    8020abc0:	00048513          	mv	a0,s1
    8020abc4:	00000097          	auipc	ra,0x0
    8020abc8:	e8c080e7          	jalr	-372(ra) # 8020aa50 <signalFinish>
            continue;
    8020abcc:	ef1ff06f          	j	8020aabc <handleSignal+0x24>
        panic("");
    8020abd0:	0000b697          	auipc	a3,0xb
    8020abd4:	01868693          	addi	a3,a3,24 # 80215be8 <__func__.0+0x48>
    8020abd8:	0000b617          	auipc	a2,0xb
    8020abdc:	0a860613          	addi	a2,a2,168 # 80215c80 <__func__.0>
    8020abe0:	01900593          	li	a1,25
    8020abe4:	0000b517          	auipc	a0,0xb
    8020abe8:	03c50513          	addi	a0,a0,60 # 80215c20 <__func__.0+0x80>
    8020abec:	ffff6097          	auipc	ra,0xffff6
    8020abf0:	2fc080e7          	jalr	764(ra) # 80200ee8 <_panic_>

000000008020abf4 <doSignalTimedWait>:

int doSignalTimedWait(SignalSet *which, SignalInfo *info, TimeSpec *ts) {
    8020abf4:	ff010113          	addi	sp,sp,-16
    8020abf8:	00113423          	sd	ra,8(sp)
    8020abfc:	00813023          	sd	s0,0(sp)
    8020ac00:	01010413          	addi	s0,sp,16
    Thread* thread = myThread();
    8020ac04:	00006097          	auipc	ra,0x6
    8020ac08:	93c080e7          	jalr	-1732(ra) # 80210540 <myThread>
    // if (ts) {
    //     thread->awakeTime = r_time() +  ts->second * 1000000 + ts->nanoSecond / 1000;
    // }
    SignalContext *sc = getFirstSignalContext(thread);
    8020ac0c:	00000097          	auipc	ra,0x0
    8020ac10:	af0080e7          	jalr	-1296(ra) # 8020a6fc <getFirstSignalContext>
    8020ac14:	00050793          	mv	a5,a0
    return sc == NULL ? 0 : sc->signal;    
    8020ac18:	00000513          	li	a0,0
    8020ac1c:	00078463          	beqz	a5,8020ac24 <doSignalTimedWait+0x30>
    8020ac20:	2217c503          	lbu	a0,545(a5)
}
    8020ac24:	00813083          	ld	ra,8(sp)
    8020ac28:	00013403          	ld	s0,0(sp)
    8020ac2c:	01010113          	addi	sp,sp,16
    8020ac30:	00008067          	ret

000000008020ac34 <segmentMapAlloc>:
#define max(x, y) ((x) > (y) ? (x) : (y))

ProcessSegmentMap segmentMaps[SEGMENT_MAP_NUMBER];
u64 segmentMapBitmap[SEGMENT_MAP_NUMBER / 64];
int segmentMapAlloc(ProcessSegmentMap **psm) {
    for (int i = 0; i < SEGMENT_MAP_NUMBER / 64; i++) {
    8020ac34:	01cbd717          	auipc	a4,0x1cbd
    8020ac38:	94c70713          	addi	a4,a4,-1716 # 81ec7580 <segmentMapBitmap>
    8020ac3c:	00000793          	li	a5,0
        if (~segmentMapBitmap[i]) {
    8020ac40:	fff00613          	li	a2,-1
    for (int i = 0; i < SEGMENT_MAP_NUMBER / 64; i++) {
    8020ac44:	01000593          	li	a1,16
        if (~segmentMapBitmap[i]) {
    8020ac48:	00073683          	ld	a3,0(a4)
    8020ac4c:	04c69263          	bne	a3,a2,8020ac90 <segmentMapAlloc+0x5c>
    for (int i = 0; i < SEGMENT_MAP_NUMBER / 64; i++) {
    8020ac50:	0017879b          	addiw	a5,a5,1
    8020ac54:	00870713          	addi	a4,a4,8
    8020ac58:	feb798e3          	bne	a5,a1,8020ac48 <segmentMapAlloc+0x14>
int segmentMapAlloc(ProcessSegmentMap **psm) {
    8020ac5c:	ff010113          	addi	sp,sp,-16
    8020ac60:	00113423          	sd	ra,8(sp)
    8020ac64:	00813023          	sd	s0,0(sp)
    8020ac68:	01010413          	addi	s0,sp,16
            segmentMapBitmap[i] |= (1UL << bit);
            *psm = &segmentMaps[(i << 6) | bit];
            return 0;
        }
    }
    panic("");
    8020ac6c:	0000b697          	auipc	a3,0xb
    8020ac70:	f7c68693          	addi	a3,a3,-132 # 80215be8 <__func__.0+0x48>
    8020ac74:	0000b617          	auipc	a2,0xb
    8020ac78:	1fc60613          	addi	a2,a2,508 # 80215e70 <__func__.5>
    8020ac7c:	02200593          	li	a1,34
    8020ac80:	0000b517          	auipc	a0,0xb
    8020ac84:	01850513          	addi	a0,a0,24 # 80215c98 <__func__.0+0x18>
    8020ac88:	ffff6097          	auipc	ra,0xffff6
    8020ac8c:	260080e7          	jalr	608(ra) # 80200ee8 <_panic_>
            int bit = LOW_BIT64(~segmentMapBitmap[i]);
    8020ac90:	fff6c713          	not	a4,a3
        __a >= __b ? __a : __b; \
    })

inline int LOW_BIT64(u64 x) {
    int res = 0;
    if ((x & ((1UL << 32) - 1)) == 0) {
    8020ac94:	02071593          	slli	a1,a4,0x20
    8020ac98:	0205d593          	srli	a1,a1,0x20
    int res = 0;
    8020ac9c:	00000613          	li	a2,0
    if ((x & ((1UL << 32) - 1)) == 0) {
    8020aca0:	00059663          	bnez	a1,8020acac <segmentMapAlloc+0x78>
        x >>= 32;
    8020aca4:	02075713          	srli	a4,a4,0x20
        res += 32;
    8020aca8:	02000613          	li	a2,32
    }
    if ((x & ((1UL << 16) - 1)) == 0) {
    8020acac:	03071593          	slli	a1,a4,0x30
    8020acb0:	0305d593          	srli	a1,a1,0x30
    8020acb4:	00059663          	bnez	a1,8020acc0 <segmentMapAlloc+0x8c>
        x >>= 16;
    8020acb8:	01075713          	srli	a4,a4,0x10
        res += 16;
    8020acbc:	0106061b          	addiw	a2,a2,16
    }
    if ((x & ((1UL << 8) - 1)) == 0) {
    8020acc0:	0ff77593          	zext.b	a1,a4
    8020acc4:	00059663          	bnez	a1,8020acd0 <segmentMapAlloc+0x9c>
        x >>= 8;
    8020acc8:	00875713          	srli	a4,a4,0x8
        res += 8;
    8020accc:	0086061b          	addiw	a2,a2,8
    }
    if ((x & ((1UL << 4) - 1)) == 0) {
    8020acd0:	00f77593          	andi	a1,a4,15
    8020acd4:	00059663          	bnez	a1,8020ace0 <segmentMapAlloc+0xac>
        x >>= 4;
    8020acd8:	00475713          	srli	a4,a4,0x4
        res += 4;
    8020acdc:	0046061b          	addiw	a2,a2,4
    }
    if ((x & ((1UL << 2) - 1)) == 0) {
    8020ace0:	00377593          	andi	a1,a4,3
    8020ace4:	00059663          	bnez	a1,8020acf0 <segmentMapAlloc+0xbc>
        x >>= 2;
    8020ace8:	00275713          	srli	a4,a4,0x2
        res += 2;
    8020acec:	0026061b          	addiw	a2,a2,2
    }
    if ((x & ((1UL << 1) - 1)) == 0) {
    8020acf0:	00177593          	andi	a1,a4,1
    8020acf4:	00059663          	bnez	a1,8020ad00 <segmentMapAlloc+0xcc>
        x >>= 1;
    8020acf8:	00175713          	srli	a4,a4,0x1
        res += 1;
    8020acfc:	0016061b          	addiw	a2,a2,1
    }
    return x ? res : -1;
    8020ad00:	04070a63          	beqz	a4,8020ad54 <segmentMapAlloc+0x120>
            segmentMapBitmap[i] |= (1UL << bit);
    8020ad04:	00379713          	slli	a4,a5,0x3
    8020ad08:	01cbd597          	auipc	a1,0x1cbd
    8020ad0c:	87858593          	addi	a1,a1,-1928 # 81ec7580 <segmentMapBitmap>
    8020ad10:	00e585b3          	add	a1,a1,a4
    8020ad14:	00100713          	li	a4,1
    8020ad18:	00c71733          	sll	a4,a4,a2
    8020ad1c:	00d76733          	or	a4,a4,a3
    8020ad20:	00e5b023          	sd	a4,0(a1)
            *psm = &segmentMaps[(i << 6) | bit];
    8020ad24:	0067979b          	slliw	a5,a5,0x6
    8020ad28:	00f66633          	or	a2,a2,a5
    8020ad2c:	0006061b          	sext.w	a2,a2
    8020ad30:	00261793          	slli	a5,a2,0x2
    8020ad34:	00c787b3          	add	a5,a5,a2
    8020ad38:	00379793          	slli	a5,a5,0x3
    8020ad3c:	01cbd717          	auipc	a4,0x1cbd
    8020ad40:	8c470713          	addi	a4,a4,-1852 # 81ec7600 <segmentMaps>
    8020ad44:	00e787b3          	add	a5,a5,a4
    8020ad48:	00f53023          	sd	a5,0(a0)
}
    8020ad4c:	00000513          	li	a0,0
    8020ad50:	00008067          	ret
    8020ad54:	fff00613          	li	a2,-1
    8020ad58:	fadff06f          	j	8020ad04 <segmentMapAlloc+0xd0>

000000008020ad5c <appendSegmentMap>:

void appendSegmentMap(Process *p, ProcessSegmentMap *psm) {
    8020ad5c:	ff010113          	addi	sp,sp,-16
    8020ad60:	00813423          	sd	s0,8(sp)
    8020ad64:	01010413          	addi	s0,sp,16
    psm->next = p->segmentMapHead;
    8020ad68:	000027b7          	lui	a5,0x2
    8020ad6c:	00f50533          	add	a0,a0,a5
    8020ad70:	0a853783          	ld	a5,168(a0)
    8020ad74:	02f5b023          	sd	a5,32(a1)
    p->segmentMapHead = psm;
    8020ad78:	0ab53423          	sd	a1,168(a0)
}
    8020ad7c:	00813403          	ld	s0,8(sp)
    8020ad80:	01010113          	addi	sp,sp,16
    8020ad84:	00008067          	ret

000000008020ad88 <segmentMapFree>:

void segmentMapFree(ProcessSegmentMap *psm) {
    8020ad88:	ff010113          	addi	sp,sp,-16
    8020ad8c:	00813423          	sd	s0,8(sp)
    8020ad90:	01010413          	addi	s0,sp,16
    int off = psm - segmentMaps;
    8020ad94:	01cbd797          	auipc	a5,0x1cbd
    8020ad98:	86c78793          	addi	a5,a5,-1940 # 81ec7600 <segmentMaps>
    8020ad9c:	40f50533          	sub	a0,a0,a5
    8020ada0:	40355513          	srai	a0,a0,0x3
    8020ada4:	0000c797          	auipc	a5,0xc
    8020ada8:	a6c7b783          	ld	a5,-1428(a5) # 80216810 <__func__.0+0x38>
    8020adac:	02f5053b          	mulw	a0,a0,a5
    segmentMapBitmap[off >> 6] &= ~(1UL << (off & 63));
    8020adb0:	4065579b          	sraiw	a5,a0,0x6
    8020adb4:	00379793          	slli	a5,a5,0x3
    8020adb8:	01cbc717          	auipc	a4,0x1cbc
    8020adbc:	7c870713          	addi	a4,a4,1992 # 81ec7580 <segmentMapBitmap>
    8020adc0:	00f70733          	add	a4,a4,a5
    8020adc4:	00100793          	li	a5,1
    8020adc8:	00a797b3          	sll	a5,a5,a0
    8020adcc:	fff7c793          	not	a5,a5
    8020add0:	00073683          	ld	a3,0(a4)
    8020add4:	00d7f7b3          	and	a5,a5,a3
    8020add8:	00f73023          	sd	a5,0(a4)
    return;
}
    8020addc:	00813403          	ld	s0,8(sp)
    8020ade0:	01010113          	addi	sp,sp,16
    8020ade4:	00008067          	ret

000000008020ade8 <processMapFree>:

void processMapFree(Process *p) {
    8020ade8:	fe010113          	addi	sp,sp,-32
    8020adec:	00113c23          	sd	ra,24(sp)
    8020adf0:	00813823          	sd	s0,16(sp)
    8020adf4:	00913423          	sd	s1,8(sp)
    8020adf8:	01213023          	sd	s2,0(sp)
    8020adfc:	02010413          	addi	s0,sp,32
    8020ae00:	00050913          	mv	s2,a0
    for (ProcessSegmentMap *psm = p->segmentMapHead; psm; psm = psm->next) {
    8020ae04:	000027b7          	lui	a5,0x2
    8020ae08:	00f507b3          	add	a5,a0,a5
    8020ae0c:	0a87b483          	ld	s1,168(a5) # 20a8 <_start-0x801fdf58>
    8020ae10:	00048c63          	beqz	s1,8020ae28 <processMapFree+0x40>
        segmentMapFree(psm);
    8020ae14:	00048513          	mv	a0,s1
    8020ae18:	00000097          	auipc	ra,0x0
    8020ae1c:	f70080e7          	jalr	-144(ra) # 8020ad88 <segmentMapFree>
    for (ProcessSegmentMap *psm = p->segmentMapHead; psm; psm = psm->next) {
    8020ae20:	0204b483          	ld	s1,32(s1)
    8020ae24:	fe0498e3          	bnez	s1,8020ae14 <processMapFree+0x2c>
    }
    p->segmentMapHead = NULL;
    8020ae28:	000027b7          	lui	a5,0x2
    8020ae2c:	00f90933          	add	s2,s2,a5
    8020ae30:	0a093423          	sd	zero,168(s2)
}
    8020ae34:	01813083          	ld	ra,24(sp)
    8020ae38:	01013403          	ld	s0,16(sp)
    8020ae3c:	00813483          	ld	s1,8(sp)
    8020ae40:	00013903          	ld	s2,0(sp)
    8020ae44:	02010113          	addi	sp,sp,32
    8020ae48:	00008067          	ret

000000008020ae4c <kmalloc>:

/* for compat with linux interface */
void* kmalloc(int size, int policy) {
    8020ae4c:	fe010113          	addi	sp,sp,-32
    8020ae50:	00113c23          	sd	ra,24(sp)
    8020ae54:	00813823          	sd	s0,16(sp)
    8020ae58:	02010413          	addi	s0,sp,32
    if (size > PAGE_SIZE){
    8020ae5c:	000017b7          	lui	a5,0x1
    8020ae60:	04a7cc63          	blt	a5,a0,8020aeb8 <kmalloc+0x6c>
        panic("Do not support kmalloc a mem which size > PAGE_SIZE");
    }
	PhysicalPage* p;
    pageAlloc(&p);
    8020ae64:	fe840513          	addi	a0,s0,-24
    8020ae68:	ffffe097          	auipc	ra,0xffffe
    8020ae6c:	054080e7          	jalr	84(ra) # 80208ebc <pageAlloc>
    int hartId;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    8020ae70:	fe843783          	ld	a5,-24(s0)
    8020ae74:	018fc717          	auipc	a4,0x18fc
    8020ae78:	08c70713          	addi	a4,a4,140 # 81b06f00 <pages>
    8020ae7c:	40e787b3          	sub	a5,a5,a4
    8020ae80:	4037d793          	srai	a5,a5,0x3
    8020ae84:	0000c717          	auipc	a4,0xc
    8020ae88:	97473703          	ld	a4,-1676(a4) # 802167f8 <__func__.0+0x20>
    8020ae8c:	02e787b3          	mul	a5,a5,a4
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020ae90:	00c7979b          	slliw	a5,a5,0xc
    8020ae94:	02079793          	slli	a5,a5,0x20
    8020ae98:	0207d793          	srli	a5,a5,0x20
    return (void *)page2pa(p);
}
    8020ae9c:	00100513          	li	a0,1
    8020aea0:	01f51513          	slli	a0,a0,0x1f
    8020aea4:	00a78533          	add	a0,a5,a0
    8020aea8:	01813083          	ld	ra,24(sp)
    8020aeac:	01013403          	ld	s0,16(sp)
    8020aeb0:	02010113          	addi	sp,sp,32
    8020aeb4:	00008067          	ret
        panic("Do not support kmalloc a mem which size > PAGE_SIZE");
    8020aeb8:	0000b697          	auipc	a3,0xb
    8020aebc:	de868693          	addi	a3,a3,-536 # 80215ca0 <__func__.0+0x20>
    8020aec0:	0000c617          	auipc	a2,0xc
    8020aec4:	91060613          	addi	a2,a2,-1776 # 802167d0 <__func__.4>
    8020aec8:	03a00593          	li	a1,58
    8020aecc:	0000b517          	auipc	a0,0xb
    8020aed0:	dcc50513          	addi	a0,a0,-564 # 80215c98 <__func__.0+0x18>
    8020aed4:	ffff6097          	auipc	ra,0xffff6
    8020aed8:	014080e7          	jalr	20(ra) # 80200ee8 <_panic_>

000000008020aedc <kfree>:
void kfree(void* mem) {
    8020aedc:	ff010113          	addi	sp,sp,-16
    8020aee0:	00113423          	sd	ra,8(sp)
    8020aee4:	00813023          	sd	s0,0(sp)
    8020aee8:	01010413          	addi	s0,sp,16
}

inline PhysicalPage* pa2page(u64 pa) {
    if (pa == 0)
    8020aeec:	02050863          	beqz	a0,8020af1c <kfree+0x40>
        return NULL;
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020aef0:	800007b7          	lui	a5,0x80000
    8020aef4:	00f50533          	add	a0,a0,a5
    8020aef8:	00c55513          	srli	a0,a0,0xc
    return pages + ppn;
    8020aefc:	02051513          	slli	a0,a0,0x20
    8020af00:	02055513          	srli	a0,a0,0x20
    8020af04:	00151793          	slli	a5,a0,0x1
    8020af08:	00a787b3          	add	a5,a5,a0
    8020af0c:	00379793          	slli	a5,a5,0x3
    8020af10:	018fc517          	auipc	a0,0x18fc
    8020af14:	ff050513          	addi	a0,a0,-16 # 81b06f00 <pages>
    8020af18:	00a78533          	add	a0,a5,a0
    pageFree(pa2page((u64)mem));
    8020af1c:	ffffe097          	auipc	ra,0xffffe
    8020af20:	108080e7          	jalr	264(ra) # 80209024 <pageFree>
}
    8020af24:	00813083          	ld	ra,8(sp)
    8020af28:	00013403          	ld	s0,0(sp)
    8020af2c:	01010113          	addi	sp,sp,16
    8020af30:	00008067          	ret

000000008020af34 <load_elf_interp>:
//加载动态链接器
u64 load_elf_interp(u64* pagetable,
                    Ehdr* interp_elf_ex,
                    Dirent* interpreter,
                    u64 no_base,
                    Phdr* interp_elf_phdata) {
    8020af34:	f4010113          	addi	sp,sp,-192
    8020af38:	0a113c23          	sd	ra,184(sp)
    8020af3c:	0a813823          	sd	s0,176(sp)
    8020af40:	0a913423          	sd	s1,168(sp)
    8020af44:	0b213023          	sd	s2,160(sp)
    8020af48:	09313c23          	sd	s3,152(sp)
    8020af4c:	09413823          	sd	s4,144(sp)
    8020af50:	09513423          	sd	s5,136(sp)
    8020af54:	09613023          	sd	s6,128(sp)
    8020af58:	07713c23          	sd	s7,120(sp)
    8020af5c:	07813823          	sd	s8,112(sp)
    8020af60:	07913423          	sd	s9,104(sp)
    8020af64:	07a13023          	sd	s10,96(sp)
    8020af68:	05b13c23          	sd	s11,88(sp)
    8020af6c:	0c010413          	addi	s0,sp,192
    8020af70:	f4c43823          	sd	a2,-176(s0)
    8020af74:	f4d43423          	sd	a3,-184(s0)
    8020af78:	00070493          	mv	s1,a4
	u64 total_size;
	int i;


	total_size = total_mapping_size(interp_elf_phdata,
					interp_elf_ex->phnum);
    8020af7c:	0385d703          	lhu	a4,56(a1)
    for (i = 0; i < nr; i++) {
    8020af80:	20070863          	beqz	a4,8020b190 <load_elf_interp+0x25c>
    8020af84:	00058993          	mv	s3,a1
    8020af88:	00048793          	mv	a5,s1
    8020af8c:	fff7071b          	addiw	a4,a4,-1
    8020af90:	02071713          	slli	a4,a4,0x20
    8020af94:	02075713          	srli	a4,a4,0x20
    8020af98:	00371693          	slli	a3,a4,0x3
    8020af9c:	40e686b3          	sub	a3,a3,a4
    8020afa0:	00369693          	slli	a3,a3,0x3
    8020afa4:	03848713          	addi	a4,s1,56
    8020afa8:	00e686b3          	add	a3,a3,a4
    bool pt_load = false;
    8020afac:	00000513          	li	a0,0
    u64 max_addr = 0;
    8020afb0:	00000893          	li	a7,0
    u64 min_addr = -1;
    8020afb4:	fff00813          	li	a6,-1
        if (phdr[i].type == PT_LOAD) {
    8020afb8:	00100613          	li	a2,1
            min_addr = min(min_addr, DOWN_ALIGN(phdr[i].vaddr, PGSIZE));//最低虚拟地址
    8020afbc:	fffff337          	lui	t1,0xfffff
    8020afc0:	0100006f          	j	8020afd0 <load_elf_interp+0x9c>
            pt_load = true;
    8020afc4:	00060513          	mv	a0,a2
    for (i = 0; i < nr; i++) {
    8020afc8:	03878793          	addi	a5,a5,56 # ffffffff80000038 <bssEnd+0xfffffffefdc90038>
    8020afcc:	02f68a63          	beq	a3,a5,8020b000 <load_elf_interp+0xcc>
        if (phdr[i].type == PT_LOAD) {
    8020afd0:	00078593          	mv	a1,a5
    8020afd4:	0007a703          	lw	a4,0(a5)
    8020afd8:	fec718e3          	bne	a4,a2,8020afc8 <load_elf_interp+0x94>
            min_addr = min(min_addr, DOWN_ALIGN(phdr[i].vaddr, PGSIZE));//最低虚拟地址
    8020afdc:	0107b703          	ld	a4,16(a5)
    8020afe0:	00677533          	and	a0,a4,t1
    8020afe4:	01057463          	bgeu	a0,a6,8020afec <load_elf_interp+0xb8>
    8020afe8:	00050813          	mv	a6,a0
            max_addr = max(max_addr, phdr[i].vaddr + phdr[i].memsz);//最高虚拟地址
    8020afec:	0285b583          	ld	a1,40(a1)
    8020aff0:	00b70733          	add	a4,a4,a1
    8020aff4:	fce8f8e3          	bgeu	a7,a4,8020afc4 <load_elf_interp+0x90>
    8020aff8:	00070893          	mv	a7,a4
    8020affc:	fc9ff06f          	j	8020afc4 <load_elf_interp+0x90>
    return pt_load ? (max_addr - min_addr) : 0;
    8020b000:	18050c63          	beqz	a0,8020b198 <load_elf_interp+0x264>
    8020b004:	41088733          	sub	a4,a7,a6
	if (!total_size) {
    8020b008:	1d088a63          	beq	a7,a6,8020b1dc <load_elf_interp+0x2a8>
首先申请total_size（这里是不固定的，需要OS来分配）。直接调用 do_mmap();
然后再把每个段填进去（这里的地址是确定的）

*/
	eppnt = interp_elf_phdata;
	for (i = 0; i < interp_elf_ex->phnum; i++, eppnt++) {
    8020b00c:	00000913          	li	s2,0
	int load_addr_set = 0;
    8020b010:	00000c93          	li	s9,0
	u64 load_addr = 0;
    8020b014:	00000d13          	li	s10,0
		if (eppnt->type == PT_LOAD) {
    8020b018:	00100a93          	li	s5,1
			u64 k, map_addr;

			vaddr = eppnt->vaddr;

            /* 第一次会走第二个分支，第二次会走第一个分支*/
			if (interp_elf_ex->type == ET_EXEC || load_addr_set)
    8020b01c:	00200c13          	li	s8,2
    u64 size = eppnt->filesz + PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b020:	000017b7          	lui	a5,0x1
    8020b024:	fff78d93          	addi	s11,a5,-1 # fff <_start-0x801ff001>
    8020b028:	08c0006f          	j	8020b0b4 <load_elf_interp+0x180>
				elf_type |= MAP_FIXED;
			else if (no_base && interp_elf_ex->type == ET_DYN)
				load_addr = -vaddr;
    8020b02c:	40b00d33          	neg	s10,a1
    8020b030:	0b40006f          	j	8020b0e4 <load_elf_interp+0x1b0>
            
            struct File interp_file;
            interp_file.ep = interpreter;
    8020b034:	f5043783          	ld	a5,-176(s0)
    8020b038:	f6f43c23          	sd	a5,-136(s0)
            interp_file.type = FD_ENTRY;
    8020b03c:	f7842023          	sw	s8,-160(s0)
            interp_file.readable = 1;
    8020b040:	f7540423          	sb	s5,-152(s0)
    u64 size = eppnt->filesz + PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b044:	01b5fbb3          	and	s7,a1,s11
    8020b048:	0204ba03          	ld	s4,32(s1)
    8020b04c:	014b8a33          	add	s4,s7,s4
    u64 off = eppnt->offset - PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b050:	0084bb03          	ld	s6,8(s1)
			map_addr = elf_map(&interp_file, load_addr + vaddr,
    8020b054:	00bd05b3          	add	a1,s10,a1
    addr = DOWN_ALIGN(addr, PAGE_SIZE);
    8020b058:	fffff7b7          	lui	a5,0xfffff
    8020b05c:	00f5f5b3          	and	a1,a1,a5
    if (!size)
    8020b060:	020a0e63          	beqz	s4,8020b09c <load_elf_interp+0x168>
				elf_type |= MAP_FIXED;
    8020b064:	01200793          	li	a5,18
    8020b068:	f4f43c23          	sd	a5,-168(s0)
    u64 off = eppnt->offset - PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b06c:	417b0b33          	sub	s6,s6,s7
    if (total_size) {
    8020b070:	0a071663          	bnez	a4,8020b11c <load_elf_interp+0x1e8>
    map_addr = do_mmap(filep, addr, size, prot, type, off);
    8020b074:	000b0793          	mv	a5,s6
    8020b078:	f5843703          	ld	a4,-168(s0)
    8020b07c:	05e00693          	li	a3,94
    8020b080:	000a0613          	mv	a2,s4
    8020b084:	f6040513          	addi	a0,s0,-160
    8020b088:	ffff9097          	auipc	ra,0xffff9
    8020b08c:	288080e7          	jalr	648(ra) # 80204310 <do_mmap>
    8020b090:	00050593          	mv	a1,a0
    if (map_addr == -1)
    8020b094:	fff00793          	li	a5,-1
    8020b098:	0af50c63          	beq	a0,a5,8020b150 <load_elf_interp+0x21c>
			total_size = 0;
			error = map_addr;
			if (map_addr == -1)
                panic("elf_map failed");

			if (!load_addr_set &&
    8020b09c:	0c0c8c63          	beqz	s9,8020b174 <load_elf_interp+0x240>
			total_size = 0;
    8020b0a0:	00000713          	li	a4,0
	for (i = 0; i < interp_elf_ex->phnum; i++, eppnt++) {
    8020b0a4:	0019091b          	addiw	s2,s2,1
    8020b0a8:	03848493          	addi	s1,s1,56
    8020b0ac:	0389d783          	lhu	a5,56(s3)
    8020b0b0:	0ef95663          	bge	s2,a5,8020b19c <load_elf_interp+0x268>
		if (eppnt->type == PT_LOAD) {
    8020b0b4:	0004a783          	lw	a5,0(s1)
    8020b0b8:	ff5796e3          	bne	a5,s5,8020b0a4 <load_elf_interp+0x170>
			vaddr = eppnt->vaddr;
    8020b0bc:	0104b583          	ld	a1,16(s1)
			if (interp_elf_ex->type == ET_EXEC || load_addr_set)
    8020b0c0:	0109d783          	lhu	a5,16(s3)
    8020b0c4:	0007869b          	sext.w	a3,a5
    8020b0c8:	f78686e3          	beq	a3,s8,8020b034 <load_elf_interp+0x100>
    8020b0cc:	100c9c63          	bnez	s9,8020b1e4 <load_elf_interp+0x2b0>
			else if (no_base && interp_elf_ex->type == ET_DYN)
    8020b0d0:	f4843683          	ld	a3,-184(s0)
    8020b0d4:	00068863          	beqz	a3,8020b0e4 <load_elf_interp+0x1b0>
    8020b0d8:	0007879b          	sext.w	a5,a5
    8020b0dc:	00300693          	li	a3,3
    8020b0e0:	f4d786e3          	beq	a5,a3,8020b02c <load_elf_interp+0xf8>
            interp_file.ep = interpreter;
    8020b0e4:	f5043783          	ld	a5,-176(s0)
    8020b0e8:	f6f43c23          	sd	a5,-136(s0)
            interp_file.type = FD_ENTRY;
    8020b0ec:	f7842023          	sw	s8,-160(s0)
            interp_file.readable = 1;
    8020b0f0:	f7540423          	sb	s5,-152(s0)
    u64 size = eppnt->filesz + PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b0f4:	01b5fbb3          	and	s7,a1,s11
    8020b0f8:	0204ba03          	ld	s4,32(s1)
    8020b0fc:	014b8a33          	add	s4,s7,s4
    u64 off = eppnt->offset - PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b100:	0084bb03          	ld	s6,8(s1)
			map_addr = elf_map(&interp_file, load_addr + vaddr,
    8020b104:	00bd05b3          	add	a1,s10,a1
    addr = DOWN_ALIGN(addr, PAGE_SIZE);
    8020b108:	fffff7b7          	lui	a5,0xfffff
    8020b10c:	00f5f5b3          	and	a1,a1,a5
    if (!size)
    8020b110:	060a0263          	beqz	s4,8020b174 <load_elf_interp+0x240>
    8020b114:	f5843c23          	sd	s8,-168(s0)
    8020b118:	f55ff06f          	j	8020b06c <load_elf_interp+0x138>
        total_size = UP_ALIGN(total_size, PAGE_SIZE);
    8020b11c:	fff70713          	addi	a4,a4,-1
    8020b120:	fffff7b7          	lui	a5,0xfffff
    8020b124:	00f77633          	and	a2,a4,a5
        map_addr = do_mmap(NULL, addr, total_size, prot, type, off);
    8020b128:	000b0793          	mv	a5,s6
    8020b12c:	f5843703          	ld	a4,-168(s0)
    8020b130:	05e00693          	li	a3,94
    8020b134:	00001537          	lui	a0,0x1
    8020b138:	00a60633          	add	a2,a2,a0
    8020b13c:	00000513          	li	a0,0
    8020b140:	ffff9097          	auipc	ra,0xffff9
    8020b144:	1d0080e7          	jalr	464(ra) # 80204310 <do_mmap>
    8020b148:	00050593          	mv	a1,a0
        addr = map_addr;
    8020b14c:	f29ff06f          	j	8020b074 <load_elf_interp+0x140>
        panic("mmap interpreter fail!");
    8020b150:	0000b697          	auipc	a3,0xb
    8020b154:	b8868693          	addi	a3,a3,-1144 # 80215cd8 <__func__.0+0x58>
    8020b158:	0000b617          	auipc	a2,0xb
    8020b15c:	67060613          	addi	a2,a2,1648 # 802167c8 <__func__.2>
    8020b160:	07600593          	li	a1,118
    8020b164:	0000b517          	auipc	a0,0xb
    8020b168:	b3450513          	addi	a0,a0,-1228 # 80215c98 <__func__.0+0x18>
    8020b16c:	ffff6097          	auipc	ra,0xffff6
    8020b170:	d7c080e7          	jalr	-644(ra) # 80200ee8 <_panic_>
			if (!load_addr_set &&
    8020b174:	0109d783          	lhu	a5,16(s3)
    8020b178:	00000c93          	li	s9,0
    8020b17c:	00300713          	li	a4,3
    8020b180:	f2e790e3          	bne	a5,a4,8020b0a0 <load_elf_interp+0x16c>
			    interp_elf_ex->type == ET_DYN) {
				load_addr = map_addr - PAGE_OFFSET(vaddr, PAGE_SIZE);
    8020b184:	41758d33          	sub	s10,a1,s7
				load_addr_set = 1;
    8020b188:	000a8c93          	mv	s9,s5
    8020b18c:	f15ff06f          	j	8020b0a0 <load_elf_interp+0x16c>
		error = -EINVAL;
    8020b190:	fea00d13          	li	s10,-22
    8020b194:	0080006f          	j	8020b19c <load_elf_interp+0x268>
    8020b198:	fea00d13          	li	s10,-22
	}*/

	error = load_addr;
out:
	return error;
}
    8020b19c:	000d0513          	mv	a0,s10
    8020b1a0:	0b813083          	ld	ra,184(sp)
    8020b1a4:	0b013403          	ld	s0,176(sp)
    8020b1a8:	0a813483          	ld	s1,168(sp)
    8020b1ac:	0a013903          	ld	s2,160(sp)
    8020b1b0:	09813983          	ld	s3,152(sp)
    8020b1b4:	09013a03          	ld	s4,144(sp)
    8020b1b8:	08813a83          	ld	s5,136(sp)
    8020b1bc:	08013b03          	ld	s6,128(sp)
    8020b1c0:	07813b83          	ld	s7,120(sp)
    8020b1c4:	07013c03          	ld	s8,112(sp)
    8020b1c8:	06813c83          	ld	s9,104(sp)
    8020b1cc:	06013d03          	ld	s10,96(sp)
    8020b1d0:	05813d83          	ld	s11,88(sp)
    8020b1d4:	0c010113          	addi	sp,sp,192
    8020b1d8:	00008067          	ret
		error = -EINVAL;
    8020b1dc:	fea00d13          	li	s10,-22
	return error;
    8020b1e0:	fbdff06f          	j	8020b19c <load_elf_interp+0x268>
            interp_file.ep = interpreter;
    8020b1e4:	f5043783          	ld	a5,-176(s0)
    8020b1e8:	f6f43c23          	sd	a5,-136(s0)
            interp_file.type = FD_ENTRY;
    8020b1ec:	f7842023          	sw	s8,-160(s0)
            interp_file.readable = 1;
    8020b1f0:	f7540423          	sb	s5,-152(s0)
    u64 size = eppnt->filesz + PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b1f4:	01b5fbb3          	and	s7,a1,s11
    8020b1f8:	0204ba03          	ld	s4,32(s1)
    8020b1fc:	014b8a33          	add	s4,s7,s4
    u64 off = eppnt->offset - PAGE_OFFSET(eppnt->vaddr, PAGE_SIZE);
    8020b200:	0084bb03          	ld	s6,8(s1)
			map_addr = elf_map(&interp_file, load_addr + vaddr,
    8020b204:	00bd05b3          	add	a1,s10,a1
    addr = DOWN_ALIGN(addr, PAGE_SIZE);
    8020b208:	fffff7b7          	lui	a5,0xfffff
    8020b20c:	00f5f5b3          	and	a1,a1,a5
    if (!size)
    8020b210:	e80a08e3          	beqz	s4,8020b0a0 <load_elf_interp+0x16c>
				elf_type |= MAP_FIXED;
    8020b214:	01200793          	li	a5,18
    8020b218:	f4f43c23          	sd	a5,-168(s0)
    8020b21c:	e51ff06f          	j	8020b06c <load_elf_interp+0x138>

000000008020b220 <exec>:
        script_argv[script_argc++] = *(argv++);
    }
    return exec(i_name, script_argv);
}

int exec(char* path, char** argv) {
    8020b220:	ae010113          	addi	sp,sp,-1312
    8020b224:	50113c23          	sd	ra,1304(sp)
    8020b228:	50813823          	sd	s0,1296(sp)
    8020b22c:	50913423          	sd	s1,1288(sp)
    8020b230:	51213023          	sd	s2,1280(sp)
    8020b234:	4f313c23          	sd	s3,1272(sp)
    8020b238:	4f413823          	sd	s4,1264(sp)
    8020b23c:	4f513423          	sd	s5,1256(sp)
    8020b240:	4f613023          	sd	s6,1248(sp)
    8020b244:	4d713c23          	sd	s7,1240(sp)
    8020b248:	4d813823          	sd	s8,1232(sp)
    8020b24c:	4d913423          	sd	s9,1224(sp)
    8020b250:	4da13023          	sd	s10,1216(sp)
    8020b254:	4bb13c23          	sd	s11,1208(sp)
    8020b258:	52010413          	addi	s0,sp,1312
    8020b25c:	00050493          	mv	s1,a0
    8020b260:	aeb43c23          	sd	a1,-1288(s0)
    u64 argc,  sp, ustack[MAXARG + AT_VECTOR_SIZE], stackbase;
    Ehdr elf;
    Dirent* de;
    Phdr ph;
    u64 *pagetable = 0, *old_pagetable = 0;
    Process* p = myProcess();
    8020b264:	00004097          	auipc	ra,0x4
    8020b268:	784080e7          	jalr	1924(ra) # 8020f9e8 <myProcess>
    8020b26c:	00050a13          	mv	s4,a0
    processMapFree(p);
    8020b270:	00000097          	auipc	ra,0x0
    8020b274:	b78080e7          	jalr	-1160(ra) # 8020ade8 <processMapFree>
    u64* oldpagetable = p->pgdir;
    8020b278:	040a3783          	ld	a5,64(s4)
    8020b27c:	aef43823          	sd	a5,-1296(s0)
    u64 phdr_addr = 0; // virtual address in user space, point to the program header. We will pass 'phdr_addr' to ld.so

    if ((de = ename(AT_FDCWD, path, true)) == 0) {
    8020b280:	00100613          	li	a2,1
    8020b284:	00048593          	mv	a1,s1
    8020b288:	f9c00513          	li	a0,-100
    8020b28c:	ffff8097          	auipc	ra,0xffff8
    8020b290:	7b0080e7          	jalr	1968(ra) # 80203a3c <ename>
    8020b294:	2e050ae3          	beqz	a0,8020bd88 <exec+0xb68>
    8020b298:	00050913          	mv	s2,a0
        MSG_PRINT("find file error\n");
        return -1;
    }
    elock(de);
    8020b29c:	ffff8097          	auipc	ra,0xffff8
    8020b2a0:	340080e7          	jalr	832(ra) # 802035dc <elock>

/* ========== check executable format (script or elf) =========== */

    char bprmbuf[BINPRM_BUF_SIZE];
    eread(de, 0, (u64)bprmbuf, 0, BINPRM_BUF_SIZE - 1);
    8020b2a4:	07f00713          	li	a4,127
    8020b2a8:	00000693          	li	a3,0
    8020b2ac:	c2840613          	addi	a2,s0,-984
    8020b2b0:	00000593          	li	a1,0
    8020b2b4:	00090513          	mv	a0,s2
    8020b2b8:	ffff8097          	auipc	ra,0xffff8
    8020b2bc:	ae4080e7          	jalr	-1308(ra) # 80202d9c <eread>
    if (bprmbuf[0] == '#' && bprmbuf[1] == '!') {
    8020b2c0:	c2844703          	lbu	a4,-984(s0)
    8020b2c4:	02300793          	li	a5,35
    8020b2c8:	00f71863          	bne	a4,a5,8020b2d8 <exec+0xb8>
    8020b2cc:	c2944703          	lbu	a4,-983(s0)
    8020b2d0:	02100793          	li	a5,33
    8020b2d4:	1af70e63          	beq	a4,a5,8020b490 <exec+0x270>
        eput(de);
        return load_script(bprmbuf, path, argv);
    }

    PhysicalPage *page;
    int r = allocPgdir(&page);
    8020b2d8:	c2040513          	addi	a0,s0,-992
    8020b2dc:	ffffe097          	auipc	ra,0xffffe
    8020b2e0:	1ec080e7          	jalr	492(ra) # 802094c8 <allocPgdir>
    if (r < 0) {
    8020b2e4:	1e054063          	bltz	a0,8020b4c4 <exec+0x2a4>
        panic("setup page alloc error\n");
        return r;
    }
    
    p->heapBottom = USER_HEAP_BOTTOM;// TODO,these code have writen twice
    8020b2e8:	00002737          	lui	a4,0x2
    8020b2ec:	00ea0733          	add	a4,s4,a4
    8020b2f0:	03ec07b7          	lui	a5,0x3ec0
    8020b2f4:	ffd78793          	addi	a5,a5,-3 # 3ebfffd <_start-0x7c340003>
    8020b2f8:	00c79793          	slli	a5,a5,0xc
    8020b2fc:	06f73c23          	sd	a5,120(a4) # 2078 <_start-0x801fdf88>
    return page - pages;
    8020b300:	c2043483          	ld	s1,-992(s0)
    8020b304:	018fc797          	auipc	a5,0x18fc
    8020b308:	bfc78793          	addi	a5,a5,-1028 # 81b06f00 <pages>
    8020b30c:	40f484b3          	sub	s1,s1,a5
    8020b310:	4034d493          	srai	s1,s1,0x3
    8020b314:	0000b797          	auipc	a5,0xb
    8020b318:	4e47b783          	ld	a5,1252(a5) # 802167f8 <__func__.0+0x20>
    8020b31c:	02f484b3          	mul	s1,s1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020b320:	00c4949b          	slliw	s1,s1,0xc
    8020b324:	02049493          	slli	s1,s1,0x20
    8020b328:	0204d493          	srli	s1,s1,0x20
    8020b32c:	00100793          	li	a5,1
    8020b330:	01f79793          	slli	a5,a5,0x1f
    8020b334:	00f484b3          	add	s1,s1,a5
    pagetable = (u64*)page2pa(page);
    extern char trampoline[];
    pageInsert(pagetable, TRAMPOLINE_BASE, (u64)trampoline, 
    8020b338:	00e00693          	li	a3,14
    8020b33c:	00007617          	auipc	a2,0x7
    8020b340:	cc460613          	addi	a2,a2,-828 # 80212000 <_trampoline>
    8020b344:	020005b7          	lui	a1,0x2000
    8020b348:	fff58593          	addi	a1,a1,-1 # 1ffffff <_start-0x7e200001>
    8020b34c:	00d59593          	slli	a1,a1,0xd
    8020b350:	00048513          	mv	a0,s1
    8020b354:	ffffe097          	auipc	ra,0xffffe
    8020b358:	f1c080e7          	jalr	-228(ra) # 80209270 <pageInsert>
        PTE_READ | PTE_WRITE | PTE_EXECUTE);
    pageInsert(pagetable, TRAMPOLINE_BASE + PAGE_SIZE, ((u64)trampoline) + PAGE_SIZE, 
    8020b35c:	00e00693          	li	a3,14
    8020b360:	00008617          	auipc	a2,0x8
    8020b364:	ca060613          	addi	a2,a2,-864 # 80213000 <trapframe>
    8020b368:	040009b7          	lui	s3,0x4000
    8020b36c:	fff98593          	addi	a1,s3,-1 # 3ffffff <_start-0x7c200001>
    8020b370:	00c59593          	slli	a1,a1,0xc
    8020b374:	00048513          	mv	a0,s1
    8020b378:	ffffe097          	auipc	ra,0xffffe
    8020b37c:	ef8080e7          	jalr	-264(ra) # 80209270 <pageInsert>
        PTE_READ | PTE_WRITE | PTE_EXECUTE);    
    extern char signalTrampoline[];
    pageInsert(pagetable, SIGNAL_TRAMPOLINE_BASE, (u64)signalTrampoline,
    8020b380:	01e00693          	li	a3,30
    8020b384:	00009617          	auipc	a2,0x9
    8020b388:	c7c60613          	addi	a2,a2,-900 # 80214000 <_signalTrampoline>
    8020b38c:	ffd98593          	addi	a1,s3,-3
    8020b390:	00c59593          	slli	a1,a1,0xc
    8020b394:	00048513          	mv	a0,s1
    8020b398:	ffffe097          	auipc	ra,0xffffe
    8020b39c:	ed8080e7          	jalr	-296(ra) # 80209270 <pageInsert>
        PTE_USER | PTE_EXECUTE | PTE_READ | PTE_WRITE);

    r = pageAlloc(&page);
    8020b3a0:	c2040513          	addi	a0,s0,-992
    8020b3a4:	ffffe097          	auipc	ra,0xffffe
    8020b3a8:	b18080e7          	jalr	-1256(ra) # 80208ebc <pageAlloc>
    if (r < 0) {
    8020b3ac:	12054e63          	bltz	a0,8020b4e8 <exec+0x2c8>
    return page - pages;
    8020b3b0:	c2043783          	ld	a5,-992(s0)
    8020b3b4:	018fc717          	auipc	a4,0x18fc
    8020b3b8:	b4c70713          	addi	a4,a4,-1204 # 81b06f00 <pages>
    8020b3bc:	40e787b3          	sub	a5,a5,a4
    8020b3c0:	4037d793          	srai	a5,a5,0x3
    8020b3c4:	0000b717          	auipc	a4,0xb
    8020b3c8:	43473703          	ld	a4,1076(a4) # 802167f8 <__func__.0+0x20>
    8020b3cc:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020b3d0:	00c7979b          	slliw	a5,a5,0xc
    8020b3d4:	02079793          	slli	a5,a5,0x20
    8020b3d8:	0207d793          	srli	a5,a5,0x20
        panic("setup stack alloc error\n");
        return r;
    }
    pageInsert(pagetable, USER_STACK_TOP - PGSIZE, page2pa(page), PTE_USER | PTE_READ | PTE_WRITE | PTE_EXECUTE); // We must alloc the stack
    8020b3dc:	01e00693          	li	a3,30
    8020b3e0:	00100613          	li	a2,1
    8020b3e4:	01f61613          	slli	a2,a2,0x1f
    8020b3e8:	00c78633          	add	a2,a5,a2
    8020b3ec:	010005b7          	lui	a1,0x1000
    8020b3f0:	fff58593          	addi	a1,a1,-1 # ffffff <_start-0x7f200001>
    8020b3f4:	00e59593          	slli	a1,a1,0xe
    8020b3f8:	00048513          	mv	a0,s1
    8020b3fc:	ffffe097          	auipc	ra,0xffffe
    8020b400:	e74080e7          	jalr	-396(ra) # 80209270 <pageInsert>

    old_pagetable = p->pgdir;
    8020b404:	040a3d03          	ld	s10,64(s4)
    p->pgdir = pagetable;
    8020b408:	049a3023          	sd	s1,64(s4)
    MSG_PRINT("setup");


    MSG_PRINT("lock file success");
    // Check ELF header
    if (eread(de, 0, (u64)&elf, 0, sizeof(elf)) != sizeof(elf)){
    8020b40c:	04000713          	li	a4,64
    8020b410:	00000693          	li	a3,0
    8020b414:	ce040613          	addi	a2,s0,-800
    8020b418:	00000593          	li	a1,0
    8020b41c:	00090513          	mv	a0,s2
    8020b420:	ffff8097          	auipc	ra,0xffff8
    8020b424:	97c080e7          	jalr	-1668(ra) # 80202d9c <eread>
    8020b428:	04000793          	li	a5,64
    8020b42c:	00f51863          	bne	a0,a5,8020b43c <exec+0x21c>
int loadElf(u8 *binary, int size, u64 *entry, void *userData, 
    int (*map)(u64, u32, u8*, u32, void*));

inline bool is_elf_format(u8 *binary) {
    u8 *magic = ((Indent*) binary)->magic;
    if (magic[0] == ELF_MAGIC0 &&
    8020b430:	ce044703          	lbu	a4,-800(s0)
    8020b434:	07f00793          	li	a5,127
    8020b438:	0cf70a63          	beq	a4,a5,8020b50c <exec+0x2ec>
    asm volatile("fence.i");
    // printf("[exec]exec finish %s\n", path);
    return 0;  // this ends up in a0, the first argument to main(argc, argv)

bad:
    p->pgdir = old_pagetable;
    8020b43c:	05aa3023          	sd	s10,64(s4)
    if (pagetable)
        pgdirFree((u64*)pagetable);
    8020b440:	00048513          	mv	a0,s1
    8020b444:	ffffe097          	auipc	ra,0xffffe
    8020b448:	cb8080e7          	jalr	-840(ra) # 802090fc <pgdirFree>
    return -1;
    8020b44c:	fff00493          	li	s1,-1
}
    8020b450:	00048513          	mv	a0,s1
    8020b454:	51813083          	ld	ra,1304(sp)
    8020b458:	51013403          	ld	s0,1296(sp)
    8020b45c:	50813483          	ld	s1,1288(sp)
    8020b460:	50013903          	ld	s2,1280(sp)
    8020b464:	4f813983          	ld	s3,1272(sp)
    8020b468:	4f013a03          	ld	s4,1264(sp)
    8020b46c:	4e813a83          	ld	s5,1256(sp)
    8020b470:	4e013b03          	ld	s6,1248(sp)
    8020b474:	4d813b83          	ld	s7,1240(sp)
    8020b478:	4d013c03          	ld	s8,1232(sp)
    8020b47c:	4c813c83          	ld	s9,1224(sp)
    8020b480:	4c013d03          	ld	s10,1216(sp)
    8020b484:	4b813d83          	ld	s11,1208(sp)
    8020b488:	52010113          	addi	sp,sp,1312
    8020b48c:	00008067          	ret
        eunlock(de);
    8020b490:	00090513          	mv	a0,s2
    8020b494:	ffff8097          	auipc	ra,0xffff8
    8020b498:	160080e7          	jalr	352(ra) # 802035f4 <eunlock>
        eput(de);
    8020b49c:	00090513          	mv	a0,s2
    8020b4a0:	ffff8097          	auipc	ra,0xffff8
    8020b4a4:	16c080e7          	jalr	364(ra) # 8020360c <eput>
        return load_script(bprmbuf, path, argv);
    8020b4a8:	af843603          	ld	a2,-1288(s0)
    8020b4ac:	00048593          	mv	a1,s1
    8020b4b0:	c2840513          	addi	a0,s0,-984
    8020b4b4:	00001097          	auipc	ra,0x1
    8020b4b8:	8ec080e7          	jalr	-1812(ra) # 8020bda0 <load_script>
    8020b4bc:	00050493          	mv	s1,a0
    8020b4c0:	f91ff06f          	j	8020b450 <exec+0x230>
        panic("setup page alloc error\n");
    8020b4c4:	0000b697          	auipc	a3,0xb
    8020b4c8:	82c68693          	addi	a3,a3,-2004 # 80215cf0 <__func__.0+0x70>
    8020b4cc:	0000b617          	auipc	a2,0xb
    8020b4d0:	2f460613          	addi	a2,a2,756 # 802167c0 <__func__.1>
    8020b4d4:	14a00593          	li	a1,330
    8020b4d8:	0000a517          	auipc	a0,0xa
    8020b4dc:	7c050513          	addi	a0,a0,1984 # 80215c98 <__func__.0+0x18>
    8020b4e0:	ffff6097          	auipc	ra,0xffff6
    8020b4e4:	a08080e7          	jalr	-1528(ra) # 80200ee8 <_panic_>
        panic("setup stack alloc error\n");
    8020b4e8:	0000b697          	auipc	a3,0xb
    8020b4ec:	82068693          	addi	a3,a3,-2016 # 80215d08 <__func__.0+0x88>
    8020b4f0:	0000b617          	auipc	a2,0xb
    8020b4f4:	2d060613          	addi	a2,a2,720 # 802167c0 <__func__.1>
    8020b4f8:	15b00593          	li	a1,347
    8020b4fc:	0000a517          	auipc	a0,0xa
    8020b500:	79c50513          	addi	a0,a0,1948 # 80215c98 <__func__.0+0x18>
    8020b504:	ffff6097          	auipc	ra,0xffff6
    8020b508:	9e4080e7          	jalr	-1564(ra) # 80200ee8 <_panic_>
    8020b50c:	ce144703          	lbu	a4,-799(s0)
    8020b510:	04500793          	li	a5,69
    8020b514:	f2f714e3          	bne	a4,a5,8020b43c <exec+0x21c>
        magic[1] == ELF_MAGIC1 &&
    8020b518:	ce244703          	lbu	a4,-798(s0)
    8020b51c:	04c00793          	li	a5,76
    8020b520:	f0f71ee3          	bne	a4,a5,8020b43c <exec+0x21c>
    if (!is_elf_format((u8*) &elf)){
    8020b524:	ce344703          	lbu	a4,-797(s0)
    8020b528:	04600793          	li	a5,70
    8020b52c:	f0f718e3          	bne	a4,a5,8020b43c <exec+0x21c>
    p->execFile = de;
    8020b530:	000027b7          	lui	a5,0x2
    8020b534:	00fa07b3          	add	a5,s4,a5
    8020b538:	0927b023          	sd	s2,128(a5) # 2080 <_start-0x801fdf80>
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b53c:	d0042983          	lw	s3,-768(s0)
    8020b540:	d1845783          	lhu	a5,-744(s0)
    8020b544:	040786e3          	beqz	a5,8020bd90 <exec+0xb70>
    u64 phdr_addr = 0; // virtual address in user space, point to the program header. We will pass 'phdr_addr' to ld.so
    8020b548:	ae043423          	sd	zero,-1304(s0)
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b54c:	00000a93          	li	s5,0
        if (ph.type != PT_LOAD)
    8020b550:	00100b13          	li	s6,1
            psm->flag = PTE_READ | PTE_WRITE | MAP_ZERO;
    8020b554:	00700c93          	li	s9,7
    psm->next = p->segmentMapHead;
    8020b558:	00002c37          	lui	s8,0x2
    8020b55c:	018a0c33          	add	s8,s4,s8
            psm->flag = PTE_EXECUTE | PTE_READ | PTE_WRITE;
    8020b560:	00e00d93          	li	s11,14
    8020b564:	0a40006f          	j	8020b608 <exec+0x3e8>
            segmentMapAlloc(&psm);
    8020b568:	b0040513          	addi	a0,s0,-1280
    8020b56c:	fffff097          	auipc	ra,0xfffff
    8020b570:	6c8080e7          	jalr	1736(ra) # 8020ac34 <segmentMapAlloc>
            psm->sourceFile = de;
    8020b574:	b0043783          	ld	a5,-1280(s0)
    8020b578:	0127b023          	sd	s2,0(a5)
            psm->va = ph.vaddr;
    8020b57c:	cb843703          	ld	a4,-840(s0)
    8020b580:	00e7b423          	sd	a4,8(a5)
            psm->fileOffset = ph.offset;
    8020b584:	cb043703          	ld	a4,-848(s0)
    8020b588:	00e7b823          	sd	a4,16(a5)
            psm->len = ph.filesz;
    8020b58c:	cc843703          	ld	a4,-824(s0)
    8020b590:	00e7ac23          	sw	a4,24(a5)
            psm->flag = PTE_EXECUTE | PTE_READ | PTE_WRITE;
    8020b594:	01b7ae23          	sw	s11,28(a5)
    psm->next = p->segmentMapHead;
    8020b598:	0a8c3703          	ld	a4,168(s8) # 20a8 <_start-0x801fdf58>
    8020b59c:	02e7b023          	sd	a4,32(a5)
    p->segmentMapHead = psm;
    8020b5a0:	0afc3423          	sd	a5,168(s8)
}
    8020b5a4:	0a40006f          	j	8020b648 <exec+0x428>
            segmentMapAlloc(&psm);
    8020b5a8:	b0040513          	addi	a0,s0,-1280
    8020b5ac:	fffff097          	auipc	ra,0xfffff
    8020b5b0:	688080e7          	jalr	1672(ra) # 8020ac34 <segmentMapAlloc>
            psm->sourceFile = NULL;
    8020b5b4:	b0043783          	ld	a5,-1280(s0)
    8020b5b8:	0007b023          	sd	zero,0(a5)
            psm->va = ph.vaddr + ph.filesz;
    8020b5bc:	cb843703          	ld	a4,-840(s0)
    8020b5c0:	cc843683          	ld	a3,-824(s0)
    8020b5c4:	00d70733          	add	a4,a4,a3
    8020b5c8:	00e7b423          	sd	a4,8(a5)
            psm->fileOffset = 0;
    8020b5cc:	0007b823          	sd	zero,16(a5)
            psm->len = ph.memsz - ph.filesz;
    8020b5d0:	cd043703          	ld	a4,-816(s0)
    8020b5d4:	cc843683          	ld	a3,-824(s0)
    8020b5d8:	40d7073b          	subw	a4,a4,a3
    8020b5dc:	00e7ac23          	sw	a4,24(a5)
            psm->flag = PTE_READ | PTE_WRITE | MAP_ZERO;
    8020b5e0:	0197ae23          	sw	s9,28(a5)
    psm->next = p->segmentMapHead;
    8020b5e4:	0a8c3703          	ld	a4,168(s8)
    8020b5e8:	02e7b023          	sd	a4,32(a5)
    p->segmentMapHead = psm;
    8020b5ec:	0afc3423          	sd	a5,168(s8)
}
    8020b5f0:	0640006f          	j	8020b654 <exec+0x434>
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b5f4:	001a8a9b          	addiw	s5,s5,1
    8020b5f8:	0389899b          	addiw	s3,s3,56
    8020b5fc:	d1845783          	lhu	a5,-744(s0)
    8020b600:	0007871b          	sext.w	a4,a5
    8020b604:	06eade63          	bge	s5,a4,8020b680 <exec+0x460>
        if (eread(de, 0, (u64)&ph, off, sizeof(ph)) != sizeof(ph)) {
    8020b608:	0009899b          	sext.w	s3,s3
    8020b60c:	03800713          	li	a4,56
    8020b610:	00098693          	mv	a3,s3
    8020b614:	ca840613          	addi	a2,s0,-856
    8020b618:	00000593          	li	a1,0
    8020b61c:	00090513          	mv	a0,s2
    8020b620:	ffff7097          	auipc	ra,0xffff7
    8020b624:	77c080e7          	jalr	1916(ra) # 80202d9c <eread>
    8020b628:	03800793          	li	a5,56
    8020b62c:	e0f518e3          	bne	a0,a5,8020b43c <exec+0x21c>
        if (ph.type != PT_LOAD)
    8020b630:	ca842783          	lw	a5,-856(s0)
    8020b634:	fd6790e3          	bne	a5,s6,8020b5f4 <exec+0x3d4>
        if (ph.memsz < ph.filesz)
    8020b638:	cc843783          	ld	a5,-824(s0)
    8020b63c:	cd043703          	ld	a4,-816(s0)
    8020b640:	def76ee3          	bltu	a4,a5,8020b43c <exec+0x21c>
        if (ph.filesz > 0) {
    8020b644:	f20792e3          	bnez	a5,8020b568 <exec+0x348>
        if (ph.memsz > ph.filesz) {
    8020b648:	cd043703          	ld	a4,-816(s0)
    8020b64c:	cc843783          	ld	a5,-824(s0)
    8020b650:	f4e7ece3          	bltu	a5,a4,8020b5a8 <exec+0x388>
        if (ph.offset <= elf.phoff && elf.phoff < ph.offset + ph.filesz) {
    8020b654:	cb043703          	ld	a4,-848(s0)
    8020b658:	d0043783          	ld	a5,-768(s0)
    8020b65c:	f8e7ece3          	bltu	a5,a4,8020b5f4 <exec+0x3d4>
    8020b660:	cc843683          	ld	a3,-824(s0)
    8020b664:	00d706b3          	add	a3,a4,a3
    8020b668:	f8d7f6e3          	bgeu	a5,a3,8020b5f4 <exec+0x3d4>
            phdr_addr = elf.phoff - ph.offset + ph.vaddr;
    8020b66c:	cb843683          	ld	a3,-840(s0)
    8020b670:	00d787b3          	add	a5,a5,a3
    8020b674:	40e787b3          	sub	a5,a5,a4
    8020b678:	aef43423          	sd	a5,-1304(s0)
    8020b67c:	f79ff06f          	j	8020b5f4 <exec+0x3d4>
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b680:	d0042983          	lw	s3,-768(s0)
    8020b684:	70078863          	beqz	a5,8020bd94 <exec+0xb74>
    Dirent* interpreter = NULL;
    8020b688:	00000b13          	li	s6,0
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b68c:	00000a93          	li	s5,0
        if (ph.type == PT_GNU_PROPERTY) {
    8020b690:	6474ec37          	lui	s8,0x6474e
    8020b694:	553c0c13          	addi	s8,s8,1363 # 6474e553 <_start-0x1bab1aad>
        if (ph.type != PT_INTERP)
    8020b698:	00300c93          	li	s9,3
        if (ph.filesz > 4096 || ph.filesz < 2)
    8020b69c:	00001db7          	lui	s11,0x1
    8020b6a0:	ffed8d93          	addi	s11,s11,-2 # ffe <_start-0x801ff002>
    8020b6a4:	1100006f          	j	8020b7b4 <exec+0x594>
            panic("do not support PT_GNU_PROPERTY Segment");
    8020b6a8:	0000a697          	auipc	a3,0xa
    8020b6ac:	68068693          	addi	a3,a3,1664 # 80215d28 <__func__.0+0xa8>
    8020b6b0:	0000b617          	auipc	a2,0xb
    8020b6b4:	11060613          	addi	a2,a2,272 # 802167c0 <__func__.1>
    8020b6b8:	1a600593          	li	a1,422
    8020b6bc:	0000a517          	auipc	a0,0xa
    8020b6c0:	5dc50513          	addi	a0,a0,1500 # 80215c98 <__func__.0+0x18>
    8020b6c4:	ffff6097          	auipc	ra,0xffff6
    8020b6c8:	824080e7          	jalr	-2012(ra) # 80200ee8 <_panic_>
            panic("interpreter path too long !");
    8020b6cc:	0000a697          	auipc	a3,0xa
    8020b6d0:	68468693          	addi	a3,a3,1668 # 80215d50 <__func__.0+0xd0>
    8020b6d4:	0000b617          	auipc	a2,0xb
    8020b6d8:	0ec60613          	addi	a2,a2,236 # 802167c0 <__func__.1>
    8020b6dc:	1af00593          	li	a1,431
    8020b6e0:	0000a517          	auipc	a0,0xa
    8020b6e4:	5b850513          	addi	a0,a0,1464 # 80215c98 <__func__.0+0x18>
    8020b6e8:	ffff6097          	auipc	ra,0xffff6
    8020b6ec:	800080e7          	jalr	-2048(ra) # 80200ee8 <_panic_>
            panic("Alloc page for elf_interpreter error!");
    8020b6f0:	0000a697          	auipc	a3,0xa
    8020b6f4:	68068693          	addi	a3,a3,1664 # 80215d70 <__func__.0+0xf0>
    8020b6f8:	0000b617          	auipc	a2,0xb
    8020b6fc:	0c860613          	addi	a2,a2,200 # 802167c0 <__func__.1>
    8020b700:	1b300593          	li	a1,435
    8020b704:	0000a517          	auipc	a0,0xa
    8020b708:	59450513          	addi	a0,a0,1428 # 80215c98 <__func__.0+0x18>
    8020b70c:	ffff5097          	auipc	ra,0xffff5
    8020b710:	7dc080e7          	jalr	2012(ra) # 80200ee8 <_panic_>
            panic("read interp path error");
    8020b714:	0000a697          	auipc	a3,0xa
    8020b718:	68468693          	addi	a3,a3,1668 # 80215d98 <__func__.0+0x118>
    8020b71c:	0000b617          	auipc	a2,0xb
    8020b720:	0a460613          	addi	a2,a2,164 # 802167c0 <__func__.1>
    8020b724:	1b700593          	li	a1,439
    8020b728:	0000a517          	auipc	a0,0xa
    8020b72c:	57050513          	addi	a0,a0,1392 # 80215c98 <__func__.0+0x18>
    8020b730:	ffff5097          	auipc	ra,0xffff5
    8020b734:	7b8080e7          	jalr	1976(ra) # 80200ee8 <_panic_>
            panic("interpreter path is not NULL terminated");
    8020b738:	0000a697          	auipc	a3,0xa
    8020b73c:	67868693          	addi	a3,a3,1656 # 80215db0 <__func__.0+0x130>
    8020b740:	0000b617          	auipc	a2,0xb
    8020b744:	08060613          	addi	a2,a2,128 # 802167c0 <__func__.1>
    8020b748:	1bb00593          	li	a1,443
    8020b74c:	0000a517          	auipc	a0,0xa
    8020b750:	54c50513          	addi	a0,a0,1356 # 80215c98 <__func__.0+0x18>
    8020b754:	ffff5097          	auipc	ra,0xffff5
    8020b758:	794080e7          	jalr	1940(ra) # 80200ee8 <_panic_>
            panic("open interpreter error!");
    8020b75c:	0000a697          	auipc	a3,0xa
    8020b760:	67c68693          	addi	a3,a3,1660 # 80215dd8 <__func__.0+0x158>
    8020b764:	0000b617          	auipc	a2,0xb
    8020b768:	05c60613          	addi	a2,a2,92 # 802167c0 <__func__.1>
    8020b76c:	1c100593          	li	a1,449
    8020b770:	0000a517          	auipc	a0,0xa
    8020b774:	52850513          	addi	a0,a0,1320 # 80215c98 <__func__.0+0x18>
    8020b778:	ffff5097          	auipc	ra,0xffff5
    8020b77c:	770080e7          	jalr	1904(ra) # 80200ee8 <_panic_>
            panic("Alloc page for interpreter Elf_Header error!");
    8020b780:	0000a697          	auipc	a3,0xa
    8020b784:	67068693          	addi	a3,a3,1648 # 80215df0 <__func__.0+0x170>
    8020b788:	0000b617          	auipc	a2,0xb
    8020b78c:	03860613          	addi	a2,a2,56 # 802167c0 <__func__.1>
    8020b790:	1c500593          	li	a1,453
    8020b794:	0000a517          	auipc	a0,0xa
    8020b798:	50450513          	addi	a0,a0,1284 # 80215c98 <__func__.0+0x18>
    8020b79c:	ffff5097          	auipc	ra,0xffff5
    8020b7a0:	74c080e7          	jalr	1868(ra) # 80200ee8 <_panic_>
    for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
    8020b7a4:	001a8a9b          	addiw	s5,s5,1
    8020b7a8:	0389899b          	addiw	s3,s3,56
    8020b7ac:	d1845783          	lhu	a5,-744(s0)
    8020b7b0:	10fad663          	bge	s5,a5,8020b8bc <exec+0x69c>
        if (eread(de, 0, (u64)&ph, off, sizeof(ph)) != sizeof(ph)) {
    8020b7b4:	0009899b          	sext.w	s3,s3
    8020b7b8:	03800713          	li	a4,56
    8020b7bc:	00098693          	mv	a3,s3
    8020b7c0:	ca840613          	addi	a2,s0,-856
    8020b7c4:	00000593          	li	a1,0
    8020b7c8:	00090513          	mv	a0,s2
    8020b7cc:	ffff7097          	auipc	ra,0xffff7
    8020b7d0:	5d0080e7          	jalr	1488(ra) # 80202d9c <eread>
    8020b7d4:	03800793          	li	a5,56
    8020b7d8:	c6f512e3          	bne	a0,a5,8020b43c <exec+0x21c>
        if (ph.type == PT_GNU_PROPERTY) {
    8020b7dc:	ca842783          	lw	a5,-856(s0)
    8020b7e0:	ed8784e3          	beq	a5,s8,8020b6a8 <exec+0x488>
        if (ph.type != PT_INTERP)
    8020b7e4:	fd9790e3          	bne	a5,s9,8020b7a4 <exec+0x584>
        if (ph.memsz < ph.filesz)
    8020b7e8:	cc843503          	ld	a0,-824(s0)
    8020b7ec:	cd043783          	ld	a5,-816(s0)
    8020b7f0:	c4a7e6e3          	bltu	a5,a0,8020b43c <exec+0x21c>
        if (ph.filesz > 4096 || ph.filesz < 2)
    8020b7f4:	ffe50793          	addi	a5,a0,-2
    8020b7f8:	ecfdeae3          	bltu	s11,a5,8020b6cc <exec+0x4ac>
        char* elf_interpreter = kmalloc(ph.filesz, 0);
    8020b7fc:	00000593          	li	a1,0
    8020b800:	0005051b          	sext.w	a0,a0
    8020b804:	fffff097          	auipc	ra,0xfffff
    8020b808:	648080e7          	jalr	1608(ra) # 8020ae4c <kmalloc>
    8020b80c:	00050b13          	mv	s6,a0
        if (!elf_interpreter)
    8020b810:	ee0500e3          	beqz	a0,8020b6f0 <exec+0x4d0>
        retval = eread(de, 0, (u64)elf_interpreter, ph.offset, ph.filesz);
    8020b814:	cc842703          	lw	a4,-824(s0)
    8020b818:	cb042683          	lw	a3,-848(s0)
    8020b81c:	00050613          	mv	a2,a0
    8020b820:	00000593          	li	a1,0
    8020b824:	00090513          	mv	a0,s2
    8020b828:	ffff7097          	auipc	ra,0xffff7
    8020b82c:	574080e7          	jalr	1396(ra) # 80202d9c <eread>
        if (retval < 0)
    8020b830:	ee0542e3          	bltz	a0,8020b714 <exec+0x4f4>
        if (elf_interpreter[ph.filesz - 1] != '\0')
    8020b834:	cc843783          	ld	a5,-824(s0)
    8020b838:	00fb07b3          	add	a5,s6,a5
    8020b83c:	fff7c783          	lbu	a5,-1(a5)
    8020b840:	ee079ce3          	bnez	a5,8020b738 <exec+0x518>
        interpreter = ename(AT_FDCWD, elf_interpreter, true);
    8020b844:	00100613          	li	a2,1
    8020b848:	000b0593          	mv	a1,s6
    8020b84c:	f9c00513          	li	a0,-100
    8020b850:	ffff8097          	auipc	ra,0xffff8
    8020b854:	1ec080e7          	jalr	492(ra) # 80203a3c <ename>
    8020b858:	00050b13          	mv	s6,a0
        if (interpreter == NULL)
    8020b85c:	f00500e3          	beqz	a0,8020b75c <exec+0x53c>
        interp_elf_ex = kmalloc(sizeof(*interp_elf_ex), 0);
    8020b860:	00000593          	li	a1,0
    8020b864:	04000513          	li	a0,64
    8020b868:	fffff097          	auipc	ra,0xfffff
    8020b86c:	5e4080e7          	jalr	1508(ra) # 8020ae4c <kmalloc>
    8020b870:	00050b93          	mv	s7,a0
        if (!interp_elf_ex) {
    8020b874:	f00506e3          	beqz	a0,8020b780 <exec+0x560>
        retval = eread(interpreter, 0, (u64)interp_elf_ex, 0,
    8020b878:	04000713          	li	a4,64
    8020b87c:	00000693          	li	a3,0
    8020b880:	00050613          	mv	a2,a0
    8020b884:	00000593          	li	a1,0
    8020b888:	000b0513          	mv	a0,s6
    8020b88c:	ffff7097          	auipc	ra,0xffff7
    8020b890:	510080e7          	jalr	1296(ra) # 80202d9c <eread>
        if (retval < 0)
    8020b894:	f00558e3          	bgez	a0,8020b7a4 <exec+0x584>
            panic("read interpreter file error");
    8020b898:	0000a697          	auipc	a3,0xa
    8020b89c:	58868693          	addi	a3,a3,1416 # 80215e20 <__func__.0+0x1a0>
    8020b8a0:	0000b617          	auipc	a2,0xb
    8020b8a4:	f2060613          	addi	a2,a2,-224 # 802167c0 <__func__.1>
    8020b8a8:	1cc00593          	li	a1,460
    8020b8ac:	0000a517          	auipc	a0,0xa
    8020b8b0:	3ec50513          	addi	a0,a0,1004 # 80215c98 <__func__.0+0x18>
    8020b8b4:	ffff5097          	auipc	ra,0xffff5
    8020b8b8:	634080e7          	jalr	1588(ra) # 80200ee8 <_panic_>
    if (interpreter) {
    8020b8bc:	4c0b0c63          	beqz	s6,8020bd94 <exec+0xb74>
        u64 interp_Phdrs_size = sizeof(Phdr) * interp_elf_ex->phnum;
    8020b8c0:	038bd783          	lhu	a5,56(s7)
    8020b8c4:	00379993          	slli	s3,a5,0x3
    8020b8c8:	40f989b3          	sub	s3,s3,a5
        Phdr* interp_elf_phdata = kmalloc(interp_Phdrs_size, 0);
    8020b8cc:	00399993          	slli	s3,s3,0x3
    8020b8d0:	00000593          	li	a1,0
    8020b8d4:	00098513          	mv	a0,s3
    8020b8d8:	fffff097          	auipc	ra,0xfffff
    8020b8dc:	574080e7          	jalr	1396(ra) # 8020ae4c <kmalloc>
    8020b8e0:	00050a13          	mv	s4,a0
        eread(interpreter, 0, (u64)interp_elf_phdata, interp_elf_ex->phoff,
    8020b8e4:	00098713          	mv	a4,s3
    8020b8e8:	020ba683          	lw	a3,32(s7)
    8020b8ec:	00050613          	mv	a2,a0
    8020b8f0:	00000593          	li	a1,0
    8020b8f4:	000b0513          	mv	a0,s6
    8020b8f8:	ffff7097          	auipc	ra,0xffff7
    8020b8fc:	4a4080e7          	jalr	1188(ra) # 80202d9c <eread>
        elf_entry = load_elf_interp(pagetable, interp_elf_ex, interpreter, load_bias,
    8020b900:	000a0713          	mv	a4,s4
    8020b904:	00000693          	li	a3,0
    8020b908:	000b0613          	mv	a2,s6
    8020b90c:	000b8593          	mv	a1,s7
    8020b910:	00048513          	mv	a0,s1
    8020b914:	fffff097          	auipc	ra,0xfffff
    8020b918:	620080e7          	jalr	1568(ra) # 8020af34 <load_elf_interp>
    8020b91c:	aea43023          	sd	a0,-1312(s0)
        elf_entry += interp_elf_ex->entry;
    8020b920:	018bb783          	ld	a5,24(s7)
    8020b924:	00f50db3          	add	s11,a0,a5
    p = myProcess();
    8020b928:	00004097          	auipc	ra,0x4
    8020b92c:	0c0080e7          	jalr	192(ra) # 8020f9e8 <myProcess>
    8020b930:	00050a13          	mv	s4,a0
    if (pageAlloc(&page)){
    8020b934:	c2040513          	addi	a0,s0,-992
    8020b938:	ffffd097          	auipc	ra,0xffffd
    8020b93c:	584080e7          	jalr	1412(ra) # 80208ebc <pageAlloc>
    8020b940:	ae051ee3          	bnez	a0,8020b43c <exec+0x21c>
    return page - pages;
    8020b944:	c2043783          	ld	a5,-992(s0)
    8020b948:	018fb717          	auipc	a4,0x18fb
    8020b94c:	5b870713          	addi	a4,a4,1464 # 81b06f00 <pages>
    8020b950:	40e787b3          	sub	a5,a5,a4
    8020b954:	4037d793          	srai	a5,a5,0x3
    8020b958:	0000b717          	auipc	a4,0xb
    8020b95c:	ea073703          	ld	a4,-352(a4) # 802167f8 <__func__.0+0x20>
    8020b960:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020b964:	00c7979b          	slliw	a5,a5,0xc
    8020b968:	02079793          	slli	a5,a5,0x20
    8020b96c:	0207d793          	srli	a5,a5,0x20
    pageInsert(pagetable, stackbase, page2pa(page),
    8020b970:	01e00693          	li	a3,30
    8020b974:	00100613          	li	a2,1
    8020b978:	01f61613          	slli	a2,a2,0x1f
    8020b97c:	00c78633          	add	a2,a5,a2
    8020b980:	010005b7          	lui	a1,0x1000
    8020b984:	fff58593          	addi	a1,a1,-1 # ffffff <_start-0x7f200001>
    8020b988:	00e59593          	slli	a1,a1,0xe
    8020b98c:	00048513          	mv	a0,s1
    8020b990:	ffffe097          	auipc	ra,0xffffe
    8020b994:	8e0080e7          	jalr	-1824(ra) # 80209270 <pageInsert>
    for (argc = 0; argv[argc]; argc++) {
    8020b998:	af843783          	ld	a5,-1288(s0)
    8020b99c:	0007b503          	ld	a0,0(a5)
    8020b9a0:	08050c63          	beqz	a0,8020ba38 <exec+0x818>
    8020b9a4:	d2840a93          	addi	s5,s0,-728
    8020b9a8:	e2840c93          	addi	s9,s0,-472
    sp = USER_STACK_TOP;
    8020b9ac:	040009b7          	lui	s3,0x4000
    8020b9b0:	ffd98993          	addi	s3,s3,-3 # 3fffffd <_start-0x7c200003>
    8020b9b4:	00c99993          	slli	s3,s3,0xc
    for (argc = 0; argv[argc]; argc++) {
    8020b9b8:	00000b93          	li	s7,0
        if (sp < stackbase)
    8020b9bc:	fbfff7b7          	lui	a5,0xfbfff
    8020b9c0:	00e79793          	slli	a5,a5,0xe
    8020b9c4:	01a7dc13          	srli	s8,a5,0x1a
        sp -= strlen(argv[argc]) + 1;
    8020b9c8:	00003097          	auipc	ra,0x3
    8020b9cc:	5b4080e7          	jalr	1460(ra) # 8020ef7c <strlen>
    8020b9d0:	0015079b          	addiw	a5,a0,1
    8020b9d4:	40f987b3          	sub	a5,s3,a5
        sp -= sp % 16;  // riscv sp must be 16-byte aligned
    8020b9d8:	ff07f993          	andi	s3,a5,-16
        if (sp < stackbase)
    8020b9dc:	a73c70e3          	bgeu	s8,s3,8020b43c <exec+0x21c>
        if (copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
    8020b9e0:	af843783          	ld	a5,-1288(s0)
    8020b9e4:	0007bb03          	ld	s6,0(a5) # fffffffffbfff000 <bssEnd+0xffffffff79c8f000>
    8020b9e8:	000b0513          	mv	a0,s6
    8020b9ec:	00003097          	auipc	ra,0x3
    8020b9f0:	590080e7          	jalr	1424(ra) # 8020ef7c <strlen>
    8020b9f4:	0015069b          	addiw	a3,a0,1
    8020b9f8:	000b0613          	mv	a2,s6
    8020b9fc:	00098593          	mv	a1,s3
    8020ba00:	00048513          	mv	a0,s1
    8020ba04:	ffffe097          	auipc	ra,0xffffe
    8020ba08:	134080e7          	jalr	308(ra) # 80209b38 <copyout>
    8020ba0c:	a20548e3          	bltz	a0,8020b43c <exec+0x21c>
        ustack[argc + 1] = sp;
    8020ba10:	001b8b93          	addi	s7,s7,1
    8020ba14:	013ab023          	sd	s3,0(s5)
    for (argc = 0; argv[argc]; argc++) {
    8020ba18:	af843783          	ld	a5,-1288(s0)
    8020ba1c:	00878793          	addi	a5,a5,8
    8020ba20:	aef43c23          	sd	a5,-1288(s0)
    8020ba24:	0007b503          	ld	a0,0(a5)
    8020ba28:	02050063          	beqz	a0,8020ba48 <exec+0x828>
        if (argc >= MAXARG)
    8020ba2c:	008a8a93          	addi	s5,s5,8
    8020ba30:	f95c9ce3          	bne	s9,s5,8020b9c8 <exec+0x7a8>
    8020ba34:	a09ff06f          	j	8020b43c <exec+0x21c>
    sp = USER_STACK_TOP;
    8020ba38:	040009b7          	lui	s3,0x4000
    8020ba3c:	ffd98993          	addi	s3,s3,-3 # 3fffffd <_start-0x7c200003>
    8020ba40:	00c99993          	slli	s3,s3,0xc
    for (argc = 0; argv[argc]; argc++) {
    8020ba44:	00000b93          	li	s7,0
    ustack[0] = argc;
    8020ba48:	d3743023          	sd	s7,-736(s0)
    ustack[argc + 1] = 0;
    8020ba4c:	001b8793          	addi	a5,s7,1
    8020ba50:	00379793          	slli	a5,a5,0x3
    8020ba54:	f9078793          	addi	a5,a5,-112
    8020ba58:	008787b3          	add	a5,a5,s0
    8020ba5c:	d807b823          	sd	zero,-624(a5)
    char *envVariable[] = {"LD_LIBRARY_PATH=/", "PATH=/"/*, "LOOP_O=1", "TIMING_O=1", "ENOUGH=1"*/};
    8020ba60:	0000a797          	auipc	a5,0xa
    8020ba64:	3e078793          	addi	a5,a5,992 # 80215e40 <__func__.0+0x1c0>
    8020ba68:	c0f43823          	sd	a5,-1008(s0)
    8020ba6c:	0000a797          	auipc	a5,0xa
    8020ba70:	3ec78793          	addi	a5,a5,1004 # 80215e58 <__func__.0+0x1d8>
    8020ba74:	c0f43c23          	sd	a5,-1000(s0)
    for (i = 0; i < envCount; i++) {
    8020ba78:	c1040a93          	addi	s5,s0,-1008
    8020ba7c:	002b8793          	addi	a5,s7,2
    8020ba80:	00379793          	slli	a5,a5,0x3
    8020ba84:	aef43c23          	sd	a5,-1288(s0)
    8020ba88:	d2040713          	addi	a4,s0,-736
    8020ba8c:	00f70c33          	add	s8,a4,a5
        if (sp < stackbase)
    8020ba90:	fbfff7b7          	lui	a5,0xfbfff
    8020ba94:	00e79793          	slli	a5,a5,0xe
    8020ba98:	01a7dc93          	srli	s9,a5,0x1a
        sp -= strlen(envVariable[i]) + 1;
    8020ba9c:	000abb03          	ld	s6,0(s5)
    8020baa0:	000b0513          	mv	a0,s6
    8020baa4:	00003097          	auipc	ra,0x3
    8020baa8:	4d8080e7          	jalr	1240(ra) # 8020ef7c <strlen>
    8020baac:	0015079b          	addiw	a5,a0,1
    8020bab0:	40f987b3          	sub	a5,s3,a5
        sp -= sp % 16;  // riscv sp must be 16-byte aligned
    8020bab4:	ff07f993          	andi	s3,a5,-16
        if (sp < stackbase)
    8020bab8:	993cf2e3          	bgeu	s9,s3,8020b43c <exec+0x21c>
        if (copyout(pagetable, sp, envVariable[i], strlen(envVariable[i]) + 1) < 0)
    8020babc:	000b0513          	mv	a0,s6
    8020bac0:	00003097          	auipc	ra,0x3
    8020bac4:	4bc080e7          	jalr	1212(ra) # 8020ef7c <strlen>
    8020bac8:	0015069b          	addiw	a3,a0,1
    8020bacc:	000b0613          	mv	a2,s6
    8020bad0:	00098593          	mv	a1,s3
    8020bad4:	00048513          	mv	a0,s1
    8020bad8:	ffffe097          	auipc	ra,0xffffe
    8020badc:	060080e7          	jalr	96(ra) # 80209b38 <copyout>
    8020bae0:	94054ee3          	bltz	a0,8020b43c <exec+0x21c>
        ustack[argc + 2 + i] = sp;
    8020bae4:	013c3023          	sd	s3,0(s8)
    for (i = 0; i < envCount; i++) {
    8020bae8:	008a8a93          	addi	s5,s5,8
    8020baec:	008c0c13          	addi	s8,s8,8
    8020baf0:	c2040793          	addi	a5,s0,-992
    8020baf4:	fb5794e3          	bne	a5,s5,8020ba9c <exec+0x87c>
    ustack[argc + 2 + envCount] = 0;
    8020baf8:	004b8793          	addi	a5,s7,4
    8020bafc:	00379793          	slli	a5,a5,0x3
    8020bb00:	f9078793          	addi	a5,a5,-112 # fffffffffbffef90 <bssEnd+0xffffffff79c8ef90>
    8020bb04:	008787b3          	add	a5,a5,s0
    8020bb08:	d807b823          	sd	zero,-624(a5)
    sp -= 32;
    8020bb0c:	fe098993          	addi	s3,s3,-32
    if (sp < stackbase)
    8020bb10:	fbfff7b7          	lui	a5,0xfbfff
    8020bb14:	00e79793          	slli	a5,a5,0xe
    8020bb18:	01a7d793          	srli	a5,a5,0x1a
    8020bb1c:	9337f0e3          	bgeu	a5,s3,8020b43c <exec+0x21c>
    if (copyout(pagetable, sp, (char *)k_rand_bytes, sizeof(k_rand_bytes)) < 0)
    8020bb20:	01000693          	li	a3,16
    8020bb24:	0000b617          	auipc	a2,0xb
    8020bb28:	4fc60613          	addi	a2,a2,1276 # 80217020 <k_rand_bytes.0>
    8020bb2c:	00098593          	mv	a1,s3
    8020bb30:	00048513          	mv	a0,s1
    8020bb34:	ffffe097          	auipc	ra,0xffffe
    8020bb38:	004080e7          	jalr	4(ra) # 80209b38 <copyout>
    8020bb3c:	900540e3          	bltz	a0,8020b43c <exec+0x21c>
    u64* elf_info = ustack + (argc + envCount + 3) ;
    8020bb40:	d2040713          	addi	a4,s0,-736
    8020bb44:	af843783          	ld	a5,-1288(s0)
    8020bb48:	01878793          	addi	a5,a5,24 # fffffffffbfff018 <bssEnd+0xffffffff79c8f018>
    8020bb4c:	00f707b3          	add	a5,a4,a5
	NEW_AUX_ENT(AT_HWCAP, ELF_HWCAP); //CPU的extension信息
    8020bb50:	01000693          	li	a3,16
    8020bb54:	00d7b023          	sd	a3,0(a5)
    8020bb58:	0007b423          	sd	zero,8(a5)
	NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE); //PAGE_SIZE
    8020bb5c:	00600693          	li	a3,6
    8020bb60:	00d7b823          	sd	a3,16(a5)
    8020bb64:	000016b7          	lui	a3,0x1
    8020bb68:	00d7bc23          	sd	a3,24(a5)
	NEW_AUX_ENT(AT_PHDR, phdr_addr);// Phdr * phdr_addr; 指向用户态。
    8020bb6c:	00300693          	li	a3,3
    8020bb70:	02d7b023          	sd	a3,32(a5)
    8020bb74:	ae843683          	ld	a3,-1304(s0)
    8020bb78:	02d7b423          	sd	a3,40(a5)
	NEW_AUX_ENT(AT_PHENT, sizeof(Phdr)); //每个 Phdr 的大小
    8020bb7c:	00400693          	li	a3,4
    8020bb80:	02d7b823          	sd	a3,48(a5)
    8020bb84:	03800693          	li	a3,56
    8020bb88:	02d7bc23          	sd	a3,56(a5)
	NEW_AUX_ENT(AT_PHNUM, elf.phnum); //phdr的数量
    8020bb8c:	00500693          	li	a3,5
    8020bb90:	04d7b023          	sd	a3,64(a5)
    8020bb94:	d1845683          	lhu	a3,-744(s0)
    8020bb98:	04d7b423          	sd	a3,72(a5)
	NEW_AUX_ENT(AT_BASE, interp_load_addr);
    8020bb9c:	00700693          	li	a3,7
    8020bba0:	04d7b823          	sd	a3,80(a5)
    8020bba4:	ae043683          	ld	a3,-1312(s0)
    8020bba8:	04d7bc23          	sd	a3,88(a5)
	NEW_AUX_ENT(AT_ENTRY, elf.entry);//源程序的入口
    8020bbac:	00900693          	li	a3,9
    8020bbb0:	06d7b023          	sd	a3,96(a5)
    8020bbb4:	cf843683          	ld	a3,-776(s0)
    8020bbb8:	06d7b423          	sd	a3,104(a5)
	NEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));// 0
    8020bbbc:	00b00693          	li	a3,11
    8020bbc0:	06d7b823          	sd	a3,112(a5)
    8020bbc4:	0607bc23          	sd	zero,120(a5)
	NEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));// 0
    8020bbc8:	00c00693          	li	a3,12
    8020bbcc:	08d7b023          	sd	a3,128(a5)
    8020bbd0:	0807b423          	sd	zero,136(a5)
	NEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));// 0
    8020bbd4:	00d00693          	li	a3,13
    8020bbd8:	08d7b823          	sd	a3,144(a5)
    8020bbdc:	0807bc23          	sd	zero,152(a5)
	NEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));// 0
    8020bbe0:	00e00693          	li	a3,14
    8020bbe4:	0ad7b023          	sd	a3,160(a5)
    8020bbe8:	0a07b423          	sd	zero,168(a5)
	NEW_AUX_ENT(AT_SECURE, secureexec);//安全，默认1。该模式下不会启用LD_LIBRARY_PATH等
    8020bbec:	01700693          	li	a3,23
    8020bbf0:	0ad7b823          	sd	a3,176(a5)
    8020bbf4:	0a07bc23          	sd	zero,184(a5)
	NEW_AUX_ENT(AT_RANDOM, u_rand_bytes);//16byte随机数的地址。
    8020bbf8:	01900693          	li	a3,25
    8020bbfc:	0cd7b023          	sd	a3,192(a5)
    8020bc00:	0d37b423          	sd	s3,200(a5)
	NEW_AUX_ENT(AT_EXECFN, ustack[1]/*用户态地址*/); /* 传递给动态连接器该程序的名称 */
    8020bc04:	01f00693          	li	a3,31
    8020bc08:	0cd7b823          	sd	a3,208(a5)
    8020bc0c:	d2843683          	ld	a3,-728(s0)
    8020bc10:	0cd7bc23          	sd	a3,216(a5)
    NEW_AUX_ENT(0, 0);
    8020bc14:	0e07b023          	sd	zero,224(a5)
    8020bc18:	0e07b423          	sd	zero,232(a5)
    8020bc1c:	0f078793          	addi	a5,a5,240
    u64 copy_size = (elf_info - ustack) * sizeof(u64);
    8020bc20:	40e786b3          	sub	a3,a5,a4
    sp -= copy_size; /* now elf_info is the stack top */
    8020bc24:	40d989b3          	sub	s3,s3,a3
    sp -= sp % 16;
    8020bc28:	ff09f993          	andi	s3,s3,-16
    if (sp < stackbase)
    8020bc2c:	fbfff7b7          	lui	a5,0xfbfff
    8020bc30:	00e79793          	slli	a5,a5,0xe
    8020bc34:	01a7d793          	srli	a5,a5,0x1a
    8020bc38:	8137f2e3          	bgeu	a5,s3,8020b43c <exec+0x21c>
    if (copyout(pagetable, sp, (char*)ustack, copy_size) < 0)
    8020bc3c:	00070613          	mv	a2,a4
    8020bc40:	00098593          	mv	a1,s3
    8020bc44:	00048513          	mv	a0,s1
    8020bc48:	ffffe097          	auipc	ra,0xffffe
    8020bc4c:	ef0080e7          	jalr	-272(ra) # 80209b38 <copyout>
    8020bc50:	fe054663          	bltz	a0,8020b43c <exec+0x21c>
    getHartTrapFrame()->a1 = sp;
    8020bc54:	ffffe097          	auipc	ra,0xffffe
    8020bc58:	588080e7          	jalr	1416(ra) # 8020a1dc <getHartTrapFrame>
    8020bc5c:	07353c23          	sd	s3,120(a0)
    getHartTrapFrame()->epc = elf_entry;  // initial program counter = main
    8020bc60:	ffffe097          	auipc	ra,0xffffe
    8020bc64:	57c080e7          	jalr	1404(ra) # 8020a1dc <getHartTrapFrame>
    8020bc68:	01b53c23          	sd	s11,24(a0)
    getHartTrapFrame()->sp = sp;          // initial stack pointer
    8020bc6c:	ffffe097          	auipc	ra,0xffffe
    8020bc70:	570080e7          	jalr	1392(ra) # 8020a1dc <getHartTrapFrame>
    8020bc74:	03353823          	sd	s3,48(a0)
    r = getAbsolutePath(de, false, (u64)buf, sizeof(buf));
    8020bc78:	10400693          	li	a3,260
    8020bc7c:	b0840613          	addi	a2,s0,-1272
    8020bc80:	00000593          	li	a1,0
    8020bc84:	00090513          	mv	a0,s2
    8020bc88:	ffffc097          	auipc	ra,0xffffc
    8020bc8c:	38c080e7          	jalr	908(ra) # 80208014 <getAbsolutePath>
    8020bc90:	00050493          	mv	s1,a0
    if (r) {
    8020bc94:	08051463          	bnez	a0,8020bd1c <exec+0xafc>
    eunlock(de);
    8020bc98:	00090513          	mv	a0,s2
    8020bc9c:	ffff8097          	auipc	ra,0xffff8
    8020bca0:	958080e7          	jalr	-1704(ra) # 802035f4 <eunlock>
    eput(de);
    8020bca4:	00090513          	mv	a0,s2
    8020bca8:	ffff8097          	auipc	ra,0xffff8
    8020bcac:	964080e7          	jalr	-1692(ra) # 8020360c <eput>
    de = ename(AT_FDCWD, "/proc/self/exe", false);
    8020bcb0:	00000613          	li	a2,0
    8020bcb4:	0000a597          	auipc	a1,0xa
    8020bcb8:	1ac58593          	addi	a1,a1,428 # 80215e60 <__func__.0+0x1e0>
    8020bcbc:	f9c00513          	li	a0,-100
    8020bcc0:	ffff8097          	auipc	ra,0xffff8
    8020bcc4:	d7c080e7          	jalr	-644(ra) # 80203a3c <ename>
    8020bcc8:	00050913          	mv	s2,a0
    if (!de) {
    8020bccc:	06050a63          	beqz	a0,8020bd40 <exec+0xb20>
    r = ewrite(de, false, (u64)buf, 0, strlen(buf) + 1);
    8020bcd0:	b0840513          	addi	a0,s0,-1272
    8020bcd4:	00003097          	auipc	ra,0x3
    8020bcd8:	2a8080e7          	jalr	680(ra) # 8020ef7c <strlen>
    8020bcdc:	0015071b          	addiw	a4,a0,1
    8020bce0:	00000693          	li	a3,0
    8020bce4:	b0840613          	addi	a2,s0,-1272
    8020bce8:	00000593          	li	a1,0
    8020bcec:	00090513          	mv	a0,s2
    8020bcf0:	ffff7097          	auipc	ra,0xffff7
    8020bcf4:	2e0080e7          	jalr	736(ra) # 80202fd0 <ewrite>
    if (r < 0) {
    8020bcf8:	06054663          	bltz	a0,8020bd64 <exec+0xb44>
    myThread()->clearChildTid = 0;
    8020bcfc:	00005097          	auipc	ra,0x5
    8020bd00:	844080e7          	jalr	-1980(ra) # 80210540 <myThread>
    8020bd04:	40053823          	sd	zero,1040(a0)
    pgdirFree(oldpagetable);
    8020bd08:	af043503          	ld	a0,-1296(s0)
    8020bd0c:	ffffd097          	auipc	ra,0xffffd
    8020bd10:	3f0080e7          	jalr	1008(ra) # 802090fc <pgdirFree>
    asm volatile("fence.i");
    8020bd14:	0000100f          	fence.i
    return 0;  // this ends up in a0, the first argument to main(argc, argv)
    8020bd18:	f38ff06f          	j	8020b450 <exec+0x230>
        panic("");
    8020bd1c:	0000a697          	auipc	a3,0xa
    8020bd20:	ecc68693          	addi	a3,a3,-308 # 80215be8 <__func__.0+0x48>
    8020bd24:	0000b617          	auipc	a2,0xb
    8020bd28:	a9c60613          	addi	a2,a2,-1380 # 802167c0 <__func__.1>
    8020bd2c:	27b00593          	li	a1,635
    8020bd30:	0000a517          	auipc	a0,0xa
    8020bd34:	f6850513          	addi	a0,a0,-152 # 80215c98 <__func__.0+0x18>
    8020bd38:	ffff5097          	auipc	ra,0xffff5
    8020bd3c:	1b0080e7          	jalr	432(ra) # 80200ee8 <_panic_>
        panic("");
    8020bd40:	0000a697          	auipc	a3,0xa
    8020bd44:	ea868693          	addi	a3,a3,-344 # 80215be8 <__func__.0+0x48>
    8020bd48:	0000b617          	auipc	a2,0xb
    8020bd4c:	a7860613          	addi	a2,a2,-1416 # 802167c0 <__func__.1>
    8020bd50:	28100593          	li	a1,641
    8020bd54:	0000a517          	auipc	a0,0xa
    8020bd58:	f4450513          	addi	a0,a0,-188 # 80215c98 <__func__.0+0x18>
    8020bd5c:	ffff5097          	auipc	ra,0xffff5
    8020bd60:	18c080e7          	jalr	396(ra) # 80200ee8 <_panic_>
        panic("");
    8020bd64:	0000a697          	auipc	a3,0xa
    8020bd68:	e8468693          	addi	a3,a3,-380 # 80215be8 <__func__.0+0x48>
    8020bd6c:	0000b617          	auipc	a2,0xb
    8020bd70:	a5460613          	addi	a2,a2,-1452 # 802167c0 <__func__.1>
    8020bd74:	28500593          	li	a1,645
    8020bd78:	0000a517          	auipc	a0,0xa
    8020bd7c:	f2050513          	addi	a0,a0,-224 # 80215c98 <__func__.0+0x18>
    8020bd80:	ffff5097          	auipc	ra,0xffff5
    8020bd84:	168080e7          	jalr	360(ra) # 80200ee8 <_panic_>
        return -1;
    8020bd88:	fff00493          	li	s1,-1
    8020bd8c:	ec4ff06f          	j	8020b450 <exec+0x230>
    u64 phdr_addr = 0; // virtual address in user space, point to the program header. We will pass 'phdr_addr' to ld.so
    8020bd90:	ae043423          	sd	zero,-1304(s0)
        elf_entry = elf.entry;
    8020bd94:	cf843d83          	ld	s11,-776(s0)
    u64 interp_load_addr = 0;
    8020bd98:	ae043023          	sd	zero,-1312(s0)
    8020bd9c:	b8dff06f          	j	8020b928 <exec+0x708>

000000008020bda0 <load_script>:
int load_script(char* bprmbuf, char* path, char** argv) {
    8020bda0:	ed010113          	addi	sp,sp,-304
    8020bda4:	12113423          	sd	ra,296(sp)
    8020bda8:	12813023          	sd	s0,288(sp)
    8020bdac:	10913c23          	sd	s1,280(sp)
    8020bdb0:	11213823          	sd	s2,272(sp)
    8020bdb4:	11313423          	sd	s3,264(sp)
    8020bdb8:	13010413          	addi	s0,sp,304
    8020bdbc:	00050913          	mv	s2,a0
    8020bdc0:	00060993          	mv	s3,a2
    if ((cp = strchr(bprmbuf, '\n')) == NULL)
    8020bdc4:	00a00593          	li	a1,10
    8020bdc8:	00003097          	auipc	ra,0x3
    8020bdcc:	1fc080e7          	jalr	508(ra) # 8020efc4 <strchr>
    8020bdd0:	00050c63          	beqz	a0,8020bde8 <load_script+0x48>
    *cp = '\0';
    8020bdd4:	00050023          	sb	zero,0(a0)
    while (cp > bprmbuf) {
    8020bdd8:	02a97e63          	bgeu	s2,a0,8020be14 <load_script+0x74>
        if ((*cp == ' ') || (*cp == '\t'))
    8020bddc:	02000713          	li	a4,32
    8020bde0:	00900693          	li	a3,9
    8020bde4:	0200006f          	j	8020be04 <load_script+0x64>
        cp = bprmbuf + strlen(bprmbuf);
    8020bde8:	00090513          	mv	a0,s2
    8020bdec:	00003097          	auipc	ra,0x3
    8020bdf0:	190080e7          	jalr	400(ra) # 8020ef7c <strlen>
    8020bdf4:	00a90533          	add	a0,s2,a0
    8020bdf8:	fddff06f          	j	8020bdd4 <load_script+0x34>
            *cp = '\0';
    8020bdfc:	00050023          	sb	zero,0(a0)
    while (cp > bprmbuf) {
    8020be00:	00a90a63          	beq	s2,a0,8020be14 <load_script+0x74>
        cp--;
    8020be04:	fff50513          	addi	a0,a0,-1
        if ((*cp == ' ') || (*cp == '\t'))
    8020be08:	00054783          	lbu	a5,0(a0)
    8020be0c:	fee788e3          	beq	a5,a4,8020bdfc <load_script+0x5c>
    8020be10:	fed786e3          	beq	a5,a3,8020bdfc <load_script+0x5c>
    for (cp = bprmbuf + 2; (*cp == ' ') || (*cp == '\t'); cp++)
    8020be14:	00290913          	addi	s2,s2,2
    8020be18:	02000713          	li	a4,32
    8020be1c:	00900693          	li	a3,9
    8020be20:	0080006f          	j	8020be28 <load_script+0x88>
    8020be24:	00190913          	addi	s2,s2,1
    8020be28:	00094783          	lbu	a5,0(s2)
    8020be2c:	fee78ce3          	beq	a5,a4,8020be24 <load_script+0x84>
    8020be30:	fed78ae3          	beq	a5,a3,8020be24 <load_script+0x84>
    if (*cp == '\0')
    8020be34:	06078263          	beqz	a5,8020be98 <load_script+0xf8>
    8020be38:	00090493          	mv	s1,s2
    for (; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
    8020be3c:	00900693          	li	a3,9
    8020be40:	00148493          	addi	s1,s1,1
    8020be44:	0004c783          	lbu	a5,0(s1)
    8020be48:	0df7f713          	andi	a4,a5,223
    8020be4c:	00070463          	beqz	a4,8020be54 <load_script+0xb4>
    8020be50:	fed798e3          	bne	a5,a3,8020be40 <load_script+0xa0>
    while ((*cp == ' ') || (*cp == '\t'))
    8020be54:	02000713          	li	a4,32
    8020be58:	00900693          	li	a3,9
    8020be5c:	00c0006f          	j	8020be68 <load_script+0xc8>
        *cp++ = '\0';
    8020be60:	00148493          	addi	s1,s1,1
    8020be64:	fe048fa3          	sb	zero,-1(s1)
    while ((*cp == ' ') || (*cp == '\t'))
    8020be68:	0004c783          	lbu	a5,0(s1)
    8020be6c:	fee78ae3          	beq	a5,a4,8020be60 <load_script+0xc0>
    8020be70:	fed788e3          	beq	a5,a3,8020be60 <load_script+0xc0>
    if (*cp)
    8020be74:	02079663          	bnez	a5,8020bea0 <load_script+0x100>
    char* script_argv[MAXARG] = {0};
    8020be78:	0f800613          	li	a2,248
    8020be7c:	00000593          	li	a1,0
    8020be80:	ed840513          	addi	a0,s0,-296
    8020be84:	00003097          	auipc	ra,0x3
    8020be88:	ee8080e7          	jalr	-280(ra) # 8020ed6c <memset>
    script_argv[script_argc++] = i_name;
    8020be8c:	ed243823          	sd	s2,-304(s0)
    8020be90:	00100793          	li	a5,1
    8020be94:	02c0006f          	j	8020bec0 <load_script+0x120>
        return -ENOEXEC; /* No interpreter name found */
    8020be98:	ff800513          	li	a0,-8
    8020be9c:	05c0006f          	j	8020bef8 <load_script+0x158>
    char* script_argv[MAXARG] = {0};
    8020bea0:	0f000613          	li	a2,240
    8020bea4:	00000593          	li	a1,0
    8020bea8:	ee040513          	addi	a0,s0,-288
    8020beac:	00003097          	auipc	ra,0x3
    8020beb0:	ec0080e7          	jalr	-320(ra) # 8020ed6c <memset>
    script_argv[script_argc++] = i_name;
    8020beb4:	ed243823          	sd	s2,-304(s0)
        script_argv[script_argc++] = i_arg;
    8020beb8:	ec943c23          	sd	s1,-296(s0)
    8020bebc:	00200793          	li	a5,2
    while (*argv) {
    8020bec0:	0009b703          	ld	a4,0(s3)
    8020bec4:	02070263          	beqz	a4,8020bee8 <load_script+0x148>
    8020bec8:	00379793          	slli	a5,a5,0x3
    8020becc:	ed040693          	addi	a3,s0,-304
    8020bed0:	00f687b3          	add	a5,a3,a5
        script_argv[script_argc++] = *(argv++);
    8020bed4:	00898993          	addi	s3,s3,8
    8020bed8:	00e7b023          	sd	a4,0(a5) # fffffffffbfff000 <bssEnd+0xffffffff79c8f000>
    while (*argv) {
    8020bedc:	0009b703          	ld	a4,0(s3)
    8020bee0:	00878793          	addi	a5,a5,8
    8020bee4:	fe0718e3          	bnez	a4,8020bed4 <load_script+0x134>
    return exec(i_name, script_argv);
    8020bee8:	ed040593          	addi	a1,s0,-304
    8020beec:	00090513          	mv	a0,s2
    8020bef0:	fffff097          	auipc	ra,0xfffff
    8020bef4:	330080e7          	jalr	816(ra) # 8020b220 <exec>
}
    8020bef8:	12813083          	ld	ra,296(sp)
    8020befc:	12013403          	ld	s0,288(sp)
    8020bf00:	11813483          	ld	s1,280(sp)
    8020bf04:	11013903          	ld	s2,272(sp)
    8020bf08:	10813983          	ld	s3,264(sp)
    8020bf0c:	13010113          	addi	sp,sp,304
    8020bf10:	00008067          	ret

000000008020bf14 <sys_exec>:

#define MAXPATH      128   // maximum file path name
u64 sys_exec(void) {
    8020bf14:	e1010113          	addi	sp,sp,-496
    8020bf18:	1e113423          	sd	ra,488(sp)
    8020bf1c:	1e813023          	sd	s0,480(sp)
    8020bf20:	1c913c23          	sd	s1,472(sp)
    8020bf24:	1d213823          	sd	s2,464(sp)
    8020bf28:	1d313423          	sd	s3,456(sp)
    8020bf2c:	1d413023          	sd	s4,448(sp)
    8020bf30:	1b513c23          	sd	s5,440(sp)
    8020bf34:	1b613823          	sd	s6,432(sp)
    8020bf38:	1b713423          	sd	s7,424(sp)
    8020bf3c:	1b813023          	sd	s8,416(sp)
    8020bf40:	1f010413          	addi	s0,sp,496
    char path[MAXPATH], *argv[MAXARG];
    int i;
    u64 uargv, uarg;

    if (argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0) {
    8020bf44:	08000613          	li	a2,128
    8020bf48:	f3040593          	addi	a1,s0,-208
    8020bf4c:	00000513          	li	a0,0
    8020bf50:	00000097          	auipc	ra,0x0
    8020bf54:	6c8080e7          	jalr	1736(ra) # 8020c618 <argstr>
        return -1;
    8020bf58:	fff00993          	li	s3,-1
    if (argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0) {
    8020bf5c:	1a054063          	bltz	a0,8020c0fc <sys_exec+0x1e8>
    8020bf60:	e2840593          	addi	a1,s0,-472
    8020bf64:	00100513          	li	a0,1
    8020bf68:	00000097          	auipc	ra,0x0
    8020bf6c:	4e4080e7          	jalr	1252(ra) # 8020c44c <argaddr>
    8020bf70:	18054663          	bltz	a0,8020c0fc <sys_exec+0x1e8>
    }

    memset(argv, 0, sizeof(argv));
    8020bf74:	10000613          	li	a2,256
    8020bf78:	00000593          	li	a1,0
    8020bf7c:	e3040513          	addi	a0,s0,-464
    8020bf80:	00003097          	auipc	ra,0x3
    8020bf84:	dec080e7          	jalr	-532(ra) # 8020ed6c <memset>
    for (i = 0;; i++) {
        if (i >= NELEM(argv)) {
    8020bf88:	e3040493          	addi	s1,s0,-464
    memset(argv, 0, sizeof(argv));
    8020bf8c:	00048993          	mv	s3,s1
    8020bf90:	00000913          	li	s2,0
    return page - pages;
    8020bf94:	018fbb17          	auipc	s6,0x18fb
    8020bf98:	f6cb0b13          	addi	s6,s6,-148 # 81b06f00 <pages>
    8020bf9c:	0000ba97          	auipc	s5,0xb
    8020bfa0:	85ca8a93          	addi	s5,s5,-1956 # 802167f8 <__func__.0+0x20>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020bfa4:	00100a13          	li	s4,1
    8020bfa8:	01fa1a13          	slli	s4,s4,0x1f
        if (i >= NELEM(argv)) {
    8020bfac:	02000b93          	li	s7,32
    8020bfb0:	00090c1b          	sext.w	s8,s2
            goto bad;
        }
        if (fetchaddr(uargv + sizeof(u64) * i, (u64*)&uarg) < 0) {
    8020bfb4:	00391513          	slli	a0,s2,0x3
    8020bfb8:	e2040593          	addi	a1,s0,-480
    8020bfbc:	e2843783          	ld	a5,-472(s0)
    8020bfc0:	00f50533          	add	a0,a0,a5
    8020bfc4:	00000097          	auipc	ra,0x0
    8020bfc8:	3ec080e7          	jalr	1004(ra) # 8020c3b0 <fetchaddr>
    8020bfcc:	06054263          	bltz	a0,8020c030 <sys_exec+0x11c>
            goto bad;
        }
        if (uarg == 0) {
    8020bfd0:	e2043783          	ld	a5,-480(s0)
    8020bfd4:	0a078863          	beqz	a5,8020c084 <sys_exec+0x170>
            argv[i] = 0;
            break;
        }
        PhysicalPage *page;
        if(pageAlloc(&page))
    8020bfd8:	e1840513          	addi	a0,s0,-488
    8020bfdc:	ffffd097          	auipc	ra,0xffffd
    8020bfe0:	ee0080e7          	jalr	-288(ra) # 80208ebc <pageAlloc>
    8020bfe4:	04051663          	bnez	a0,8020c030 <sys_exec+0x11c>
    return page - pages;
    8020bfe8:	e1843583          	ld	a1,-488(s0)
    8020bfec:	416585b3          	sub	a1,a1,s6
    8020bff0:	4035d593          	srai	a1,a1,0x3
    8020bff4:	000ab783          	ld	a5,0(s5)
    8020bff8:	02f585b3          	mul	a1,a1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020bffc:	00c5959b          	slliw	a1,a1,0xc
    8020c000:	02059593          	slli	a1,a1,0x20
    8020c004:	0205d593          	srli	a1,a1,0x20
    8020c008:	014585b3          	add	a1,a1,s4
            goto bad;
        argv[i] = (char *)page2pa(page);
    8020c00c:	00b9b023          	sd	a1,0(s3)
        if (argv[i] == 0)
            goto bad;
        if (fetchstr(uarg, argv[i], PGSIZE) < 0)
    8020c010:	00001637          	lui	a2,0x1
    8020c014:	e2043503          	ld	a0,-480(s0)
    8020c018:	00000097          	auipc	ra,0x0
    8020c01c:	58c080e7          	jalr	1420(ra) # 8020c5a4 <fetchstr>
    8020c020:	00054863          	bltz	a0,8020c030 <sys_exec+0x11c>
        if (i >= NELEM(argv)) {
    8020c024:	00190913          	addi	s2,s2,1
    8020c028:	00898993          	addi	s3,s3,8
    8020c02c:	f97912e3          	bne	s2,s7,8020bfb0 <sys_exec+0x9c>
        pageFree(pa2page((u64)argv[i]));

    return ret;

bad:
    for (i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    8020c030:	f3040913          	addi	s2,s0,-208
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020c034:	80000ab7          	lui	s5,0x80000
    return pages + ppn;
    8020c038:	fff00993          	li	s3,-1
    8020c03c:	0209d993          	srli	s3,s3,0x20
    8020c040:	018fba17          	auipc	s4,0x18fb
    8020c044:	ec0a0a13          	addi	s4,s4,-320 # 81b06f00 <pages>
    8020c048:	0004b783          	ld	a5,0(s1)
    8020c04c:	0a078663          	beqz	a5,8020c0f8 <sys_exec+0x1e4>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020c050:	015787b3          	add	a5,a5,s5
    8020c054:	00c7d793          	srli	a5,a5,0xc
    return pages + ppn;
    8020c058:	0137f7b3          	and	a5,a5,s3
    8020c05c:	00179513          	slli	a0,a5,0x1
    8020c060:	00f50533          	add	a0,a0,a5
    8020c064:	00351513          	slli	a0,a0,0x3
        pageFree(pa2page((u64)argv[i]));
    8020c068:	00aa0533          	add	a0,s4,a0
    8020c06c:	ffffd097          	auipc	ra,0xffffd
    8020c070:	fb8080e7          	jalr	-72(ra) # 80209024 <pageFree>
    for (i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    8020c074:	00848493          	addi	s1,s1,8
    8020c078:	fc9918e3          	bne	s2,s1,8020c048 <sys_exec+0x134>
    return -1;
    8020c07c:	fff00993          	li	s3,-1
    8020c080:	07c0006f          	j	8020c0fc <sys_exec+0x1e8>
            argv[i] = 0;
    8020c084:	003c1c13          	slli	s8,s8,0x3
    8020c088:	fb0c0793          	addi	a5,s8,-80
    8020c08c:	00878c33          	add	s8,a5,s0
    8020c090:	e80c3023          	sd	zero,-384(s8)
    int ret = exec(path, argv);
    8020c094:	e3040593          	addi	a1,s0,-464
    8020c098:	f3040513          	addi	a0,s0,-208
    8020c09c:	fffff097          	auipc	ra,0xfffff
    8020c0a0:	184080e7          	jalr	388(ra) # 8020b220 <exec>
    8020c0a4:	00050993          	mv	s3,a0
    for (i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    8020c0a8:	f3040913          	addi	s2,s0,-208
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020c0ac:	80000b37          	lui	s6,0x80000
    return pages + ppn;
    8020c0b0:	fff00a13          	li	s4,-1
    8020c0b4:	020a5a13          	srli	s4,s4,0x20
    8020c0b8:	018fba97          	auipc	s5,0x18fb
    8020c0bc:	e48a8a93          	addi	s5,s5,-440 # 81b06f00 <pages>
    8020c0c0:	0004b783          	ld	a5,0(s1)
    8020c0c4:	02078c63          	beqz	a5,8020c0fc <sys_exec+0x1e8>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020c0c8:	016787b3          	add	a5,a5,s6
    8020c0cc:	00c7d793          	srli	a5,a5,0xc
    return pages + ppn;
    8020c0d0:	0147f7b3          	and	a5,a5,s4
    8020c0d4:	00179513          	slli	a0,a5,0x1
    8020c0d8:	00f50533          	add	a0,a0,a5
    8020c0dc:	00351513          	slli	a0,a0,0x3
        pageFree(pa2page((u64)argv[i]));
    8020c0e0:	00aa8533          	add	a0,s5,a0
    8020c0e4:	ffffd097          	auipc	ra,0xffffd
    8020c0e8:	f40080e7          	jalr	-192(ra) # 80209024 <pageFree>
    for (i = 0; i < NELEM(argv) && argv[i] != 0; i++)
    8020c0ec:	00848493          	addi	s1,s1,8
    8020c0f0:	fd2498e3          	bne	s1,s2,8020c0c0 <sys_exec+0x1ac>
    8020c0f4:	0080006f          	j	8020c0fc <sys_exec+0x1e8>
    return -1;
    8020c0f8:	fff00993          	li	s3,-1
}
    8020c0fc:	00098513          	mv	a0,s3
    8020c100:	1e813083          	ld	ra,488(sp)
    8020c104:	1e013403          	ld	s0,480(sp)
    8020c108:	1d813483          	ld	s1,472(sp)
    8020c10c:	1d013903          	ld	s2,464(sp)
    8020c110:	1c813983          	ld	s3,456(sp)
    8020c114:	1c013a03          	ld	s4,448(sp)
    8020c118:	1b813a83          	ld	s5,440(sp)
    8020c11c:	1b013b03          	ld	s6,432(sp)
    8020c120:	1a813b83          	ld	s7,424(sp)
    8020c124:	1a013c03          	ld	s8,416(sp)
    8020c128:	1f010113          	addi	sp,sp,496
    8020c12c:	00008067          	ret

000000008020c130 <kernelVector>:
.globl kernelTrap
.section .text
.globl kernelVector
.align 2
kernelVector:
    addi sp, sp, -256
    8020c130:	f0010113          	addi	sp,sp,-256

    sd ra, 0(sp)
    8020c134:	00113023          	sd	ra,0(sp)
    sd sp, 8(sp)
    8020c138:	00213423          	sd	sp,8(sp)
    sd gp, 16(sp)
    8020c13c:	00313823          	sd	gp,16(sp)
    sd tp, 24(sp)
    8020c140:	00413c23          	sd	tp,24(sp)
    sd t0, 32(sp)
    8020c144:	02513023          	sd	t0,32(sp)
    sd t1, 40(sp)
    8020c148:	02613423          	sd	t1,40(sp)
    sd t2, 48(sp)
    8020c14c:	02713823          	sd	t2,48(sp)
    sd s0, 56(sp)
    8020c150:	02813c23          	sd	s0,56(sp)
    sd s1, 64(sp)
    8020c154:	04913023          	sd	s1,64(sp)
    sd a0, 72(sp)
    8020c158:	04a13423          	sd	a0,72(sp)
    sd a1, 80(sp)
    8020c15c:	04b13823          	sd	a1,80(sp)
    sd a2, 88(sp)
    8020c160:	04c13c23          	sd	a2,88(sp)
    sd a3, 96(sp)
    8020c164:	06d13023          	sd	a3,96(sp)
    sd a4, 104(sp)
    8020c168:	06e13423          	sd	a4,104(sp)
    sd a5, 112(sp)
    8020c16c:	06f13823          	sd	a5,112(sp)
    sd a6, 120(sp)
    8020c170:	07013c23          	sd	a6,120(sp)
    sd a7, 128(sp)
    8020c174:	09113023          	sd	a7,128(sp)
    sd s2, 136(sp)
    8020c178:	09213423          	sd	s2,136(sp)
    sd s3, 144(sp)
    8020c17c:	09313823          	sd	s3,144(sp)
    sd s4, 152(sp)
    8020c180:	09413c23          	sd	s4,152(sp)
    sd s5, 160(sp)
    8020c184:	0b513023          	sd	s5,160(sp)
    sd s6, 168(sp)
    8020c188:	0b613423          	sd	s6,168(sp)
    sd s7, 176(sp)
    8020c18c:	0b713823          	sd	s7,176(sp)
    sd s8, 184(sp)
    8020c190:	0b813c23          	sd	s8,184(sp)
    sd s9, 192(sp)
    8020c194:	0d913023          	sd	s9,192(sp)
    sd s10, 200(sp)
    8020c198:	0da13423          	sd	s10,200(sp)
    sd s11, 208(sp)
    8020c19c:	0db13823          	sd	s11,208(sp)
    sd t3, 216(sp)
    8020c1a0:	0dc13c23          	sd	t3,216(sp)
    sd t4, 224(sp)
    8020c1a4:	0fd13023          	sd	t4,224(sp)
    sd t5, 232(sp)
    8020c1a8:	0fe13423          	sd	t5,232(sp)
    sd t6, 240(sp)
    8020c1ac:	0ff13823          	sd	t6,240(sp)

	// call the C trap handler in trap.c
    call kernelTrap
    8020c1b0:	0a1020ef          	jal	ra,8020ea50 <kernelTrap>
    ld ra, 0(sp)
    8020c1b4:	00013083          	ld	ra,0(sp)
    ld sp, 8(sp)
    8020c1b8:	00813103          	ld	sp,8(sp)
    ld gp, 16(sp)
    8020c1bc:	01013183          	ld	gp,16(sp)
    // not this, in case we moved CPUs: ld tp, 24(sp)
    ld t0, 32(sp)
    8020c1c0:	02013283          	ld	t0,32(sp)
    ld t1, 40(sp)
    8020c1c4:	02813303          	ld	t1,40(sp)
    ld t2, 48(sp)
    8020c1c8:	03013383          	ld	t2,48(sp)
    ld s0, 56(sp)
    8020c1cc:	03813403          	ld	s0,56(sp)
    ld s1, 64(sp)
    8020c1d0:	04013483          	ld	s1,64(sp)
    ld a0, 72(sp)
    8020c1d4:	04813503          	ld	a0,72(sp)
    ld a1, 80(sp)
    8020c1d8:	05013583          	ld	a1,80(sp)
    ld a2, 88(sp)
    8020c1dc:	05813603          	ld	a2,88(sp)
    ld a3, 96(sp)
    8020c1e0:	06013683          	ld	a3,96(sp)
    ld a4, 104(sp)
    8020c1e4:	06813703          	ld	a4,104(sp)
    ld a5, 112(sp)
    8020c1e8:	07013783          	ld	a5,112(sp)
    ld a6, 120(sp)
    8020c1ec:	07813803          	ld	a6,120(sp)
    ld a7, 128(sp)
    8020c1f0:	08013883          	ld	a7,128(sp)
    ld s2, 136(sp)
    8020c1f4:	08813903          	ld	s2,136(sp)
    ld s3, 144(sp)
    8020c1f8:	09013983          	ld	s3,144(sp)
    ld s4, 152(sp)
    8020c1fc:	09813a03          	ld	s4,152(sp)
    ld s5, 160(sp)
    8020c200:	0a013a83          	ld	s5,160(sp)
    ld s6, 168(sp)
    8020c204:	0a813b03          	ld	s6,168(sp)
    ld s7, 176(sp)
    8020c208:	0b013b83          	ld	s7,176(sp)
    ld s8, 184(sp)
    8020c20c:	0b813c03          	ld	s8,184(sp)
    ld s9, 192(sp)
    8020c210:	0c013c83          	ld	s9,192(sp)
    ld s10, 200(sp)
    8020c214:	0c813d03          	ld	s10,200(sp)
    ld s11, 208(sp)
    8020c218:	0d013d83          	ld	s11,208(sp)
    ld t3, 216(sp)
    8020c21c:	0d813e03          	ld	t3,216(sp)
    ld t4, 224(sp)
    8020c220:	0e013e83          	ld	t4,224(sp)
    ld t5, 232(sp)
    8020c224:	0e813f03          	ld	t5,232(sp)
    ld t6, 240(sp)
    8020c228:	0f013f83          	ld	t6,240(sp)

    addi sp, sp, 256
    8020c22c:	10010113          	addi	sp,sp,256
    sret
    8020c230:	10200073          	sret
	...

000000008020c240 <sleepSave>:
#include <assembly/Trapframe.h>

    .globl sleepSave
    .align 4
sleepSave:
    sd ra, -8(sp)
    8020c240:	fe113c23          	sd	ra,-8(sp)
    sd gp, -16(sp)
    8020c244:	fe313823          	sd	gp,-16(sp)
    # sd tp, -24(sp)
    sd s0, -32(sp)
    8020c248:	fe813023          	sd	s0,-32(sp)
    sd s1, -40(sp)
    8020c24c:	fc913c23          	sd	s1,-40(sp)
    sd s2, -48(sp)
    8020c250:	fd213823          	sd	s2,-48(sp)
    sd s3, -56(sp)
    8020c254:	fd313423          	sd	s3,-56(sp)
    sd s4, -64(sp)
    8020c258:	fd413023          	sd	s4,-64(sp)
    sd s5, -72(sp)
    8020c25c:	fb513c23          	sd	s5,-72(sp)
    sd s6, -80(sp)
    8020c260:	fb613823          	sd	s6,-80(sp)
    sd s7, -88(sp)
    8020c264:	fb713423          	sd	s7,-88(sp)
    sd s8, -96(sp)
    8020c268:	fb813023          	sd	s8,-96(sp)
    sd s9, -104(sp)
    8020c26c:	f9913c23          	sd	s9,-104(sp)
    sd s10, -112(sp)
    8020c270:	f9a13823          	sd	s10,-112(sp)
    sd s11, -120(sp)
    8020c274:	f9b13423          	sd	s11,-120(sp)
    sd a0, -128(sp)
    8020c278:	f8a13023          	sd	a0,-128(sp)
    sd a1, -136(sp)
    8020c27c:	f6b13c23          	sd	a1,-136(sp)
    sd a2, -144(sp)
    8020c280:	f6c13823          	sd	a2,-144(sp)
    sd a3, -152(sp)
    8020c284:	f6d13423          	sd	a3,-152(sp)
    sd a4, -160(sp)
    8020c288:	f6e13023          	sd	a4,-160(sp)
    sd a5, -168(sp)
    8020c28c:	f4f13c23          	sd	a5,-168(sp)
    sd a6, -176(sp)
    8020c290:	f5013823          	sd	a6,-176(sp)
    sd a7, -184(sp)
    8020c294:	f5113423          	sd	a7,-184(sp)
    add sp, sp, -184
    8020c298:	f4810113          	addi	sp,sp,-184
    jal yield
    8020c29c:	29d050ef          	jal	ra,80211d38 <yield>

000000008020c2a0 <sleepRec>:

    .globl sleepRec
    .align 4
sleepRec:
    ld ra, -8(sp)
    8020c2a0:	ff813083          	ld	ra,-8(sp)
    ld gp, -16(sp)
    8020c2a4:	ff013183          	ld	gp,-16(sp)
    # ld tp, -24(sp)
    ld s0, -32(sp)
    8020c2a8:	fe013403          	ld	s0,-32(sp)
    ld s1, -40(sp)
    8020c2ac:	fd813483          	ld	s1,-40(sp)
    ld s2, -48(sp)
    8020c2b0:	fd013903          	ld	s2,-48(sp)
    ld s3, -56(sp)
    8020c2b4:	fc813983          	ld	s3,-56(sp)
    ld s4, -64(sp)
    8020c2b8:	fc013a03          	ld	s4,-64(sp)
    ld s5, -72(sp)
    8020c2bc:	fb813a83          	ld	s5,-72(sp)
    ld s6, -80(sp)
    8020c2c0:	fb013b03          	ld	s6,-80(sp)
    ld s7, -88(sp)
    8020c2c4:	fa813b83          	ld	s7,-88(sp)
    ld s8, -96(sp)
    8020c2c8:	fa013c03          	ld	s8,-96(sp)
    ld s9, -104(sp)
    8020c2cc:	f9813c83          	ld	s9,-104(sp)
    ld s10, -112(sp)
    8020c2d0:	f9013d03          	ld	s10,-112(sp)
    ld s11, -120(sp)
    8020c2d4:	f8813d83          	ld	s11,-120(sp)
    ld a0, -128(sp)
    8020c2d8:	f8013503          	ld	a0,-128(sp)
    ld a1, -136(sp)
    8020c2dc:	f7813583          	ld	a1,-136(sp)
    ld a2, -144(sp)
    8020c2e0:	f7013603          	ld	a2,-144(sp)
    ld a3, -152(sp)
    8020c2e4:	f6813683          	ld	a3,-152(sp)
    ld a4, -160(sp)
    8020c2e8:	f6013703          	ld	a4,-160(sp)
    ld a5, -168(sp)
    8020c2ec:	f5813783          	ld	a5,-168(sp)
    ld a6, -176(sp)
    8020c2f0:	f5013803          	ld	a6,-176(sp)
    ld a7, -184(sp)
    8020c2f4:	f4813883          	ld	a7,-184(sp)
    8020c2f8:	00008067          	ret
	...

000000008020c308 <argraw>:
        return err;
    return strlen(buf);
}


static u64 argraw(int n) {
    8020c308:	fe010113          	addi	sp,sp,-32
    8020c30c:	00113c23          	sd	ra,24(sp)
    8020c310:	00813823          	sd	s0,16(sp)
    8020c314:	00913423          	sd	s1,8(sp)
    8020c318:	02010413          	addi	s0,sp,32
    8020c31c:	00050493          	mv	s1,a0
    Trapframe *trapframe = getHartTrapFrame();
    8020c320:	ffffe097          	auipc	ra,0xffffe
    8020c324:	ebc080e7          	jalr	-324(ra) # 8020a1dc <getHartTrapFrame>
    switch (n) {
    8020c328:	00500793          	li	a5,5
    8020c32c:	0697e063          	bltu	a5,s1,8020c38c <argraw+0x84>
    8020c330:	00249493          	slli	s1,s1,0x2
    8020c334:	0000a717          	auipc	a4,0xa
    8020c338:	b7070713          	addi	a4,a4,-1168 # 80215ea4 <__func__.5+0x34>
    8020c33c:	00e484b3          	add	s1,s1,a4
    8020c340:	0004a783          	lw	a5,0(s1)
    8020c344:	00e787b3          	add	a5,a5,a4
    8020c348:	00078067          	jr	a5
        case 0:
            return trapframe->a0;
    8020c34c:	07053503          	ld	a0,112(a0)
        case 5:
            return trapframe->a5;
    }
    panic("argraw");
    return -1;
}
    8020c350:	01813083          	ld	ra,24(sp)
    8020c354:	01013403          	ld	s0,16(sp)
    8020c358:	00813483          	ld	s1,8(sp)
    8020c35c:	02010113          	addi	sp,sp,32
    8020c360:	00008067          	ret
            return trapframe->a1;
    8020c364:	07853503          	ld	a0,120(a0)
    8020c368:	fe9ff06f          	j	8020c350 <argraw+0x48>
            return trapframe->a2;
    8020c36c:	08053503          	ld	a0,128(a0)
    8020c370:	fe1ff06f          	j	8020c350 <argraw+0x48>
            return trapframe->a3;
    8020c374:	08853503          	ld	a0,136(a0)
    8020c378:	fd9ff06f          	j	8020c350 <argraw+0x48>
            return trapframe->a4;
    8020c37c:	09053503          	ld	a0,144(a0)
    8020c380:	fd1ff06f          	j	8020c350 <argraw+0x48>
            return trapframe->a5;
    8020c384:	09853503          	ld	a0,152(a0)
    8020c388:	fc9ff06f          	j	8020c350 <argraw+0x48>
    panic("argraw");
    8020c38c:	0000a697          	auipc	a3,0xa
    8020c390:	af468693          	addi	a3,a3,-1292 # 80215e80 <__func__.5+0x10>
    8020c394:	0000a617          	auipc	a2,0xa
    8020c398:	44460613          	addi	a2,a2,1092 # 802167d8 <__func__.0>
    8020c39c:	02e00593          	li	a1,46
    8020c3a0:	0000a517          	auipc	a0,0xa
    8020c3a4:	ae850513          	addi	a0,a0,-1304 # 80215e88 <__func__.5+0x18>
    8020c3a8:	ffff5097          	auipc	ra,0xffff5
    8020c3ac:	b40080e7          	jalr	-1216(ra) # 80200ee8 <_panic_>

000000008020c3b0 <fetchaddr>:
int fetchaddr(u64 addr, u64* ip) {
    8020c3b0:	fe010113          	addi	sp,sp,-32
    8020c3b4:	00113c23          	sd	ra,24(sp)
    8020c3b8:	00813823          	sd	s0,16(sp)
    8020c3bc:	00913423          	sd	s1,8(sp)
    8020c3c0:	01213023          	sd	s2,0(sp)
    8020c3c4:	02010413          	addi	s0,sp,32
    8020c3c8:	00050913          	mv	s2,a0
    8020c3cc:	00058493          	mv	s1,a1
    struct Process* p = myProcess();
    8020c3d0:	00003097          	auipc	ra,0x3
    8020c3d4:	618080e7          	jalr	1560(ra) # 8020f9e8 <myProcess>
    if (copyin(p->pgdir, (char*)ip, addr, sizeof(*ip)) != 0)
    8020c3d8:	00800693          	li	a3,8
    8020c3dc:	00090613          	mv	a2,s2
    8020c3e0:	00048593          	mv	a1,s1
    8020c3e4:	04053503          	ld	a0,64(a0)
    8020c3e8:	ffffd097          	auipc	ra,0xffffd
    8020c3ec:	660080e7          	jalr	1632(ra) # 80209a48 <copyin>
    8020c3f0:	00a03533          	snez	a0,a0
}
    8020c3f4:	40a00533          	neg	a0,a0
    8020c3f8:	01813083          	ld	ra,24(sp)
    8020c3fc:	01013403          	ld	s0,16(sp)
    8020c400:	00813483          	ld	s1,8(sp)
    8020c404:	00013903          	ld	s2,0(sp)
    8020c408:	02010113          	addi	sp,sp,32
    8020c40c:	00008067          	ret

000000008020c410 <argint>:

// Fetch the nth 32-bit system call argument.
int argint(int n, int* ip) {
    8020c410:	fe010113          	addi	sp,sp,-32
    8020c414:	00113c23          	sd	ra,24(sp)
    8020c418:	00813823          	sd	s0,16(sp)
    8020c41c:	00913423          	sd	s1,8(sp)
    8020c420:	02010413          	addi	s0,sp,32
    8020c424:	00058493          	mv	s1,a1
    *ip = argraw(n);
    8020c428:	00000097          	auipc	ra,0x0
    8020c42c:	ee0080e7          	jalr	-288(ra) # 8020c308 <argraw>
    8020c430:	00a4a023          	sw	a0,0(s1)
    return 0;
}
    8020c434:	00000513          	li	a0,0
    8020c438:	01813083          	ld	ra,24(sp)
    8020c43c:	01013403          	ld	s0,16(sp)
    8020c440:	00813483          	ld	s1,8(sp)
    8020c444:	02010113          	addi	sp,sp,32
    8020c448:	00008067          	ret

000000008020c44c <argaddr>:

// Retrieve an argument as a pointer.
// Doesn't check for legality, since
// copyin/copyout will do that.
int argaddr(int n, u64* ip) {
    8020c44c:	fe010113          	addi	sp,sp,-32
    8020c450:	00113c23          	sd	ra,24(sp)
    8020c454:	00813823          	sd	s0,16(sp)
    8020c458:	00913423          	sd	s1,8(sp)
    8020c45c:	02010413          	addi	s0,sp,32
    8020c460:	00058493          	mv	s1,a1
    *ip = argraw(n);
    8020c464:	00000097          	auipc	ra,0x0
    8020c468:	ea4080e7          	jalr	-348(ra) # 8020c308 <argraw>
    8020c46c:	00a4b023          	sd	a0,0(s1)
    return 0;
}
    8020c470:	00000513          	li	a0,0
    8020c474:	01813083          	ld	ra,24(sp)
    8020c478:	01013403          	ld	s0,16(sp)
    8020c47c:	00813483          	ld	s1,8(sp)
    8020c480:	02010113          	addi	sp,sp,32
    8020c484:	00008067          	ret

000000008020c488 <copyinstr>:

// Copy a null-terminated string from user to kernel.
// Copy bytes to dst from virtual address srcva in a given page table,
// until a '\0', or max.
// Return 0 on success, -1 on error.
int copyinstr(u64* pagetable, char* dst, u64 srcva, u64 max) {
    8020c488:	fa010113          	addi	sp,sp,-96
    8020c48c:	04113c23          	sd	ra,88(sp)
    8020c490:	04813823          	sd	s0,80(sp)
    8020c494:	04913423          	sd	s1,72(sp)
    8020c498:	05213023          	sd	s2,64(sp)
    8020c49c:	03313c23          	sd	s3,56(sp)
    8020c4a0:	03413823          	sd	s4,48(sp)
    8020c4a4:	03513423          	sd	s5,40(sp)
    8020c4a8:	03613023          	sd	s6,32(sp)
    8020c4ac:	01713c23          	sd	s7,24(sp)
    8020c4b0:	06010413          	addi	s0,sp,96
    u64 n, va0, pa0;
    int got_null = 0, cow;

    while (got_null == 0 && max > 0) {
    8020c4b4:	0c068c63          	beqz	a3,8020c58c <copyinstr+0x104>
    8020c4b8:	00050a13          	mv	s4,a0
    8020c4bc:	00058b13          	mv	s6,a1
    8020c4c0:	00060493          	mv	s1,a2
    8020c4c4:	00068b93          	mv	s7,a3
        va0 = DOWN_ALIGN(srcva, PGSIZE);
    8020c4c8:	fffffab7          	lui	s5,0xfffff
        pa0 = vir2phy(pagetable, srcva, &cow);
        if (pa0 == 0){
            pa0 = pageout(pagetable, srcva);
        }
        n = PGSIZE - (srcva - va0);
    8020c4cc:	000019b7          	lui	s3,0x1
    8020c4d0:	0540006f          	j	8020c524 <copyinstr+0x9c>
            pa0 = pageout(pagetable, srcva);
    8020c4d4:	00048593          	mv	a1,s1
    8020c4d8:	000a0513          	mv	a0,s4
    8020c4dc:	ffffd097          	auipc	ra,0xffffd
    8020c4e0:	038080e7          	jalr	56(ra) # 80209514 <pageout>
    8020c4e4:	05c0006f          	j	8020c540 <copyinstr+0xb8>
            n = max;

        char* p = (char*)(pa0);
        while (n > 0) {
            if (*p == '\0') {
                *dst = '\0';
    8020c4e8:	00078023          	sb	zero,0(a5)
        }

        srcva = va0 + PGSIZE;
    }
    if (got_null) {
        return 0;
    8020c4ec:	00000513          	li	a0,0
    } else {
        printf("ungot null\n");
        return -1;
    }
}
    8020c4f0:	05813083          	ld	ra,88(sp)
    8020c4f4:	05013403          	ld	s0,80(sp)
    8020c4f8:	04813483          	ld	s1,72(sp)
    8020c4fc:	04013903          	ld	s2,64(sp)
    8020c500:	03813983          	ld	s3,56(sp)
    8020c504:	03013a03          	ld	s4,48(sp)
    8020c508:	02813a83          	ld	s5,40(sp)
    8020c50c:	02013b03          	ld	s6,32(sp)
    8020c510:	01813b83          	ld	s7,24(sp)
    8020c514:	06010113          	addi	sp,sp,96
    8020c518:	00008067          	ret
        srcva = va0 + PGSIZE;
    8020c51c:	013904b3          	add	s1,s2,s3
    while (got_null == 0 && max > 0) {
    8020c520:	060b8663          	beqz	s7,8020c58c <copyinstr+0x104>
        va0 = DOWN_ALIGN(srcva, PGSIZE);
    8020c524:	0154f933          	and	s2,s1,s5
        pa0 = vir2phy(pagetable, srcva, &cow);
    8020c528:	fac40613          	addi	a2,s0,-84
    8020c52c:	00048593          	mv	a1,s1
    8020c530:	000a0513          	mv	a0,s4
    8020c534:	ffffd097          	auipc	ra,0xffffd
    8020c538:	440080e7          	jalr	1088(ra) # 80209974 <vir2phy>
        if (pa0 == 0){
    8020c53c:	f8050ce3          	beqz	a0,8020c4d4 <copyinstr+0x4c>
        n = PGSIZE - (srcva - va0);
    8020c540:	409905b3          	sub	a1,s2,s1
    8020c544:	013585b3          	add	a1,a1,s3
    8020c548:	00bbf463          	bgeu	s7,a1,8020c550 <copyinstr+0xc8>
    8020c54c:	000b8593          	mv	a1,s7
        while (n > 0) {
    8020c550:	fc0586e3          	beqz	a1,8020c51c <copyinstr+0x94>
    8020c554:	000b0793          	mv	a5,s6
            if (*p == '\0') {
    8020c558:	41650533          	sub	a0,a0,s6
    8020c55c:	fffb8693          	addi	a3,s7,-1
    8020c560:	00db06b3          	add	a3,s6,a3
        while (n > 0) {
    8020c564:	00bb05b3          	add	a1,s6,a1
            if (*p == '\0') {
    8020c568:	00f50733          	add	a4,a0,a5
    8020c56c:	00074703          	lbu	a4,0(a4)
    8020c570:	f6070ce3          	beqz	a4,8020c4e8 <copyinstr+0x60>
                *dst = *p;
    8020c574:	00e78023          	sb	a4,0(a5)
            --max;
    8020c578:	40f68bb3          	sub	s7,a3,a5
            dst++;
    8020c57c:	00178793          	addi	a5,a5,1
        while (n > 0) {
    8020c580:	feb794e3          	bne	a5,a1,8020c568 <copyinstr+0xe0>
            dst++;
    8020c584:	00078b13          	mv	s6,a5
    8020c588:	f95ff06f          	j	8020c51c <copyinstr+0x94>
        printf("ungot null\n");
    8020c58c:	0000a517          	auipc	a0,0xa
    8020c590:	90c50513          	addi	a0,a0,-1780 # 80215e98 <__func__.5+0x28>
    8020c594:	ffff5097          	auipc	ra,0xffff5
    8020c598:	8bc080e7          	jalr	-1860(ra) # 80200e50 <printf>
        return -1;
    8020c59c:	fff00513          	li	a0,-1
    8020c5a0:	f51ff06f          	j	8020c4f0 <copyinstr+0x68>

000000008020c5a4 <fetchstr>:
int fetchstr(u64 uva, char* buf, int max) {
    8020c5a4:	fd010113          	addi	sp,sp,-48
    8020c5a8:	02113423          	sd	ra,40(sp)
    8020c5ac:	02813023          	sd	s0,32(sp)
    8020c5b0:	00913c23          	sd	s1,24(sp)
    8020c5b4:	01213823          	sd	s2,16(sp)
    8020c5b8:	01313423          	sd	s3,8(sp)
    8020c5bc:	03010413          	addi	s0,sp,48
    8020c5c0:	00050913          	mv	s2,a0
    8020c5c4:	00058493          	mv	s1,a1
    8020c5c8:	00060993          	mv	s3,a2
    struct Process* p = myProcess();
    8020c5cc:	00003097          	auipc	ra,0x3
    8020c5d0:	41c080e7          	jalr	1052(ra) # 8020f9e8 <myProcess>
    int err = copyinstr(p->pgdir, buf, uva, max);
    8020c5d4:	00098693          	mv	a3,s3
    8020c5d8:	00090613          	mv	a2,s2
    8020c5dc:	00048593          	mv	a1,s1
    8020c5e0:	04053503          	ld	a0,64(a0)
    8020c5e4:	00000097          	auipc	ra,0x0
    8020c5e8:	ea4080e7          	jalr	-348(ra) # 8020c488 <copyinstr>
    if (err < 0)
    8020c5ec:	00054863          	bltz	a0,8020c5fc <fetchstr+0x58>
    return strlen(buf);
    8020c5f0:	00048513          	mv	a0,s1
    8020c5f4:	00003097          	auipc	ra,0x3
    8020c5f8:	988080e7          	jalr	-1656(ra) # 8020ef7c <strlen>
}
    8020c5fc:	02813083          	ld	ra,40(sp)
    8020c600:	02013403          	ld	s0,32(sp)
    8020c604:	01813483          	ld	s1,24(sp)
    8020c608:	01013903          	ld	s2,16(sp)
    8020c60c:	00813983          	ld	s3,8(sp)
    8020c610:	03010113          	addi	sp,sp,48
    8020c614:	00008067          	ret

000000008020c618 <argstr>:
int argstr(int n, char* buf, int max) {
    8020c618:	fe010113          	addi	sp,sp,-32
    8020c61c:	00113c23          	sd	ra,24(sp)
    8020c620:	00813823          	sd	s0,16(sp)
    8020c624:	00913423          	sd	s1,8(sp)
    8020c628:	01213023          	sd	s2,0(sp)
    8020c62c:	02010413          	addi	s0,sp,32
    8020c630:	00058493          	mv	s1,a1
    8020c634:	00060913          	mv	s2,a2
    *ip = argraw(n);
    8020c638:	00000097          	auipc	ra,0x0
    8020c63c:	cd0080e7          	jalr	-816(ra) # 8020c308 <argraw>
    return fetchstr(addr, buf, max);
    8020c640:	00090613          	mv	a2,s2
    8020c644:	00048593          	mv	a1,s1
    8020c648:	00000097          	auipc	ra,0x0
    8020c64c:	f5c080e7          	jalr	-164(ra) # 8020c5a4 <fetchstr>
}
    8020c650:	01813083          	ld	ra,24(sp)
    8020c654:	01013403          	ld	s0,16(sp)
    8020c658:	00813483          	ld	s1,8(sp)
    8020c65c:	00013903          	ld	s2,0(sp)
    8020c660:	02010113          	addi	sp,sp,32
    8020c664:	00008067          	ret

000000008020c668 <syscallExitGroup>:
    // printf("settid: %lx\n", tf->a0);
    myThread()->clearChildTid = tf->a0;
    tf->a0 = myThread()->id;
}

void syscallExitGroup() {
    8020c668:	ff010113          	addi	sp,sp,-16
    8020c66c:	00113423          	sd	ra,8(sp)
    8020c670:	00813023          	sd	s0,0(sp)
    8020c674:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c678:	ffffe097          	auipc	ra,0xffffe
    8020c67c:	b64080e7          	jalr	-1180(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c680:	06053823          	sd	zero,112(a0)
}
    8020c684:	00813083          	ld	ra,8(sp)
    8020c688:	00013403          	ld	s0,0(sp)
    8020c68c:	01010113          	addi	sp,sp,16
    8020c690:	00008067          	ret

000000008020c694 <syscallIOControl>:
    }
    // releaseLock(&process->lock);
    tf->a0 = 0;
}

void syscallIOControl() {
    8020c694:	ff010113          	addi	sp,sp,-16
    8020c698:	00113423          	sd	ra,8(sp)
    8020c69c:	00813023          	sd	s0,0(sp)
    8020c6a0:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c6a4:	ffffe097          	auipc	ra,0xffffe
    8020c6a8:	b38080e7          	jalr	-1224(ra) # 8020a1dc <getHartTrapFrame>
    // printf("fd: %d, cmd: %d, argc: %d\n", tf->a0, tf->a1, tf->a2);
    tf->a0 = 0;
    8020c6ac:	06053823          	sd	zero,112(a0)
}
    8020c6b0:	00813083          	ld	ra,8(sp)
    8020c6b4:	00013403          	ld	s0,0(sp)
    8020c6b8:	01010113          	addi	sp,sp,16
    8020c6bc:	00008067          	ret

000000008020c6c0 <syscallSetSocketOption>:
void syscallGetSocketName() {
    Trapframe *tf = getHartTrapFrame();
    tf->a0 = getSocketName(tf->a0, tf->a1);
}

void syscallSetSocketOption() {
    8020c6c0:	ff010113          	addi	sp,sp,-16
    8020c6c4:	00113423          	sd	ra,8(sp)
    8020c6c8:	00813023          	sd	s0,0(sp)
    8020c6cc:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c6d0:	ffffe097          	auipc	ra,0xffffe
    8020c6d4:	b0c080e7          	jalr	-1268(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c6d8:	06053823          	sd	zero,112(a0)
}
    8020c6dc:	00813083          	ld	ra,8(sp)
    8020c6e0:	00013403          	ld	s0,0(sp)
    8020c6e4:	01010113          	addi	sp,sp,16
    8020c6e8:	00008067          	ret

000000008020c6ec <syscallGetUserId>:
        // printf("bjoweihgre8i %ld\n", tf->a1);
        copyout(myProcess()->pgdir, tf->a1, (char*)&fss, sizeof(FileSystemStatus));
    }
}

void syscallGetUserId() {
    8020c6ec:	ff010113          	addi	sp,sp,-16
    8020c6f0:	00113423          	sd	ra,8(sp)
    8020c6f4:	00813023          	sd	s0,0(sp)
    8020c6f8:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c6fc:	ffffe097          	auipc	ra,0xffffe
    8020c700:	ae0080e7          	jalr	-1312(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c704:	06053823          	sd	zero,112(a0)
}
    8020c708:	00813083          	ld	ra,8(sp)
    8020c70c:	00013403          	ld	s0,0(sp)
    8020c710:	01010113          	addi	sp,sp,16
    8020c714:	00008067          	ret

000000008020c718 <syscallGetEffectiveUserId>:

void syscallGetEffectiveUserId() {
    8020c718:	ff010113          	addi	sp,sp,-16
    8020c71c:	00113423          	sd	ra,8(sp)
    8020c720:	00813023          	sd	s0,0(sp)
    8020c724:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c728:	ffffe097          	auipc	ra,0xffffe
    8020c72c:	ab4080e7          	jalr	-1356(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;    
    8020c730:	06053823          	sd	zero,112(a0)
}
    8020c734:	00813083          	ld	ra,8(sp)
    8020c738:	00013403          	ld	s0,0(sp)
    8020c73c:	01010113          	addi	sp,sp,16
    8020c740:	00008067          	ret

000000008020c744 <syscallMemoryBarrier>:

void syscallMemoryBarrier() {
    8020c744:	ff010113          	addi	sp,sp,-16
    8020c748:	00113423          	sd	ra,8(sp)
    8020c74c:	00813023          	sd	s0,0(sp)
    8020c750:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c754:	ffffe097          	auipc	ra,0xffffe
    8020c758:	a88080e7          	jalr	-1400(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c75c:	06053823          	sd	zero,112(a0)
}
    8020c760:	00813083          	ld	ra,8(sp)
    8020c764:	00013403          	ld	s0,0(sp)
    8020c768:	01010113          	addi	sp,sp,16
    8020c76c:	00008067          	ret

000000008020c770 <syscallSystemInfo>:
        panic("%d\n", type);
        break;
    }
}

void syscallSystemInfo() {
    8020c770:	ff010113          	addi	sp,sp,-16
    8020c774:	00113423          	sd	ra,8(sp)
    8020c778:	00813023          	sd	s0,0(sp)
    8020c77c:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c780:	ffffe097          	auipc	ra,0xffffe
    8020c784:	a5c080e7          	jalr	-1444(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c788:	06053823          	sd	zero,112(a0)
}
    8020c78c:	00813083          	ld	ra,8(sp)
    8020c790:	00013403          	ld	s0,0(sp)
    8020c794:	01010113          	addi	sp,sp,16
    8020c798:	00008067          	ret

000000008020c79c <syscallMemorySychronize>:
        setTimer(time);
    }
    tf->a0 = 0;    
}

void syscallMemorySychronize() {
    8020c79c:	ff010113          	addi	sp,sp,-16
    8020c7a0:	00113423          	sd	ra,8(sp)
    8020c7a4:	00813023          	sd	s0,0(sp)
    8020c7a8:	01010413          	addi	s0,sp,16
    Trapframe *tf = getHartTrapFrame();
    8020c7ac:	ffffe097          	auipc	ra,0xffffe
    8020c7b0:	a30080e7          	jalr	-1488(ra) # 8020a1dc <getHartTrapFrame>
    tf->a0 = 0;
    8020c7b4:	06053823          	sd	zero,112(a0)
    8020c7b8:	00813083          	ld	ra,8(sp)
    8020c7bc:	00013403          	ld	s0,0(sp)
    8020c7c0:	01010113          	addi	sp,sp,16
    8020c7c4:	00008067          	ret

000000008020c7c8 <syscallPutchar>:
void syscallPutchar() {
    8020c7c8:	ff010113          	addi	sp,sp,-16
    8020c7cc:	00113423          	sd	ra,8(sp)
    8020c7d0:	00813023          	sd	s0,0(sp)
    8020c7d4:	01010413          	addi	s0,sp,16
    Trapframe* trapframe = getHartTrapFrame();
    8020c7d8:	ffffe097          	auipc	ra,0xffffe
    8020c7dc:	a04080e7          	jalr	-1532(ra) # 8020a1dc <getHartTrapFrame>
    putchar(trapframe->a0);
    8020c7e0:	07054503          	lbu	a0,112(a0)
    8020c7e4:	ffff4097          	auipc	ra,0xffff4
    8020c7e8:	c34080e7          	jalr	-972(ra) # 80200418 <putchar>
}
    8020c7ec:	00813083          	ld	ra,8(sp)
    8020c7f0:	00013403          	ld	s0,0(sp)
    8020c7f4:	01010113          	addi	sp,sp,16
    8020c7f8:	00008067          	ret

000000008020c7fc <syscallGetProcessId>:
void syscallGetProcessId() {
    8020c7fc:	fe010113          	addi	sp,sp,-32
    8020c800:	00113c23          	sd	ra,24(sp)
    8020c804:	00813823          	sd	s0,16(sp)
    8020c808:	00913423          	sd	s1,8(sp)
    8020c80c:	02010413          	addi	s0,sp,32
    Trapframe* trapframe = getHartTrapFrame();
    8020c810:	ffffe097          	auipc	ra,0xffffe
    8020c814:	9cc080e7          	jalr	-1588(ra) # 8020a1dc <getHartTrapFrame>
    8020c818:	00050493          	mv	s1,a0
    trapframe->a0 = myProcess()->processId;
    8020c81c:	00003097          	auipc	ra,0x3
    8020c820:	1cc080e7          	jalr	460(ra) # 8020f9e8 <myProcess>
    8020c824:	04856783          	lwu	a5,72(a0)
    8020c828:	06f4b823          	sd	a5,112(s1)
}
    8020c82c:	01813083          	ld	ra,24(sp)
    8020c830:	01013403          	ld	s0,16(sp)
    8020c834:	00813483          	ld	s1,8(sp)
    8020c838:	02010113          	addi	sp,sp,32
    8020c83c:	00008067          	ret

000000008020c840 <syscallGetParentProcessId>:
void syscallGetParentProcessId() {
    8020c840:	fe010113          	addi	sp,sp,-32
    8020c844:	00113c23          	sd	ra,24(sp)
    8020c848:	00813823          	sd	s0,16(sp)
    8020c84c:	00913423          	sd	s1,8(sp)
    8020c850:	02010413          	addi	s0,sp,32
    Trapframe* trapframe = getHartTrapFrame();
    8020c854:	ffffe097          	auipc	ra,0xffffe
    8020c858:	988080e7          	jalr	-1656(ra) # 8020a1dc <getHartTrapFrame>
    8020c85c:	00050493          	mv	s1,a0
    trapframe->a0 = myProcess()->parentId;
    8020c860:	00003097          	auipc	ra,0x3
    8020c864:	188080e7          	jalr	392(ra) # 8020f9e8 <myProcess>
    8020c868:	04c56783          	lwu	a5,76(a0)
    8020c86c:	06f4b823          	sd	a5,112(s1)
}
    8020c870:	01813083          	ld	ra,24(sp)
    8020c874:	01013403          	ld	s0,16(sp)
    8020c878:	00813483          	ld	s1,8(sp)
    8020c87c:	02010113          	addi	sp,sp,32
    8020c880:	00008067          	ret

000000008020c884 <syscallWait>:
void syscallWait() {
    8020c884:	fe010113          	addi	sp,sp,-32
    8020c888:	00113c23          	sd	ra,24(sp)
    8020c88c:	00813823          	sd	s0,16(sp)
    8020c890:	00913423          	sd	s1,8(sp)
    8020c894:	02010413          	addi	s0,sp,32
    Trapframe* trapframe = getHartTrapFrame();
    8020c898:	ffffe097          	auipc	ra,0xffffe
    8020c89c:	944080e7          	jalr	-1724(ra) # 8020a1dc <getHartTrapFrame>
    8020c8a0:	00050493          	mv	s1,a0
    trapframe->a0 = wait(pid, addr, flags);
    8020c8a4:	08052603          	lw	a2,128(a0)
    8020c8a8:	07853583          	ld	a1,120(a0)
    8020c8ac:	07052503          	lw	a0,112(a0)
    8020c8b0:	00004097          	auipc	ra,0x4
    8020c8b4:	86c080e7          	jalr	-1940(ra) # 8021011c <wait>
    8020c8b8:	06a4b823          	sd	a0,112(s1)
}
    8020c8bc:	01813083          	ld	ra,24(sp)
    8020c8c0:	01013403          	ld	s0,16(sp)
    8020c8c4:	00813483          	ld	s1,8(sp)
    8020c8c8:	02010113          	addi	sp,sp,32
    8020c8cc:	00008067          	ret

000000008020c8d0 <syscallYield>:
void syscallYield() {
    8020c8d0:	ff010113          	addi	sp,sp,-16
    8020c8d4:	00113423          	sd	ra,8(sp)
    8020c8d8:	00813023          	sd	s0,0(sp)
    8020c8dc:	01010413          	addi	s0,sp,16
    kernelProcessCpuTimeEnd();
    8020c8e0:	00004097          	auipc	ra,0x4
    8020c8e4:	c48080e7          	jalr	-952(ra) # 80210528 <kernelProcessCpuTimeEnd>
	yield();
    8020c8e8:	00005097          	auipc	ra,0x5
    8020c8ec:	450080e7          	jalr	1104(ra) # 80211d38 <yield>
}
    8020c8f0:	00813083          	ld	ra,8(sp)
    8020c8f4:	00013403          	ld	s0,0(sp)
    8020c8f8:	01010113          	addi	sp,sp,16
    8020c8fc:	00008067          	ret

000000008020c900 <syscallClone>:
void syscallClone() {
    8020c900:	fe010113          	addi	sp,sp,-32
    8020c904:	00113c23          	sd	ra,24(sp)
    8020c908:	00813823          	sd	s0,16(sp)
    8020c90c:	00913423          	sd	s1,8(sp)
    8020c910:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020c914:	ffffe097          	auipc	ra,0xffffe
    8020c918:	8c8080e7          	jalr	-1848(ra) # 8020a1dc <getHartTrapFrame>
    8020c91c:	00050493          	mv	s1,a0
    tf->a0 = clone(tf->a0, tf->a1, tf->a2, tf->a3, tf->a4);
    8020c920:	09053703          	ld	a4,144(a0)
    8020c924:	08853683          	ld	a3,136(a0)
    8020c928:	08053603          	ld	a2,128(a0)
    8020c92c:	07853583          	ld	a1,120(a0)
    8020c930:	07052503          	lw	a0,112(a0)
    8020c934:	00003097          	auipc	ra,0x3
    8020c938:	bc4080e7          	jalr	-1084(ra) # 8020f4f8 <clone>
    8020c93c:	06a4b823          	sd	a0,112(s1)
}
    8020c940:	01813083          	ld	ra,24(sp)
    8020c944:	01013403          	ld	s0,16(sp)
    8020c948:	00813483          	ld	s1,8(sp)
    8020c94c:	02010113          	addi	sp,sp,32
    8020c950:	00008067          	ret

000000008020c954 <syscallExit>:
void syscallExit() {
    8020c954:	fd010113          	addi	sp,sp,-48
    8020c958:	02113423          	sd	ra,40(sp)
    8020c95c:	02813023          	sd	s0,32(sp)
    8020c960:	00913c23          	sd	s1,24(sp)
    8020c964:	03010413          	addi	s0,sp,48
    Trapframe* trapframe = getHartTrapFrame();
    8020c968:	ffffe097          	auipc	ra,0xffffe
    8020c96c:	874080e7          	jalr	-1932(ra) # 8020a1dc <getHartTrapFrame>
    int ret, ec = trapframe->a0;
    8020c970:	07053483          	ld	s1,112(a0)
    if ((ret = tid2Thread(0, &th, 1)) < 0) {
    8020c974:	00100613          	li	a2,1
    8020c978:	fd840593          	addi	a1,s0,-40
    8020c97c:	00000513          	li	a0,0
    8020c980:	00004097          	auipc	ra,0x4
    8020c984:	f4c080e7          	jalr	-180(ra) # 802108cc <tid2Thread>
    8020c988:	02054e63          	bltz	a0,8020c9c4 <syscallExit+0x70>
    th->retValue = (ec << 8); //todo
    8020c98c:	fd843503          	ld	a0,-40(s0)
    8020c990:	0084949b          	slliw	s1,s1,0x8
    8020c994:	28952223          	sw	s1,644(a0)
    threadDestroy(th);
    8020c998:	00004097          	auipc	ra,0x4
    8020c99c:	ea4080e7          	jalr	-348(ra) # 8021083c <threadDestroy>
    panic("sycall exit error");
    8020c9a0:	00009697          	auipc	a3,0x9
    8020c9a4:	54868693          	addi	a3,a3,1352 # 80215ee8 <__func__.5+0x78>
    8020c9a8:	00009617          	auipc	a2,0x9
    8020c9ac:	67860613          	addi	a2,a2,1656 # 80216020 <__func__.9>
    8020c9b0:	0a800593          	li	a1,168
    8020c9b4:	00009517          	auipc	a0,0x9
    8020c9b8:	52450513          	addi	a0,a0,1316 # 80215ed8 <__func__.5+0x68>
    8020c9bc:	ffff4097          	auipc	ra,0xffff4
    8020c9c0:	52c080e7          	jalr	1324(ra) # 80200ee8 <_panic_>
        panic("thread exit error\n");
    8020c9c4:	00009697          	auipc	a3,0x9
    8020c9c8:	4fc68693          	addi	a3,a3,1276 # 80215ec0 <__func__.5+0x50>
    8020c9cc:	00009617          	auipc	a2,0x9
    8020c9d0:	65460613          	addi	a2,a2,1620 # 80216020 <__func__.9>
    8020c9d4:	0a100593          	li	a1,161
    8020c9d8:	00009517          	auipc	a0,0x9
    8020c9dc:	50050513          	addi	a0,a0,1280 # 80215ed8 <__func__.5+0x68>
    8020c9e0:	ffff4097          	auipc	ra,0xffff4
    8020c9e4:	508080e7          	jalr	1288(ra) # 80200ee8 <_panic_>

000000008020c9e8 <syscallPutString>:
void syscallPutString() {
    8020c9e8:	fc010113          	addi	sp,sp,-64
    8020c9ec:	02113c23          	sd	ra,56(sp)
    8020c9f0:	02813823          	sd	s0,48(sp)
    8020c9f4:	02913423          	sd	s1,40(sp)
    8020c9f8:	03213023          	sd	s2,32(sp)
    8020c9fc:	01313c23          	sd	s3,24(sp)
    8020ca00:	04010413          	addi	s0,sp,64
    Trapframe* trapframe = getHartTrapFrame();
    8020ca04:	ffffd097          	auipc	ra,0xffffd
    8020ca08:	7d8080e7          	jalr	2008(ra) # 8020a1dc <getHartTrapFrame>
    u64 va = trapframe->a0;
    8020ca0c:	07053483          	ld	s1,112(a0)
    int len = trapframe->a1;
    8020ca10:	07853903          	ld	s2,120(a0)
    8020ca14:	0009099b          	sext.w	s3,s2
    u64 pa = pageLookup(myProcess()->pgdir, va, &pte) + (va & 0xfff);
    8020ca18:	00003097          	auipc	ra,0x3
    8020ca1c:	fd0080e7          	jalr	-48(ra) # 8020f9e8 <myProcess>
    8020ca20:	fc840613          	addi	a2,s0,-56
    8020ca24:	00048593          	mv	a1,s1
    8020ca28:	04053503          	ld	a0,64(a0)
    8020ca2c:	ffffc097          	auipc	ra,0xffffc
    8020ca30:	54c080e7          	jalr	1356(ra) # 80208f78 <pageLookup>
    8020ca34:	03449793          	slli	a5,s1,0x34
    8020ca38:	0347d793          	srli	a5,a5,0x34
    8020ca3c:	00a78533          	add	a0,a5,a0
    if (pa == 0) {
    8020ca40:	04050863          	beqz	a0,8020ca90 <syscallPutString+0xa8>
    char* start = (char*) pa;
    8020ca44:	00050493          	mv	s1,a0
    while (len--) {
    8020ca48:	02098663          	beqz	s3,8020ca74 <syscallPutString+0x8c>
    8020ca4c:	fff9091b          	addiw	s2,s2,-1
    8020ca50:	02091913          	slli	s2,s2,0x20
    8020ca54:	02095913          	srli	s2,s2,0x20
    8020ca58:	00150513          	addi	a0,a0,1
    8020ca5c:	00a90933          	add	s2,s2,a0
        putchar(*start);
    8020ca60:	0004c503          	lbu	a0,0(s1)
    8020ca64:	ffff4097          	auipc	ra,0xffff4
    8020ca68:	9b4080e7          	jalr	-1612(ra) # 80200418 <putchar>
        start++;
    8020ca6c:	00148493          	addi	s1,s1,1
    while (len--) {
    8020ca70:	ff2498e3          	bne	s1,s2,8020ca60 <syscallPutString+0x78>
}
    8020ca74:	03813083          	ld	ra,56(sp)
    8020ca78:	03013403          	ld	s0,48(sp)
    8020ca7c:	02813483          	ld	s1,40(sp)
    8020ca80:	02013903          	ld	s2,32(sp)
    8020ca84:	01813983          	ld	s3,24(sp)
    8020ca88:	04010113          	addi	sp,sp,64
    8020ca8c:	00008067          	ret
        panic("Syscall put string address error!\nThe virtual address is %x, the length is %x\n", va, len);
    8020ca90:	00098793          	mv	a5,s3
    8020ca94:	00048713          	mv	a4,s1
    8020ca98:	00009697          	auipc	a3,0x9
    8020ca9c:	46868693          	addi	a3,a3,1128 # 80215f00 <__func__.5+0x90>
    8020caa0:	00009617          	auipc	a2,0x9
    8020caa4:	59060613          	addi	a2,a2,1424 # 80216030 <__func__.8>
    8020caa8:	0b300593          	li	a1,179
    8020caac:	00009517          	auipc	a0,0x9
    8020cab0:	42c50513          	addi	a0,a0,1068 # 80215ed8 <__func__.5+0x68>
    8020cab4:	ffff4097          	auipc	ra,0xffff4
    8020cab8:	434080e7          	jalr	1076(ra) # 80200ee8 <_panic_>

000000008020cabc <syscallGetCpuTimes>:
void syscallGetCpuTimes() {
    8020cabc:	fe010113          	addi	sp,sp,-32
    8020cac0:	00113c23          	sd	ra,24(sp)
    8020cac4:	00813823          	sd	s0,16(sp)
    8020cac8:	00913423          	sd	s1,8(sp)
    8020cacc:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020cad0:	ffffd097          	auipc	ra,0xffffd
    8020cad4:	70c080e7          	jalr	1804(ra) # 8020a1dc <getHartTrapFrame>
    8020cad8:	00050493          	mv	s1,a0
    Process *p = myProcess();
    8020cadc:	00003097          	auipc	ra,0x3
    8020cae0:	f0c080e7          	jalr	-244(ra) # 8020f9e8 <myProcess>
    copyout(p->pgdir, tf->a0, (char*)&p->cpuTime, sizeof(CpuTimes));
    8020cae4:	02000693          	li	a3,32
    8020cae8:	01050613          	addi	a2,a0,16
    8020caec:	0704b583          	ld	a1,112(s1)
    8020caf0:	04053503          	ld	a0,64(a0)
    8020caf4:	ffffd097          	auipc	ra,0xffffd
    8020caf8:	044080e7          	jalr	68(ra) # 80209b38 <copyout>
	return x;
}

static inline u64 r_cycle() {
	u64 x;
	asm volatile("rdcycle %0" : "=r" (x) );
    8020cafc:	c00027f3          	rdcycle	a5
    tf->a0 = (r_cycle() & 0x3FFFFFFF);
    8020cb00:	02279793          	slli	a5,a5,0x22
    8020cb04:	0227d793          	srli	a5,a5,0x22
    8020cb08:	06f4b823          	sd	a5,112(s1)
}
    8020cb0c:	01813083          	ld	ra,24(sp)
    8020cb10:	01013403          	ld	s0,16(sp)
    8020cb14:	00813483          	ld	s1,8(sp)
    8020cb18:	02010113          	addi	sp,sp,32
    8020cb1c:	00008067          	ret

000000008020cb20 <syscallGetClockTime>:
void syscallGetClockTime() {
    8020cb20:	fd010113          	addi	sp,sp,-48
    8020cb24:	02113423          	sd	ra,40(sp)
    8020cb28:	02813023          	sd	s0,32(sp)
    8020cb2c:	00913c23          	sd	s1,24(sp)
    8020cb30:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    8020cb34:	ffffd097          	auipc	ra,0xffffd
    8020cb38:	6a8080e7          	jalr	1704(ra) # 8020a1dc <getHartTrapFrame>
    8020cb3c:	00050493          	mv	s1,a0
	asm volatile("rdtime %0" : "=r" (x) );
    8020cb40:	c01027f3          	rdtime	a5
	return x + (1ll << 35);
    8020cb44:	00100713          	li	a4,1
    8020cb48:	02371713          	slli	a4,a4,0x23
    8020cb4c:	00e787b3          	add	a5,a5,a4
    ts.second = time / 1000000;
    8020cb50:	000f4737          	lui	a4,0xf4
    8020cb54:	24070713          	addi	a4,a4,576 # f4240 <_start-0x8010bdc0>
    8020cb58:	02e7d6b3          	divu	a3,a5,a4
    8020cb5c:	fcd43823          	sd	a3,-48(s0)
    ts.nanoSecond = time % 1000000 * 1000; //todo
    8020cb60:	02e7f7b3          	remu	a5,a5,a4
    8020cb64:	3e800713          	li	a4,1000
    8020cb68:	02e787b3          	mul	a5,a5,a4
    8020cb6c:	fcf43c23          	sd	a5,-40(s0)
    copyout(myProcess()->pgdir, tf->a1, (char*)&ts, sizeof(TimeSpec));
    8020cb70:	00003097          	auipc	ra,0x3
    8020cb74:	e78080e7          	jalr	-392(ra) # 8020f9e8 <myProcess>
    8020cb78:	01000693          	li	a3,16
    8020cb7c:	fd040613          	addi	a2,s0,-48
    8020cb80:	0784b583          	ld	a1,120(s1)
    8020cb84:	04053503          	ld	a0,64(a0)
    8020cb88:	ffffd097          	auipc	ra,0xffffd
    8020cb8c:	fb0080e7          	jalr	-80(ra) # 80209b38 <copyout>
    tf->a0 = 0;
    8020cb90:	0604b823          	sd	zero,112(s1)
}
    8020cb94:	02813083          	ld	ra,40(sp)
    8020cb98:	02013403          	ld	s0,32(sp)
    8020cb9c:	01813483          	ld	s1,24(sp)
    8020cba0:	03010113          	addi	sp,sp,48
    8020cba4:	00008067          	ret

000000008020cba8 <syscallGetTimeOfDay>:
void syscallGetTimeOfDay() {
    8020cba8:	fd010113          	addi	sp,sp,-48
    8020cbac:	02113423          	sd	ra,40(sp)
    8020cbb0:	02813023          	sd	s0,32(sp)
    8020cbb4:	00913c23          	sd	s1,24(sp)
    8020cbb8:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    8020cbbc:	ffffd097          	auipc	ra,0xffffd
    8020cbc0:	620080e7          	jalr	1568(ra) # 8020a1dc <getHartTrapFrame>
    8020cbc4:	00050493          	mv	s1,a0
	asm volatile("rdtime %0" : "=r" (x) );
    8020cbc8:	c01027f3          	rdtime	a5
	return x + (1ll << 35);
    8020cbcc:	00100713          	li	a4,1
    8020cbd0:	02371713          	slli	a4,a4,0x23
    8020cbd4:	00e787b3          	add	a5,a5,a4
    ts.second = time / 1000000;
    8020cbd8:	000f4737          	lui	a4,0xf4
    8020cbdc:	24070713          	addi	a4,a4,576 # f4240 <_start-0x8010bdc0>
    8020cbe0:	02e7d6b3          	divu	a3,a5,a4
    8020cbe4:	fcd43823          	sd	a3,-48(s0)
    ts.microSecond = time % 1000000; //todo
    8020cbe8:	02e7f7b3          	remu	a5,a5,a4
    8020cbec:	fcf43c23          	sd	a5,-40(s0)
    copyout(myProcess()->pgdir, tf->a1, (char*)&ts, sizeof(TimeVal));
    8020cbf0:	00003097          	auipc	ra,0x3
    8020cbf4:	df8080e7          	jalr	-520(ra) # 8020f9e8 <myProcess>
    8020cbf8:	01000693          	li	a3,16
    8020cbfc:	fd040613          	addi	a2,s0,-48
    8020cc00:	0784b583          	ld	a1,120(s1)
    8020cc04:	04053503          	ld	a0,64(a0)
    8020cc08:	ffffd097          	auipc	ra,0xffffd
    8020cc0c:	f30080e7          	jalr	-208(ra) # 80209b38 <copyout>
    tf->a0 = 0;
    8020cc10:	0604b823          	sd	zero,112(s1)
}
    8020cc14:	02813083          	ld	ra,40(sp)
    8020cc18:	02013403          	ld	s0,32(sp)
    8020cc1c:	01813483          	ld	s1,24(sp)
    8020cc20:	03010113          	addi	sp,sp,48
    8020cc24:	00008067          	ret

000000008020cc28 <syscallLog>:
void syscallLog() {
    8020cc28:	fb010113          	addi	sp,sp,-80
    8020cc2c:	04113423          	sd	ra,72(sp)
    8020cc30:	04813023          	sd	s0,64(sp)
    8020cc34:	02913c23          	sd	s1,56(sp)
    8020cc38:	03213823          	sd	s2,48(sp)
    8020cc3c:	03313423          	sd	s3,40(sp)
    8020cc40:	05010413          	addi	s0,sp,80
    Trapframe *tf = getHartTrapFrame();
    8020cc44:	ffffd097          	auipc	ra,0xffffd
    8020cc48:	598080e7          	jalr	1432(ra) # 8020a1dc <getHartTrapFrame>
    8020cc4c:	00050493          	mv	s1,a0
    int type = tf->a0;
    8020cc50:	07052703          	lw	a4,112(a0)
    u64 buf = tf->a1;
    8020cc54:	07853983          	ld	s3,120(a0)
    u32 len = tf->a2;
    8020cc58:	08053903          	ld	s2,128(a0)
    char tmp[] = "We havn't support syslog yet!\n";
    8020cc5c:	00009797          	auipc	a5,0x9
    8020cc60:	2f478793          	addi	a5,a5,756 # 80215f50 <__func__.5+0xe0>
    8020cc64:	0007b583          	ld	a1,0(a5)
    8020cc68:	0087b603          	ld	a2,8(a5)
    8020cc6c:	0107b683          	ld	a3,16(a5)
    8020cc70:	fab43823          	sd	a1,-80(s0)
    8020cc74:	fac43c23          	sd	a2,-72(s0)
    8020cc78:	fcd43023          	sd	a3,-64(s0)
    8020cc7c:	0187a683          	lw	a3,24(a5)
    8020cc80:	fcd42423          	sw	a3,-56(s0)
    8020cc84:	01c7d683          	lhu	a3,28(a5)
    8020cc88:	fcd41623          	sh	a3,-52(s0)
    8020cc8c:	01e7c783          	lbu	a5,30(a5)
    8020cc90:	fcf40723          	sb	a5,-50(s0)
    switch (type) {
    8020cc94:	00300793          	li	a5,3
    8020cc98:	02f70863          	beq	a4,a5,8020ccc8 <syscallLog+0xa0>
    8020cc9c:	00a00793          	li	a5,10
    8020cca0:	01f00913          	li	s2,31
    8020cca4:	04f71e63          	bne	a4,a5,8020cd00 <syscallLog+0xd8>
        tf->a0 = MIN(sizeof(tmp), len);
    8020cca8:	0724b823          	sd	s2,112(s1)
}
    8020ccac:	04813083          	ld	ra,72(sp)
    8020ccb0:	04013403          	ld	s0,64(sp)
    8020ccb4:	03813483          	ld	s1,56(sp)
    8020ccb8:	03013903          	ld	s2,48(sp)
    8020ccbc:	02813983          	ld	s3,40(sp)
    8020ccc0:	05010113          	addi	sp,sp,80
    8020ccc4:	00008067          	ret
        copyout(myProcess()->pgdir, buf, (char*)&tmp, MIN(sizeof(tmp), len));
    8020ccc8:	00003097          	auipc	ra,0x3
    8020cccc:	d20080e7          	jalr	-736(ra) # 8020f9e8 <myProcess>
    8020ccd0:	02091913          	slli	s2,s2,0x20
    8020ccd4:	02095913          	srli	s2,s2,0x20
    8020ccd8:	01f00793          	li	a5,31
    8020ccdc:	0127f463          	bgeu	a5,s2,8020cce4 <syscallLog+0xbc>
    8020cce0:	01f00913          	li	s2,31
    8020cce4:	00090693          	mv	a3,s2
    8020cce8:	fb040613          	addi	a2,s0,-80
    8020ccec:	00098593          	mv	a1,s3
    8020ccf0:	04053503          	ld	a0,64(a0)
    8020ccf4:	ffffd097          	auipc	ra,0xffffd
    8020ccf8:	e44080e7          	jalr	-444(ra) # 80209b38 <copyout>
        return;
    8020ccfc:	fadff06f          	j	8020cca8 <syscallLog+0x80>
        panic("%d\n", type);
    8020cd00:	00009697          	auipc	a3,0x9
    8020cd04:	2e068693          	addi	a3,a3,736 # 80215fe0 <__func__.5+0x170>
    8020cd08:	00009617          	auipc	a2,0x9
    8020cd0c:	34060613          	addi	a2,a2,832 # 80216048 <__func__.1>
    8020cd10:	28000593          	li	a1,640
    8020cd14:	00009517          	auipc	a0,0x9
    8020cd18:	1c450513          	addi	a0,a0,452 # 80215ed8 <__func__.5+0x68>
    8020cd1c:	ffff4097          	auipc	ra,0xffff4
    8020cd20:	1cc080e7          	jalr	460(ra) # 80200ee8 <_panic_>

000000008020cd24 <syscallProcessResourceLimit>:
void syscallProcessResourceLimit() {
    8020cd24:	fb010113          	addi	sp,sp,-80
    8020cd28:	04113423          	sd	ra,72(sp)
    8020cd2c:	04813023          	sd	s0,64(sp)
    8020cd30:	02913c23          	sd	s1,56(sp)
    8020cd34:	03213823          	sd	s2,48(sp)
    8020cd38:	03313423          	sd	s3,40(sp)
    8020cd3c:	03413023          	sd	s4,32(sp)
    8020cd40:	01513c23          	sd	s5,24(sp)
    8020cd44:	05010413          	addi	s0,sp,80
    Trapframe *tf = getHartTrapFrame();
    8020cd48:	ffffd097          	auipc	ra,0xffffd
    8020cd4c:	494080e7          	jalr	1172(ra) # 8020a1dc <getHartTrapFrame>
    u64 pid = tf->a0, resouce = tf->a1, newVa = tf->a2, oldVa = tf->a3;
    8020cd50:	07853983          	ld	s3,120(a0)
    8020cd54:	08053903          	ld	s2,128(a0)
    8020cd58:	08853a83          	ld	s5,136(a0)
    if (pid) {
    8020cd5c:	07053783          	ld	a5,112(a0)
    8020cd60:	04079463          	bnez	a5,8020cda8 <syscallProcessResourceLimit+0x84>
    8020cd64:	00050493          	mv	s1,a0
    Process* process = myProcess();
    8020cd68:	00003097          	auipc	ra,0x3
    8020cd6c:	c80080e7          	jalr	-896(ra) # 8020f9e8 <myProcess>
    8020cd70:	00050a13          	mv	s4,a0
    if (newVa && copyin(process->pgdir, (char*)&newLimit, newVa, sizeof(struct ResourceLimit)) < 0) {
    8020cd74:	04091c63          	bnez	s2,8020cdcc <syscallProcessResourceLimit+0xa8>
    switch(resouce) {
    8020cd78:	00700793          	li	a5,7
    8020cd7c:	08f98663          	beq	s3,a5,8020ce08 <syscallProcessResourceLimit+0xe4>
    tf->a0 = 0;
    8020cd80:	0604b823          	sd	zero,112(s1)
}
    8020cd84:	04813083          	ld	ra,72(sp)
    8020cd88:	04013403          	ld	s0,64(sp)
    8020cd8c:	03813483          	ld	s1,56(sp)
    8020cd90:	03013903          	ld	s2,48(sp)
    8020cd94:	02813983          	ld	s3,40(sp)
    8020cd98:	02013a03          	ld	s4,32(sp)
    8020cd9c:	01813a83          	ld	s5,24(sp)
    8020cda0:	05010113          	addi	sp,sp,80
    8020cda4:	00008067          	ret
        panic("Resource limit not current process!\n");
    8020cda8:	00009697          	auipc	a3,0x9
    8020cdac:	1c868693          	addi	a3,a3,456 # 80215f70 <__func__.5+0x100>
    8020cdb0:	00009617          	auipc	a2,0x9
    8020cdb4:	2a860613          	addi	a2,a2,680 # 80216058 <__func__.7>
    8020cdb8:	17000593          	li	a1,368
    8020cdbc:	00009517          	auipc	a0,0x9
    8020cdc0:	11c50513          	addi	a0,a0,284 # 80215ed8 <__func__.5+0x68>
    8020cdc4:	ffff4097          	auipc	ra,0xffff4
    8020cdc8:	124080e7          	jalr	292(ra) # 80200ee8 <_panic_>
    if (newVa && copyin(process->pgdir, (char*)&newLimit, newVa, sizeof(struct ResourceLimit)) < 0) {
    8020cdcc:	01000693          	li	a3,16
    8020cdd0:	00090613          	mv	a2,s2
    8020cdd4:	fb040593          	addi	a1,s0,-80
    8020cdd8:	04053503          	ld	a0,64(a0)
    8020cddc:	ffffd097          	auipc	ra,0xffffd
    8020cde0:	c6c080e7          	jalr	-916(ra) # 80209a48 <copyin>
    8020cde4:	04054663          	bltz	a0,8020ce30 <syscallProcessResourceLimit+0x10c>
    switch(resouce) {
    8020cde8:	00700793          	li	a5,7
    8020cdec:	f8f99ae3          	bne	s3,a5,8020cd80 <syscallProcessResourceLimit+0x5c>
                process->fileDescription.hard = newLimit.hard;
    8020cdf0:	000027b7          	lui	a5,0x2
    8020cdf4:	00fa07b3          	add	a5,s4,a5
    8020cdf8:	fb843703          	ld	a4,-72(s0)
    8020cdfc:	0ae7b023          	sd	a4,160(a5) # 20a0 <_start-0x801fdf60>
                process->fileDescription.soft = newLimit.soft;
    8020ce00:	fb043703          	ld	a4,-80(s0)
    8020ce04:	08e7bc23          	sd	a4,152(a5)
            if (oldVa) {
    8020ce08:	f60a8ce3          	beqz	s5,8020cd80 <syscallProcessResourceLimit+0x5c>
                copyout(process->pgdir, oldVa, (char*)&process->fileDescription, sizeof(struct ResourceLimit));
    8020ce0c:	01000693          	li	a3,16
    8020ce10:	00002637          	lui	a2,0x2
    8020ce14:	09860613          	addi	a2,a2,152 # 2098 <_start-0x801fdf68>
    8020ce18:	00ca0633          	add	a2,s4,a2
    8020ce1c:	000a8593          	mv	a1,s5
    8020ce20:	040a3503          	ld	a0,64(s4)
    8020ce24:	ffffd097          	auipc	ra,0xffffd
    8020ce28:	d14080e7          	jalr	-748(ra) # 80209b38 <copyout>
    8020ce2c:	f55ff06f          	j	8020cd80 <syscallProcessResourceLimit+0x5c>
        tf->a0 = -1;
    8020ce30:	fff00793          	li	a5,-1
    8020ce34:	06f4b823          	sd	a5,112(s1)
    8020ce38:	fb1ff06f          	j	8020cde8 <syscallProcessResourceLimit+0xc4>

000000008020ce3c <syscallPoll>:
void syscallPoll() {
    8020ce3c:	fc010113          	addi	sp,sp,-64
    8020ce40:	02113c23          	sd	ra,56(sp)
    8020ce44:	02813823          	sd	s0,48(sp)
    8020ce48:	02913423          	sd	s1,40(sp)
    8020ce4c:	03213023          	sd	s2,32(sp)
    8020ce50:	01313c23          	sd	s3,24(sp)
    8020ce54:	04010413          	addi	s0,sp,64
    Trapframe *tf = getHartTrapFrame();
    8020ce58:	ffffd097          	auipc	ra,0xffffd
    8020ce5c:	384080e7          	jalr	900(ra) # 8020a1dc <getHartTrapFrame>
    8020ce60:	00050993          	mv	s3,a0
    u64 startva = tf->a0;
    8020ce64:	07053483          	ld	s1,112(a0)
    int n = tf->a1;
    8020ce68:	07853903          	ld	s2,120(a0)
    for (int i = 0; i < n; i++) {
    8020ce6c:	0009079b          	sext.w	a5,s2
    8020ce70:	06f05263          	blez	a5,8020ced4 <syscallPoll+0x98>
    8020ce74:	fff9091b          	addiw	s2,s2,-1
    8020ce78:	02091793          	slli	a5,s2,0x20
    8020ce7c:	01d7d913          	srli	s2,a5,0x1d
    8020ce80:	00848793          	addi	a5,s1,8
    8020ce84:	00f90933          	add	s2,s2,a5
        copyin(myProcess()->pgdir, (char*)&p, startva, sizeof(struct pollfd));
    8020ce88:	00003097          	auipc	ra,0x3
    8020ce8c:	b60080e7          	jalr	-1184(ra) # 8020f9e8 <myProcess>
    8020ce90:	00800693          	li	a3,8
    8020ce94:	00048613          	mv	a2,s1
    8020ce98:	fc840593          	addi	a1,s0,-56
    8020ce9c:	04053503          	ld	a0,64(a0)
    8020cea0:	ffffd097          	auipc	ra,0xffffd
    8020cea4:	ba8080e7          	jalr	-1112(ra) # 80209a48 <copyin>
        p.revents = 0;
    8020cea8:	fc041723          	sh	zero,-50(s0)
        copyout(myProcess()->pgdir, startva, (char*)&p, sizeof(struct pollfd));
    8020ceac:	00003097          	auipc	ra,0x3
    8020ceb0:	b3c080e7          	jalr	-1220(ra) # 8020f9e8 <myProcess>
    8020ceb4:	00800693          	li	a3,8
    8020ceb8:	fc840613          	addi	a2,s0,-56
    8020cebc:	00048593          	mv	a1,s1
    8020cec0:	04053503          	ld	a0,64(a0)
    8020cec4:	ffffd097          	auipc	ra,0xffffd
    8020cec8:	c74080e7          	jalr	-908(ra) # 80209b38 <copyout>
        startva += sizeof(struct pollfd);
    8020cecc:	00848493          	addi	s1,s1,8
    for (int i = 0; i < n; i++) {
    8020ced0:	fb249ce3          	bne	s1,s2,8020ce88 <syscallPoll+0x4c>
    tf->a0 = 1;
    8020ced4:	00100793          	li	a5,1
    8020ced8:	06f9b823          	sd	a5,112(s3) # 1070 <_start-0x801fef90>
}
    8020cedc:	03813083          	ld	ra,56(sp)
    8020cee0:	03013403          	ld	s0,48(sp)
    8020cee4:	02813483          	ld	s1,40(sp)
    8020cee8:	02013903          	ld	s2,32(sp)
    8020ceec:	01813983          	ld	s3,24(sp)
    8020cef0:	04010113          	addi	sp,sp,64
    8020cef4:	00008067          	ret

000000008020cef8 <syscallSleepTime>:
void syscallSleepTime() {
    8020cef8:	fd010113          	addi	sp,sp,-48
    8020cefc:	02113423          	sd	ra,40(sp)
    8020cf00:	02813023          	sd	s0,32(sp)
    8020cf04:	00913c23          	sd	s1,24(sp)
    8020cf08:	01213823          	sd	s2,16(sp)
    8020cf0c:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    8020cf10:	ffffd097          	auipc	ra,0xffffd
    8020cf14:	2cc080e7          	jalr	716(ra) # 8020a1dc <getHartTrapFrame>
    8020cf18:	00050493          	mv	s1,a0
    copyin(myProcess()->pgdir, (char*)&ts, tf->a0, sizeof(TimeSpec));
    8020cf1c:	00003097          	auipc	ra,0x3
    8020cf20:	acc080e7          	jalr	-1332(ra) # 8020f9e8 <myProcess>
    8020cf24:	01000693          	li	a3,16
    8020cf28:	0704b603          	ld	a2,112(s1)
    8020cf2c:	fd040593          	addi	a1,s0,-48
    8020cf30:	04053503          	ld	a0,64(a0)
    8020cf34:	ffffd097          	auipc	ra,0xffffd
    8020cf38:	b14080e7          	jalr	-1260(ra) # 80209a48 <copyin>
	asm volatile("rdtime %0" : "=r" (x) );
    8020cf3c:	c0102973          	rdtime	s2
    myThread()->awakeTime = r_time() +  ts.second * 1000000 + ts.nanoSecond / 1000;
    8020cf40:	fd043483          	ld	s1,-48(s0)
    8020cf44:	000f47b7          	lui	a5,0xf4
    8020cf48:	24078793          	addi	a5,a5,576 # f4240 <_start-0x8010bdc0>
    8020cf4c:	02f484b3          	mul	s1,s1,a5
    8020cf50:	00100793          	li	a5,1
    8020cf54:	02379793          	slli	a5,a5,0x23
    8020cf58:	00f484b3          	add	s1,s1,a5
    8020cf5c:	fd843783          	ld	a5,-40(s0)
    8020cf60:	3e800713          	li	a4,1000
    8020cf64:	02e7c7b3          	div	a5,a5,a4
    8020cf68:	00f484b3          	add	s1,s1,a5
    8020cf6c:	00003097          	auipc	ra,0x3
    8020cf70:	5d4080e7          	jalr	1492(ra) # 80210540 <myThread>
    8020cf74:	00990933          	add	s2,s2,s1
    8020cf78:	23253823          	sd	s2,560(a0)
    kernelProcessCpuTimeEnd();
    8020cf7c:	00003097          	auipc	ra,0x3
    8020cf80:	5ac080e7          	jalr	1452(ra) # 80210528 <kernelProcessCpuTimeEnd>
    yield();
    8020cf84:	00005097          	auipc	ra,0x5
    8020cf88:	db4080e7          	jalr	-588(ra) # 80211d38 <yield>
}
    8020cf8c:	02813083          	ld	ra,40(sp)
    8020cf90:	02013403          	ld	s0,32(sp)
    8020cf94:	01813483          	ld	s1,24(sp)
    8020cf98:	01013903          	ld	s2,16(sp)
    8020cf9c:	03010113          	addi	sp,sp,48
    8020cfa0:	00008067          	ret

000000008020cfa4 <syscallSetTidAddress>:
void syscallSetTidAddress() {
    8020cfa4:	fe010113          	addi	sp,sp,-32
    8020cfa8:	00113c23          	sd	ra,24(sp)
    8020cfac:	00813823          	sd	s0,16(sp)
    8020cfb0:	00913423          	sd	s1,8(sp)
    8020cfb4:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020cfb8:	ffffd097          	auipc	ra,0xffffd
    8020cfbc:	224080e7          	jalr	548(ra) # 8020a1dc <getHartTrapFrame>
    8020cfc0:	00050493          	mv	s1,a0
    myThread()->clearChildTid = tf->a0;
    8020cfc4:	00003097          	auipc	ra,0x3
    8020cfc8:	57c080e7          	jalr	1404(ra) # 80210540 <myThread>
    8020cfcc:	0704b783          	ld	a5,112(s1)
    8020cfd0:	40f53823          	sd	a5,1040(a0)
    tf->a0 = myThread()->id;
    8020cfd4:	00003097          	auipc	ra,0x3
    8020cfd8:	56c080e7          	jalr	1388(ra) # 80210540 <myThread>
    8020cfdc:	23856783          	lwu	a5,568(a0)
    8020cfe0:	06f4b823          	sd	a5,112(s1)
}
    8020cfe4:	01813083          	ld	ra,24(sp)
    8020cfe8:	01013403          	ld	s0,16(sp)
    8020cfec:	00813483          	ld	s1,8(sp)
    8020cff0:	02010113          	addi	sp,sp,32
    8020cff4:	00008067          	ret

000000008020cff8 <syscallGetTheardId>:
void syscallGetTheardId() {
    8020cff8:	fe010113          	addi	sp,sp,-32
    8020cffc:	00113c23          	sd	ra,24(sp)
    8020d000:	00813823          	sd	s0,16(sp)
    8020d004:	00913423          	sd	s1,8(sp)
    8020d008:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d00c:	ffffd097          	auipc	ra,0xffffd
    8020d010:	1d0080e7          	jalr	464(ra) # 8020a1dc <getHartTrapFrame>
    8020d014:	00050493          	mv	s1,a0
    tf->a0 = myThread()->id;
    8020d018:	00003097          	auipc	ra,0x3
    8020d01c:	528080e7          	jalr	1320(ra) # 80210540 <myThread>
    8020d020:	23856783          	lwu	a5,568(a0)
    8020d024:	06f4b823          	sd	a5,112(s1)
}
    8020d028:	01813083          	ld	ra,24(sp)
    8020d02c:	01013403          	ld	s0,16(sp)
    8020d030:	00813483          	ld	s1,8(sp)
    8020d034:	02010113          	addi	sp,sp,32
    8020d038:	00008067          	ret

000000008020d03c <syscallGetRobustList>:
void syscallGetRobustList() {
    8020d03c:	fd010113          	addi	sp,sp,-48
    8020d040:	02113423          	sd	ra,40(sp)
    8020d044:	02813023          	sd	s0,32(sp)
    8020d048:	00913c23          	sd	s1,24(sp)
    8020d04c:	01213823          	sd	s2,16(sp)
    8020d050:	01313423          	sd	s3,8(sp)
    8020d054:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    8020d058:	ffffd097          	auipc	ra,0xffffd
    8020d05c:	184080e7          	jalr	388(ra) # 8020a1dc <getHartTrapFrame>
    8020d060:	00050493          	mv	s1,a0
    copyout(myProcess()->pgdir, tf->a1, (char*)&myThread()->robustHeadPointer, sizeof(u64));
    8020d064:	00003097          	auipc	ra,0x3
    8020d068:	984080e7          	jalr	-1660(ra) # 8020f9e8 <myProcess>
    8020d06c:	04053903          	ld	s2,64(a0)
    8020d070:	0784b983          	ld	s3,120(s1)
    8020d074:	00003097          	auipc	ra,0x3
    8020d078:	4cc080e7          	jalr	1228(ra) # 80210540 <myThread>
    8020d07c:	00800693          	li	a3,8
    8020d080:	42050613          	addi	a2,a0,1056
    8020d084:	00098593          	mv	a1,s3
    8020d088:	00090513          	mv	a0,s2
    8020d08c:	ffffd097          	auipc	ra,0xffffd
    8020d090:	aac080e7          	jalr	-1364(ra) # 80209b38 <copyout>
    tf->a0 = 0;
    8020d094:	0604b823          	sd	zero,112(s1)
}
    8020d098:	02813083          	ld	ra,40(sp)
    8020d09c:	02013403          	ld	s0,32(sp)
    8020d0a0:	01813483          	ld	s1,24(sp)
    8020d0a4:	01013903          	ld	s2,16(sp)
    8020d0a8:	00813983          	ld	s3,8(sp)
    8020d0ac:	03010113          	addi	sp,sp,48
    8020d0b0:	00008067          	ret

000000008020d0b4 <syscallSetRobustList>:
void syscallSetRobustList() {
    8020d0b4:	fe010113          	addi	sp,sp,-32
    8020d0b8:	00113c23          	sd	ra,24(sp)
    8020d0bc:	00813823          	sd	s0,16(sp)
    8020d0c0:	00913423          	sd	s1,8(sp)
    8020d0c4:	01213023          	sd	s2,0(sp)
    8020d0c8:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d0cc:	ffffd097          	auipc	ra,0xffffd
    8020d0d0:	110080e7          	jalr	272(ra) # 8020a1dc <getHartTrapFrame>
    8020d0d4:	00050493          	mv	s1,a0
    copyin(myProcess()->pgdir, (char*)&myThread()->robustHeadPointer, tf->a1, sizeof(u64));
    8020d0d8:	00003097          	auipc	ra,0x3
    8020d0dc:	910080e7          	jalr	-1776(ra) # 8020f9e8 <myProcess>
    8020d0e0:	04053903          	ld	s2,64(a0)
    8020d0e4:	00003097          	auipc	ra,0x3
    8020d0e8:	45c080e7          	jalr	1116(ra) # 80210540 <myThread>
    8020d0ec:	00800693          	li	a3,8
    8020d0f0:	0784b603          	ld	a2,120(s1)
    8020d0f4:	42050593          	addi	a1,a0,1056
    8020d0f8:	00090513          	mv	a0,s2
    8020d0fc:	ffffd097          	auipc	ra,0xffffd
    8020d100:	94c080e7          	jalr	-1716(ra) # 80209a48 <copyin>
    tf->a0 = 0;
    8020d104:	0604b823          	sd	zero,112(s1)
}
    8020d108:	01813083          	ld	ra,24(sp)
    8020d10c:	01013403          	ld	s0,16(sp)
    8020d110:	00813483          	ld	s1,8(sp)
    8020d114:	00013903          	ld	s2,0(sp)
    8020d118:	02010113          	addi	sp,sp,32
    8020d11c:	00008067          	ret

000000008020d120 <syscallBrk>:
void syscallBrk() {
    8020d120:	fe010113          	addi	sp,sp,-32
    8020d124:	00113c23          	sd	ra,24(sp)
    8020d128:	00813823          	sd	s0,16(sp)
    8020d12c:	00913423          	sd	s1,8(sp)
    8020d130:	01213023          	sd	s2,0(sp)
    8020d134:	02010413          	addi	s0,sp,32
    Trapframe *trapframe = getHartTrapFrame();
    8020d138:	ffffd097          	auipc	ra,0xffffd
    8020d13c:	0a4080e7          	jalr	164(ra) # 8020a1dc <getHartTrapFrame>
    u64 addr = trapframe->a0;
    8020d140:	07053903          	ld	s2,112(a0)
    if (addr == 0) {
    8020d144:	02091c63          	bnez	s2,8020d17c <syscallBrk+0x5c>
    8020d148:	00050493          	mv	s1,a0
        trapframe->a0 = myProcess()->heapBottom;
    8020d14c:	00003097          	auipc	ra,0x3
    8020d150:	89c080e7          	jalr	-1892(ra) # 8020f9e8 <myProcess>
    8020d154:	000027b7          	lui	a5,0x2
    8020d158:	00f50533          	add	a0,a0,a5
    8020d15c:	07853783          	ld	a5,120(a0)
    8020d160:	06f4b823          	sd	a5,112(s1)
} 
    8020d164:	01813083          	ld	ra,24(sp)
    8020d168:	01013403          	ld	s0,16(sp)
    8020d16c:	00813483          	ld	s1,8(sp)
    8020d170:	00013903          	ld	s2,0(sp)
    8020d174:	02010113          	addi	sp,sp,32
    8020d178:	00008067          	ret
    } else if (addr >= myProcess()->heapBottom) {
    8020d17c:	00003097          	auipc	ra,0x3
    8020d180:	86c080e7          	jalr	-1940(ra) # 8020f9e8 <myProcess>
    8020d184:	000027b7          	lui	a5,0x2
    8020d188:	00f50533          	add	a0,a0,a5
    8020d18c:	07853783          	ld	a5,120(a0)
    8020d190:	fcf96ae3          	bltu	s2,a5,8020d164 <syscallBrk+0x44>
        sys_sbrk(addr - myProcess()->heapBottom);
    8020d194:	00003097          	auipc	ra,0x3
    8020d198:	854080e7          	jalr	-1964(ra) # 8020f9e8 <myProcess>
    8020d19c:	000027b7          	lui	a5,0x2
    8020d1a0:	00f50533          	add	a0,a0,a5
    8020d1a4:	07853503          	ld	a0,120(a0)
    8020d1a8:	40a9053b          	subw	a0,s2,a0
    8020d1ac:	ffffd097          	auipc	ra,0xffffd
    8020d1b0:	d78080e7          	jalr	-648(ra) # 80209f24 <sys_sbrk>
} 
    8020d1b4:	fb1ff06f          	j	8020d164 <syscallBrk+0x44>

000000008020d1b8 <syscallSetBrk>:
void syscallSetBrk() {
    8020d1b8:	fe010113          	addi	sp,sp,-32
    8020d1bc:	00113c23          	sd	ra,24(sp)
    8020d1c0:	00813823          	sd	s0,16(sp)
    8020d1c4:	00913423          	sd	s1,8(sp)
    8020d1c8:	02010413          	addi	s0,sp,32
    Trapframe *trapframe = getHartTrapFrame();
    8020d1cc:	ffffd097          	auipc	ra,0xffffd
    8020d1d0:	010080e7          	jalr	16(ra) # 8020a1dc <getHartTrapFrame>
    8020d1d4:	00050493          	mv	s1,a0
    trapframe->a0 = sys_sbrk(len);
    8020d1d8:	07052503          	lw	a0,112(a0)
    8020d1dc:	ffffd097          	auipc	ra,0xffffd
    8020d1e0:	d48080e7          	jalr	-696(ra) # 80209f24 <sys_sbrk>
    8020d1e4:	06a4b823          	sd	a0,112(s1)
}
    8020d1e8:	01813083          	ld	ra,24(sp)
    8020d1ec:	01013403          	ld	s0,16(sp)
    8020d1f0:	00813483          	ld	s1,8(sp)
    8020d1f4:	02010113          	addi	sp,sp,32
    8020d1f8:	00008067          	ret

000000008020d1fc <syscallMapMemory>:
void syscallMapMemory() {
    8020d1fc:	fb010113          	addi	sp,sp,-80
    8020d200:	04113423          	sd	ra,72(sp)
    8020d204:	04813023          	sd	s0,64(sp)
    8020d208:	02913c23          	sd	s1,56(sp)
    8020d20c:	03213823          	sd	s2,48(sp)
    8020d210:	03313423          	sd	s3,40(sp)
    8020d214:	03413023          	sd	s4,32(sp)
    8020d218:	01513c23          	sd	s5,24(sp)
    8020d21c:	01613823          	sd	s6,16(sp)
    8020d220:	05010413          	addi	s0,sp,80
    Trapframe* trapframe = getHartTrapFrame();
    8020d224:	ffffd097          	auipc	ra,0xffffd
    8020d228:	fb8080e7          	jalr	-72(ra) # 8020a1dc <getHartTrapFrame>
    8020d22c:	00050493          	mv	s1,a0
    u64 start = trapframe->a0, len = trapframe->a1, prot = trapframe->a2,
    8020d230:	07053983          	ld	s3,112(a0)
    8020d234:	07853a03          	ld	s4,120(a0)
    8020d238:	08053783          	ld	a5,128(a0)
        off = trapframe->a5, flags = trapframe->a3;
    8020d23c:	09853b03          	ld	s6,152(a0)
    8020d240:	08853a83          	ld	s5,136(a0)
    if (prot & PROT_EXEC) {
    8020d244:	0017f913          	andi	s2,a5,1
    8020d248:	00090463          	beqz	s2,8020d250 <syscallMapMemory+0x54>
        perm |= PTE_EXECUTE | PTE_READ;
    8020d24c:	00a00913          	li	s2,10
    if (prot & PROT_READ) {
    8020d250:	0047f713          	andi	a4,a5,4
    8020d254:	00070463          	beqz	a4,8020d25c <syscallMapMemory+0x60>
        perm |= PTE_READ;
    8020d258:	00296913          	ori	s2,s2,2
    if (prot & PROT_WRITE) {
    8020d25c:	0027f793          	andi	a5,a5,2
    8020d260:	00078463          	beqz	a5,8020d268 <syscallMapMemory+0x6c>
        perm |= PTE_WRITE | PTE_READ;
    8020d264:	00696913          	ori	s2,s2,6
    argfd(4, 0, &fd);
    8020d268:	fb840613          	addi	a2,s0,-72
    8020d26c:	00000593          	li	a1,0
    8020d270:	00400513          	li	a0,4
    8020d274:	ffff9097          	auipc	ra,0xffff9
    8020d278:	22c080e7          	jalr	556(ra) # 802064a0 <argfd>
        do_mmap(fd, start, len, perm, /*'type' currently not used */ flags, off);
    8020d27c:	000b0793          	mv	a5,s6
    8020d280:	000a871b          	sext.w	a4,s5
    8020d284:	0009069b          	sext.w	a3,s2
    8020d288:	000a0613          	mv	a2,s4
    8020d28c:	00098593          	mv	a1,s3
    8020d290:	fb843503          	ld	a0,-72(s0)
    8020d294:	ffff7097          	auipc	ra,0xffff7
    8020d298:	07c080e7          	jalr	124(ra) # 80204310 <do_mmap>
    trapframe->a0 =
    8020d29c:	06a4b823          	sd	a0,112(s1)
}
    8020d2a0:	04813083          	ld	ra,72(sp)
    8020d2a4:	04013403          	ld	s0,64(sp)
    8020d2a8:	03813483          	ld	s1,56(sp)
    8020d2ac:	03013903          	ld	s2,48(sp)
    8020d2b0:	02813983          	ld	s3,40(sp)
    8020d2b4:	02013a03          	ld	s4,32(sp)
    8020d2b8:	01813a83          	ld	s5,24(sp)
    8020d2bc:	01013b03          	ld	s6,16(sp)
    8020d2c0:	05010113          	addi	sp,sp,80
    8020d2c4:	00008067          	ret

000000008020d2c8 <syscallUnMapMemory>:
void syscallUnMapMemory() {
    8020d2c8:	fd010113          	addi	sp,sp,-48
    8020d2cc:	02113423          	sd	ra,40(sp)
    8020d2d0:	02813023          	sd	s0,32(sp)
    8020d2d4:	00913c23          	sd	s1,24(sp)
    8020d2d8:	01213823          	sd	s2,16(sp)
    8020d2dc:	01313423          	sd	s3,8(sp)
    8020d2e0:	01413023          	sd	s4,0(sp)
    8020d2e4:	03010413          	addi	s0,sp,48
    Trapframe *trapframe = getHartTrapFrame();
    8020d2e8:	ffffd097          	auipc	ra,0xffffd
    8020d2ec:	ef4080e7          	jalr	-268(ra) # 8020a1dc <getHartTrapFrame>
    8020d2f0:	00050a13          	mv	s4,a0
    u64 start = trapframe->a0, len = trapframe->a1, end = start + len;
    8020d2f4:	07053483          	ld	s1,112(a0)
    8020d2f8:	07853903          	ld	s2,120(a0)
    8020d2fc:	01248933          	add	s2,s1,s2
    start = UP_ALIGN(start, PAGE_SIZE);
    8020d300:	fff48493          	addi	s1,s1,-1
    8020d304:	fffff7b7          	lui	a5,0xfffff
    8020d308:	00f4f4b3          	and	s1,s1,a5
    8020d30c:	00001737          	lui	a4,0x1
    8020d310:	00e484b3          	add	s1,s1,a4
    end = DOWN_ALIGN(end, PAGE_SIZE);
    8020d314:	00f97933          	and	s2,s2,a5
    while (start < end) {
    8020d318:	0324f663          	bgeu	s1,s2,8020d344 <syscallUnMapMemory+0x7c>
        start += PGSIZE;
    8020d31c:	000019b7          	lui	s3,0x1
        if (pageRemove(myProcess()->pgdir, start) < 0) {
    8020d320:	00002097          	auipc	ra,0x2
    8020d324:	6c8080e7          	jalr	1736(ra) # 8020f9e8 <myProcess>
    8020d328:	00048593          	mv	a1,s1
    8020d32c:	04053503          	ld	a0,64(a0)
    8020d330:	ffffc097          	auipc	ra,0xffffc
    8020d334:	d38080e7          	jalr	-712(ra) # 80209068 <pageRemove>
    8020d338:	02054a63          	bltz	a0,8020d36c <syscallUnMapMemory+0xa4>
        start += PGSIZE;
    8020d33c:	013484b3          	add	s1,s1,s3
    while (start < end) {
    8020d340:	ff24e0e3          	bltu	s1,s2,8020d320 <syscallUnMapMemory+0x58>
    trapframe->a0 = 0;
    8020d344:	00000793          	li	a5,0
            trapframe->a0 = -1;
    8020d348:	06fa3823          	sd	a5,112(s4)
}
    8020d34c:	02813083          	ld	ra,40(sp)
    8020d350:	02013403          	ld	s0,32(sp)
    8020d354:	01813483          	ld	s1,24(sp)
    8020d358:	01013903          	ld	s2,16(sp)
    8020d35c:	00813983          	ld	s3,8(sp)
    8020d360:	00013a03          	ld	s4,0(sp)
    8020d364:	03010113          	addi	sp,sp,48
    8020d368:	00008067          	ret
    8020d36c:	fff00793          	li	a5,-1
    8020d370:	fd9ff06f          	j	8020d348 <syscallUnMapMemory+0x80>

000000008020d374 <syscallExec>:
void syscallExec() {
    8020d374:	fe010113          	addi	sp,sp,-32
    8020d378:	00113c23          	sd	ra,24(sp)
    8020d37c:	00813823          	sd	s0,16(sp)
    8020d380:	00913423          	sd	s1,8(sp)
    8020d384:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d388:	ffffd097          	auipc	ra,0xffffd
    8020d38c:	e54080e7          	jalr	-428(ra) # 8020a1dc <getHartTrapFrame>
    8020d390:	00050493          	mv	s1,a0
    tf->a0 = sys_exec();
    8020d394:	fffff097          	auipc	ra,0xfffff
    8020d398:	b80080e7          	jalr	-1152(ra) # 8020bf14 <sys_exec>
    8020d39c:	06a4b823          	sd	a0,112(s1)
}
    8020d3a0:	01813083          	ld	ra,24(sp)
    8020d3a4:	01013403          	ld	s0,16(sp)
    8020d3a8:	00813483          	ld	s1,8(sp)
    8020d3ac:	02010113          	addi	sp,sp,32
    8020d3b0:	00008067          	ret

000000008020d3b4 <syscallUname>:
void syscallUname() {
    8020d3b4:	e5010113          	addi	sp,sp,-432
    8020d3b8:	1a113423          	sd	ra,424(sp)
    8020d3bc:	1a813023          	sd	s0,416(sp)
    8020d3c0:	18913c23          	sd	s1,408(sp)
    8020d3c4:	1b010413          	addi	s0,sp,432
    strncpy(uname.sysname, "my_linux", 65);
    8020d3c8:	04100613          	li	a2,65
    8020d3cc:	00009597          	auipc	a1,0x9
    8020d3d0:	bcc58593          	addi	a1,a1,-1076 # 80215f98 <__func__.5+0x128>
    8020d3d4:	e5840513          	addi	a0,s0,-424
    8020d3d8:	00002097          	auipc	ra,0x2
    8020d3dc:	afc080e7          	jalr	-1284(ra) # 8020eed4 <strncpy>
    strncpy(uname.nodename, "my_node", 65);
    8020d3e0:	04100613          	li	a2,65
    8020d3e4:	00009597          	auipc	a1,0x9
    8020d3e8:	bc458593          	addi	a1,a1,-1084 # 80215fa8 <__func__.5+0x138>
    8020d3ec:	e9940513          	addi	a0,s0,-359
    8020d3f0:	00002097          	auipc	ra,0x2
    8020d3f4:	ae4080e7          	jalr	-1308(ra) # 8020eed4 <strncpy>
    strncpy(uname.release, "10.2.0", 65);
    8020d3f8:	04100613          	li	a2,65
    8020d3fc:	00009597          	auipc	a1,0x9
    8020d400:	bb458593          	addi	a1,a1,-1100 # 80215fb0 <__func__.5+0x140>
    8020d404:	eda40513          	addi	a0,s0,-294
    8020d408:	00002097          	auipc	ra,0x2
    8020d40c:	acc080e7          	jalr	-1332(ra) # 8020eed4 <strncpy>
    strncpy(uname.version, "MIPS-OS", 65);
    8020d410:	04100613          	li	a2,65
    8020d414:	00009597          	auipc	a1,0x9
    8020d418:	ba458593          	addi	a1,a1,-1116 # 80215fb8 <__func__.5+0x148>
    8020d41c:	f1b40513          	addi	a0,s0,-229
    8020d420:	00002097          	auipc	ra,0x2
    8020d424:	ab4080e7          	jalr	-1356(ra) # 8020eed4 <strncpy>
    strncpy(uname.machine, "Risc-V sifive_u", 65);
    8020d428:	04100613          	li	a2,65
    8020d42c:	00009597          	auipc	a1,0x9
    8020d430:	b9458593          	addi	a1,a1,-1132 # 80215fc0 <__func__.5+0x150>
    8020d434:	f5c40513          	addi	a0,s0,-164
    8020d438:	00002097          	auipc	ra,0x2
    8020d43c:	a9c080e7          	jalr	-1380(ra) # 8020eed4 <strncpy>
    strncpy(uname.domainname, "Beijing", 65);
    8020d440:	04100613          	li	a2,65
    8020d444:	00009597          	auipc	a1,0x9
    8020d448:	b8c58593          	addi	a1,a1,-1140 # 80215fd0 <__func__.5+0x160>
    8020d44c:	f9d40513          	addi	a0,s0,-99
    8020d450:	00002097          	auipc	ra,0x2
    8020d454:	a84080e7          	jalr	-1404(ra) # 8020eed4 <strncpy>
    Trapframe *tf = getHartTrapFrame();
    8020d458:	ffffd097          	auipc	ra,0xffffd
    8020d45c:	d84080e7          	jalr	-636(ra) # 8020a1dc <getHartTrapFrame>
    8020d460:	00050493          	mv	s1,a0
    copyout(myProcess()->pgdir, tf->a0, (char*)&uname, sizeof(struct utsname));
    8020d464:	00002097          	auipc	ra,0x2
    8020d468:	584080e7          	jalr	1412(ra) # 8020f9e8 <myProcess>
    8020d46c:	18600693          	li	a3,390
    8020d470:	e5840613          	addi	a2,s0,-424
    8020d474:	0704b583          	ld	a1,112(s1)
    8020d478:	04053503          	ld	a0,64(a0)
    8020d47c:	ffffc097          	auipc	ra,0xffffc
    8020d480:	6bc080e7          	jalr	1724(ra) # 80209b38 <copyout>
    tf->a0 = 0;
    8020d484:	0604b823          	sd	zero,112(s1)
}
    8020d488:	1a813083          	ld	ra,424(sp)
    8020d48c:	1a013403          	ld	s0,416(sp)
    8020d490:	19813483          	ld	s1,408(sp)
    8020d494:	1b010113          	addi	sp,sp,432
    8020d498:	00008067          	ret

000000008020d49c <syscallSignProccessMask>:
void syscallSignProccessMask() {
    8020d49c:	f5010113          	addi	sp,sp,-176
    8020d4a0:	0a113423          	sd	ra,168(sp)
    8020d4a4:	0a813023          	sd	s0,160(sp)
    8020d4a8:	08913c23          	sd	s1,152(sp)
    8020d4ac:	09213823          	sd	s2,144(sp)
    8020d4b0:	09313423          	sd	s3,136(sp)
    8020d4b4:	09413023          	sd	s4,128(sp)
    8020d4b8:	0b010413          	addi	s0,sp,176
    Trapframe *tf = getHartTrapFrame();
    8020d4bc:	ffffd097          	auipc	ra,0xffffd
    8020d4c0:	d20080e7          	jalr	-736(ra) # 8020a1dc <getHartTrapFrame>
    8020d4c4:	00050493          	mv	s1,a0
    u64 how = tf->a0;
    8020d4c8:	07053a03          	ld	s4,112(a0)
    Process *p = myProcess();
    8020d4cc:	00002097          	auipc	ra,0x2
    8020d4d0:	51c080e7          	jalr	1308(ra) # 8020f9e8 <myProcess>
    8020d4d4:	00050913          	mv	s2,a0
    copyin(p->pgdir, (char*)&set, tf->a1, tf->a3);
    8020d4d8:	0884b683          	ld	a3,136(s1)
    8020d4dc:	0784b603          	ld	a2,120(s1)
    8020d4e0:	f5040593          	addi	a1,s0,-176
    8020d4e4:	04053503          	ld	a0,64(a0)
    8020d4e8:	ffffc097          	auipc	ra,0xffffc
    8020d4ec:	560080e7          	jalr	1376(ra) # 80209a48 <copyin>
    if (tf->a2 != 0) {
    8020d4f0:	0804b983          	ld	s3,128(s1)
    8020d4f4:	02099c63          	bnez	s3,8020d52c <syscallSignProccessMask+0x90>
    tf->a0 = signProccessMask(how, &set);
    8020d4f8:	f5040593          	addi	a1,s0,-176
    8020d4fc:	000a0513          	mv	a0,s4
    8020d500:	ffffd097          	auipc	ra,0xffffd
    8020d504:	08c080e7          	jalr	140(ra) # 8020a58c <signProccessMask>
    8020d508:	06a4b823          	sd	a0,112(s1)
}
    8020d50c:	0a813083          	ld	ra,168(sp)
    8020d510:	0a013403          	ld	s0,160(sp)
    8020d514:	09813483          	ld	s1,152(sp)
    8020d518:	09013903          	ld	s2,144(sp)
    8020d51c:	08813983          	ld	s3,136(sp)
    8020d520:	08013a03          	ld	s4,128(sp)
    8020d524:	0b010113          	addi	sp,sp,176
    8020d528:	00008067          	ret
        copyout(p->pgdir, tf->a2, (char*)(&myThread()->blocked), tf->a3);
    8020d52c:	04093903          	ld	s2,64(s2)
    8020d530:	00003097          	auipc	ra,0x3
    8020d534:	010080e7          	jalr	16(ra) # 80210540 <myThread>
    8020d538:	0884b683          	ld	a3,136(s1)
    8020d53c:	28850613          	addi	a2,a0,648
    8020d540:	00098593          	mv	a1,s3
    8020d544:	00090513          	mv	a0,s2
    8020d548:	ffffc097          	auipc	ra,0xffffc
    8020d54c:	5f0080e7          	jalr	1520(ra) # 80209b38 <copyout>
    8020d550:	fa9ff06f          	j	8020d4f8 <syscallSignProccessMask+0x5c>

000000008020d554 <syscallSignalAction>:
void syscallSignalAction() {
    8020d554:	fe010113          	addi	sp,sp,-32
    8020d558:	00113c23          	sd	ra,24(sp)
    8020d55c:	00813823          	sd	s0,16(sp)
    8020d560:	00913423          	sd	s1,8(sp)
    8020d564:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d568:	ffffd097          	auipc	ra,0xffffd
    8020d56c:	c74080e7          	jalr	-908(ra) # 8020a1dc <getHartTrapFrame>
    8020d570:	00050493          	mv	s1,a0
    tf->a0 = doSignalAction(tf->a0, tf->a1, tf->a2);
    8020d574:	08053603          	ld	a2,128(a0)
    8020d578:	07853583          	ld	a1,120(a0)
    8020d57c:	07052503          	lw	a0,112(a0)
    8020d580:	ffffd097          	auipc	ra,0xffffd
    8020d584:	0ac080e7          	jalr	172(ra) # 8020a62c <doSignalAction>
    8020d588:	06a4b823          	sd	a0,112(s1)
}
    8020d58c:	01813083          	ld	ra,24(sp)
    8020d590:	01013403          	ld	s0,16(sp)
    8020d594:	00813483          	ld	s1,8(sp)
    8020d598:	02010113          	addi	sp,sp,32
    8020d59c:	00008067          	ret

000000008020d5a0 <syscallSignalTimedWait>:
void syscallSignalTimedWait() {
    8020d5a0:	ed010113          	addi	sp,sp,-304
    8020d5a4:	12113423          	sd	ra,296(sp)
    8020d5a8:	12813023          	sd	s0,288(sp)
    8020d5ac:	10913c23          	sd	s1,280(sp)
    8020d5b0:	11213823          	sd	s2,272(sp)
    8020d5b4:	13010413          	addi	s0,sp,304
    Trapframe *tf = getHartTrapFrame();
    8020d5b8:	ffffd097          	auipc	ra,0xffffd
    8020d5bc:	c24080e7          	jalr	-988(ra) # 8020a1dc <getHartTrapFrame>
    8020d5c0:	00050493          	mv	s1,a0
    Process *p = myProcess();
    8020d5c4:	00002097          	auipc	ra,0x2
    8020d5c8:	424080e7          	jalr	1060(ra) # 8020f9e8 <myProcess>
    8020d5cc:	00050913          	mv	s2,a0
    if (tf->a2) {
    8020d5d0:	0804b603          	ld	a2,128(s1)
    8020d5d4:	06061a63          	bnez	a2,8020d648 <syscallSignalTimedWait+0xa8>
    copyin(p->pgdir, (char*) &signalSet, tf->a0, tf->a3);
    8020d5d8:	0884b683          	ld	a3,136(s1)
    8020d5dc:	0704b603          	ld	a2,112(s1)
    8020d5e0:	f5040593          	addi	a1,s0,-176
    8020d5e4:	04093503          	ld	a0,64(s2)
    8020d5e8:	ffffc097          	auipc	ra,0xffffc
    8020d5ec:	460080e7          	jalr	1120(ra) # 80209a48 <copyin>
    copyin(p->pgdir, (char*) &info, tf->a0, sizeof(SignalInfo));
    8020d5f0:	08000693          	li	a3,128
    8020d5f4:	0704b603          	ld	a2,112(s1)
    8020d5f8:	ed040593          	addi	a1,s0,-304
    8020d5fc:	04093503          	ld	a0,64(s2)
    8020d600:	ffffc097          	auipc	ra,0xffffc
    8020d604:	448080e7          	jalr	1096(ra) # 80209a48 <copyin>
    tf->a0 = doSignalTimedWait(&signalSet, &info, tf->a2 ? &ts: 0);
    8020d608:	0804b783          	ld	a5,128(s1)
    8020d60c:	00f037b3          	snez	a5,a5
    8020d610:	40f007b3          	neg	a5,a5
    8020d614:	fd040613          	addi	a2,s0,-48
    8020d618:	00f67633          	and	a2,a2,a5
    8020d61c:	ed040593          	addi	a1,s0,-304
    8020d620:	f5040513          	addi	a0,s0,-176
    8020d624:	ffffd097          	auipc	ra,0xffffd
    8020d628:	5d0080e7          	jalr	1488(ra) # 8020abf4 <doSignalTimedWait>
    8020d62c:	06a4b823          	sd	a0,112(s1)
}
    8020d630:	12813083          	ld	ra,296(sp)
    8020d634:	12013403          	ld	s0,288(sp)
    8020d638:	11813483          	ld	s1,280(sp)
    8020d63c:	11013903          	ld	s2,272(sp)
    8020d640:	13010113          	addi	sp,sp,304
    8020d644:	00008067          	ret
        copyin(p->pgdir, (char*) &ts, tf->a2, sizeof(TimeSpec));
    8020d648:	01000693          	li	a3,16
    8020d64c:	fd040593          	addi	a1,s0,-48
    8020d650:	04053503          	ld	a0,64(a0)
    8020d654:	ffffc097          	auipc	ra,0xffffc
    8020d658:	3f4080e7          	jalr	1012(ra) # 80209a48 <copyin>
    8020d65c:	f7dff06f          	j	8020d5d8 <syscallSignalTimedWait+0x38>

000000008020d660 <syscallSocket>:
void syscallSocket() {
    8020d660:	fe010113          	addi	sp,sp,-32
    8020d664:	00113c23          	sd	ra,24(sp)
    8020d668:	00813823          	sd	s0,16(sp)
    8020d66c:	00913423          	sd	s1,8(sp)
    8020d670:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d674:	ffffd097          	auipc	ra,0xffffd
    8020d678:	b68080e7          	jalr	-1176(ra) # 8020a1dc <getHartTrapFrame>
    8020d67c:	00050493          	mv	s1,a0
    tf->a0 = createSocket(domain, type, protocal);
    8020d680:	08052603          	lw	a2,128(a0)
    8020d684:	07852583          	lw	a1,120(a0)
    8020d688:	07052503          	lw	a0,112(a0)
    8020d68c:	ffff8097          	auipc	ra,0xffff8
    8020d690:	448080e7          	jalr	1096(ra) # 80205ad4 <createSocket>
    8020d694:	06a4b823          	sd	a0,112(s1)
}
    8020d698:	01813083          	ld	ra,24(sp)
    8020d69c:	01013403          	ld	s0,16(sp)
    8020d6a0:	00813483          	ld	s1,8(sp)
    8020d6a4:	02010113          	addi	sp,sp,32
    8020d6a8:	00008067          	ret

000000008020d6ac <syscallBind>:
void syscallBind() {
    8020d6ac:	fc010113          	addi	sp,sp,-64
    8020d6b0:	02113c23          	sd	ra,56(sp)
    8020d6b4:	02813823          	sd	s0,48(sp)
    8020d6b8:	02913423          	sd	s1,40(sp)
    8020d6bc:	04010413          	addi	s0,sp,64
    Trapframe *tf = getHartTrapFrame();
    8020d6c0:	ffffd097          	auipc	ra,0xffffd
    8020d6c4:	b1c080e7          	jalr	-1252(ra) # 8020a1dc <getHartTrapFrame>
    8020d6c8:	00050493          	mv	s1,a0
    copyin(myProcess()->pgdir, (char*)&sa, tf->a1, tf->a2);
    8020d6cc:	00002097          	auipc	ra,0x2
    8020d6d0:	31c080e7          	jalr	796(ra) # 8020f9e8 <myProcess>
    8020d6d4:	0804b683          	ld	a3,128(s1)
    8020d6d8:	0784b603          	ld	a2,120(s1)
    8020d6dc:	fc040593          	addi	a1,s0,-64
    8020d6e0:	04053503          	ld	a0,64(a0)
    8020d6e4:	ffffc097          	auipc	ra,0xffffc
    8020d6e8:	364080e7          	jalr	868(ra) # 80209a48 <copyin>
    tf->a0 = bindSocket(tf->a0, &sa);
    8020d6ec:	fc040593          	addi	a1,s0,-64
    8020d6f0:	0704a503          	lw	a0,112(s1)
    8020d6f4:	ffff8097          	auipc	ra,0xffff8
    8020d6f8:	4cc080e7          	jalr	1228(ra) # 80205bc0 <bindSocket>
    8020d6fc:	06a4b823          	sd	a0,112(s1)
}
    8020d700:	03813083          	ld	ra,56(sp)
    8020d704:	03013403          	ld	s0,48(sp)
    8020d708:	02813483          	ld	s1,40(sp)
    8020d70c:	04010113          	addi	sp,sp,64
    8020d710:	00008067          	ret

000000008020d714 <syscallGetSocketName>:
void syscallGetSocketName() {
    8020d714:	fe010113          	addi	sp,sp,-32
    8020d718:	00113c23          	sd	ra,24(sp)
    8020d71c:	00813823          	sd	s0,16(sp)
    8020d720:	00913423          	sd	s1,8(sp)
    8020d724:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d728:	ffffd097          	auipc	ra,0xffffd
    8020d72c:	ab4080e7          	jalr	-1356(ra) # 8020a1dc <getHartTrapFrame>
    8020d730:	00050493          	mv	s1,a0
    tf->a0 = getSocketName(tf->a0, tf->a1);
    8020d734:	07853583          	ld	a1,120(a0)
    8020d738:	07052503          	lw	a0,112(a0)
    8020d73c:	ffff8097          	auipc	ra,0xffff8
    8020d740:	59c080e7          	jalr	1436(ra) # 80205cd8 <getSocketName>
    8020d744:	06a4b823          	sd	a0,112(s1)
}
    8020d748:	01813083          	ld	ra,24(sp)
    8020d74c:	01013403          	ld	s0,16(sp)
    8020d750:	00813483          	ld	s1,8(sp)
    8020d754:	02010113          	addi	sp,sp,32
    8020d758:	00008067          	ret

000000008020d75c <syscallGetResouceUsage>:
void syscallGetResouceUsage() {
    8020d75c:	f4010113          	addi	sp,sp,-192
    8020d760:	0a113c23          	sd	ra,184(sp)
    8020d764:	0a813823          	sd	s0,176(sp)
    8020d768:	0a913423          	sd	s1,168(sp)
    8020d76c:	0b213023          	sd	s2,160(sp)
    8020d770:	09313c23          	sd	s3,152(sp)
    8020d774:	09413823          	sd	s4,144(sp)
    8020d778:	0c010413          	addi	s0,sp,192
    Trapframe *tf = getHartTrapFrame();
    8020d77c:	ffffd097          	auipc	ra,0xffffd
    8020d780:	a60080e7          	jalr	-1440(ra) # 8020a1dc <getHartTrapFrame>
    8020d784:	00050913          	mv	s2,a0
    u64 usage = tf->a1;
    8020d788:	07853983          	ld	s3,120(a0)
    assert(who == 0);
    8020d78c:	07052683          	lw	a3,112(a0)
    8020d790:	0016b693          	seqz	a3,a3
    8020d794:	00009617          	auipc	a2,0x9
    8020d798:	8e460613          	addi	a2,a2,-1820 # 80216078 <__func__.0>
    8020d79c:	28e00593          	li	a1,654
    8020d7a0:	00008517          	auipc	a0,0x8
    8020d7a4:	73850513          	addi	a0,a0,1848 # 80215ed8 <__func__.5+0x68>
    8020d7a8:	ffff3097          	auipc	ra,0xffff3
    8020d7ac:	7b0080e7          	jalr	1968(ra) # 80200f58 <_assert_>
    rusage.ru_utime.second = myProcess()->cpuTime.user / 1000000;
    8020d7b0:	00002097          	auipc	ra,0x2
    8020d7b4:	238080e7          	jalr	568(ra) # 8020f9e8 <myProcess>
    8020d7b8:	01053783          	ld	a5,16(a0)
    8020d7bc:	000f44b7          	lui	s1,0xf4
    8020d7c0:	24048493          	addi	s1,s1,576 # f4240 <_start-0x8010bdc0>
    8020d7c4:	0297c7b3          	div	a5,a5,s1
    8020d7c8:	f4f43023          	sd	a5,-192(s0)
    rusage.ru_utime.nanoSecond = myProcess()->cpuTime.user % 1000000 * 1000;
    8020d7cc:	00002097          	auipc	ra,0x2
    8020d7d0:	21c080e7          	jalr	540(ra) # 8020f9e8 <myProcess>
    8020d7d4:	01053783          	ld	a5,16(a0)
    8020d7d8:	0297e7b3          	rem	a5,a5,s1
    8020d7dc:	3e800a13          	li	s4,1000
    8020d7e0:	034787b3          	mul	a5,a5,s4
    8020d7e4:	f4f43423          	sd	a5,-184(s0)
    rusage.ru_stime.second = myProcess()->cpuTime.kernel / 1000000;
    8020d7e8:	00002097          	auipc	ra,0x2
    8020d7ec:	200080e7          	jalr	512(ra) # 8020f9e8 <myProcess>
    8020d7f0:	01853783          	ld	a5,24(a0)
    8020d7f4:	0297c7b3          	div	a5,a5,s1
    8020d7f8:	f4f43823          	sd	a5,-176(s0)
    rusage.ru_stime.nanoSecond = myProcess()->cpuTime.kernel % 1000000 * 1000;
    8020d7fc:	00002097          	auipc	ra,0x2
    8020d800:	1ec080e7          	jalr	492(ra) # 8020f9e8 <myProcess>
    8020d804:	01853783          	ld	a5,24(a0)
    8020d808:	0297e7b3          	rem	a5,a5,s1
    8020d80c:	034787b3          	mul	a5,a5,s4
    8020d810:	f4f43c23          	sd	a5,-168(s0)
    copyout(myProcess()->pgdir, usage, (char*)&rusage, sizeof (struct rusage));
    8020d814:	00002097          	auipc	ra,0x2
    8020d818:	1d4080e7          	jalr	468(ra) # 8020f9e8 <myProcess>
    8020d81c:	09000693          	li	a3,144
    8020d820:	f4040613          	addi	a2,s0,-192
    8020d824:	00098593          	mv	a1,s3
    8020d828:	04053503          	ld	a0,64(a0)
    8020d82c:	ffffc097          	auipc	ra,0xffffc
    8020d830:	30c080e7          	jalr	780(ra) # 80209b38 <copyout>
    tf->a0 = 0;
    8020d834:	06093823          	sd	zero,112(s2)
}
    8020d838:	0b813083          	ld	ra,184(sp)
    8020d83c:	0b013403          	ld	s0,176(sp)
    8020d840:	0a813483          	ld	s1,168(sp)
    8020d844:	0a013903          	ld	s2,160(sp)
    8020d848:	09813983          	ld	s3,152(sp)
    8020d84c:	09013a03          	ld	s4,144(sp)
    8020d850:	0c010113          	addi	sp,sp,192
    8020d854:	00008067          	ret

000000008020d858 <syscallSendTo>:
void syscallSendTo() {
    8020d858:	fc010113          	addi	sp,sp,-64
    8020d85c:	02113c23          	sd	ra,56(sp)
    8020d860:	02813823          	sd	s0,48(sp)
    8020d864:	02913423          	sd	s1,40(sp)
    8020d868:	03213023          	sd	s2,32(sp)
    8020d86c:	04010413          	addi	s0,sp,64
    Trapframe *tf = getHartTrapFrame();
    8020d870:	ffffd097          	auipc	ra,0xffffd
    8020d874:	96c080e7          	jalr	-1684(ra) # 8020a1dc <getHartTrapFrame>
    8020d878:	00050493          	mv	s1,a0
    assert(tf->a5 == sizeof(SocketAddr));
    8020d87c:	09853683          	ld	a3,152(a0)
    8020d880:	fe068693          	addi	a3,a3,-32
    8020d884:	0016b693          	seqz	a3,a3
    8020d888:	00009617          	auipc	a2,0x9
    8020d88c:	80860613          	addi	a2,a2,-2040 # 80216090 <__func__.6>
    8020d890:	1aa00593          	li	a1,426
    8020d894:	00008517          	auipc	a0,0x8
    8020d898:	64450513          	addi	a0,a0,1604 # 80215ed8 <__func__.5+0x68>
    8020d89c:	ffff3097          	auipc	ra,0xffff3
    8020d8a0:	6bc080e7          	jalr	1724(ra) # 80200f58 <_assert_>
    copyin(myProcess()->pgdir, (char *)&sa, tf->a4, sizeof(SocketAddr));
    8020d8a4:	00002097          	auipc	ra,0x2
    8020d8a8:	144080e7          	jalr	324(ra) # 8020f9e8 <myProcess>
    8020d8ac:	02000693          	li	a3,32
    8020d8b0:	0904b603          	ld	a2,144(s1)
    8020d8b4:	fc040593          	addi	a1,s0,-64
    8020d8b8:	04053503          	ld	a0,64(a0)
    8020d8bc:	ffffc097          	auipc	ra,0xffffc
    8020d8c0:	18c080e7          	jalr	396(ra) # 80209a48 <copyin>
    u32 len = MIN(tf->a2, PAGE_SIZE);
    8020d8c4:	0804b903          	ld	s2,128(s1)
    8020d8c8:	000017b7          	lui	a5,0x1
    8020d8cc:	0127f463          	bgeu	a5,s2,8020d8d4 <syscallSendTo+0x7c>
    8020d8d0:	00001937          	lui	s2,0x1
    copyin(myProcess()->pgdir, buf, tf->a1, len);
    8020d8d4:	00002097          	auipc	ra,0x2
    8020d8d8:	114080e7          	jalr	276(ra) # 8020f9e8 <myProcess>
    8020d8dc:	00090693          	mv	a3,s2
    8020d8e0:	0784b603          	ld	a2,120(s1)
    8020d8e4:	01cc4597          	auipc	a1,0x1cc4
    8020d8e8:	d1c58593          	addi	a1,a1,-740 # 81ed1600 <buf.5>
    8020d8ec:	04053503          	ld	a0,64(a0)
    8020d8f0:	ffffc097          	auipc	ra,0xffffc
    8020d8f4:	158080e7          	jalr	344(ra) # 80209a48 <copyin>
    tf->a0 = sendTo(myProcess()->ofile[tf->a0]->socket, buf, tf->a2, tf->a3, &sa);
    8020d8f8:	00002097          	auipc	ra,0x2
    8020d8fc:	0f0080e7          	jalr	240(ra) # 8020f9e8 <myProcess>
    8020d900:	0704b783          	ld	a5,112(s1)
    8020d904:	00e78793          	addi	a5,a5,14 # 100e <_start-0x801feff2>
    8020d908:	00379793          	slli	a5,a5,0x3
    8020d90c:	00f50533          	add	a0,a0,a5
    8020d910:	00053783          	ld	a5,0(a0)
    8020d914:	fc040713          	addi	a4,s0,-64
    8020d918:	0884a683          	lw	a3,136(s1)
    8020d91c:	0804a603          	lw	a2,128(s1)
    8020d920:	01cc4597          	auipc	a1,0x1cc4
    8020d924:	ce058593          	addi	a1,a1,-800 # 81ed1600 <buf.5>
    8020d928:	0207b503          	ld	a0,32(a5)
    8020d92c:	ffff8097          	auipc	ra,0xffff8
    8020d930:	44c080e7          	jalr	1100(ra) # 80205d78 <sendTo>
    8020d934:	06a4b823          	sd	a0,112(s1)
}
    8020d938:	03813083          	ld	ra,56(sp)
    8020d93c:	03013403          	ld	s0,48(sp)
    8020d940:	02813483          	ld	s1,40(sp)
    8020d944:	02013903          	ld	s2,32(sp)
    8020d948:	04010113          	addi	sp,sp,64
    8020d94c:	00008067          	ret

000000008020d950 <syscallReceiveFrom>:
void syscallReceiveFrom() {
    8020d950:	fe010113          	addi	sp,sp,-32
    8020d954:	00113c23          	sd	ra,24(sp)
    8020d958:	00813823          	sd	s0,16(sp)
    8020d95c:	00913423          	sd	s1,8(sp)
    8020d960:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d964:	ffffd097          	auipc	ra,0xffffd
    8020d968:	878080e7          	jalr	-1928(ra) # 8020a1dc <getHartTrapFrame>
    8020d96c:	00050493          	mv	s1,a0
    tf->a0 = receiveFrom(myProcess()->ofile[tf->a0]->socket, tf->a1, tf->a2, tf->a3, tf->a4);
    8020d970:	00002097          	auipc	ra,0x2
    8020d974:	078080e7          	jalr	120(ra) # 8020f9e8 <myProcess>
    8020d978:	0704b783          	ld	a5,112(s1)
    8020d97c:	00e78793          	addi	a5,a5,14
    8020d980:	00379793          	slli	a5,a5,0x3
    8020d984:	00f50533          	add	a0,a0,a5
    8020d988:	00053783          	ld	a5,0(a0)
    8020d98c:	0904b703          	ld	a4,144(s1)
    8020d990:	0884a683          	lw	a3,136(s1)
    8020d994:	0804a603          	lw	a2,128(s1)
    8020d998:	0784b583          	ld	a1,120(s1)
    8020d99c:	0207b503          	ld	a0,32(a5)
    8020d9a0:	ffff8097          	auipc	ra,0xffff8
    8020d9a4:	564080e7          	jalr	1380(ra) # 80205f04 <receiveFrom>
    8020d9a8:	06a4b823          	sd	a0,112(s1)
}
    8020d9ac:	01813083          	ld	ra,24(sp)
    8020d9b0:	01013403          	ld	s0,16(sp)
    8020d9b4:	00813483          	ld	s1,8(sp)
    8020d9b8:	02010113          	addi	sp,sp,32
    8020d9bc:	00008067          	ret

000000008020d9c0 <syscallListen>:
void syscallListen() {
    8020d9c0:	fe010113          	addi	sp,sp,-32
    8020d9c4:	00113c23          	sd	ra,24(sp)
    8020d9c8:	00813823          	sd	s0,16(sp)
    8020d9cc:	00913423          	sd	s1,8(sp)
    8020d9d0:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020d9d4:	ffffd097          	auipc	ra,0xffffd
    8020d9d8:	808080e7          	jalr	-2040(ra) # 8020a1dc <getHartTrapFrame>
    8020d9dc:	00050493          	mv	s1,a0
    printf("[%s] fd %d\n",__func__, sockfd);
    8020d9e0:	07852603          	lw	a2,120(a0)
    8020d9e4:	00008597          	auipc	a1,0x8
    8020d9e8:	6bc58593          	addi	a1,a1,1724 # 802160a0 <__func__.4>
    8020d9ec:	00008517          	auipc	a0,0x8
    8020d9f0:	5ec50513          	addi	a0,a0,1516 # 80215fd8 <__func__.5+0x168>
    8020d9f4:	ffff3097          	auipc	ra,0xffff3
    8020d9f8:	45c080e7          	jalr	1116(ra) # 80200e50 <printf>
    tf->a0 = 0;
    8020d9fc:	0604b823          	sd	zero,112(s1)
}
    8020da00:	01813083          	ld	ra,24(sp)
    8020da04:	01013403          	ld	s0,16(sp)
    8020da08:	00813483          	ld	s1,8(sp)
    8020da0c:	02010113          	addi	sp,sp,32
    8020da10:	00008067          	ret

000000008020da14 <syscallConnect>:
void syscallConnect() {
    8020da14:	fc010113          	addi	sp,sp,-64
    8020da18:	02113c23          	sd	ra,56(sp)
    8020da1c:	02813823          	sd	s0,48(sp)
    8020da20:	02913423          	sd	s1,40(sp)
    8020da24:	03213023          	sd	s2,32(sp)
    8020da28:	04010413          	addi	s0,sp,64
    Trapframe* tf = getHartTrapFrame();
    8020da2c:	ffffc097          	auipc	ra,0xffffc
    8020da30:	7b0080e7          	jalr	1968(ra) # 8020a1dc <getHartTrapFrame>
    8020da34:	00050493          	mv	s1,a0
    int sockfd = tf->a0;
    8020da38:	07052903          	lw	s2,112(a0)
    copyin(myProcess()->pgdir, (char*)&sa, tf->a1, tf->a2);
    8020da3c:	00002097          	auipc	ra,0x2
    8020da40:	fac080e7          	jalr	-84(ra) # 8020f9e8 <myProcess>
    8020da44:	0804b683          	ld	a3,128(s1)
    8020da48:	0784b603          	ld	a2,120(s1)
    8020da4c:	fc040593          	addi	a1,s0,-64
    8020da50:	04053503          	ld	a0,64(a0)
    8020da54:	ffffc097          	auipc	ra,0xffffc
    8020da58:	ff4080e7          	jalr	-12(ra) # 80209a48 <copyin>
    tf->a0 = connect(sockfd, &sa);
    8020da5c:	fc040593          	addi	a1,s0,-64
    8020da60:	00090513          	mv	a0,s2
    8020da64:	ffff9097          	auipc	ra,0xffff9
    8020da68:	8d4080e7          	jalr	-1836(ra) # 80206338 <connect>
    8020da6c:	06a4b823          	sd	a0,112(s1)
}
    8020da70:	03813083          	ld	ra,56(sp)
    8020da74:	03013403          	ld	s0,48(sp)
    8020da78:	02813483          	ld	s1,40(sp)
    8020da7c:	02013903          	ld	s2,32(sp)
    8020da80:	04010113          	addi	sp,sp,64
    8020da84:	00008067          	ret

000000008020da88 <syscallAccept>:
void syscallAccept() {
    8020da88:	fc010113          	addi	sp,sp,-64
    8020da8c:	02113c23          	sd	ra,56(sp)
    8020da90:	02813823          	sd	s0,48(sp)
    8020da94:	02913423          	sd	s1,40(sp)
    8020da98:	04010413          	addi	s0,sp,64
    Trapframe* tf = getHartTrapFrame();
    8020da9c:	ffffc097          	auipc	ra,0xffffc
    8020daa0:	740080e7          	jalr	1856(ra) # 8020a1dc <getHartTrapFrame>
    8020daa4:	00050493          	mv	s1,a0
    tf->a0 = accept(sockfd, &sa);
    8020daa8:	fc040593          	addi	a1,s0,-64
    8020daac:	07052503          	lw	a0,112(a0)
    8020dab0:	ffff8097          	auipc	ra,0xffff8
    8020dab4:	6a0080e7          	jalr	1696(ra) # 80206150 <accept>
    8020dab8:	06a4b823          	sd	a0,112(s1)
    copyout(myProcess()->pgdir, tf->a1, (char*)&sa, tf->a2);
    8020dabc:	00002097          	auipc	ra,0x2
    8020dac0:	f2c080e7          	jalr	-212(ra) # 8020f9e8 <myProcess>
    8020dac4:	0804b683          	ld	a3,128(s1)
    8020dac8:	fc040613          	addi	a2,s0,-64
    8020dacc:	0784b583          	ld	a1,120(s1)
    8020dad0:	04053503          	ld	a0,64(a0)
    8020dad4:	ffffc097          	auipc	ra,0xffffc
    8020dad8:	064080e7          	jalr	100(ra) # 80209b38 <copyout>
}
    8020dadc:	03813083          	ld	ra,56(sp)
    8020dae0:	03013403          	ld	s0,48(sp)
    8020dae4:	02813483          	ld	s1,40(sp)
    8020dae8:	04010113          	addi	sp,sp,64
    8020daec:	00008067          	ret

000000008020daf0 <syscallFutex>:
void syscallFutex() {
    8020daf0:	fb010113          	addi	sp,sp,-80
    8020daf4:	04113423          	sd	ra,72(sp)
    8020daf8:	04813023          	sd	s0,64(sp)
    8020dafc:	02913c23          	sd	s1,56(sp)
    8020db00:	03213823          	sd	s2,48(sp)
    8020db04:	03313423          	sd	s3,40(sp)
    8020db08:	03413023          	sd	s4,32(sp)
    8020db0c:	05010413          	addi	s0,sp,80
    Trapframe *tf = getHartTrapFrame();
    8020db10:	ffffc097          	auipc	ra,0xffffc
    8020db14:	6cc080e7          	jalr	1740(ra) # 8020a1dc <getHartTrapFrame>
    8020db18:	00050493          	mv	s1,a0
    int op = tf->a1, val = tf->a2, userVal;
    8020db1c:	07852783          	lw	a5,120(a0)
    8020db20:	08052983          	lw	s3,128(a0)
    u64 time = tf->a3;
    8020db24:	08853a03          	ld	s4,136(a0)
    u64 uaddr = tf->a0, newAddr = tf->a4;
    8020db28:	07053903          	ld	s2,112(a0)
    8020db2c:	09053603          	ld	a2,144(a0)
    op &= (FUTEX_PRIVATE_FLAG - 1);
    8020db30:	07f7f793          	andi	a5,a5,127
    switch (op)
    8020db34:	00100713          	li	a4,1
    8020db38:	0ce78c63          	beq	a5,a4,8020dc10 <syscallFutex+0x120>
    8020db3c:	00300713          	li	a4,3
    8020db40:	10e78463          	beq	a5,a4,8020dc48 <syscallFutex+0x158>
    8020db44:	02078463          	beqz	a5,8020db6c <syscallFutex+0x7c>
            panic("Futex type not support!\n");
    8020db48:	00008697          	auipc	a3,0x8
    8020db4c:	4b868693          	addi	a3,a3,1208 # 80216000 <__func__.5+0x190>
    8020db50:	00008617          	auipc	a2,0x8
    8020db54:	56060613          	addi	a2,a2,1376 # 802160b0 <__func__.3>
    8020db58:	1f100593          	li	a1,497
    8020db5c:	00008517          	auipc	a0,0x8
    8020db60:	37c50513          	addi	a0,a0,892 # 80215ed8 <__func__.5+0x68>
    8020db64:	ffff3097          	auipc	ra,0xffff3
    8020db68:	384080e7          	jalr	900(ra) # 80200ee8 <_panic_>
            copyin(myProcess()->pgdir, (char*)&userVal, uaddr, sizeof(int));
    8020db6c:	00002097          	auipc	ra,0x2
    8020db70:	e7c080e7          	jalr	-388(ra) # 8020f9e8 <myProcess>
    8020db74:	00400693          	li	a3,4
    8020db78:	00090613          	mv	a2,s2
    8020db7c:	fcc40593          	addi	a1,s0,-52
    8020db80:	04053503          	ld	a0,64(a0)
    8020db84:	ffffc097          	auipc	ra,0xffffc
    8020db88:	ec4080e7          	jalr	-316(ra) # 80209a48 <copyin>
            if (time) {
    8020db8c:	000a1a63          	bnez	s4,8020dba0 <syscallFutex+0xb0>
            if (userVal != val) {
    8020db90:	fcc42783          	lw	a5,-52(s0)
    8020db94:	0d378463          	beq	a5,s3,8020dc5c <syscallFutex+0x16c>
                return;
    8020db98:	fff00793          	li	a5,-1
    8020db9c:	0880006f          	j	8020dc24 <syscallFutex+0x134>
                if (copyin(myProcess()->pgdir, (char*)&t, time, sizeof(struct TimeSpec)) < 0) {
    8020dba0:	00002097          	auipc	ra,0x2
    8020dba4:	e48080e7          	jalr	-440(ra) # 8020f9e8 <myProcess>
    8020dba8:	01000693          	li	a3,16
    8020dbac:	000a0613          	mv	a2,s4
    8020dbb0:	fb840593          	addi	a1,s0,-72
    8020dbb4:	04053503          	ld	a0,64(a0)
    8020dbb8:	ffffc097          	auipc	ra,0xffffc
    8020dbbc:	e90080e7          	jalr	-368(ra) # 80209a48 <copyin>
    8020dbc0:	02054663          	bltz	a0,8020dbec <syscallFutex+0xfc>
            if (userVal != val) {
    8020dbc4:	fcc42783          	lw	a5,-52(s0)
    8020dbc8:	fd3798e3          	bne	a5,s3,8020db98 <syscallFutex+0xa8>
            futexWait(uaddr, myThread(), time ? &t : 0);
    8020dbcc:	00003097          	auipc	ra,0x3
    8020dbd0:	974080e7          	jalr	-1676(ra) # 80210540 <myThread>
    8020dbd4:	00050593          	mv	a1,a0
    8020dbd8:	fb840613          	addi	a2,s0,-72
    8020dbdc:	00090513          	mv	a0,s2
    8020dbe0:	ffffc097          	auipc	ra,0xffffc
    8020dbe4:	3a8080e7          	jalr	936(ra) # 80209f88 <futexWait>
            break;
    8020dbe8:	0380006f          	j	8020dc20 <syscallFutex+0x130>
                    panic("copy time error!\n");
    8020dbec:	00008697          	auipc	a3,0x8
    8020dbf0:	3fc68693          	addi	a3,a3,1020 # 80215fe8 <__func__.5+0x178>
    8020dbf4:	00008617          	auipc	a2,0x8
    8020dbf8:	4bc60613          	addi	a2,a2,1212 # 802160b0 <__func__.3>
    8020dbfc:	1de00593          	li	a1,478
    8020dc00:	00008517          	auipc	a0,0x8
    8020dc04:	2d850513          	addi	a0,a0,728 # 80215ed8 <__func__.5+0x68>
    8020dc08:	ffff3097          	auipc	ra,0xffff3
    8020dc0c:	2e0080e7          	jalr	736(ra) # 80200ee8 <_panic_>
            futexWake(uaddr, val);
    8020dc10:	00098593          	mv	a1,s3
    8020dc14:	00090513          	mv	a0,s2
    8020dc18:	ffffc097          	auipc	ra,0xffffc
    8020dc1c:	43c080e7          	jalr	1084(ra) # 8020a054 <futexWake>
    tf->a0 = 0;
    8020dc20:	00000793          	li	a5,0
    8020dc24:	06f4b823          	sd	a5,112(s1)
}
    8020dc28:	04813083          	ld	ra,72(sp)
    8020dc2c:	04013403          	ld	s0,64(sp)
    8020dc30:	03813483          	ld	s1,56(sp)
    8020dc34:	03013903          	ld	s2,48(sp)
    8020dc38:	02813983          	ld	s3,40(sp)
    8020dc3c:	02013a03          	ld	s4,32(sp)
    8020dc40:	05010113          	addi	sp,sp,80
    8020dc44:	00008067          	ret
            futexRequeue(uaddr, val, newAddr);
    8020dc48:	00098593          	mv	a1,s3
    8020dc4c:	00090513          	mv	a0,s2
    8020dc50:	ffffc097          	auipc	ra,0xffffc
    8020dc54:	470080e7          	jalr	1136(ra) # 8020a0c0 <futexRequeue>
            break;
    8020dc58:	fc9ff06f          	j	8020dc20 <syscallFutex+0x130>
            futexWait(uaddr, myThread(), time ? &t : 0);
    8020dc5c:	00003097          	auipc	ra,0x3
    8020dc60:	8e4080e7          	jalr	-1820(ra) # 80210540 <myThread>
    8020dc64:	00050593          	mv	a1,a0
    8020dc68:	00000613          	li	a2,0
    8020dc6c:	f71ff06f          	j	8020dbdc <syscallFutex+0xec>

000000008020dc70 <syscallProcessKill>:
void syscallProcessKill() {
    8020dc70:	fe010113          	addi	sp,sp,-32
    8020dc74:	00113c23          	sd	ra,24(sp)
    8020dc78:	00813823          	sd	s0,16(sp)
    8020dc7c:	00913423          	sd	s1,8(sp)
    8020dc80:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020dc84:	ffffc097          	auipc	ra,0xffffc
    8020dc88:	558080e7          	jalr	1368(ra) # 8020a1dc <getHartTrapFrame>
    8020dc8c:	00050493          	mv	s1,a0
    tf->a0 = processSignalSend(tf->a0, tf->a1);
    8020dc90:	07852583          	lw	a1,120(a0)
    8020dc94:	07052503          	lw	a0,112(a0)
    8020dc98:	ffffd097          	auipc	ra,0xffffd
    8020dc9c:	840080e7          	jalr	-1984(ra) # 8020a4d8 <processSignalSend>
    8020dca0:	06a4b823          	sd	a0,112(s1)
}
    8020dca4:	01813083          	ld	ra,24(sp)
    8020dca8:	01013403          	ld	s0,16(sp)
    8020dcac:	00813483          	ld	s1,8(sp)
    8020dcb0:	02010113          	addi	sp,sp,32
    8020dcb4:	00008067          	ret

000000008020dcb8 <syscallThreadKill>:
void syscallThreadKill() {
    8020dcb8:	fe010113          	addi	sp,sp,-32
    8020dcbc:	00113c23          	sd	ra,24(sp)
    8020dcc0:	00813823          	sd	s0,16(sp)
    8020dcc4:	00913423          	sd	s1,8(sp)
    8020dcc8:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020dccc:	ffffc097          	auipc	ra,0xffffc
    8020dcd0:	510080e7          	jalr	1296(ra) # 8020a1dc <getHartTrapFrame>
    8020dcd4:	00050493          	mv	s1,a0
    tf->a0 = signalSend(0, tid, signal);
    8020dcd8:	07852603          	lw	a2,120(a0)
    8020dcdc:	07052583          	lw	a1,112(a0)
    8020dce0:	00000513          	li	a0,0
    8020dce4:	ffffc097          	auipc	ra,0xffffc
    8020dce8:	6b8080e7          	jalr	1720(ra) # 8020a39c <signalSend>
    8020dcec:	06a4b823          	sd	a0,112(s1)
}
    8020dcf0:	01813083          	ld	ra,24(sp)
    8020dcf4:	01013403          	ld	s0,16(sp)
    8020dcf8:	00813483          	ld	s1,8(sp)
    8020dcfc:	02010113          	addi	sp,sp,32
    8020dd00:	00008067          	ret

000000008020dd04 <syscallThreadGroupKill>:
void syscallThreadGroupKill() {
    8020dd04:	fe010113          	addi	sp,sp,-32
    8020dd08:	00113c23          	sd	ra,24(sp)
    8020dd0c:	00813823          	sd	s0,16(sp)
    8020dd10:	00913423          	sd	s1,8(sp)
    8020dd14:	02010413          	addi	s0,sp,32
    Trapframe *tf = getHartTrapFrame();
    8020dd18:	ffffc097          	auipc	ra,0xffffc
    8020dd1c:	4c4080e7          	jalr	1220(ra) # 8020a1dc <getHartTrapFrame>
    8020dd20:	00050493          	mv	s1,a0
    tf->a0 = signalSend(tgid, tid, signal);
    8020dd24:	08052603          	lw	a2,128(a0)
    8020dd28:	07852583          	lw	a1,120(a0)
    8020dd2c:	07052503          	lw	a0,112(a0)
    8020dd30:	ffffc097          	auipc	ra,0xffffc
    8020dd34:	66c080e7          	jalr	1644(ra) # 8020a39c <signalSend>
    8020dd38:	06a4b823          	sd	a0,112(s1)
}
    8020dd3c:	01813083          	ld	ra,24(sp)
    8020dd40:	01013403          	ld	s0,16(sp)
    8020dd44:	00813483          	ld	s1,8(sp)
    8020dd48:	02010113          	addi	sp,sp,32
    8020dd4c:	00008067          	ret

000000008020dd50 <syscallMemoryProtect>:
void syscallMemoryProtect() {
    8020dd50:	fb010113          	addi	sp,sp,-80
    8020dd54:	04113423          	sd	ra,72(sp)
    8020dd58:	04813023          	sd	s0,64(sp)
    8020dd5c:	02913c23          	sd	s1,56(sp)
    8020dd60:	03213823          	sd	s2,48(sp)
    8020dd64:	03313423          	sd	s3,40(sp)
    8020dd68:	03413023          	sd	s4,32(sp)
    8020dd6c:	01513c23          	sd	s5,24(sp)
    8020dd70:	05010413          	addi	s0,sp,80
    Trapframe *tf = getHartTrapFrame();
    8020dd74:	ffffc097          	auipc	ra,0xffffc
    8020dd78:	468080e7          	jalr	1128(ra) # 8020a1dc <getHartTrapFrame>
    8020dd7c:	00050a13          	mv	s4,a0
    u64 start = DOWN_ALIGN(tf->a0, PGSIZE);
    8020dd80:	07053783          	ld	a5,112(a0)
    8020dd84:	fffff737          	lui	a4,0xfffff
    8020dd88:	00e7f4b3          	and	s1,a5,a4
    u64 end = UP_ALIGN(tf->a0+tf->a1, PGSIZE);
    8020dd8c:	07853683          	ld	a3,120(a0)
    8020dd90:	00d78933          	add	s2,a5,a3
    8020dd94:	fff90913          	addi	s2,s2,-1 # fff <_start-0x801ff001>
    8020dd98:	00e97933          	and	s2,s2,a4
    8020dd9c:	000017b7          	lui	a5,0x1
    8020dda0:	00f90933          	add	s2,s2,a5
    if (tf->a2 & PROT_EXEC) {
    8020dda4:	08053783          	ld	a5,128(a0)
    8020dda8:	0017fa93          	andi	s5,a5,1
    8020ddac:	000a8463          	beqz	s5,8020ddb4 <syscallMemoryProtect+0x64>
        perm |= PTE_EXECUTE | PTE_READ;
    8020ddb0:	00a00a93          	li	s5,10
    if (tf->a2 & PROT_READ) {
    8020ddb4:	0047f713          	andi	a4,a5,4
    8020ddb8:	00070463          	beqz	a4,8020ddc0 <syscallMemoryProtect+0x70>
        perm |= PTE_READ;
    8020ddbc:	002aea93          	ori	s5,s5,2
    if (tf->a2 & PROT_WRITE) {
    8020ddc0:	0027f793          	andi	a5,a5,2
    8020ddc4:	00078463          	beqz	a5,8020ddcc <syscallMemoryProtect+0x7c>
        perm |= PTE_WRITE | PTE_READ;
    8020ddc8:	006aea93          	ori	s5,s5,6
        start += PGSIZE;
    8020ddcc:	000019b7          	lui	s3,0x1
    while(start < end){
    8020ddd0:	0524e463          	bltu	s1,s2,8020de18 <syscallMemoryProtect+0xc8>
    tf->a0 = 0;
    8020ddd4:	060a3823          	sd	zero,112(s4)
}
    8020ddd8:	04813083          	ld	ra,72(sp)
    8020dddc:	04013403          	ld	s0,64(sp)
    8020dde0:	03813483          	ld	s1,56(sp)
    8020dde4:	03013903          	ld	s2,48(sp)
    8020dde8:	02813983          	ld	s3,40(sp)
    8020ddec:	02013a03          	ld	s4,32(sp)
    8020ddf0:	01813a83          	ld	s5,24(sp)
    8020ddf4:	05010113          	addi	sp,sp,80
    8020ddf8:	00008067          	ret
            *pte = (*pte & ~(PTE_READ | PTE_WRITE | PTE_EXECUTE)) | perm;
    8020ddfc:	fb843703          	ld	a4,-72(s0)
    8020de00:	00073783          	ld	a5,0(a4) # fffffffffffff000 <bssEnd+0xffffffff7dc8f000>
    8020de04:	ff17f793          	andi	a5,a5,-15
    8020de08:	0157e7b3          	or	a5,a5,s5
    8020de0c:	00f73023          	sd	a5,0(a4)
        start += PGSIZE;
    8020de10:	013484b3          	add	s1,s1,s3
    while(start < end){
    8020de14:	fd24f0e3          	bgeu	s1,s2,8020ddd4 <syscallMemoryProtect+0x84>
        pa = pageLookup(myProcess()->pgdir, start, &pte);
    8020de18:	00002097          	auipc	ra,0x2
    8020de1c:	bd0080e7          	jalr	-1072(ra) # 8020f9e8 <myProcess>
    8020de20:	fb840613          	addi	a2,s0,-72
    8020de24:	00048593          	mv	a1,s1
    8020de28:	04053503          	ld	a0,64(a0)
    8020de2c:	ffffb097          	auipc	ra,0xffffb
    8020de30:	14c080e7          	jalr	332(ra) # 80208f78 <pageLookup>
        if(!pa){
    8020de34:	fc0514e3          	bnez	a0,8020ddfc <syscallMemoryProtect+0xac>
            pageout(myProcess()->pgdir, start);
    8020de38:	00002097          	auipc	ra,0x2
    8020de3c:	bb0080e7          	jalr	-1104(ra) # 8020f9e8 <myProcess>
    8020de40:	00048593          	mv	a1,s1
    8020de44:	04053503          	ld	a0,64(a0)
    8020de48:	ffffb097          	auipc	ra,0xffffb
    8020de4c:	6cc080e7          	jalr	1740(ra) # 80209514 <pageout>
    8020de50:	fc1ff06f          	j	8020de10 <syscallMemoryProtect+0xc0>

000000008020de54 <syscallStateFileSystem>:
void syscallStateFileSystem() {
    8020de54:	e6010113          	addi	sp,sp,-416
    8020de58:	18113c23          	sd	ra,408(sp)
    8020de5c:	18813823          	sd	s0,400(sp)
    8020de60:	18913423          	sd	s1,392(sp)
    8020de64:	1a010413          	addi	s0,sp,416
    Trapframe *tf = getHartTrapFrame();
    8020de68:	ffffc097          	auipc	ra,0xffffc
    8020de6c:	374080e7          	jalr	884(ra) # 8020a1dc <getHartTrapFrame>
    8020de70:	00050493          	mv	s1,a0
    if (argstr(0, path, FAT32_MAX_PATH) < 0) {
    8020de74:	10400613          	li	a2,260
    8020de78:	ed840593          	addi	a1,s0,-296
    8020de7c:	00000513          	li	a0,0
    8020de80:	ffffe097          	auipc	ra,0xffffe
    8020de84:	798080e7          	jalr	1944(ra) # 8020c618 <argstr>
    8020de88:	04054a63          	bltz	a0,8020dedc <syscallStateFileSystem+0x88>
    memset(&fss, 0, sizeof(FileSystemStatus));
    8020de8c:	07800613          	li	a2,120
    8020de90:	00000593          	li	a1,0
    8020de94:	e6040513          	addi	a0,s0,-416
    8020de98:	00001097          	auipc	ra,0x1
    8020de9c:	ed4080e7          	jalr	-300(ra) # 8020ed6c <memset>
    tf->a0 = getFsStatus(path, &fss);
    8020dea0:	e6040593          	addi	a1,s0,-416
    8020dea4:	ed840513          	addi	a0,s0,-296
    8020dea8:	ffff7097          	auipc	ra,0xffff7
    8020deac:	f88080e7          	jalr	-120(ra) # 80204e30 <getFsStatus>
    8020deb0:	06a4b823          	sd	a0,112(s1)
    if (tf->a0 == 0) {
    8020deb4:	02051863          	bnez	a0,8020dee4 <syscallStateFileSystem+0x90>
        copyout(myProcess()->pgdir, tf->a1, (char*)&fss, sizeof(FileSystemStatus));
    8020deb8:	00002097          	auipc	ra,0x2
    8020debc:	b30080e7          	jalr	-1232(ra) # 8020f9e8 <myProcess>
    8020dec0:	07800693          	li	a3,120
    8020dec4:	e6040613          	addi	a2,s0,-416
    8020dec8:	0784b583          	ld	a1,120(s1)
    8020decc:	04053503          	ld	a0,64(a0)
    8020ded0:	ffffc097          	auipc	ra,0xffffc
    8020ded4:	c68080e7          	jalr	-920(ra) # 80209b38 <copyout>
    8020ded8:	00c0006f          	j	8020dee4 <syscallStateFileSystem+0x90>
        tf->a0 = -1;
    8020dedc:	fff00793          	li	a5,-1
    8020dee0:	06f4b823          	sd	a5,112(s1)
}
    8020dee4:	19813083          	ld	ra,408(sp)
    8020dee8:	19013403          	ld	s0,400(sp)
    8020deec:	18813483          	ld	s1,392(sp)
    8020def0:	1a010113          	addi	sp,sp,416
    8020def4:	00008067          	ret

000000008020def8 <syscallSignalReturn>:
void syscallSignalReturn() {
    8020def8:	fd010113          	addi	sp,sp,-48
    8020defc:	02113423          	sd	ra,40(sp)
    8020df00:	02813023          	sd	s0,32(sp)
    8020df04:	00913c23          	sd	s1,24(sp)
    8020df08:	01213823          	sd	s2,16(sp)
    8020df0c:	01313423          	sd	s3,8(sp)
    8020df10:	03010413          	addi	s0,sp,48
    Trapframe *tf = getHartTrapFrame();
    8020df14:	ffffc097          	auipc	ra,0xffffc
    8020df18:	2c8080e7          	jalr	712(ra) # 8020a1dc <getHartTrapFrame>
    8020df1c:	00050993          	mv	s3,a0
    Thread* thread = myThread();
    8020df20:	00002097          	auipc	ra,0x2
    8020df24:	620080e7          	jalr	1568(ra) # 80210540 <myThread>
    8020df28:	00050913          	mv	s2,a0
    SignalContext* sc = getHandlingSignal(thread);
    8020df2c:	ffffd097          	auipc	ra,0xffffd
    8020df30:	85c080e7          	jalr	-1956(ra) # 8020a788 <getHandlingSignal>
    8020df34:	00050493          	mv	s1,a0
    sc->contextRecover.epc = sc->uContext->uc_mcontext.MC_PC;
    8020df38:	22853683          	ld	a3,552(a0)
    8020df3c:	0b06b783          	ld	a5,176(a3)
    8020df40:	00f53c23          	sd	a5,24(a0)
    thread->blocked = sc->uContext->uc_sigmask;
    8020df44:	02868793          	addi	a5,a3,40
    8020df48:	28890713          	addi	a4,s2,648
    8020df4c:	0a868693          	addi	a3,a3,168
    8020df50:	0007b803          	ld	a6,0(a5) # 1000 <_start-0x801ff000>
    8020df54:	0087b503          	ld	a0,8(a5)
    8020df58:	0107b583          	ld	a1,16(a5)
    8020df5c:	0187b603          	ld	a2,24(a5)
    8020df60:	01073023          	sd	a6,0(a4)
    8020df64:	00a73423          	sd	a0,8(a4)
    8020df68:	00b73823          	sd	a1,16(a4)
    8020df6c:	00c73c23          	sd	a2,24(a4)
    8020df70:	02078793          	addi	a5,a5,32
    8020df74:	02070713          	addi	a4,a4,32
    8020df78:	fcd79ce3          	bne	a5,a3,8020df50 <syscallSignalReturn+0x58>
    bcopy(&sc->contextRecover, tf, sizeof(Trapframe));
    8020df7c:	22000613          	li	a2,544
    8020df80:	00098593          	mv	a1,s3
    8020df84:	00048513          	mv	a0,s1
    8020df88:	ffffb097          	auipc	ra,0xffffb
    8020df8c:	d18080e7          	jalr	-744(ra) # 80208ca0 <bcopy>
    signalProcessEnd(sc->signal, &thread->processing);
    8020df90:	2214c783          	lbu	a5,545(s1)
    8020df94:	0007869b          	sext.w	a3,a5
    }
    ss->signal[0] |= (1UL << (signal - 1));
}

inline static void signalProcessEnd(int signal, SignalSet *ss) {
    if (signal > 64) {
    8020df98:	04000713          	li	a4,64
    8020df9c:	04d74663          	blt	a4,a3,8020dfe8 <syscallSignalReturn+0xf0>
        panic("");
    }
    ss->signal[0] &= ~(1UL << (signal - 1));
    8020dfa0:	fff7871b          	addiw	a4,a5,-1
    8020dfa4:	00100793          	li	a5,1
    8020dfa8:	00e797b3          	sll	a5,a5,a4
    8020dfac:	fff7c793          	not	a5,a5
    8020dfb0:	38893703          	ld	a4,904(s2)
    8020dfb4:	00f777b3          	and	a5,a4,a5
    8020dfb8:	38f93423          	sd	a5,904(s2)
    signalFinish(thread, sc);
    8020dfbc:	00048593          	mv	a1,s1
    8020dfc0:	00090513          	mv	a0,s2
    8020dfc4:	ffffd097          	auipc	ra,0xffffd
    8020dfc8:	a8c080e7          	jalr	-1396(ra) # 8020aa50 <signalFinish>
}
    8020dfcc:	02813083          	ld	ra,40(sp)
    8020dfd0:	02013403          	ld	s0,32(sp)
    8020dfd4:	01813483          	ld	s1,24(sp)
    8020dfd8:	01013903          	ld	s2,16(sp)
    8020dfdc:	00813983          	ld	s3,8(sp)
    8020dfe0:	03010113          	addi	sp,sp,48
    8020dfe4:	00008067          	ret
        panic("");
    8020dfe8:	00008697          	auipc	a3,0x8
    8020dfec:	c0068693          	addi	a3,a3,-1024 # 80215be8 <__func__.0+0x48>
    8020dff0:	00008617          	auipc	a2,0x8
    8020dff4:	0d060613          	addi	a2,a2,208 # 802160c0 <__func__.2>
    8020dff8:	02000593          	li	a1,32
    8020dffc:	00008517          	auipc	a0,0x8
    8020e000:	c2450513          	addi	a0,a0,-988 # 80215c20 <__func__.0+0x80>
    8020e004:	ffff3097          	auipc	ra,0xffff3
    8020e008:	ee4080e7          	jalr	-284(ra) # 80200ee8 <_panic_>

000000008020e00c <syscallSelect>:
void syscallSelect() {
    8020e00c:	f8010113          	addi	sp,sp,-128
    8020e010:	06113c23          	sd	ra,120(sp)
    8020e014:	06813823          	sd	s0,112(sp)
    8020e018:	06913423          	sd	s1,104(sp)
    8020e01c:	07213023          	sd	s2,96(sp)
    8020e020:	05313c23          	sd	s3,88(sp)
    8020e024:	05413823          	sd	s4,80(sp)
    8020e028:	05513423          	sd	s5,72(sp)
    8020e02c:	05613023          	sd	s6,64(sp)
    8020e030:	03713c23          	sd	s7,56(sp)
    8020e034:	03813823          	sd	s8,48(sp)
    8020e038:	03913423          	sd	s9,40(sp)
    8020e03c:	03a13023          	sd	s10,32(sp)
    8020e040:	01b13c23          	sd	s11,24(sp)
    8020e044:	08010413          	addi	s0,sp,128
    Trapframe *tf = getHartTrapFrame();
    8020e048:	ffffc097          	auipc	ra,0xffffc
    8020e04c:	194080e7          	jalr	404(ra) # 8020a1dc <getHartTrapFrame>
    8020e050:	00050a13          	mv	s4,a0
    int nfd = tf->a0;
    8020e054:	07052a83          	lw	s5,112(a0)
    u64 read = tf->a1, write = tf->a2, except = tf->a3/*, timeout = tf->a4*/;
    8020e058:	07853c03          	ld	s8,120(a0)
    8020e05c:	08053d03          	ld	s10,128(a0)
    8020e060:	08853c83          	ld	s9,136(a0)
    int cnt = 0;
    8020e064:	00000993          	li	s3,0
    if (read) {
    8020e068:	040c1863          	bnez	s8,8020e0b8 <syscallSelect+0xac>
    if (write) {
    8020e06c:	160d1263          	bnez	s10,8020e1d0 <syscallSelect+0x1c4>
    if (except) {
    8020e070:	1c0c9263          	bnez	s9,8020e234 <syscallSelect+0x228>
    if (cnt == 0) {
    8020e074:	1e098263          	beqz	s3,8020e258 <syscallSelect+0x24c>
    tf->a0 = cnt;
    8020e078:	073a3823          	sd	s3,112(s4)
}
    8020e07c:	07813083          	ld	ra,120(sp)
    8020e080:	07013403          	ld	s0,112(sp)
    8020e084:	06813483          	ld	s1,104(sp)
    8020e088:	06013903          	ld	s2,96(sp)
    8020e08c:	05813983          	ld	s3,88(sp)
    8020e090:	05013a03          	ld	s4,80(sp)
    8020e094:	04813a83          	ld	s5,72(sp)
    8020e098:	04013b03          	ld	s6,64(sp)
    8020e09c:	03813b83          	ld	s7,56(sp)
    8020e0a0:	03013c03          	ld	s8,48(sp)
    8020e0a4:	02813c83          	ld	s9,40(sp)
    8020e0a8:	02013d03          	ld	s10,32(sp)
    8020e0ac:	01813d83          	ld	s11,24(sp)
    8020e0b0:	08010113          	addi	sp,sp,128
    8020e0b4:	00008067          	ret
        copyin(myProcess()->pgdir, (char*)&readSet, read, sizeof(FdSet));
    8020e0b8:	00002097          	auipc	ra,0x2
    8020e0bc:	930080e7          	jalr	-1744(ra) # 8020f9e8 <myProcess>
    8020e0c0:	01000693          	li	a3,16
    8020e0c4:	000c0613          	mv	a2,s8
    8020e0c8:	f8040593          	addi	a1,s0,-128
    8020e0cc:	04053503          	ld	a0,64(a0)
    8020e0d0:	ffffc097          	auipc	ra,0xffffc
    8020e0d4:	978080e7          	jalr	-1672(ra) # 80209a48 <copyin>
        for (int i = 0; i < nfd; i++) {
    8020e0d8:	0d505863          	blez	s5,8020e1a8 <syscallSelect+0x19c>
    8020e0dc:	00000913          	li	s2,0
                             : readSet.bits[1] & (1UL << (i - 64));
    8020e0e0:	03f00b93          	li	s7,63
    8020e0e4:	00100b13          	li	s6,1
            switch (file->type) {
    8020e0e8:	00400d93          	li	s11,4
    8020e0ec:	0380006f          	j	8020e124 <syscallSelect+0x118>
            u64 cur = i < 64 ? readSet.bits[0] & (1UL << i)
    8020e0f0:	012b14b3          	sll	s1,s6,s2
                             : readSet.bits[1] & (1UL << (i - 64));
    8020e0f4:	f8043783          	ld	a5,-128(s0)
    8020e0f8:	00f4f4b3          	and	s1,s1,a5
    8020e0fc:	03c0006f          	j	8020e138 <syscallSelect+0x12c>
                    if (file->pipe->nread == file->pipe->nwrite) {
    8020e100:	0107b783          	ld	a5,16(a5)
    8020e104:	00010737          	lui	a4,0x10
    8020e108:	00e787b3          	add	a5,a5,a4
    8020e10c:	0187b703          	ld	a4,24(a5)
    8020e110:	0207b783          	ld	a5,32(a5)
    8020e114:	06f70463          	beq	a4,a5,8020e17c <syscallSelect+0x170>
                ++cnt;
    8020e118:	0019899b          	addiw	s3,s3,1
        for (int i = 0; i < nfd; i++) {
    8020e11c:	0019091b          	addiw	s2,s2,1
    8020e120:	092a8663          	beq	s5,s2,8020e1ac <syscallSelect+0x1a0>
                             : readSet.bits[1] & (1UL << (i - 64));
    8020e124:	fd2bd6e3          	bge	s7,s2,8020e0f0 <syscallSelect+0xe4>
    8020e128:	fc09049b          	addiw	s1,s2,-64
    8020e12c:	009b14b3          	sll	s1,s6,s1
    8020e130:	f8843783          	ld	a5,-120(s0)
    8020e134:	00f4f4b3          	and	s1,s1,a5
            if (!cur)
    8020e138:	fe0482e3          	beqz	s1,8020e11c <syscallSelect+0x110>
            file = myProcess()->ofile[i];
    8020e13c:	00002097          	auipc	ra,0x2
    8020e140:	8ac080e7          	jalr	-1876(ra) # 8020f9e8 <myProcess>
    8020e144:	00e90793          	addi	a5,s2,14
    8020e148:	00379793          	slli	a5,a5,0x3
    8020e14c:	00f50533          	add	a0,a0,a5
    8020e150:	00053783          	ld	a5,0(a0)
            if (!file)
    8020e154:	fc0784e3          	beqz	a5,8020e11c <syscallSelect+0x110>
            switch (file->type) {
    8020e158:	0007a703          	lw	a4,0(a5)
    8020e15c:	fb6702e3          	beq	a4,s6,8020e100 <syscallSelect+0xf4>
    8020e160:	fbb71ce3          	bne	a4,s11,8020e118 <syscallSelect+0x10c>
                    if (file->socket->used != 0 &&
    8020e164:	0207b783          	ld	a5,32(a5)
    8020e168:	0007c703          	lbu	a4,0(a5)
    8020e16c:	fa0706e3          	beqz	a4,8020e118 <syscallSelect+0x10c>
    8020e170:	0507b703          	ld	a4,80(a5)
    8020e174:	0587b783          	ld	a5,88(a5)
    8020e178:	faf710e3          	bne	a4,a5,8020e118 <syscallSelect+0x10c>
                if (i < 64)
    8020e17c:	012bdc63          	bge	s7,s2,8020e194 <syscallSelect+0x188>
                    readSet.bits[1] &= ~cur;
    8020e180:	fff4c493          	not	s1,s1
    8020e184:	f8843783          	ld	a5,-120(s0)
    8020e188:	0097f7b3          	and	a5,a5,s1
    8020e18c:	f8f43423          	sd	a5,-120(s0)
    8020e190:	f8dff06f          	j	8020e11c <syscallSelect+0x110>
                    readSet.bits[0] &= ~cur;
    8020e194:	fff4c493          	not	s1,s1
    8020e198:	f8043783          	ld	a5,-128(s0)
    8020e19c:	0097f7b3          	and	a5,a5,s1
    8020e1a0:	f8f43023          	sd	a5,-128(s0)
    8020e1a4:	f79ff06f          	j	8020e11c <syscallSelect+0x110>
    int cnt = 0;
    8020e1a8:	00000993          	li	s3,0
        copyout(myProcess()->pgdir, read, (char*)&readSet, sizeof(FdSet));
    8020e1ac:	00002097          	auipc	ra,0x2
    8020e1b0:	83c080e7          	jalr	-1988(ra) # 8020f9e8 <myProcess>
    8020e1b4:	01000693          	li	a3,16
    8020e1b8:	f8040613          	addi	a2,s0,-128
    8020e1bc:	000c0593          	mv	a1,s8
    8020e1c0:	04053503          	ld	a0,64(a0)
    8020e1c4:	ffffc097          	auipc	ra,0xffffc
    8020e1c8:	974080e7          	jalr	-1676(ra) # 80209b38 <copyout>
    8020e1cc:	ea1ff06f          	j	8020e06c <syscallSelect+0x60>
        copyin(myProcess()->pgdir, (char*)&writeSet, write, sizeof(FdSet));
    8020e1d0:	00002097          	auipc	ra,0x2
    8020e1d4:	818080e7          	jalr	-2024(ra) # 8020f9e8 <myProcess>
    8020e1d8:	01000693          	li	a3,16
    8020e1dc:	000d0613          	mv	a2,s10
    8020e1e0:	f8040593          	addi	a1,s0,-128
    8020e1e4:	04053503          	ld	a0,64(a0)
    8020e1e8:	ffffc097          	auipc	ra,0xffffc
    8020e1ec:	860080e7          	jalr	-1952(ra) # 80209a48 <copyin>
        for (int i = 0; i < nfd; i++) {
    8020e1f0:	e95050e3          	blez	s5,8020e070 <syscallSelect+0x64>
                cnt += !!((1UL << (i)) & writeSet.bits[0]);
    8020e1f4:	f8043583          	ld	a1,-128(s0)
                cnt += !!((1UL << (i - 64)) & writeSet.bits[1]);
    8020e1f8:	f8843603          	ld	a2,-120(s0)
        for (int i = 0; i < nfd; i++) {
    8020e1fc:	00000793          	li	a5,0
            if (i >= 64) {
    8020e200:	03f00693          	li	a3,63
    8020e204:	0180006f          	j	8020e21c <syscallSelect+0x210>
                cnt += !!((1UL << (i)) & writeSet.bits[0]);
    8020e208:	00f5d733          	srl	a4,a1,a5
    8020e20c:	00177713          	andi	a4,a4,1
    8020e210:	013709bb          	addw	s3,a4,s3
        for (int i = 0; i < nfd; i++) {
    8020e214:	0017879b          	addiw	a5,a5,1
    8020e218:	e4fa8ce3          	beq	s5,a5,8020e070 <syscallSelect+0x64>
            if (i >= 64) {
    8020e21c:	fef6d6e3          	bge	a3,a5,8020e208 <syscallSelect+0x1fc>
                cnt += !!((1UL << (i - 64)) & writeSet.bits[1]);
    8020e220:	fc07871b          	addiw	a4,a5,-64
    8020e224:	00e65733          	srl	a4,a2,a4
    8020e228:	00177713          	andi	a4,a4,1
    8020e22c:	013709bb          	addw	s3,a4,s3
    8020e230:	fe5ff06f          	j	8020e214 <syscallSelect+0x208>
        memsetOut(myProcess()->pgdir, except, zero, nfd);
    8020e234:	00001097          	auipc	ra,0x1
    8020e238:	7b4080e7          	jalr	1972(ra) # 8020f9e8 <myProcess>
    8020e23c:	000a8693          	mv	a3,s5
    8020e240:	00000613          	li	a2,0
    8020e244:	000c8593          	mv	a1,s9
    8020e248:	04053503          	ld	a0,64(a0)
    8020e24c:	ffffc097          	auipc	ra,0xffffc
    8020e250:	9f4080e7          	jalr	-1548(ra) # 80209c40 <memsetOut>
    8020e254:	e21ff06f          	j	8020e074 <syscallSelect+0x68>
        if (!(myThread()->reason & SELECT_BLOCK)) {
    8020e258:	00002097          	auipc	ra,0x2
    8020e25c:	2e8080e7          	jalr	744(ra) # 80210540 <myThread>
    8020e260:	28052783          	lw	a5,640(a0)
    8020e264:	0027f793          	andi	a5,a5,2
    8020e268:	00078e63          	beqz	a5,8020e284 <syscallSelect+0x278>
        myThread()->reason &= ~SELECT_BLOCK;
    8020e26c:	00002097          	auipc	ra,0x2
    8020e270:	2d4080e7          	jalr	724(ra) # 80210540 <myThread>
    8020e274:	28052783          	lw	a5,640(a0)
    8020e278:	ffd7f793          	andi	a5,a5,-3
    8020e27c:	28f52023          	sw	a5,640(a0)
    8020e280:	df9ff06f          	j	8020e078 <syscallSelect+0x6c>
            myThread()->reason |= SELECT_BLOCK;
    8020e284:	00002097          	auipc	ra,0x2
    8020e288:	2bc080e7          	jalr	700(ra) # 80210540 <myThread>
    8020e28c:	28052783          	lw	a5,640(a0)
    8020e290:	0027e793          	ori	a5,a5,2
    8020e294:	28f52023          	sw	a5,640(a0)
            tf->epc -= 4;
    8020e298:	018a3783          	ld	a5,24(s4)
    8020e29c:	ffc78793          	addi	a5,a5,-4
    8020e2a0:	00fa3c23          	sd	a5,24(s4)
            yield();
    8020e2a4:	00004097          	auipc	ra,0x4
    8020e2a8:	a94080e7          	jalr	-1388(ra) # 80211d38 <yield>
    8020e2ac:	fc1ff06f          	j	8020e26c <syscallSelect+0x260>

000000008020e2b0 <syscallSetTimer>:
void syscallSetTimer() {
    8020e2b0:	fa010113          	addi	sp,sp,-96
    8020e2b4:	04113c23          	sd	ra,88(sp)
    8020e2b8:	04813823          	sd	s0,80(sp)
    8020e2bc:	04913423          	sd	s1,72(sp)
    8020e2c0:	06010413          	addi	s0,sp,96
    Trapframe *tf = getHartTrapFrame();
    8020e2c4:	ffffc097          	auipc	ra,0xffffc
    8020e2c8:	f18080e7          	jalr	-232(ra) # 8020a1dc <getHartTrapFrame>
    8020e2cc:	00050493          	mv	s1,a0
    IntervalTimer time = getTimer();
    8020e2d0:	fc040513          	addi	a0,s0,-64
    8020e2d4:	00000097          	auipc	ra,0x0
    8020e2d8:	15c080e7          	jalr	348(ra) # 8020e430 <getTimer>
    if (tf->a2) {
    8020e2dc:	0804b783          	ld	a5,128(s1)
    8020e2e0:	02079263          	bnez	a5,8020e304 <syscallSetTimer+0x54>
    if (tf->a1) {
    8020e2e4:	0784b783          	ld	a5,120(s1)
    8020e2e8:	04079063          	bnez	a5,8020e328 <syscallSetTimer+0x78>
    tf->a0 = 0;    
    8020e2ec:	0604b823          	sd	zero,112(s1)
}
    8020e2f0:	05813083          	ld	ra,88(sp)
    8020e2f4:	05013403          	ld	s0,80(sp)
    8020e2f8:	04813483          	ld	s1,72(sp)
    8020e2fc:	06010113          	addi	sp,sp,96
    8020e300:	00008067          	ret
        copyout(myProcess()->pgdir, tf->a2, (char*)&time, sizeof(IntervalTimer));
    8020e304:	00001097          	auipc	ra,0x1
    8020e308:	6e4080e7          	jalr	1764(ra) # 8020f9e8 <myProcess>
    8020e30c:	02000693          	li	a3,32
    8020e310:	fc040613          	addi	a2,s0,-64
    8020e314:	0804b583          	ld	a1,128(s1)
    8020e318:	04053503          	ld	a0,64(a0)
    8020e31c:	ffffc097          	auipc	ra,0xffffc
    8020e320:	81c080e7          	jalr	-2020(ra) # 80209b38 <copyout>
    8020e324:	fc1ff06f          	j	8020e2e4 <syscallSetTimer+0x34>
        copyin(myProcess()->pgdir, (char*)&time, tf->a1, sizeof(IntervalTimer));
    8020e328:	00001097          	auipc	ra,0x1
    8020e32c:	6c0080e7          	jalr	1728(ra) # 8020f9e8 <myProcess>
    8020e330:	02000693          	li	a3,32
    8020e334:	0784b603          	ld	a2,120(s1)
    8020e338:	fc040593          	addi	a1,s0,-64
    8020e33c:	04053503          	ld	a0,64(a0)
    8020e340:	ffffb097          	auipc	ra,0xffffb
    8020e344:	708080e7          	jalr	1800(ra) # 80209a48 <copyin>
        setTimer(time);
    8020e348:	fc043783          	ld	a5,-64(s0)
    8020e34c:	faf43023          	sd	a5,-96(s0)
    8020e350:	fc843783          	ld	a5,-56(s0)
    8020e354:	faf43423          	sd	a5,-88(s0)
    8020e358:	fd043783          	ld	a5,-48(s0)
    8020e35c:	faf43823          	sd	a5,-80(s0)
    8020e360:	fd843783          	ld	a5,-40(s0)
    8020e364:	faf43c23          	sd	a5,-72(s0)
    8020e368:	fa040513          	addi	a0,s0,-96
    8020e36c:	00000097          	auipc	ra,0x0
    8020e370:	084080e7          	jalr	132(ra) # 8020e3f0 <setTimer>
    8020e374:	f79ff06f          	j	8020e2ec <syscallSetTimer+0x3c>

000000008020e378 <setNextTimeout>:

static u32 ticks;

IntervalTimer timer;

void setNextTimeout() {
    8020e378:	ff010113          	addi	sp,sp,-16
    8020e37c:	00813423          	sd	s0,8(sp)
    8020e380:	01010413          	addi	s0,sp,16
	asm volatile("rdtime %0" : "=r" (x) );
    8020e384:	c0102573          	rdtime	a0
    SBI_CALL_1(SBI_SET_TIMER, r_realTime() + INTERVAL);
    8020e388:	000317b7          	lui	a5,0x31
    8020e38c:	d4078793          	addi	a5,a5,-704 # 30d40 <_start-0x801cf2c0>
    8020e390:	00f50533          	add	a0,a0,a5
    8020e394:	00000593          	li	a1,0
    8020e398:	00000613          	li	a2,0
    8020e39c:	00000693          	li	a3,0
    8020e3a0:	00000893          	li	a7,0
    8020e3a4:	00000073          	ecall
}
    8020e3a8:	00813403          	ld	s0,8(sp)
    8020e3ac:	01010113          	addi	sp,sp,16
    8020e3b0:	00008067          	ret

000000008020e3b4 <timerTick>:

void timerTick() {
    8020e3b4:	ff010113          	addi	sp,sp,-16
    8020e3b8:	00113423          	sd	ra,8(sp)
    8020e3bc:	00813023          	sd	s0,0(sp)
    8020e3c0:	01010413          	addi	s0,sp,16
    ticks++;
    8020e3c4:	01cc4717          	auipc	a4,0x1cc4
    8020e3c8:	25c70713          	addi	a4,a4,604 # 81ed2620 <ticks>
    8020e3cc:	00072783          	lw	a5,0(a4)
    8020e3d0:	0017879b          	addiw	a5,a5,1
    8020e3d4:	00f72023          	sw	a5,0(a4)
    setNextTimeout();
    8020e3d8:	00000097          	auipc	ra,0x0
    8020e3dc:	fa0080e7          	jalr	-96(ra) # 8020e378 <setNextTimeout>
}
    8020e3e0:	00813083          	ld	ra,8(sp)
    8020e3e4:	00013403          	ld	s0,0(sp)
    8020e3e8:	01010113          	addi	sp,sp,16
    8020e3ec:	00008067          	ret

000000008020e3f0 <setTimer>:

void setTimer(IntervalTimer new) {
    8020e3f0:	ff010113          	addi	sp,sp,-16
    8020e3f4:	00813423          	sd	s0,8(sp)
    8020e3f8:	01010413          	addi	s0,sp,16
    timer = new;
    8020e3fc:	01cc4797          	auipc	a5,0x1cc4
    8020e400:	20478793          	addi	a5,a5,516 # 81ed2600 <timer>
    8020e404:	00053583          	ld	a1,0(a0)
    8020e408:	00853603          	ld	a2,8(a0)
    8020e40c:	01053683          	ld	a3,16(a0)
    8020e410:	01853703          	ld	a4,24(a0)
    8020e414:	00b7b023          	sd	a1,0(a5)
    8020e418:	00c7b423          	sd	a2,8(a5)
    8020e41c:	00d7b823          	sd	a3,16(a5)
    8020e420:	00e7bc23          	sd	a4,24(a5)
}
    8020e424:	00813403          	ld	s0,8(sp)
    8020e428:	01010113          	addi	sp,sp,16
    8020e42c:	00008067          	ret

000000008020e430 <getTimer>:

IntervalTimer getTimer() {
    8020e430:	ff010113          	addi	sp,sp,-16
    8020e434:	00813423          	sd	s0,8(sp)
    8020e438:	01010413          	addi	s0,sp,16
    return timer;
    8020e43c:	01cc4717          	auipc	a4,0x1cc4
    8020e440:	1c470713          	addi	a4,a4,452 # 81ed2600 <timer>
    8020e444:	00073583          	ld	a1,0(a4)
    8020e448:	00873603          	ld	a2,8(a4)
    8020e44c:	01073683          	ld	a3,16(a4)
    8020e450:	01873703          	ld	a4,24(a4)
    8020e454:	00b53023          	sd	a1,0(a0)
    8020e458:	00c53423          	sd	a2,8(a0)
    8020e45c:	00d53823          	sd	a3,16(a0)
    8020e460:	00e53c23          	sd	a4,24(a0)
    8020e464:	00813403          	ld	s0,8(sp)
    8020e468:	01010113          	addi	sp,sp,16
    8020e46c:	00008067          	ret

000000008020e470 <trapInit>:
#include <Debug.h>
#include <Defs.h>
#include <exec.h>
#include <Thread.h>

void trapInit() {
    8020e470:	ff010113          	addi	sp,sp,-16
    8020e474:	00113423          	sd	ra,8(sp)
    8020e478:	00813023          	sd	s0,0(sp)
    8020e47c:	01010413          	addi	s0,sp,16
    printf("Trap init start...\n");
    8020e480:	00008517          	auipc	a0,0x8
    8020e484:	c5850513          	addi	a0,a0,-936 # 802160d8 <__func__.2+0x18>
    8020e488:	ffff3097          	auipc	ra,0xffff3
    8020e48c:	9c8080e7          	jalr	-1592(ra) # 80200e50 <printf>
	asm volatile("csrw stvec, %0" : : "r" (x));
    8020e490:	ffffe797          	auipc	a5,0xffffe
    8020e494:	ca078793          	addi	a5,a5,-864 # 8020c130 <kernelVector>
    8020e498:	10579073          	csrw	stvec,a5
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020e49c:	100027f3          	csrr	a5,sstatus
    w_stvec((u64)kernelVector);
    w_sstatus(r_sstatus() | SSTATUS_SIE | SSTATUS_SPIE);
    8020e4a0:	0227e793          	ori	a5,a5,34
    asm volatile("csrw sstatus, %0" : : "r" (x));
    8020e4a4:	10079073          	csrw	sstatus,a5
    asm volatile("csrw sip, %0" : : "r" (x));
    8020e4a8:	00000793          	li	a5,0
    8020e4ac:	14479073          	csrw	sip,a5
    asm volatile("csrr %0, sie" : "=r" (x) );
    8020e4b0:	104027f3          	csrr	a5,sie
    // setNextTimeout();
    w_sip(0); //todo
    w_sie(r_sie() | SIE_SEIE | SIE_SSIE | SIE_STIE);
    8020e4b4:	2227e793          	ori	a5,a5,546
	asm volatile("csrw sie, %0" : : "r" (x));
    8020e4b8:	10479073          	csrw	sie,a5
    printf("Trap init finish!\n");
    8020e4bc:	00008517          	auipc	a0,0x8
    8020e4c0:	c3450513          	addi	a0,a0,-972 # 802160f0 <__func__.2+0x30>
    8020e4c4:	ffff3097          	auipc	ra,0xffff3
    8020e4c8:	98c080e7          	jalr	-1652(ra) # 80200e50 <printf>
}
    8020e4cc:	00813083          	ld	ra,8(sp)
    8020e4d0:	00013403          	ld	s0,0(sp)
    8020e4d4:	01010113          	addi	sp,sp,16
    8020e4d8:	00008067          	ret

000000008020e4dc <trapDevice>:
	asm volatile("csrr %0, scause" : "=r" (x) );
    8020e4dc:	142027f3          	csrr	a5,scause
    if ((scause & SCAUSE_INTERRUPT) &&
    ((scause & SCAUSE_EXCEPTION_CODE) == SCAUSE_SUPERVISOR_TIMER)) {
        timerTick();
        return TIMER_INTERRUPT;
    }
    return UNKNOWN_DEVICE;
    8020e4e0:	00000513          	li	a0,0
    if ((scause & SCAUSE_INTERRUPT) && 
    8020e4e4:	0007c463          	bltz	a5,8020e4ec <trapDevice+0x10>
}
    8020e4e8:	00008067          	ret
int trapDevice() {
    8020e4ec:	fe010113          	addi	sp,sp,-32
    8020e4f0:	00113c23          	sd	ra,24(sp)
    8020e4f4:	00813823          	sd	s0,16(sp)
    8020e4f8:	00913423          	sd	s1,8(sp)
    8020e4fc:	02010413          	addi	s0,sp,32
    ((scause & SCAUSE_EXCEPTION_CODE) == SCAUSE_SUPERVISOR_EXTERNAL)) {
    8020e500:	00179793          	slli	a5,a5,0x1
    8020e504:	0017d793          	srli	a5,a5,0x1
    if ((scause & SCAUSE_INTERRUPT) && 
    8020e508:	00900713          	li	a4,9
    8020e50c:	02e78263          	beq	a5,a4,8020e530 <trapDevice+0x54>
    if ((scause & SCAUSE_INTERRUPT) &&
    8020e510:	00500713          	li	a4,5
    return UNKNOWN_DEVICE;
    8020e514:	00000513          	li	a0,0
    if ((scause & SCAUSE_INTERRUPT) &&
    8020e518:	0ae78663          	beq	a5,a4,8020e5c4 <trapDevice+0xe8>
}
    8020e51c:	01813083          	ld	ra,24(sp)
    8020e520:	01013403          	ld	s0,16(sp)
    8020e524:	00813483          	ld	s1,8(sp)
    8020e528:	02010113          	addi	sp,sp,32
    8020e52c:	00008067          	ret

// read and write tp, the thread pointer, which holds
// this core's hartid (core number), the index into cpus[].
static inline u64 r_tp() {
	u64 x;
	asm volatile("mv %0, tp" : "=r" (x) );
    8020e530:	00020713          	mv	a4,tp
void trapframeDump(Trapframe*);

inline static u32 interruptServed() {
    int hart = r_tp();
    #ifndef QEMU
    return *(u32*)PLIC_MCLAIM(hart);
    8020e534:	00d7171b          	slliw	a4,a4,0xd
    8020e538:	1f8617b7          	lui	a5,0x1f861
    8020e53c:	00979793          	slli	a5,a5,0x9
    8020e540:	00e787b3          	add	a5,a5,a4
    8020e544:	0047a483          	lw	s1,4(a5) # 1f861004 <_start-0x6099effc>
        int irq = interruptServed();
    8020e548:	0004871b          	sext.w	a4,s1
        if (irq == UART_IRQ) {
    8020e54c:	02100793          	li	a5,33
    8020e550:	02f70c63          	beq	a4,a5,8020e588 <trapDevice+0xac>
        } else if (irq == DISK_IRQ) {
    8020e554:	01b00793          	li	a5,27
    8020e558:	04f70063          	beq	a4,a5,8020e598 <trapDevice+0xbc>
        return SOFTWARE_TRAP;
    8020e55c:	00100513          	li	a0,1
        } else if (irq) {
    8020e560:	fa070ee3          	beqz	a4,8020e51c <trapDevice+0x40>
            panic("unexpected interrupt irq = %d\n", irq);
    8020e564:	00008697          	auipc	a3,0x8
    8020e568:	ba468693          	addi	a3,a3,-1116 # 80216108 <__func__.2+0x48>
    8020e56c:	00008617          	auipc	a2,0x8
    8020e570:	e3c60613          	addi	a2,a2,-452 # 802163a8 <__func__.2>
    8020e574:	02c00593          	li	a1,44
    8020e578:	00008517          	auipc	a0,0x8
    8020e57c:	bb050513          	addi	a0,a0,-1104 # 80216128 <__func__.2+0x68>
    8020e580:	ffff3097          	auipc	ra,0xffff3
    8020e584:	968080e7          	jalr	-1688(ra) # 80200ee8 <_panic_>
            int c = getchar();
    8020e588:	ffff2097          	auipc	ra,0xffff2
    8020e58c:	ec8080e7          	jalr	-312(ra) # 80200450 <getchar>
            if (c != -1) {
    8020e590:	fff00793          	li	a5,-1
    8020e594:	02f51263          	bne	a0,a5,8020e5b8 <trapDevice+0xdc>
    8020e598:	00020713          	mv	a4,tp
}

inline static void interruptCompleted(int irq) {
    int hart = r_tp();
    #ifndef QEMU
    *(u32*)PLIC_MCLAIM(hart) = irq;
    8020e59c:	00d7171b          	slliw	a4,a4,0xd
    8020e5a0:	1f8617b7          	lui	a5,0x1f861
    8020e5a4:	00979793          	slli	a5,a5,0x9
    8020e5a8:	00e787b3          	add	a5,a5,a4
    8020e5ac:	0097a223          	sw	s1,4(a5) # 1f861004 <_start-0x6099effc>
        return SOFTWARE_TRAP;
    8020e5b0:	00100513          	li	a0,1
    #else
    *(u32*)PLIC_SCLAIM(hart) = irq;
    #endif
}
    8020e5b4:	f69ff06f          	j	8020e51c <trapDevice+0x40>
                consoleInterrupt(c);
    8020e5b8:	ffff2097          	auipc	ra,0xffff2
    8020e5bc:	e48080e7          	jalr	-440(ra) # 80200400 <consoleInterrupt>
    8020e5c0:	fd9ff06f          	j	8020e598 <trapDevice+0xbc>
        timerTick();
    8020e5c4:	00000097          	auipc	ra,0x0
    8020e5c8:	df0080e7          	jalr	-528(ra) # 8020e3b4 <timerTick>
        return TIMER_INTERRUPT;
    8020e5cc:	00200513          	li	a0,2
    8020e5d0:	f4dff06f          	j	8020e51c <trapDevice+0x40>

000000008020e5d4 <userTrapReturn>:
    return;
    Process *p = myProcess();
    p->processTime.lastUserTime = r_time();
}

void userTrapReturn() {
    8020e5d4:	fd010113          	addi	sp,sp,-48
    8020e5d8:	02113423          	sd	ra,40(sp)
    8020e5dc:	02813023          	sd	s0,32(sp)
    8020e5e0:	00913c23          	sd	s1,24(sp)
    8020e5e4:	01213823          	sd	s2,16(sp)
    8020e5e8:	01313423          	sd	s3,8(sp)
    8020e5ec:	03010413          	addi	s0,sp,48
    userProcessCpuTimeBegin();
    extern char trampoline[];
    w_stvec(TRAMPOLINE_BASE + ((u64)userVector - (u64)trampoline));
    8020e5f0:	00004997          	auipc	s3,0x4
    8020e5f4:	a1098993          	addi	s3,s3,-1520 # 80212000 <_trampoline>
    8020e5f8:	02000937          	lui	s2,0x2000
    8020e5fc:	fff90913          	addi	s2,s2,-1 # 1ffffff <_start-0x7e200001>
    8020e600:	00d91913          	slli	s2,s2,0xd
    8020e604:	00004797          	auipc	a5,0x4
    8020e608:	9fc78793          	addi	a5,a5,-1540 # 80212000 <_trampoline>
    8020e60c:	012787b3          	add	a5,a5,s2
    8020e610:	413787b3          	sub	a5,a5,s3
	asm volatile("csrw stvec, %0" : : "r" (x));
    8020e614:	10579073          	csrw	stvec,a5

    Trapframe* trapframe = getHartTrapFrame();
    8020e618:	ffffc097          	auipc	ra,0xffffc
    8020e61c:	bc4080e7          	jalr	-1084(ra) # 8020a1dc <getHartTrapFrame>
    8020e620:	00050493          	mv	s1,a0

    trapframe->kernelSp = getThreadTopSp(myThread());
    8020e624:	00002097          	auipc	ra,0x2
    8020e628:	f1c080e7          	jalr	-228(ra) # 80210540 <myThread>
    8020e62c:	00002097          	auipc	ra,0x2
    8020e630:	f60080e7          	jalr	-160(ra) # 8021058c <getThreadTopSp>
    8020e634:	00a4b423          	sd	a0,8(s1)
    trapframe->trapHandler = (u64)userTrap;
    8020e638:	00000797          	auipc	a5,0x0
    8020e63c:	08478793          	addi	a5,a5,132 # 8020e6bc <userTrap>
    8020e640:	00f4b823          	sd	a5,16(s1)
	asm volatile("mv %0, tp" : "=r" (x) );
    8020e644:	00020793          	mv	a5,tp
    trapframe->kernelHartId = r_tp();
    8020e648:	02f4b023          	sd	a5,32(s1)

    handleSignal(myThread());
    8020e64c:	00002097          	auipc	ra,0x2
    8020e650:	ef4080e7          	jalr	-268(ra) # 80210540 <myThread>
    8020e654:	ffffc097          	auipc	ra,0xffffc
    8020e658:	444080e7          	jalr	1092(ra) # 8020aa98 <handleSignal>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020e65c:	100027f3          	csrr	a5,sstatus

    //bcopy(&(currentProcess->trapframe), trapframe, sizeof(Trapframe));

    u64 sstatus = r_sstatus();
    sstatus &= ~SSTATUS_SPP;
    8020e660:	eff7f793          	andi	a5,a5,-257
    sstatus |= SSTATUS_SPIE;
    8020e664:	0207e793          	ori	a5,a5,32
    asm volatile("csrw sstatus, %0" : : "r" (x));
    8020e668:	10079073          	csrw	sstatus,a5
    w_sstatus(sstatus);
    u64 satp = MAKE_SATP(myProcess()->pgdir);
    8020e66c:	00001097          	auipc	ra,0x1
    8020e670:	37c080e7          	jalr	892(ra) # 8020f9e8 <myProcess>
    8020e674:	04053583          	ld	a1,64(a0)
    8020e678:	00c5d593          	srli	a1,a1,0xc
    u64 fn = TRAMPOLINE_BASE + ((u64)userReturn - (u64)trampoline);
    8020e67c:	00004797          	auipc	a5,0x4
    8020e680:	aac78793          	addi	a5,a5,-1364 # 80212128 <userReturn>
    8020e684:	012787b3          	add	a5,a5,s2
    8020e688:	413787b3          	sub	a5,a5,s3
    // printf("out tp: %lx\n", trapframe->tp);
    // printf("return to user!\n");
    ((void(*)(u64, u64))fn)((u64)trapframe, satp);
    8020e68c:	fff00713          	li	a4,-1
    8020e690:	03f71713          	slli	a4,a4,0x3f
    8020e694:	00e5e5b3          	or	a1,a1,a4
    8020e698:	00048513          	mv	a0,s1
    8020e69c:	000780e7          	jalr	a5
}
    8020e6a0:	02813083          	ld	ra,40(sp)
    8020e6a4:	02013403          	ld	s0,32(sp)
    8020e6a8:	01813483          	ld	s1,24(sp)
    8020e6ac:	01013903          	ld	s2,16(sp)
    8020e6b0:	00813983          	ld	s3,8(sp)
    8020e6b4:	03010113          	addi	sp,sp,48
    8020e6b8:	00008067          	ret

000000008020e6bc <userTrap>:
void userTrap() {
    8020e6bc:	fd010113          	addi	sp,sp,-48
    8020e6c0:	02113423          	sd	ra,40(sp)
    8020e6c4:	02813023          	sd	s0,32(sp)
    8020e6c8:	00913c23          	sd	s1,24(sp)
    8020e6cc:	01213823          	sd	s2,16(sp)
    8020e6d0:	03010413          	addi	s0,sp,48
    u64* pgdir = myProcess()->pgdir;
    8020e6d4:	00001097          	auipc	ra,0x1
    8020e6d8:	314080e7          	jalr	788(ra) # 8020f9e8 <myProcess>
    8020e6dc:	04053903          	ld	s2,64(a0)
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020e6e0:	100027f3          	csrr	a5,sstatus
    if (r_sstatus() & SSTATUS_SPP) {
    8020e6e4:	1007f793          	andi	a5,a5,256
    8020e6e8:	06079863          	bnez	a5,8020e758 <userTrap+0x9c>
	asm volatile("csrw stvec, %0" : : "r" (x));
    8020e6ec:	ffffe797          	auipc	a5,0xffffe
    8020e6f0:	a4478793          	addi	a5,a5,-1468 # 8020c130 <kernelVector>
    8020e6f4:	10579073          	csrw	stvec,a5
    Trapframe* trapframe = getHartTrapFrame();
    8020e6f8:	ffffc097          	auipc	ra,0xffffc
    8020e6fc:	ae4080e7          	jalr	-1308(ra) # 8020a1dc <getHartTrapFrame>
    8020e700:	00050493          	mv	s1,a0
	asm volatile("csrr %0, scause" : "=r" (x) );
    8020e704:	142027f3          	csrr	a5,scause
    if (r_scause() & SCAUSE_INTERRUPT) {
    8020e708:	0607ca63          	bltz	a5,8020e77c <userTrap+0xc0>
        kernelProcessCpuTimeBegin();
    8020e70c:	00002097          	auipc	ra,0x2
    8020e710:	e04080e7          	jalr	-508(ra) # 80210510 <kernelProcessCpuTimeBegin>
        u64 *pte = NULL;
    8020e714:	fc043c23          	sd	zero,-40(s0)
    8020e718:	142027f3          	csrr	a5,scause
        switch (r_scause() & SCAUSE_EXCEPTION_CODE)
    8020e71c:	00179793          	slli	a5,a5,0x1
    8020e720:	0017d793          	srli	a5,a5,0x1
    8020e724:	00d00713          	li	a4,13
    8020e728:	0ee78063          	beq	a5,a4,8020e808 <userTrap+0x14c>
    8020e72c:	00f00713          	li	a4,15
    8020e730:	14e78a63          	beq	a5,a4,8020e884 <userTrap+0x1c8>
    8020e734:	00800713          	li	a4,8
    8020e738:	06e78e63          	beq	a5,a4,8020e7b4 <userTrap+0xf8>
            pageout(myProcess()->pgdir, r_stval());
    8020e73c:	00001097          	auipc	ra,0x1
    8020e740:	2ac080e7          	jalr	684(ra) # 8020f9e8 <myProcess>
	asm volatile("csrr %0, stval" : "=r" (x) );
    8020e744:	143025f3          	csrr	a1,stval
    8020e748:	04053503          	ld	a0,64(a0)
    8020e74c:	ffffb097          	auipc	ra,0xffffb
    8020e750:	dc8080e7          	jalr	-568(ra) # 80209514 <pageout>
            break;
    8020e754:	0380006f          	j	8020e78c <userTrap+0xd0>
        panic("usertrap: not from user mode\n");
    8020e758:	00008697          	auipc	a3,0x8
    8020e75c:	9d868693          	addi	a3,a3,-1576 # 80216130 <__func__.2+0x70>
    8020e760:	00008617          	auipc	a2,0x8
    8020e764:	c5860613          	addi	a2,a2,-936 # 802163b8 <__func__.0>
    8020e768:	07700593          	li	a1,119
    8020e76c:	00008517          	auipc	a0,0x8
    8020e770:	9bc50513          	addi	a0,a0,-1604 # 80216128 <__func__.2+0x68>
    8020e774:	ffff2097          	auipc	ra,0xffff2
    8020e778:	774080e7          	jalr	1908(ra) # 80200ee8 <_panic_>
        trapDevice();
    8020e77c:	00000097          	auipc	ra,0x0
    8020e780:	d60080e7          	jalr	-672(ra) # 8020e4dc <trapDevice>
        yield();
    8020e784:	00003097          	auipc	ra,0x3
    8020e788:	5b4080e7          	jalr	1460(ra) # 80211d38 <yield>
    kernelProcessCpuTimeEnd();
    8020e78c:	00002097          	auipc	ra,0x2
    8020e790:	d9c080e7          	jalr	-612(ra) # 80210528 <kernelProcessCpuTimeEnd>
    userTrapReturn();
    8020e794:	00000097          	auipc	ra,0x0
    8020e798:	e40080e7          	jalr	-448(ra) # 8020e5d4 <userTrapReturn>
}
    8020e79c:	02813083          	ld	ra,40(sp)
    8020e7a0:	02013403          	ld	s0,32(sp)
    8020e7a4:	01813483          	ld	s1,24(sp)
    8020e7a8:	01013903          	ld	s2,16(sp)
    8020e7ac:	03010113          	addi	sp,sp,48
    8020e7b0:	00008067          	ret
            trapframe->epc += 4;
    8020e7b4:	0184b783          	ld	a5,24(s1)
    8020e7b8:	00478793          	addi	a5,a5,4
    8020e7bc:	00f4bc23          	sd	a5,24(s1)
            if (!syscallVector[trapframe->a7]) {
    8020e7c0:	0a84b703          	ld	a4,168(s1)
    8020e7c4:	00371693          	slli	a3,a4,0x3
    8020e7c8:	00009797          	auipc	a5,0x9
    8020e7cc:	86878793          	addi	a5,a5,-1944 # 80217030 <syscallVector>
    8020e7d0:	00d787b3          	add	a5,a5,a3
    8020e7d4:	0007b783          	ld	a5,0(a5)
    8020e7d8:	00078663          	beqz	a5,8020e7e4 <userTrap+0x128>
            syscallVector[trapframe->a7]();
    8020e7dc:	000780e7          	jalr	a5
            break;
    8020e7e0:	fadff06f          	j	8020e78c <userTrap+0xd0>
                panic("unknown-syscall: %d\n", trapframe->a7);
    8020e7e4:	00008697          	auipc	a3,0x8
    8020e7e8:	96c68693          	addi	a3,a3,-1684 # 80216150 <__func__.2+0x90>
    8020e7ec:	00008617          	auipc	a2,0x8
    8020e7f0:	bcc60613          	addi	a2,a2,-1076 # 802163b8 <__func__.0>
    8020e7f4:	09500593          	li	a1,149
    8020e7f8:	00008517          	auipc	a0,0x8
    8020e7fc:	93050513          	addi	a0,a0,-1744 # 80216128 <__func__.2+0x68>
    8020e800:	ffff2097          	auipc	ra,0xffff2
    8020e804:	6e8080e7          	jalr	1768(ra) # 80200ee8 <_panic_>
    8020e808:	143025f3          	csrr	a1,stval
            pa = pageLookup(pgdir, r_stval(), &pte);
    8020e80c:	fd840613          	addi	a2,s0,-40
    8020e810:	00090513          	mv	a0,s2
    8020e814:	ffffa097          	auipc	ra,0xffffa
    8020e818:	764080e7          	jalr	1892(ra) # 80208f78 <pageLookup>
            if (pa == 0) {
    8020e81c:	02050863          	beqz	a0,8020e84c <userTrap+0x190>
            } else if (!(*pte & PTE_READ)) {
    8020e820:	fd843783          	ld	a5,-40(s0)
    8020e824:	0007b783          	ld	a5,0(a5)
    8020e828:	0027f793          	andi	a5,a5,2
    8020e82c:	02079a63          	bnez	a5,8020e860 <userTrap+0x1a4>
                processSignalSend(myProcess()->processId, SIGSEGV);
    8020e830:	00001097          	auipc	ra,0x1
    8020e834:	1b8080e7          	jalr	440(ra) # 8020f9e8 <myProcess>
    8020e838:	00b00593          	li	a1,11
    8020e83c:	04852503          	lw	a0,72(a0)
    8020e840:	ffffc097          	auipc	ra,0xffffc
    8020e844:	c98080e7          	jalr	-872(ra) # 8020a4d8 <processSignalSend>
    8020e848:	f45ff06f          	j	8020e78c <userTrap+0xd0>
    8020e84c:	143025f3          	csrr	a1,stval
                pageout(pgdir, r_stval());
    8020e850:	00090513          	mv	a0,s2
    8020e854:	ffffb097          	auipc	ra,0xffffb
    8020e858:	cc0080e7          	jalr	-832(ra) # 80209514 <pageout>
    8020e85c:	f31ff06f          	j	8020e78c <userTrap+0xd0>
                panic("unknown");
    8020e860:	00008697          	auipc	a3,0x8
    8020e864:	90868693          	addi	a3,a3,-1784 # 80216168 <__func__.2+0xa8>
    8020e868:	00008617          	auipc	a2,0x8
    8020e86c:	b5060613          	addi	a2,a2,-1200 # 802163b8 <__func__.0>
    8020e870:	0aa00593          	li	a1,170
    8020e874:	00008517          	auipc	a0,0x8
    8020e878:	8b450513          	addi	a0,a0,-1868 # 80216128 <__func__.2+0x68>
    8020e87c:	ffff2097          	auipc	ra,0xffff2
    8020e880:	66c080e7          	jalr	1644(ra) # 80200ee8 <_panic_>
    8020e884:	143025f3          	csrr	a1,stval
            pa = pageLookup(pgdir, r_stval(), &pte);
    8020e888:	fd840613          	addi	a2,s0,-40
    8020e88c:	00090513          	mv	a0,s2
    8020e890:	ffffa097          	auipc	ra,0xffffa
    8020e894:	6e8080e7          	jalr	1768(ra) # 80208f78 <pageLookup>
            if (pa == 0) {
    8020e898:	02050c63          	beqz	a0,8020e8d0 <userTrap+0x214>
            } else if (*pte & PTE_COW) {
    8020e89c:	fd843783          	ld	a5,-40(s0)
    8020e8a0:	0007b783          	ld	a5,0(a5)
    8020e8a4:	1007f713          	andi	a4,a5,256
    8020e8a8:	02071e63          	bnez	a4,8020e8e4 <userTrap+0x228>
            } else if (!(*pte & PTE_WRITE)) {
    8020e8ac:	0047f793          	andi	a5,a5,4
    8020e8b0:	04079463          	bnez	a5,8020e8f8 <userTrap+0x23c>
                processSignalSend(myProcess()->processId, SIGSEGV);
    8020e8b4:	00001097          	auipc	ra,0x1
    8020e8b8:	134080e7          	jalr	308(ra) # 8020f9e8 <myProcess>
    8020e8bc:	00b00593          	li	a1,11
    8020e8c0:	04852503          	lw	a0,72(a0)
    8020e8c4:	ffffc097          	auipc	ra,0xffffc
    8020e8c8:	c14080e7          	jalr	-1004(ra) # 8020a4d8 <processSignalSend>
    8020e8cc:	ec1ff06f          	j	8020e78c <userTrap+0xd0>
    8020e8d0:	143025f3          	csrr	a1,stval
                pageout(pgdir, r_stval());
    8020e8d4:	00090513          	mv	a0,s2
    8020e8d8:	ffffb097          	auipc	ra,0xffffb
    8020e8dc:	c3c080e7          	jalr	-964(ra) # 80209514 <pageout>
    8020e8e0:	eadff06f          	j	8020e78c <userTrap+0xd0>
    8020e8e4:	143025f3          	csrr	a1,stval
                cowHandler(pgdir, r_stval());
    8020e8e8:	00090513          	mv	a0,s2
    8020e8ec:	ffffb097          	auipc	ra,0xffffb
    8020e8f0:	f38080e7          	jalr	-200(ra) # 80209824 <cowHandler>
    8020e8f4:	e99ff06f          	j	8020e78c <userTrap+0xd0>
                panic("unknown");
    8020e8f8:	00008697          	auipc	a3,0x8
    8020e8fc:	87068693          	addi	a3,a3,-1936 # 80216168 <__func__.2+0xa8>
    8020e900:	00008617          	auipc	a2,0x8
    8020e904:	ab860613          	addi	a2,a2,-1352 # 802163b8 <__func__.0>
    8020e908:	0b800593          	li	a1,184
    8020e90c:	00008517          	auipc	a0,0x8
    8020e910:	81c50513          	addi	a0,a0,-2020 # 80216128 <__func__.2+0x68>
    8020e914:	ffff2097          	auipc	ra,0xffff2
    8020e918:	5d4080e7          	jalr	1492(ra) # 80200ee8 <_panic_>

000000008020e91c <trapframeDump>:

void trapframeDump(Trapframe *tf)
{
    8020e91c:	f0010113          	addi	sp,sp,-256
    8020e920:	0e113c23          	sd	ra,248(sp)
    8020e924:	0e813823          	sd	s0,240(sp)
    8020e928:	10010413          	addi	s0,sp,256
    printf(" a0: %lx\n \
    8020e92c:	02053783          	ld	a5,32(a0)
    8020e930:	0ef13023          	sd	a5,224(sp)
    8020e934:	01053783          	ld	a5,16(a0)
    8020e938:	0cf13c23          	sd	a5,216(sp)
    8020e93c:	00053783          	ld	a5,0(a0)
    8020e940:	0cf13823          	sd	a5,208(sp)
    8020e944:	00853783          	ld	a5,8(a0)
    8020e948:	0cf13423          	sd	a5,200(sp)
    8020e94c:	01853783          	ld	a5,24(a0)
    8020e950:	0cf13023          	sd	a5,192(sp)
    8020e954:	04053783          	ld	a5,64(a0)
    8020e958:	0af13c23          	sd	a5,184(sp)
    8020e95c:	03853783          	ld	a5,56(a0)
    8020e960:	0af13823          	sd	a5,176(sp)
    8020e964:	03053783          	ld	a5,48(a0)
    8020e968:	0af13423          	sd	a5,168(sp)
    8020e96c:	02853783          	ld	a5,40(a0)
    8020e970:	0af13023          	sd	a5,160(sp)
    8020e974:	0f853783          	ld	a5,248(a0)
    8020e978:	08f13c23          	sd	a5,152(sp)
    8020e97c:	0f053783          	ld	a5,240(a0)
    8020e980:	08f13823          	sd	a5,144(sp)
    8020e984:	0e853783          	ld	a5,232(a0)
    8020e988:	08f13423          	sd	a5,136(sp)
    8020e98c:	0e053783          	ld	a5,224(a0)
    8020e990:	08f13023          	sd	a5,128(sp)
    8020e994:	0d853783          	ld	a5,216(a0)
    8020e998:	06f13c23          	sd	a5,120(sp)
    8020e99c:	0d053783          	ld	a5,208(a0)
    8020e9a0:	06f13823          	sd	a5,112(sp)
    8020e9a4:	0c853783          	ld	a5,200(a0)
    8020e9a8:	06f13423          	sd	a5,104(sp)
    8020e9ac:	0c053783          	ld	a5,192(a0)
    8020e9b0:	06f13023          	sd	a5,96(sp)
    8020e9b4:	0b853783          	ld	a5,184(a0)
    8020e9b8:	04f13c23          	sd	a5,88(sp)
    8020e9bc:	0b053783          	ld	a5,176(a0)
    8020e9c0:	04f13823          	sd	a5,80(sp)
    8020e9c4:	06853783          	ld	a5,104(a0)
    8020e9c8:	04f13423          	sd	a5,72(sp)
    8020e9cc:	06053783          	ld	a5,96(a0)
    8020e9d0:	04f13023          	sd	a5,64(sp)
    8020e9d4:	11853783          	ld	a5,280(a0)
    8020e9d8:	02f13c23          	sd	a5,56(sp)
    8020e9dc:	11053783          	ld	a5,272(a0)
    8020e9e0:	02f13823          	sd	a5,48(sp)
    8020e9e4:	10853783          	ld	a5,264(a0)
    8020e9e8:	02f13423          	sd	a5,40(sp)
    8020e9ec:	10053783          	ld	a5,256(a0)
    8020e9f0:	02f13023          	sd	a5,32(sp)
    8020e9f4:	05853783          	ld	a5,88(a0)
    8020e9f8:	00f13c23          	sd	a5,24(sp)
    8020e9fc:	05053783          	ld	a5,80(a0)
    8020ea00:	00f13823          	sd	a5,16(sp)
    8020ea04:	04853783          	ld	a5,72(a0)
    8020ea08:	00f13423          	sd	a5,8(sp)
    8020ea0c:	0a853783          	ld	a5,168(a0)
    8020ea10:	00f13023          	sd	a5,0(sp)
    8020ea14:	0a053883          	ld	a7,160(a0)
    8020ea18:	09853803          	ld	a6,152(a0)
    8020ea1c:	09053783          	ld	a5,144(a0)
    8020ea20:	08853703          	ld	a4,136(a0)
    8020ea24:	08053683          	ld	a3,128(a0)
    8020ea28:	07853603          	ld	a2,120(a0)
    8020ea2c:	07053583          	ld	a1,112(a0)
    8020ea30:	00007517          	auipc	a0,0x7
    8020ea34:	74050513          	addi	a0,a0,1856 # 80216170 <__func__.2+0xb0>
    8020ea38:	ffff2097          	auipc	ra,0xffff2
    8020ea3c:	418080e7          	jalr	1048(ra) # 80200e50 <printf>
            tf->s0, tf->s1, tf->s2, tf->s3, tf->s4,
            tf->s5, tf->s6, tf->s7, tf->s8, tf->s9,
            tf->s10, tf->s11, tf->ra, tf->sp, tf->gp,
            tf->tp, tf->epc, tf->kernelSp, tf->kernelSatp,
            tf->trapHandler, tf->kernelHartId);
}
    8020ea40:	0f813083          	ld	ra,248(sp)
    8020ea44:	0f013403          	ld	s0,240(sp)
    8020ea48:	10010113          	addi	sp,sp,256
    8020ea4c:	00008067          	ret

000000008020ea50 <kernelTrap>:
void kernelTrap() {
    8020ea50:	fc010113          	addi	sp,sp,-64
    8020ea54:	02113c23          	sd	ra,56(sp)
    8020ea58:	02813823          	sd	s0,48(sp)
    8020ea5c:	02913423          	sd	s1,40(sp)
    8020ea60:	03213023          	sd	s2,32(sp)
    8020ea64:	01313c23          	sd	s3,24(sp)
    8020ea68:	04010413          	addi	s0,sp,64
    asm volatile("csrr %0, sepc" : "=r" (x) );
    8020ea6c:	14102973          	csrr	s2,sepc
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020ea70:	100024f3          	csrr	s1,sstatus
	asm volatile("csrr %0, scause" : "=r" (x) );
    8020ea74:	142029f3          	csrr	s3,scause
    asm volatile("mv %0, tp" : "=r" (x) );
    8020ea78:	00020593          	mv	a1,tp
	asm volatile("csrr %0, stval" : "=r" (x) );
    8020ea7c:	143027f3          	csrr	a5,stval
    printf("[Kernel Trap] hartId is %lx, status is %lx, spec is %lx, cause is %lx, stval is %lx\n", hartId, sstatus, sepc, scause, r_stval());
    8020ea80:	00098713          	mv	a4,s3
    8020ea84:	00090693          	mv	a3,s2
    8020ea88:	00048613          	mv	a2,s1
    8020ea8c:	00008517          	auipc	a0,0x8
    8020ea90:	85450513          	addi	a0,a0,-1964 # 802162e0 <__func__.2+0x220>
    8020ea94:	ffff2097          	auipc	ra,0xffff2
    8020ea98:	3bc080e7          	jalr	956(ra) # 80200e50 <printf>
    Trapframe* trapframe = getHartTrapFrame();
    8020ea9c:	ffffb097          	auipc	ra,0xffffb
    8020eaa0:	740080e7          	jalr	1856(ra) # 8020a1dc <getHartTrapFrame>
    trapframeDump(trapframe);
    8020eaa4:	00000097          	auipc	ra,0x0
    8020eaa8:	e78080e7          	jalr	-392(ra) # 8020e91c <trapframeDump>
    if (!(sstatus & SSTATUS_SPP)) {
    8020eaac:	1004f793          	andi	a5,s1,256
    8020eab0:	04078463          	beqz	a5,8020eaf8 <kernelTrap+0xa8>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020eab4:	100027f3          	csrr	a5,sstatus
	return (x & SSTATUS_SIE) != 0;
    8020eab8:	0027f793          	andi	a5,a5,2
    if (intr_get()) {
    8020eabc:	06079063          	bnez	a5,8020eb1c <kernelTrap+0xcc>
    int device = trapDevice();
    8020eac0:	00000097          	auipc	ra,0x0
    8020eac4:	a1c080e7          	jalr	-1508(ra) # 8020e4dc <trapDevice>
    if (device == UNKNOWN_DEVICE) {
    8020eac8:	06050c63          	beqz	a0,8020eb40 <kernelTrap+0xf0>
    if (device == TIMER_INTERRUPT) {
    8020eacc:	00200793          	li	a5,2
    8020ead0:	0af50e63          	beq	a0,a5,8020eb8c <kernelTrap+0x13c>
  	asm volatile("csrw sepc, %0" : : "r" (x));
    8020ead4:	14191073          	csrw	sepc,s2
    asm volatile("csrw sstatus, %0" : : "r" (x));
    8020ead8:	10049073          	csrw	sstatus,s1
}
    8020eadc:	03813083          	ld	ra,56(sp)
    8020eae0:	03013403          	ld	s0,48(sp)
    8020eae4:	02813483          	ld	s1,40(sp)
    8020eae8:	02013903          	ld	s2,32(sp)
    8020eaec:	01813983          	ld	s3,24(sp)
    8020eaf0:	04010113          	addi	sp,sp,64
    8020eaf4:	00008067          	ret
        panic("kernel trap not from supervisor mode");
    8020eaf8:	00008697          	auipc	a3,0x8
    8020eafc:	84068693          	addi	a3,a3,-1984 # 80216338 <__func__.2+0x278>
    8020eb00:	00008617          	auipc	a2,0x8
    8020eb04:	8c860613          	addi	a2,a2,-1848 # 802163c8 <__func__.1>
    8020eb08:	04d00593          	li	a1,77
    8020eb0c:	00007517          	auipc	a0,0x7
    8020eb10:	61c50513          	addi	a0,a0,1564 # 80216128 <__func__.2+0x68>
    8020eb14:	ffff2097          	auipc	ra,0xffff2
    8020eb18:	3d4080e7          	jalr	980(ra) # 80200ee8 <_panic_>
        panic("kernel trap while interrupts enbled");
    8020eb1c:	00008697          	auipc	a3,0x8
    8020eb20:	84468693          	addi	a3,a3,-1980 # 80216360 <__func__.2+0x2a0>
    8020eb24:	00008617          	auipc	a2,0x8
    8020eb28:	8a460613          	addi	a2,a2,-1884 # 802163c8 <__func__.1>
    8020eb2c:	05000593          	li	a1,80
    8020eb30:	00007517          	auipc	a0,0x7
    8020eb34:	5f850513          	addi	a0,a0,1528 # 80216128 <__func__.2+0x68>
    8020eb38:	ffff2097          	auipc	ra,0xffff2
    8020eb3c:	3b0080e7          	jalr	944(ra) # 80200ee8 <_panic_>
        int pa = pageLookup(myProcess()->pgdir, r_stval(), &pte);
    8020eb40:	00001097          	auipc	ra,0x1
    8020eb44:	ea8080e7          	jalr	-344(ra) # 8020f9e8 <myProcess>
	asm volatile("csrr %0, stval" : "=r" (x) );
    8020eb48:	143025f3          	csrr	a1,stval
    8020eb4c:	fc840613          	addi	a2,s0,-56
    8020eb50:	04053503          	ld	a0,64(a0)
    8020eb54:	ffffa097          	auipc	ra,0xffffa
    8020eb58:	424080e7          	jalr	1060(ra) # 80208f78 <pageLookup>
    8020eb5c:	143027f3          	csrr	a5,stval
        panic("unhandled error %d,  %lx, %lx\n", scause, r_stval(), pa);
    8020eb60:	0005081b          	sext.w	a6,a0
    8020eb64:	00098713          	mv	a4,s3
    8020eb68:	00008697          	auipc	a3,0x8
    8020eb6c:	82068693          	addi	a3,a3,-2016 # 80216388 <__func__.2+0x2c8>
    8020eb70:	00008617          	auipc	a2,0x8
    8020eb74:	85860613          	addi	a2,a2,-1960 # 802163c8 <__func__.1>
    8020eb78:	05700593          	li	a1,87
    8020eb7c:	00007517          	auipc	a0,0x7
    8020eb80:	5ac50513          	addi	a0,a0,1452 # 80216128 <__func__.2+0x68>
    8020eb84:	ffff2097          	auipc	ra,0xffff2
    8020eb88:	364080e7          	jalr	868(ra) # 80200ee8 <_panic_>
        yield();
    8020eb8c:	00003097          	auipc	ra,0x3
    8020eb90:	1ac080e7          	jalr	428(ra) # 80211d38 <yield>
    8020eb94:	f41ff06f          	j	8020ead4 <kernelTrap+0x84>

000000008020eb98 <getSyscallMessage>:
#include <Debug.h>
#include <SyscallId.h>
#include <Driver.h>
#include <Type.h>

void getSyscallMessage(int id, u64 pc) {
    8020eb98:	ff010113          	addi	sp,sp,-16
    8020eb9c:	00113423          	sd	ra,8(sp)
    8020eba0:	00813023          	sd	s0,0(sp)
    8020eba4:	01010413          	addi	s0,sp,16
    switch (id)
    8020eba8:	08200793          	li	a5,130
    8020ebac:	06f50463          	beq	a0,a5,8020ec14 <getSyscallMessage+0x7c>
    8020ebb0:	02a7c463          	blt	a5,a0,8020ebd8 <getSyscallMessage+0x40>
    8020ebb4:	03b00793          	li	a5,59
    8020ebb8:	04f50463          	beq	a0,a5,8020ec00 <getSyscallMessage+0x68>
    8020ebbc:	08100793          	li	a5,129
    8020ebc0:	02f51863          	bne	a0,a5,8020ebf0 <getSyscallMessage+0x58>
            break;
        case SYSCALL_PIPE2:
            printf("syscall pipe2, pc=%lx\n", pc);
            break;
        case SYSCALL_PROCESS_KILL:
            printf("syscall process kill, pc=%lx\n", pc);
    8020ebc4:	00008517          	auipc	a0,0x8
    8020ebc8:	84450513          	addi	a0,a0,-1980 # 80216408 <__func__.1+0x40>
    8020ebcc:	ffff2097          	auipc	ra,0xffff2
    8020ebd0:	284080e7          	jalr	644(ra) # 80200e50 <printf>
            break;
    8020ebd4:	01c0006f          	j	8020ebf0 <getSyscallMessage+0x58>
    switch (id)
    8020ebd8:	0dc00793          	li	a5,220
    8020ebdc:	00f51a63          	bne	a0,a5,8020ebf0 <getSyscallMessage+0x58>
            printf("syscall Clone, pc=%lx\n", pc);
    8020ebe0:	00007517          	auipc	a0,0x7
    8020ebe4:	7f850513          	addi	a0,a0,2040 # 802163d8 <__func__.1+0x10>
    8020ebe8:	ffff2097          	auipc	ra,0xffff2
    8020ebec:	268080e7          	jalr	616(ra) # 80200e50 <printf>
            printf("syscall thread kill, pc=%lx\n", pc);
            break;
        default:
            break;
    }
    8020ebf0:	00813083          	ld	ra,8(sp)
    8020ebf4:	00013403          	ld	s0,0(sp)
    8020ebf8:	01010113          	addi	sp,sp,16
    8020ebfc:	00008067          	ret
            printf("syscall pipe2, pc=%lx\n", pc);
    8020ec00:	00007517          	auipc	a0,0x7
    8020ec04:	7f050513          	addi	a0,a0,2032 # 802163f0 <__func__.1+0x28>
    8020ec08:	ffff2097          	auipc	ra,0xffff2
    8020ec0c:	248080e7          	jalr	584(ra) # 80200e50 <printf>
            break;
    8020ec10:	fe1ff06f          	j	8020ebf0 <getSyscallMessage+0x58>
            printf("syscall thread kill, pc=%lx\n", pc);
    8020ec14:	00008517          	auipc	a0,0x8
    8020ec18:	81450513          	addi	a0,a0,-2028 # 80216428 <__func__.1+0x60>
    8020ec1c:	ffff2097          	auipc	ra,0xffff2
    8020ec20:	234080e7          	jalr	564(ra) # 80200e50 <printf>
    8020ec24:	fcdff06f          	j	8020ebf0 <getSyscallMessage+0x58>

000000008020ec28 <loadElf>:
    u8 *ph_table = 0;
    u16 entry_cnt;
    u16 entry_size;
    int r;

    if (size < 4 || !is_elf_format(binary)) {
    8020ec28:	00300793          	li	a5,3
    8020ec2c:	12b7d863          	bge	a5,a1,8020ed5c <loadElf+0x134>
    int (*map)(u64 va, u32 segmentSize, u8 *bin, u32 binSize, void *userData)) {
    8020ec30:	fa010113          	addi	sp,sp,-96
    8020ec34:	04113c23          	sd	ra,88(sp)
    8020ec38:	04813823          	sd	s0,80(sp)
    8020ec3c:	04913423          	sd	s1,72(sp)
    8020ec40:	05213023          	sd	s2,64(sp)
    8020ec44:	03313c23          	sd	s3,56(sp)
    8020ec48:	03413823          	sd	s4,48(sp)
    8020ec4c:	03513423          	sd	s5,40(sp)
    8020ec50:	03613023          	sd	s6,32(sp)
    8020ec54:	01713c23          	sd	s7,24(sp)
    8020ec58:	01813823          	sd	s8,16(sp)
    8020ec5c:	01913423          	sd	s9,8(sp)
    8020ec60:	06010413          	addi	s0,sp,96
    8020ec64:	00050b13          	mv	s6,a0
    8020ec68:	00060c93          	mv	s9,a2
    8020ec6c:	00068b93          	mv	s7,a3
    8020ec70:	00070c13          	mv	s8,a4
int loadElf(u8 *binary, int size, u64 *entry, void *userData, 
    int (*map)(u64, u32, u8*, u32, void*));

inline bool is_elf_format(u8 *binary) {
    u8 *magic = ((Indent*) binary)->magic;
    if (magic[0] == ELF_MAGIC0 &&
    8020ec74:	00054703          	lbu	a4,0(a0)
    8020ec78:	07f00793          	li	a5,127
        return -NOT_ELF_FILE;
    8020ec7c:	ffa00513          	li	a0,-6
    8020ec80:	0af71463          	bne	a4,a5,8020ed28 <loadElf+0x100>
    8020ec84:	001b4703          	lbu	a4,1(s6) # ffffffff80000001 <bssEnd+0xfffffffefdc90001>
    8020ec88:	04500793          	li	a5,69
    8020ec8c:	08f71e63          	bne	a4,a5,8020ed28 <loadElf+0x100>
        magic[1] == ELF_MAGIC1 &&
    8020ec90:	002b4703          	lbu	a4,2(s6)
    8020ec94:	04c00793          	li	a5,76
    8020ec98:	08f71863          	bne	a4,a5,8020ed28 <loadElf+0x100>
    if (size < 4 || !is_elf_format(binary)) {
    8020ec9c:	003b4703          	lbu	a4,3(s6)
    8020eca0:	04600793          	li	a5,70
    8020eca4:	0cf71063          	bne	a4,a5,8020ed64 <loadElf+0x13c>
    }

    ph_table = binary + ehdr->phoff;
    8020eca8:	020b3903          	ld	s2,32(s6)
    8020ecac:	012b0933          	add	s2,s6,s2
    entry_cnt = ehdr->phnum;
    8020ecb0:	038b5783          	lhu	a5,56(s6)
    entry_size = ehdr->phentsize;
    8020ecb4:	036b5a83          	lhu	s5,54(s6)

    while (entry_cnt--) {
    8020ecb8:	fff7849b          	addiw	s1,a5,-1
    8020ecbc:	03049493          	slli	s1,s1,0x30
    8020ecc0:	0304d493          	srli	s1,s1,0x30
    8020ecc4:	04078c63          	beqz	a5,8020ed1c <loadElf+0xf4>
        phdr = (Phdr*)ph_table;
        if (phdr->type == PT_LOAD) {
    8020ecc8:	00100a13          	li	s4,1
    while (entry_cnt--) {
    8020eccc:	000109b7          	lui	s3,0x10
    8020ecd0:	fff98993          	addi	s3,s3,-1 # ffff <_start-0x801f0001>
    8020ecd4:	01c0006f          	j	8020ecf0 <loadElf+0xc8>
            r = map(phdr->vaddr, phdr->memsz, binary + phdr->offset, phdr->filesz, userData);
            if (r < 0) {
                return r;
            }
        }
        ph_table += entry_size;
    8020ecd8:	01590933          	add	s2,s2,s5
    while (entry_cnt--) {
    8020ecdc:	fff4849b          	addiw	s1,s1,-1
    8020ece0:	03049493          	slli	s1,s1,0x30
    8020ece4:	0304d493          	srli	s1,s1,0x30
    8020ece8:	0004879b          	sext.w	a5,s1
    8020ecec:	03378863          	beq	a5,s3,8020ed1c <loadElf+0xf4>
        if (phdr->type == PT_LOAD) {
    8020ecf0:	00092783          	lw	a5,0(s2)
    8020ecf4:	ff4792e3          	bne	a5,s4,8020ecd8 <loadElf+0xb0>
            r = map(phdr->vaddr, phdr->memsz, binary + phdr->offset, phdr->filesz, userData);
    8020ecf8:	00893603          	ld	a2,8(s2)
    8020ecfc:	000b8713          	mv	a4,s7
    8020ed00:	02092683          	lw	a3,32(s2)
    8020ed04:	00cb0633          	add	a2,s6,a2
    8020ed08:	02892583          	lw	a1,40(s2)
    8020ed0c:	01093503          	ld	a0,16(s2)
    8020ed10:	000c00e7          	jalr	s8
            if (r < 0) {
    8020ed14:	fc0552e3          	bgez	a0,8020ecd8 <loadElf+0xb0>
    8020ed18:	0100006f          	j	8020ed28 <loadElf+0x100>
    }
    
    *entry = ehdr->entry;
    8020ed1c:	018b3783          	ld	a5,24(s6)
    8020ed20:	00fcb023          	sd	a5,0(s9)
    return 0;
    8020ed24:	00000513          	li	a0,0
    8020ed28:	05813083          	ld	ra,88(sp)
    8020ed2c:	05013403          	ld	s0,80(sp)
    8020ed30:	04813483          	ld	s1,72(sp)
    8020ed34:	04013903          	ld	s2,64(sp)
    8020ed38:	03813983          	ld	s3,56(sp)
    8020ed3c:	03013a03          	ld	s4,48(sp)
    8020ed40:	02813a83          	ld	s5,40(sp)
    8020ed44:	02013b03          	ld	s6,32(sp)
    8020ed48:	01813b83          	ld	s7,24(sp)
    8020ed4c:	01013c03          	ld	s8,16(sp)
    8020ed50:	00813c83          	ld	s9,8(sp)
    8020ed54:	06010113          	addi	sp,sp,96
    8020ed58:	00008067          	ret
        return -NOT_ELF_FILE;
    8020ed5c:	ffa00513          	li	a0,-6
    8020ed60:	00008067          	ret
        return -NOT_ELF_FILE;
    8020ed64:	ffa00513          	li	a0,-6
    8020ed68:	fc1ff06f          	j	8020ed28 <loadElf+0x100>

000000008020ed6c <memset>:
#include "Type.h"

void* memset(void* dst, int c, uint n) {
    8020ed6c:	ff010113          	addi	sp,sp,-16
    8020ed70:	00813423          	sd	s0,8(sp)
    8020ed74:	01010413          	addi	s0,sp,16
    char* cdst = (char*)dst;
    int i;
    for (i = 0; i < n; i++) {
    8020ed78:	02060063          	beqz	a2,8020ed98 <memset+0x2c>
    8020ed7c:	00050793          	mv	a5,a0
    8020ed80:	02061613          	slli	a2,a2,0x20
    8020ed84:	02065613          	srli	a2,a2,0x20
    8020ed88:	00a60733          	add	a4,a2,a0
        cdst[i] = c;
    8020ed8c:	00b78023          	sb	a1,0(a5)
    for (i = 0; i < n; i++) {
    8020ed90:	00178793          	addi	a5,a5,1
    8020ed94:	fee79ce3          	bne	a5,a4,8020ed8c <memset+0x20>
    }
    return dst;
}
    8020ed98:	00813403          	ld	s0,8(sp)
    8020ed9c:	01010113          	addi	sp,sp,16
    8020eda0:	00008067          	ret

000000008020eda4 <memcmp>:

int memcmp(const void* v1, const void* v2, uint n) {
    8020eda4:	ff010113          	addi	sp,sp,-16
    8020eda8:	00813423          	sd	s0,8(sp)
    8020edac:	01010413          	addi	s0,sp,16
    const uchar *s1, *s2;

    s1 = v1;
    s2 = v2;
    while (n-- > 0) {
    8020edb0:	04060463          	beqz	a2,8020edf8 <memcmp+0x54>
    8020edb4:	fff6069b          	addiw	a3,a2,-1
    8020edb8:	02069693          	slli	a3,a3,0x20
    8020edbc:	0206d693          	srli	a3,a3,0x20
    8020edc0:	00168693          	addi	a3,a3,1
    8020edc4:	00d506b3          	add	a3,a0,a3
        if (*s1 != *s2)
    8020edc8:	00054783          	lbu	a5,0(a0)
    8020edcc:	0005c703          	lbu	a4,0(a1)
    8020edd0:	00e79c63          	bne	a5,a4,8020ede8 <memcmp+0x44>
            return *s1 - *s2;
        s1++, s2++;
    8020edd4:	00150513          	addi	a0,a0,1
    8020edd8:	00158593          	addi	a1,a1,1
    while (n-- > 0) {
    8020eddc:	fed516e3          	bne	a0,a3,8020edc8 <memcmp+0x24>
    }

    return 0;
    8020ede0:	00000513          	li	a0,0
    8020ede4:	0080006f          	j	8020edec <memcmp+0x48>
            return *s1 - *s2;
    8020ede8:	40e7853b          	subw	a0,a5,a4
}
    8020edec:	00813403          	ld	s0,8(sp)
    8020edf0:	01010113          	addi	sp,sp,16
    8020edf4:	00008067          	ret
    return 0;
    8020edf8:	00000513          	li	a0,0
    8020edfc:	ff1ff06f          	j	8020edec <memcmp+0x48>

000000008020ee00 <memmove>:

void* memmove(void* dst, const void* src, uint n) {
    8020ee00:	ff010113          	addi	sp,sp,-16
    8020ee04:	00813423          	sd	s0,8(sp)
    8020ee08:	01010413          	addi	s0,sp,16
    //     s += n;
    //     d += n;
    //     while (n-- > 0)
    //         *--d = *--s;
    // } else
        while (n-- > 0)
    8020ee0c:	02060863          	beqz	a2,8020ee3c <memmove+0x3c>
    8020ee10:	fff6069b          	addiw	a3,a2,-1
    8020ee14:	02069693          	slli	a3,a3,0x20
    8020ee18:	0206d693          	srli	a3,a3,0x20
    8020ee1c:	00168693          	addi	a3,a3,1
    8020ee20:	00d586b3          	add	a3,a1,a3
    d = dst;
    8020ee24:	00050793          	mv	a5,a0
            *d++ = *s++;
    8020ee28:	00158593          	addi	a1,a1,1
    8020ee2c:	00178793          	addi	a5,a5,1
    8020ee30:	fff5c703          	lbu	a4,-1(a1)
    8020ee34:	fee78fa3          	sb	a4,-1(a5)
        while (n-- > 0)
    8020ee38:	feb698e3          	bne	a3,a1,8020ee28 <memmove+0x28>

    return dst;
}
    8020ee3c:	00813403          	ld	s0,8(sp)
    8020ee40:	01010113          	addi	sp,sp,16
    8020ee44:	00008067          	ret

000000008020ee48 <memcpy>:

// memcpy exists to placate GCC.  Use memmove.
void* memcpy(void* dst, const void* src, uint n) {
    8020ee48:	ff010113          	addi	sp,sp,-16
    8020ee4c:	00113423          	sd	ra,8(sp)
    8020ee50:	00813023          	sd	s0,0(sp)
    8020ee54:	01010413          	addi	s0,sp,16
    return memmove(dst, src, n);
    8020ee58:	00000097          	auipc	ra,0x0
    8020ee5c:	fa8080e7          	jalr	-88(ra) # 8020ee00 <memmove>
}
    8020ee60:	00813083          	ld	ra,8(sp)
    8020ee64:	00013403          	ld	s0,0(sp)
    8020ee68:	01010113          	addi	sp,sp,16
    8020ee6c:	00008067          	ret

000000008020ee70 <strncmp>:

int strncmp(const char* p, const char* q, uint n) {
    8020ee70:	ff010113          	addi	sp,sp,-16
    8020ee74:	00813423          	sd	s0,8(sp)
    8020ee78:	01010413          	addi	s0,sp,16
    while (n > 0 && *p && *p == *q)
    8020ee7c:	02060663          	beqz	a2,8020eea8 <strncmp+0x38>
    8020ee80:	00054783          	lbu	a5,0(a0)
    8020ee84:	02078663          	beqz	a5,8020eeb0 <strncmp+0x40>
    8020ee88:	0005c703          	lbu	a4,0(a1)
    8020ee8c:	02f71263          	bne	a4,a5,8020eeb0 <strncmp+0x40>
        n--, p++, q++;
    8020ee90:	fff6061b          	addiw	a2,a2,-1
    8020ee94:	00150513          	addi	a0,a0,1
    8020ee98:	00158593          	addi	a1,a1,1
    while (n > 0 && *p && *p == *q)
    8020ee9c:	fe0612e3          	bnez	a2,8020ee80 <strncmp+0x10>
    if (n == 0)
        return 0;
    8020eea0:	00000513          	li	a0,0
    8020eea4:	01c0006f          	j	8020eec0 <strncmp+0x50>
    8020eea8:	00000513          	li	a0,0
    8020eeac:	0140006f          	j	8020eec0 <strncmp+0x50>
    if (n == 0)
    8020eeb0:	00060e63          	beqz	a2,8020eecc <strncmp+0x5c>
    return (uchar)*p - (uchar)*q;
    8020eeb4:	00054503          	lbu	a0,0(a0)
    8020eeb8:	0005c783          	lbu	a5,0(a1)
    8020eebc:	40f5053b          	subw	a0,a0,a5
}
    8020eec0:	00813403          	ld	s0,8(sp)
    8020eec4:	01010113          	addi	sp,sp,16
    8020eec8:	00008067          	ret
        return 0;
    8020eecc:	00000513          	li	a0,0
    8020eed0:	ff1ff06f          	j	8020eec0 <strncmp+0x50>

000000008020eed4 <strncpy>:

char* strncpy(char* s, const char* t, int n) {
    8020eed4:	ff010113          	addi	sp,sp,-16
    8020eed8:	00813423          	sd	s0,8(sp)
    8020eedc:	01010413          	addi	s0,sp,16
    char* os;

    os = s;
    while (n-- > 0 && (*s++ = *t++) != 0)
    8020eee0:	00050713          	mv	a4,a0
    8020eee4:	00060813          	mv	a6,a2
    8020eee8:	fff6061b          	addiw	a2,a2,-1
    8020eeec:	01005c63          	blez	a6,8020ef04 <strncpy+0x30>
    8020eef0:	00170713          	addi	a4,a4,1
    8020eef4:	0005c783          	lbu	a5,0(a1)
    8020eef8:	fef70fa3          	sb	a5,-1(a4)
    8020eefc:	00158593          	addi	a1,a1,1
    8020ef00:	fe0792e3          	bnez	a5,8020eee4 <strncpy+0x10>
        ;
    while (n-- > 0)
    8020ef04:	00070693          	mv	a3,a4
    8020ef08:	00c05e63          	blez	a2,8020ef24 <strncpy+0x50>
        *s++ = 0;
    8020ef0c:	00168693          	addi	a3,a3,1
    8020ef10:	fe068fa3          	sb	zero,-1(a3)
    while (n-- > 0)
    8020ef14:	40d707bb          	subw	a5,a4,a3
    8020ef18:	fff7879b          	addiw	a5,a5,-1
    8020ef1c:	010787bb          	addw	a5,a5,a6
    8020ef20:	fef046e3          	bgtz	a5,8020ef0c <strncpy+0x38>
    return os;
}
    8020ef24:	00813403          	ld	s0,8(sp)
    8020ef28:	01010113          	addi	sp,sp,16
    8020ef2c:	00008067          	ret

000000008020ef30 <safestrcpy>:

// Like strncpy but guaranteed to NUL-terminate.
char* safestrcpy(char* s, const char* t, int n) {
    8020ef30:	ff010113          	addi	sp,sp,-16
    8020ef34:	00813423          	sd	s0,8(sp)
    8020ef38:	01010413          	addi	s0,sp,16
    char* os;

    os = s;
    if (n <= 0)
    8020ef3c:	02c05a63          	blez	a2,8020ef70 <safestrcpy+0x40>
    8020ef40:	fff6069b          	addiw	a3,a2,-1
    8020ef44:	02069693          	slli	a3,a3,0x20
    8020ef48:	0206d693          	srli	a3,a3,0x20
    8020ef4c:	00d586b3          	add	a3,a1,a3
    8020ef50:	00050793          	mv	a5,a0
        return os;
    while (--n > 0 && (*s++ = *t++) != 0)
    8020ef54:	00d58c63          	beq	a1,a3,8020ef6c <safestrcpy+0x3c>
    8020ef58:	00158593          	addi	a1,a1,1
    8020ef5c:	00178793          	addi	a5,a5,1
    8020ef60:	fff5c703          	lbu	a4,-1(a1)
    8020ef64:	fee78fa3          	sb	a4,-1(a5)
    8020ef68:	fe0716e3          	bnez	a4,8020ef54 <safestrcpy+0x24>
        ;
    *s = 0;
    8020ef6c:	00078023          	sb	zero,0(a5)
    return os;
}
    8020ef70:	00813403          	ld	s0,8(sp)
    8020ef74:	01010113          	addi	sp,sp,16
    8020ef78:	00008067          	ret

000000008020ef7c <strlen>:

int strlen(const char* s) {
    8020ef7c:	ff010113          	addi	sp,sp,-16
    8020ef80:	00813423          	sd	s0,8(sp)
    8020ef84:	01010413          	addi	s0,sp,16
    int n;

    for (n = 0; s[n]; n++)
    8020ef88:	00054783          	lbu	a5,0(a0)
    8020ef8c:	02078863          	beqz	a5,8020efbc <strlen+0x40>
    8020ef90:	00150513          	addi	a0,a0,1
    8020ef94:	00050793          	mv	a5,a0
    8020ef98:	00100693          	li	a3,1
    8020ef9c:	40a686bb          	subw	a3,a3,a0
    8020efa0:	00f6853b          	addw	a0,a3,a5
    8020efa4:	00178793          	addi	a5,a5,1
    8020efa8:	fff7c703          	lbu	a4,-1(a5)
    8020efac:	fe071ae3          	bnez	a4,8020efa0 <strlen+0x24>
        ;
    return n;
}
    8020efb0:	00813403          	ld	s0,8(sp)
    8020efb4:	01010113          	addi	sp,sp,16
    8020efb8:	00008067          	ret
    for (n = 0; s[n]; n++)
    8020efbc:	00000513          	li	a0,0
    8020efc0:	ff1ff06f          	j	8020efb0 <strlen+0x34>

000000008020efc4 <strchr>:

char* strchr(const char* s, char c) {
    8020efc4:	ff010113          	addi	sp,sp,-16
    8020efc8:	00813423          	sd	s0,8(sp)
    8020efcc:	01010413          	addi	s0,sp,16
    for (; *s; s++)
    8020efd0:	00054783          	lbu	a5,0(a0)
    8020efd4:	02078263          	beqz	a5,8020eff8 <strchr+0x34>
        if (*s == c)
    8020efd8:	00f58a63          	beq	a1,a5,8020efec <strchr+0x28>
    for (; *s; s++)
    8020efdc:	00150513          	addi	a0,a0,1
    8020efe0:	00054783          	lbu	a5,0(a0)
    8020efe4:	fe079ae3          	bnez	a5,8020efd8 <strchr+0x14>
            return (char*)s;
    return 0;
    8020efe8:	00000513          	li	a0,0
}
    8020efec:	00813403          	ld	s0,8(sp)
    8020eff0:	01010113          	addi	sp,sp,16
    8020eff4:	00008067          	ret
    return 0;
    8020eff8:	00000513          	li	a0,0
    8020effc:	ff1ff06f          	j	8020efec <strchr+0x28>

000000008020f000 <snstr>:

// convert wide char string into uchar string
void snstr(char* dst, wchar const* src, int len) {
    8020f000:	ff010113          	addi	sp,sp,-16
    8020f004:	00813423          	sd	s0,8(sp)
    8020f008:	01010413          	addi	s0,sp,16
    while (len-- && *src) {
    8020f00c:	fff6071b          	addiw	a4,a2,-1
    8020f010:	02061693          	slli	a3,a2,0x20
    8020f014:	0206d693          	srli	a3,a3,0x20
    8020f018:	00d506b3          	add	a3,a0,a3
    8020f01c:	04060063          	beqz	a2,8020f05c <snstr+0x5c>
    8020f020:	0005d783          	lhu	a5,0(a1)
    8020f024:	00078e63          	beqz	a5,8020f040 <snstr+0x40>
        *dst++ = (uchar)(*src & 0xff);
    8020f028:	00150513          	addi	a0,a0,1
    8020f02c:	fef50fa3          	sb	a5,-1(a0)
        src++;
    8020f030:	00258593          	addi	a1,a1,2
    while (len-- && *src) {
    8020f034:	fff7071b          	addiw	a4,a4,-1
    8020f038:	fed514e3          	bne	a0,a3,8020f020 <snstr+0x20>
        *dst++ = (uchar)(*src & 0xff);
    8020f03c:	00068513          	mv	a0,a3
    }
    while (len-- > 0)
    8020f040:	02071793          	slli	a5,a4,0x20
    8020f044:	0207d793          	srli	a5,a5,0x20
    8020f048:	00f507b3          	add	a5,a0,a5
    8020f04c:	00e05863          	blez	a4,8020f05c <snstr+0x5c>
        *dst++ = 0;
    8020f050:	00150513          	addi	a0,a0,1
    8020f054:	fe050fa3          	sb	zero,-1(a0)
    while (len-- > 0)
    8020f058:	fea79ce3          	bne	a5,a0,8020f050 <snstr+0x50>
}
    8020f05c:	00813403          	ld	s0,8(sp)
    8020f060:	01010113          	addi	sp,sp,16
    8020f064:	00008067          	ret

000000008020f068 <processFork>:
#include <Process.h>
#include <Page.h>

extern struct Spinlock scheduleListLock;
extern struct ThreadList scheduleList[2];
int processFork() {
    8020f068:	f7010113          	addi	sp,sp,-144
    8020f06c:	08113423          	sd	ra,136(sp)
    8020f070:	08813023          	sd	s0,128(sp)
    8020f074:	06913c23          	sd	s1,120(sp)
    8020f078:	07213823          	sd	s2,112(sp)
    8020f07c:	07313423          	sd	s3,104(sp)
    8020f080:	07413023          	sd	s4,96(sp)
    8020f084:	05513c23          	sd	s5,88(sp)
    8020f088:	05613823          	sd	s6,80(sp)
    8020f08c:	05713423          	sd	s7,72(sp)
    8020f090:	05813023          	sd	s8,64(sp)
    8020f094:	03913c23          	sd	s9,56(sp)
    8020f098:	03a13823          	sd	s10,48(sp)
    8020f09c:	03b13423          	sd	s11,40(sp)
    8020f0a0:	09010413          	addi	s0,sp,144
    Thread* thread;
    Process* process, *current = myProcess();
    8020f0a4:	00001097          	auipc	ra,0x1
    8020f0a8:	944080e7          	jalr	-1724(ra) # 8020f9e8 <myProcess>
    8020f0ac:	00050d93          	mv	s11,a0
    int r = mainThreadAlloc(&thread, current->processId);
    8020f0b0:	04856583          	lwu	a1,72(a0)
    8020f0b4:	f8840513          	addi	a0,s0,-120
    8020f0b8:	00002097          	auipc	ra,0x2
    8020f0bc:	e74080e7          	jalr	-396(ra) # 80210f2c <mainThreadAlloc>
    if (r < 0) {
    8020f0c0:	2a054063          	bltz	a0,8020f360 <processFork+0x2f8>
        return r;
    }
    process = thread->process;
    8020f0c4:	f8843783          	ld	a5,-120(s0)
    8020f0c8:	4187bb03          	ld	s6,1048(a5)
    process->cwd = current->cwd;
    8020f0cc:	000027b7          	lui	a5,0x2
    8020f0d0:	00fd8733          	add	a4,s11,a5
    8020f0d4:	08873683          	ld	a3,136(a4)
    8020f0d8:	00fb07b3          	add	a5,s6,a5
    8020f0dc:	08d7b423          	sd	a3,136(a5) # 2088 <_start-0x801fdf78>
    for (ProcessSegmentMap *psm = current->segmentMapHead; psm; psm = psm->next) {
    8020f0e0:	0a873483          	ld	s1,168(a4)
    8020f0e4:	04048c63          	beqz	s1,8020f13c <processFork+0xd4>
        ProcessSegmentMap *new;
        if (segmentMapAlloc(&new) < 0) {
    8020f0e8:	f8040513          	addi	a0,s0,-128
    8020f0ec:	ffffc097          	auipc	ra,0xffffc
    8020f0f0:	b48080e7          	jalr	-1208(ra) # 8020ac34 <segmentMapAlloc>
    8020f0f4:	06054863          	bltz	a0,8020f164 <processFork+0xfc>
            panic("");
        }
        *new = *psm;
    8020f0f8:	f8043783          	ld	a5,-128(s0)
    8020f0fc:	0004b503          	ld	a0,0(s1)
    8020f100:	0084b583          	ld	a1,8(s1)
    8020f104:	0104b603          	ld	a2,16(s1)
    8020f108:	0184b683          	ld	a3,24(s1)
    8020f10c:	0204b703          	ld	a4,32(s1)
    8020f110:	00a7b023          	sd	a0,0(a5)
    8020f114:	00b7b423          	sd	a1,8(a5)
    8020f118:	00c7b823          	sd	a2,16(a5)
    8020f11c:	00d7bc23          	sd	a3,24(a5)
    8020f120:	02e7b023          	sd	a4,32(a5)
        appendSegmentMap(process, new);
    8020f124:	f8043583          	ld	a1,-128(s0)
    8020f128:	000b0513          	mv	a0,s6
    8020f12c:	ffffc097          	auipc	ra,0xffffc
    8020f130:	c30080e7          	jalr	-976(ra) # 8020ad5c <appendSegmentMap>
    for (ProcessSegmentMap *psm = current->segmentMapHead; psm; psm = psm->next) {
    8020f134:	0204b483          	ld	s1,32(s1)
    8020f138:	fa0498e3          	bnez	s1,8020f0e8 <processFork+0x80>
    }
    for (int i = 0; i < process->fileDescription.hard; i++)
    8020f13c:	000027b7          	lui	a5,0x2
    8020f140:	00fb07b3          	add	a5,s6,a5
    8020f144:	0a07b783          	ld	a5,160(a5) # 20a0 <_start-0x801fdf60>
    8020f148:	06078663          	beqz	a5,8020f1b4 <processFork+0x14c>
    8020f14c:	070d8a13          	addi	s4,s11,112
    8020f150:	070b0993          	addi	s3,s6,112
    8020f154:	00000913          	li	s2,0
    8020f158:	000024b7          	lui	s1,0x2
    8020f15c:	009b04b3          	add	s1,s6,s1
    8020f160:	03c0006f          	j	8020f19c <processFork+0x134>
            panic("");
    8020f164:	00007697          	auipc	a3,0x7
    8020f168:	a8468693          	addi	a3,a3,-1404 # 80215be8 <__func__.0+0x48>
    8020f16c:	00007617          	auipc	a2,0x7
    8020f170:	2e460613          	addi	a2,a2,740 # 80216450 <__func__.0>
    8020f174:	01400593          	li	a1,20
    8020f178:	00007517          	auipc	a0,0x7
    8020f17c:	2d050513          	addi	a0,a0,720 # 80216448 <__func__.1+0x80>
    8020f180:	ffff2097          	auipc	ra,0xffff2
    8020f184:	d68080e7          	jalr	-664(ra) # 80200ee8 <_panic_>
    for (int i = 0; i < process->fileDescription.hard; i++)
    8020f188:	00190913          	addi	s2,s2,1
    8020f18c:	008a0a13          	addi	s4,s4,8
    8020f190:	00898993          	addi	s3,s3,8
    8020f194:	0a04b783          	ld	a5,160(s1) # 20a0 <_start-0x801fdf60>
    8020f198:	00f97e63          	bgeu	s2,a5,8020f1b4 <processFork+0x14c>
        if (current->ofile[i])
    8020f19c:	000a3503          	ld	a0,0(s4)
    8020f1a0:	fe0504e3          	beqz	a0,8020f188 <processFork+0x120>
            process->ofile[i] = filedup(current->ofile[i]);
    8020f1a4:	ffff5097          	auipc	ra,0xffff5
    8020f1a8:	d50080e7          	jalr	-688(ra) # 80203ef4 <filedup>
    8020f1ac:	00a9b023          	sd	a0,0(s3)
    8020f1b0:	fd9ff06f          	j	8020f188 <processFork+0x120>
    process->priority = current->priority;
    8020f1b4:	050da783          	lw	a5,80(s11)
    8020f1b8:	04fb2823          	sw	a5,80(s6)
    process->heapBottom = current->heapBottom;
    8020f1bc:	000027b7          	lui	a5,0x2
    8020f1c0:	00fd8733          	add	a4,s11,a5
    8020f1c4:	07873703          	ld	a4,120(a4)
    8020f1c8:	00fb07b3          	add	a5,s6,a5
    8020f1cc:	06e7bc23          	sd	a4,120(a5) # 2078 <_start-0x801fdf88>
    // assert(current->threadCount == 1);
    Trapframe* trapframe = getHartTrapFrame();
    8020f1d0:	ffffb097          	auipc	ra,0xffffb
    8020f1d4:	00c080e7          	jalr	12(ra) # 8020a1dc <getHartTrapFrame>
    bcopy(trapframe, &thread->trapframe, sizeof(Trapframe));
    8020f1d8:	22000613          	li	a2,544
    8020f1dc:	f8843583          	ld	a1,-120(s0)
    8020f1e0:	ffffa097          	auipc	ra,0xffffa
    8020f1e4:	ac0080e7          	jalr	-1344(ra) # 80208ca0 <bcopy>
    thread->trapframe.a0 = 0;
    8020f1e8:	f8843483          	ld	s1,-120(s0)
    8020f1ec:	0604b823          	sd	zero,112(s1)
    thread->trapframe.kernelSp = getThreadTopSp(thread);
    8020f1f0:	00048513          	mv	a0,s1
    8020f1f4:	00001097          	auipc	ra,0x1
    8020f1f8:	398080e7          	jalr	920(ra) # 8021058c <getThreadTopSp>
    8020f1fc:	00a4b423          	sd	a0,8(s1)
    8020f200:	f6043c23          	sd	zero,-136(s0)
            for (k = 0; k < 512; k++) {
                if (!(pa2[k] & PTE_VALID)) {
                    continue;
                }
                u64 va = (i << 30) + (j << 21) + (k << 12);
                if (va == TRAMPOLINE_BASE || va == TRAMPOLINE_BASE + PAGE_SIZE) {
    8020f204:	02000ab7          	lui	s5,0x2000
    8020f208:	fffa8a93          	addi	s5,s5,-1 # 1ffffff <_start-0x7e200001>
    8020f20c:	00da9a93          	slli	s5,s5,0xd
                }
                if (pa2[k] & PTE_WRITE) {
                    pa2[k] |= PTE_COW;
                    pa2[k] &= ~PTE_WRITE;
                } 
                pageInsert(process->pgdir, va, PTE2PA(pa2[k]), PTE2PERM(pa2[k]));
    8020f210:	fff00b93          	li	s7,-1
    8020f214:	036b9b93          	slli	s7,s7,0x36
    8020f218:	3ffb8b93          	addi	s7,s7,1023
    8020f21c:	0c80006f          	j	8020f2e4 <processFork+0x27c>
    8020f220:	0006b683          	ld	a3,0(a3)
    8020f224:	00269613          	slli	a2,a3,0x2
    8020f228:	0176f6b3          	and	a3,a3,s7
    8020f22c:	fff007b7          	lui	a5,0xfff00
    8020f230:	0087d793          	srli	a5,a5,0x8
    8020f234:	00f67633          	and	a2,a2,a5
    8020f238:	00090593          	mv	a1,s2
    8020f23c:	040b3503          	ld	a0,64(s6)
    8020f240:	ffffa097          	auipc	ra,0xffffa
    8020f244:	030080e7          	jalr	48(ra) # 80209270 <pageInsert>
            for (k = 0; k < 512; k++) {
    8020f248:	00848493          	addi	s1,s1,8
    8020f24c:	000017b7          	lui	a5,0x1
    8020f250:	00f90933          	add	s2,s2,a5
    8020f254:	03348a63          	beq	s1,s3,8020f288 <processFork+0x220>
                if (!(pa2[k] & PTE_VALID)) {
    8020f258:	00048693          	mv	a3,s1
    8020f25c:	0004b783          	ld	a5,0(s1)
    8020f260:	0017f713          	andi	a4,a5,1
    8020f264:	fe0702e3          	beqz	a4,8020f248 <processFork+0x1e0>
                if (va == TRAMPOLINE_BASE || va == TRAMPOLINE_BASE + PAGE_SIZE) {
    8020f268:	01497733          	and	a4,s2,s4
    8020f26c:	fd570ee3          	beq	a4,s5,8020f248 <processFork+0x1e0>
                if (pa2[k] & PTE_WRITE) {
    8020f270:	0047f713          	andi	a4,a5,4
    8020f274:	fa0706e3          	beqz	a4,8020f220 <processFork+0x1b8>
                    pa2[k] &= ~PTE_WRITE;
    8020f278:	ffb7f793          	andi	a5,a5,-5
    8020f27c:	1007e793          	ori	a5,a5,256
    8020f280:	00f4b023          	sd	a5,0(s1)
    8020f284:	f9dff06f          	j	8020f220 <processFork+0x1b8>
        for (j = 0; j < 512; j++) {
    8020f288:	008c0c13          	addi	s8,s8,8
    8020f28c:	002007b7          	lui	a5,0x200
    8020f290:	00fc8cb3          	add	s9,s9,a5
    8020f294:	03ac0c63          	beq	s8,s10,8020f2cc <processFork+0x264>
            if (!(pa[j] & PTE_VALID)) {
    8020f298:	000c3783          	ld	a5,0(s8)
    8020f29c:	0017f713          	andi	a4,a5,1
    8020f2a0:	fe0704e3          	beqz	a4,8020f288 <processFork+0x220>
            u64 *pa2 = (u64*) PTE2PA(pa[j]);
    8020f2a4:	00279793          	slli	a5,a5,0x2
    8020f2a8:	fff00737          	lui	a4,0xfff00
    8020f2ac:	00875713          	srli	a4,a4,0x8
    8020f2b0:	00e7f4b3          	and	s1,a5,a4
            for (k = 0; k < 512; k++) {
    8020f2b4:	000019b7          	lui	s3,0x1
    8020f2b8:	013489b3          	add	s3,s1,s3
            u64 *pa2 = (u64*) PTE2PA(pa[j]);
    8020f2bc:	000c8913          	mv	s2,s9
                if (va == TRAMPOLINE_BASE || va == TRAMPOLINE_BASE + PAGE_SIZE) {
    8020f2c0:	fffffa37          	lui	s4,0xfffff
    8020f2c4:	fffa0a13          	addi	s4,s4,-1 # ffffffffffffefff <bssEnd+0xffffffff7dc8efff>
    8020f2c8:	f91ff06f          	j	8020f258 <processFork+0x1f0>
    for (i = 0; i < 512; i++) {
    8020f2cc:	f7843783          	ld	a5,-136(s0)
    8020f2d0:	00878793          	addi	a5,a5,8 # 200008 <_start-0x7ffffff8>
    8020f2d4:	00078713          	mv	a4,a5
    8020f2d8:	f6f43c23          	sd	a5,-136(s0)
    8020f2dc:	000017b7          	lui	a5,0x1
    8020f2e0:	02f70e63          	beq	a4,a5,8020f31c <processFork+0x2b4>
        if (!(current->pgdir[i] & PTE_VALID)) {
    8020f2e4:	040db783          	ld	a5,64(s11)
    8020f2e8:	f7843683          	ld	a3,-136(s0)
    8020f2ec:	00d787b3          	add	a5,a5,a3
    8020f2f0:	0007b783          	ld	a5,0(a5) # 1000 <_start-0x801ff000>
    8020f2f4:	0017f713          	andi	a4,a5,1
    8020f2f8:	fc070ae3          	beqz	a4,8020f2cc <processFork+0x264>
        u64 *pa = (u64*) PTE2PA(current->pgdir[i]);
    8020f2fc:	00279793          	slli	a5,a5,0x2
    8020f300:	fff00737          	lui	a4,0xfff00
    8020f304:	00875713          	srli	a4,a4,0x8
    8020f308:	00e7fc33          	and	s8,a5,a4
        for (j = 0; j < 512; j++) {
    8020f30c:	01b69c93          	slli	s9,a3,0x1b
    8020f310:	00001d37          	lui	s10,0x1
    8020f314:	01ac0d33          	add	s10,s8,s10
    8020f318:	f81ff06f          	j	8020f298 <processFork+0x230>
            }
        }
    }
    // acquireLock(&scheduleListLock);
    LIST_INSERT_TAIL(&scheduleList[0], thread, scheduleLink);
    8020f31c:	020d9697          	auipc	a3,0x20d9
    8020f320:	3ec6b683          	ld	a3,1004(a3) # 822e8708 <scheduleList>
    8020f324:	06068c63          	beqz	a3,8020f39c <processFork+0x334>
    8020f328:	f8843783          	ld	a5,-120(s0)
    8020f32c:	24d7b023          	sd	a3,576(a5)
    8020f330:	2406b703          	ld	a4,576(a3)
    8020f334:	00070a63          	beqz	a4,8020f348 <processFork+0x2e0>
    8020f338:	24e7b023          	sd	a4,576(a5)
    8020f33c:	00070693          	mv	a3,a4
    8020f340:	24073703          	ld	a4,576(a4) # fffffffffff00240 <bssEnd+0xffffffff7db90240>
    8020f344:	fe071ae3          	bnez	a4,8020f338 <processFork+0x2d0>
    8020f348:	24f6b023          	sd	a5,576(a3)
    8020f34c:	2407b703          	ld	a4,576(a5)
    8020f350:	24070713          	addi	a4,a4,576
    8020f354:	24e7b423          	sd	a4,584(a5)
    8020f358:	2407b023          	sd	zero,576(a5)
    // releaseLock(&scheduleListLock);
    return process->processId;
    8020f35c:	048b2503          	lw	a0,72(s6)
}
    8020f360:	08813083          	ld	ra,136(sp)
    8020f364:	08013403          	ld	s0,128(sp)
    8020f368:	07813483          	ld	s1,120(sp)
    8020f36c:	07013903          	ld	s2,112(sp)
    8020f370:	06813983          	ld	s3,104(sp)
    8020f374:	06013a03          	ld	s4,96(sp)
    8020f378:	05813a83          	ld	s5,88(sp)
    8020f37c:	05013b03          	ld	s6,80(sp)
    8020f380:	04813b83          	ld	s7,72(sp)
    8020f384:	04013c03          	ld	s8,64(sp)
    8020f388:	03813c83          	ld	s9,56(sp)
    8020f38c:	03013d03          	ld	s10,48(sp)
    8020f390:	02813d83          	ld	s11,40(sp)
    8020f394:	09010113          	addi	sp,sp,144
    8020f398:	00008067          	ret
    LIST_INSERT_TAIL(&scheduleList[0], thread, scheduleLink);
    8020f39c:	f8843783          	ld	a5,-120(s0)
    8020f3a0:	2407b023          	sd	zero,576(a5)
    8020f3a4:	020d9717          	auipc	a4,0x20d9
    8020f3a8:	36470713          	addi	a4,a4,868 # 822e8708 <scheduleList>
    8020f3ac:	00f73023          	sd	a5,0(a4)
    8020f3b0:	24e7b423          	sd	a4,584(a5)
    8020f3b4:	fa9ff06f          	j	8020f35c <processFork+0x2f4>

000000008020f3b8 <threadFork>:

int threadFork(u64 stackVa, u64 ptid, u64 tls, u64 ctid) {
    8020f3b8:	fb010113          	addi	sp,sp,-80
    8020f3bc:	04113423          	sd	ra,72(sp)
    8020f3c0:	04813023          	sd	s0,64(sp)
    8020f3c4:	02913c23          	sd	s1,56(sp)
    8020f3c8:	03213823          	sd	s2,48(sp)
    8020f3cc:	03313423          	sd	s3,40(sp)
    8020f3d0:	03413023          	sd	s4,32(sp)
    8020f3d4:	01513c23          	sd	s5,24(sp)
    8020f3d8:	01613823          	sd	s6,16(sp)
    8020f3dc:	05010413          	addi	s0,sp,80
    8020f3e0:	00050493          	mv	s1,a0
    8020f3e4:	00058b13          	mv	s6,a1
    8020f3e8:	00060993          	mv	s3,a2
    8020f3ec:	00068a93          	mv	s5,a3
    Thread* thread;
    Process* current = myProcess();
    8020f3f0:	00000097          	auipc	ra,0x0
    8020f3f4:	5f8080e7          	jalr	1528(ra) # 8020f9e8 <myProcess>
    8020f3f8:	00050913          	mv	s2,a0
    int r = threadAlloc(&thread, current, stackVa);
    8020f3fc:	00048613          	mv	a2,s1
    8020f400:	00050593          	mv	a1,a0
    8020f404:	fb840513          	addi	a0,s0,-72
    8020f408:	00002097          	auipc	ra,0x2
    8020f40c:	c34080e7          	jalr	-972(ra) # 8021103c <threadAlloc>
    if (r < 0) {
    8020f410:	08054663          	bltz	a0,8020f49c <threadFork+0xe4>
        return r;
    }
    Trapframe* trapframe = getHartTrapFrame();
    8020f414:	ffffb097          	auipc	ra,0xffffb
    8020f418:	dc8080e7          	jalr	-568(ra) # 8020a1dc <getHartTrapFrame>
    bcopy(trapframe, &thread->trapframe, sizeof(Trapframe));
    8020f41c:	22000613          	li	a2,544
    8020f420:	fb843583          	ld	a1,-72(s0)
    8020f424:	ffffa097          	auipc	ra,0xffffa
    8020f428:	87c080e7          	jalr	-1924(ra) # 80208ca0 <bcopy>
    thread->trapframe.a0 = 0;
    8020f42c:	fb843a03          	ld	s4,-72(s0)
    8020f430:	060a3823          	sd	zero,112(s4)
    thread->trapframe.tp = tls;
    8020f434:	053a3023          	sd	s3,64(s4)
    thread->trapframe.kernelSp = getThreadTopSp(thread);
    8020f438:	000a0513          	mv	a0,s4
    8020f43c:	00001097          	auipc	ra,0x1
    8020f440:	150080e7          	jalr	336(ra) # 8021058c <getThreadTopSp>
    8020f444:	00aa3423          	sd	a0,8(s4)
    thread->trapframe.sp = stackVa;
    8020f448:	fb843603          	ld	a2,-72(s0)
    8020f44c:	02963823          	sd	s1,48(a2)
    if (ptid != 0) {
    8020f450:	060b1a63          	bnez	s6,8020f4c4 <threadFork+0x10c>
        copyout(current->pgdir, ptid, (char*) &thread->id, sizeof(u32));
    }
    thread->clearChildTid = ctid;
    8020f454:	fb843703          	ld	a4,-72(s0)
    8020f458:	41573823          	sd	s5,1040(a4)
    // acquireLock(&scheduleListLock);
    LIST_INSERT_TAIL(&scheduleList[0], thread, scheduleLink);
    8020f45c:	020d9697          	auipc	a3,0x20d9
    8020f460:	2ac6b683          	ld	a3,684(a3) # 822e8708 <scheduleList>
    8020f464:	06068e63          	beqz	a3,8020f4e0 <threadFork+0x128>
    8020f468:	24d73023          	sd	a3,576(a4)
    8020f46c:	2406b783          	ld	a5,576(a3)
    8020f470:	00078a63          	beqz	a5,8020f484 <threadFork+0xcc>
    8020f474:	24f73023          	sd	a5,576(a4)
    8020f478:	00078693          	mv	a3,a5
    8020f47c:	2407b783          	ld	a5,576(a5)
    8020f480:	fe079ae3          	bnez	a5,8020f474 <threadFork+0xbc>
    8020f484:	24e6b023          	sd	a4,576(a3)
    8020f488:	24073783          	ld	a5,576(a4)
    8020f48c:	24078793          	addi	a5,a5,576
    8020f490:	24f73423          	sd	a5,584(a4)
    8020f494:	24073023          	sd	zero,576(a4)
    // releaseLock(&scheduleListLock);
    return thread->id;
    8020f498:	23872503          	lw	a0,568(a4)
}
    8020f49c:	04813083          	ld	ra,72(sp)
    8020f4a0:	04013403          	ld	s0,64(sp)
    8020f4a4:	03813483          	ld	s1,56(sp)
    8020f4a8:	03013903          	ld	s2,48(sp)
    8020f4ac:	02813983          	ld	s3,40(sp)
    8020f4b0:	02013a03          	ld	s4,32(sp)
    8020f4b4:	01813a83          	ld	s5,24(sp)
    8020f4b8:	01013b03          	ld	s6,16(sp)
    8020f4bc:	05010113          	addi	sp,sp,80
    8020f4c0:	00008067          	ret
        copyout(current->pgdir, ptid, (char*) &thread->id, sizeof(u32));
    8020f4c4:	00400693          	li	a3,4
    8020f4c8:	23860613          	addi	a2,a2,568
    8020f4cc:	000b0593          	mv	a1,s6
    8020f4d0:	04093503          	ld	a0,64(s2)
    8020f4d4:	ffffa097          	auipc	ra,0xffffa
    8020f4d8:	664080e7          	jalr	1636(ra) # 80209b38 <copyout>
    8020f4dc:	f79ff06f          	j	8020f454 <threadFork+0x9c>
    LIST_INSERT_TAIL(&scheduleList[0], thread, scheduleLink);
    8020f4e0:	24073023          	sd	zero,576(a4)
    8020f4e4:	020d9797          	auipc	a5,0x20d9
    8020f4e8:	22478793          	addi	a5,a5,548 # 822e8708 <scheduleList>
    8020f4ec:	00e7b023          	sd	a4,0(a5)
    8020f4f0:	24f73423          	sd	a5,584(a4)
    8020f4f4:	fa5ff06f          	j	8020f498 <threadFork+0xe0>

000000008020f4f8 <clone>:

int clone(u32 flags, u64 stackVa, u64 ptid, u64 tls, u64 ctid) {
    8020f4f8:	ff010113          	addi	sp,sp,-16
    8020f4fc:	00113423          	sd	ra,8(sp)
    8020f500:	00813023          	sd	s0,0(sp)
    8020f504:	01010413          	addi	s0,sp,16
    // printf("clone flags: %lx\n", flags);
    if (flags & CLONE_VM) {
    8020f508:	10057793          	andi	a5,a0,256
    8020f50c:	02078863          	beqz	a5,8020f53c <clone+0x44>
    8020f510:	00058813          	mv	a6,a1
    8020f514:	00060593          	mv	a1,a2
    8020f518:	00068613          	mv	a2,a3
        return threadFork(stackVa, ptid, tls, ctid);
    8020f51c:	00070693          	mv	a3,a4
    8020f520:	00080513          	mv	a0,a6
    8020f524:	00000097          	auipc	ra,0x0
    8020f528:	e94080e7          	jalr	-364(ra) # 8020f3b8 <threadFork>
    } else {
        return processFork();
    }
}
    8020f52c:	00813083          	ld	ra,8(sp)
    8020f530:	00013403          	ld	s0,0(sp)
    8020f534:	01010113          	addi	sp,sp,16
    8020f538:	00008067          	ret
        return processFork();
    8020f53c:	00000097          	auipc	ra,0x0
    8020f540:	b2c080e7          	jalr	-1236(ra) # 8020f068 <processFork>
    8020f544:	fe9ff06f          	j	8020f52c <clone+0x34>

000000008020f548 <codeMapper>:

    *new = p;
    return 0;
}

int codeMapper(u64 va, u32 segmentSize, u8 *binary, u32 binSize, void *userData) {
    8020f548:	f8010113          	addi	sp,sp,-128
    8020f54c:	06113c23          	sd	ra,120(sp)
    8020f550:	06813823          	sd	s0,112(sp)
    8020f554:	06913423          	sd	s1,104(sp)
    8020f558:	07213023          	sd	s2,96(sp)
    8020f55c:	05313c23          	sd	s3,88(sp)
    8020f560:	05413823          	sd	s4,80(sp)
    8020f564:	05513423          	sd	s5,72(sp)
    8020f568:	05613023          	sd	s6,64(sp)
    8020f56c:	03713c23          	sd	s7,56(sp)
    8020f570:	03813823          	sd	s8,48(sp)
    8020f574:	03913423          	sd	s9,40(sp)
    8020f578:	03a13023          	sd	s10,32(sp)
    8020f57c:	01b13c23          	sd	s11,24(sp)
    8020f580:	08010413          	addi	s0,sp,128
    8020f584:	00050b93          	mv	s7,a0
    8020f588:	00058d13          	mv	s10,a1
    8020f58c:	00060d93          	mv	s11,a2
    8020f590:	00068993          	mv	s3,a3
    8020f594:	00070c13          	mv	s8,a4
    Process *process = (Process*)userData;
    PhysicalPage *p = NULL;
    8020f598:	f8043423          	sd	zero,-120(s0)
    u64 i;
    int r = 0;
    u64 offset = va - DOWN_ALIGN(va, PAGE_SIZE);
    8020f59c:	03451793          	slli	a5,a0,0x34
    8020f5a0:	0347d913          	srli	s2,a5,0x34
    u64* j;

    if (offset > 0) {
    8020f5a4:	02079863          	bnez	a5,8020f5d4 <codeMapper+0x8c>
                PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        }
        r = MIN(binSize, PAGE_SIZE - offset);
        bcopy(binary, (void*) page2pa(p) + offset, r);
    }
    for (i = r; i < binSize; i += r) {
    8020f5a8:	02069993          	slli	s3,a3,0x20
    8020f5ac:	0209d993          	srli	s3,s3,0x20
    8020f5b0:	3c098463          	beqz	s3,8020f978 <codeMapper+0x430>
    int hartId;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    8020f5b4:	018f8b17          	auipc	s6,0x18f8
    8020f5b8:	94cb0b13          	addi	s6,s6,-1716 # 81b06f00 <pages>
    8020f5bc:	00007a97          	auipc	s5,0x7
    8020f5c0:	23ca8a93          	addi	s5,s5,572 # 802167f8 <__func__.0+0x20>
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f5c4:	00100a13          	li	s4,1
    8020f5c8:	01fa1a13          	slli	s4,s4,0x1f
        if (pageAlloc(&p) != 0) {
            return -1;
        }
        pageInsert(process->pgdir, va + i, page2pa(p), 
            PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        r = MIN(PAGE_SIZE, binSize - i);
    8020f5cc:	00001cb7          	lui	s9,0x1
    8020f5d0:	13c0006f          	j	8020f70c <codeMapper+0x1c4>
        p = pa2page(pageLookup(process->pgdir, va, &j));
    8020f5d4:	f8040613          	addi	a2,s0,-128
    8020f5d8:	00050593          	mv	a1,a0
    8020f5dc:	04073503          	ld	a0,64(a4)
    8020f5e0:	ffffa097          	auipc	ra,0xffffa
    8020f5e4:	998080e7          	jalr	-1640(ra) # 80208f78 <pageLookup>
}

inline PhysicalPage* pa2page(u64 pa) {
    if (pa == 0)
    8020f5e8:	38050e63          	beqz	a0,8020f984 <codeMapper+0x43c>
        return NULL;
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020f5ec:	800007b7          	lui	a5,0x80000
    8020f5f0:	00f507b3          	add	a5,a0,a5
    8020f5f4:	00c7d793          	srli	a5,a5,0xc
    return pages + ppn;
    8020f5f8:	02079793          	slli	a5,a5,0x20
    8020f5fc:	0207d793          	srli	a5,a5,0x20
    8020f600:	00179713          	slli	a4,a5,0x1
    8020f604:	00f707b3          	add	a5,a4,a5
    8020f608:	00379793          	slli	a5,a5,0x3
    8020f60c:	018f8717          	auipc	a4,0x18f8
    8020f610:	8f470713          	addi	a4,a4,-1804 # 81b06f00 <pages>
    8020f614:	00e787b3          	add	a5,a5,a4
    8020f618:	f8f43423          	sd	a5,-120(s0)
        r = MIN(binSize, PAGE_SIZE - offset);
    8020f61c:	02099993          	slli	s3,s3,0x20
    8020f620:	0209d993          	srli	s3,s3,0x20
    8020f624:	000014b7          	lui	s1,0x1
    8020f628:	412484b3          	sub	s1,s1,s2
    8020f62c:	0099f463          	bgeu	s3,s1,8020f634 <codeMapper+0xec>
    8020f630:	00098493          	mv	s1,s3
    8020f634:	0004849b          	sext.w	s1,s1
    return page - pages;
    8020f638:	f8843583          	ld	a1,-120(s0)
    8020f63c:	018f8797          	auipc	a5,0x18f8
    8020f640:	8c478793          	addi	a5,a5,-1852 # 81b06f00 <pages>
    8020f644:	40f585b3          	sub	a1,a1,a5
    8020f648:	4035d593          	srai	a1,a1,0x3
    8020f64c:	00007797          	auipc	a5,0x7
    8020f650:	1ac7b783          	ld	a5,428(a5) # 802167f8 <__func__.0+0x20>
    8020f654:	02f585b3          	mul	a1,a1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f658:	00c5959b          	slliw	a1,a1,0xc
    8020f65c:	02059593          	slli	a1,a1,0x20
    8020f660:	0205d593          	srli	a1,a1,0x20
    8020f664:	00100793          	li	a5,1
    8020f668:	01f79793          	slli	a5,a5,0x1f
    8020f66c:	00f585b3          	add	a1,a1,a5
        bcopy(binary, (void*) page2pa(p) + offset, r);
    8020f670:	00048613          	mv	a2,s1
    8020f674:	012585b3          	add	a1,a1,s2
    8020f678:	000d8513          	mv	a0,s11
    8020f67c:	ffff9097          	auipc	ra,0xffff9
    8020f680:	624080e7          	jalr	1572(ra) # 80208ca0 <bcopy>
    for (i = r; i < binSize; i += r) {
    8020f684:	00048913          	mv	s2,s1
    8020f688:	f334e6e3          	bltu	s1,s3,8020f5b4 <codeMapper+0x6c>
        bcopy(binary + i, (void*) page2pa(p), r);
    }

    offset = va + i - DOWN_ALIGN(va + i, PAGE_SIZE);
    8020f68c:	012b8a33          	add	s4,s7,s2
    8020f690:	034a1793          	slli	a5,s4,0x34
    8020f694:	0347d993          	srli	s3,a5,0x34
    if (offset > 0) {
    8020f698:	0c079663          	bnez	a5,8020f764 <codeMapper+0x21c>
                PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        }
        r = MIN(segmentSize - i, PAGE_SIZE - offset);
        bzero((void*) page2pa(p) + offset, r);
    }
    for (i += r; i < segmentSize; i += r) {
    8020f69c:	012484b3          	add	s1,s1,s2
    8020f6a0:	020d1d13          	slli	s10,s10,0x20
    8020f6a4:	020d5d13          	srli	s10,s10,0x20
    8020f6a8:	25a4f663          	bgeu	s1,s10,8020f8f4 <codeMapper+0x3ac>
    return page - pages;
    8020f6ac:	018f8b17          	auipc	s6,0x18f8
    8020f6b0:	854b0b13          	addi	s6,s6,-1964 # 81b06f00 <pages>
    8020f6b4:	00007a97          	auipc	s5,0x7
    8020f6b8:	144a8a93          	addi	s5,s5,324 # 802167f8 <__func__.0+0x20>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f6bc:	00100a13          	li	s4,1
    8020f6c0:	01fa1a13          	slli	s4,s4,0x1f
        if (pageAlloc(&p) != 0) {
            return -1;
        }
        pageInsert(process->pgdir, va + i, page2pa(p), 
            PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        r = MIN(PAGE_SIZE, segmentSize - i);
    8020f6c4:	00001cb7          	lui	s9,0x1
    8020f6c8:	18c0006f          	j	8020f854 <codeMapper+0x30c>
        r = MIN(PAGE_SIZE, binSize - i);
    8020f6cc:	0004849b          	sext.w	s1,s1
    return page - pages;
    8020f6d0:	f8843583          	ld	a1,-120(s0)
    8020f6d4:	416585b3          	sub	a1,a1,s6
    8020f6d8:	4035d593          	srai	a1,a1,0x3
    8020f6dc:	000ab783          	ld	a5,0(s5)
    8020f6e0:	02f585b3          	mul	a1,a1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f6e4:	00c5959b          	slliw	a1,a1,0xc
    8020f6e8:	02059593          	slli	a1,a1,0x20
    8020f6ec:	0205d593          	srli	a1,a1,0x20
        bcopy(binary + i, (void*) page2pa(p), r);
    8020f6f0:	00048613          	mv	a2,s1
    8020f6f4:	014585b3          	add	a1,a1,s4
    8020f6f8:	012d8533          	add	a0,s11,s2
    8020f6fc:	ffff9097          	auipc	ra,0xffff9
    8020f700:	5a4080e7          	jalr	1444(ra) # 80208ca0 <bcopy>
    for (i = r; i < binSize; i += r) {
    8020f704:	00990933          	add	s2,s2,s1
    8020f708:	f93972e3          	bgeu	s2,s3,8020f68c <codeMapper+0x144>
        if (pageAlloc(&p) != 0) {
    8020f70c:	f8840513          	addi	a0,s0,-120
    8020f710:	ffff9097          	auipc	ra,0xffff9
    8020f714:	7ac080e7          	jalr	1964(ra) # 80208ebc <pageAlloc>
    8020f718:	18051c63          	bnez	a0,8020f8b0 <codeMapper+0x368>
    return page - pages;
    8020f71c:	f8843603          	ld	a2,-120(s0)
    8020f720:	41660633          	sub	a2,a2,s6
    8020f724:	40365613          	srai	a2,a2,0x3
    8020f728:	000ab783          	ld	a5,0(s5)
    8020f72c:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f730:	00c6161b          	slliw	a2,a2,0xc
    8020f734:	02061613          	slli	a2,a2,0x20
    8020f738:	02065613          	srli	a2,a2,0x20
        pageInsert(process->pgdir, va + i, page2pa(p), 
    8020f73c:	01e00693          	li	a3,30
    8020f740:	01460633          	add	a2,a2,s4
    8020f744:	012b85b3          	add	a1,s7,s2
    8020f748:	040c3503          	ld	a0,64(s8)
    8020f74c:	ffffa097          	auipc	ra,0xffffa
    8020f750:	b24080e7          	jalr	-1244(ra) # 80209270 <pageInsert>
        r = MIN(PAGE_SIZE, binSize - i);
    8020f754:	412984b3          	sub	s1,s3,s2
    8020f758:	f69cfae3          	bgeu	s9,s1,8020f6cc <codeMapper+0x184>
    8020f75c:	000c8493          	mv	s1,s9
    8020f760:	f6dff06f          	j	8020f6cc <codeMapper+0x184>
        p = pa2page(pageLookup(process->pgdir, va + i, &j));
    8020f764:	f8040613          	addi	a2,s0,-128
    8020f768:	000a0593          	mv	a1,s4
    8020f76c:	040c3503          	ld	a0,64(s8)
    8020f770:	ffffa097          	auipc	ra,0xffffa
    8020f774:	808080e7          	jalr	-2040(ra) # 80208f78 <pageLookup>
    if (pa == 0)
    8020f778:	18050e63          	beqz	a0,8020f914 <codeMapper+0x3cc>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020f77c:	800007b7          	lui	a5,0x80000
    8020f780:	00f507b3          	add	a5,a0,a5
    8020f784:	00c7d793          	srli	a5,a5,0xc
    return pages + ppn;
    8020f788:	02079793          	slli	a5,a5,0x20
    8020f78c:	0207d793          	srli	a5,a5,0x20
    8020f790:	00179713          	slli	a4,a5,0x1
    8020f794:	00f707b3          	add	a5,a4,a5
    8020f798:	00379793          	slli	a5,a5,0x3
    8020f79c:	018f7717          	auipc	a4,0x18f7
    8020f7a0:	76470713          	addi	a4,a4,1892 # 81b06f00 <pages>
    8020f7a4:	00e787b3          	add	a5,a5,a4
    8020f7a8:	f8f43423          	sd	a5,-120(s0)
        r = MIN(segmentSize - i, PAGE_SIZE - offset);
    8020f7ac:	020d1493          	slli	s1,s10,0x20
    8020f7b0:	0204d493          	srli	s1,s1,0x20
    8020f7b4:	000017b7          	lui	a5,0x1
    8020f7b8:	413787b3          	sub	a5,a5,s3
    8020f7bc:	412484b3          	sub	s1,s1,s2
    8020f7c0:	0097f463          	bgeu	a5,s1,8020f7c8 <codeMapper+0x280>
    8020f7c4:	00078493          	mv	s1,a5
    8020f7c8:	0004849b          	sext.w	s1,s1
    return page - pages;
    8020f7cc:	f8843503          	ld	a0,-120(s0)
    8020f7d0:	018f7797          	auipc	a5,0x18f7
    8020f7d4:	73078793          	addi	a5,a5,1840 # 81b06f00 <pages>
    8020f7d8:	40f50533          	sub	a0,a0,a5
    8020f7dc:	40355513          	srai	a0,a0,0x3
    8020f7e0:	00007797          	auipc	a5,0x7
    8020f7e4:	0187b783          	ld	a5,24(a5) # 802167f8 <__func__.0+0x20>
    8020f7e8:	02f50533          	mul	a0,a0,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f7ec:	00c5151b          	slliw	a0,a0,0xc
    8020f7f0:	02051513          	slli	a0,a0,0x20
    8020f7f4:	02055513          	srli	a0,a0,0x20
    8020f7f8:	00100793          	li	a5,1
    8020f7fc:	01f79793          	slli	a5,a5,0x1f
    8020f800:	00f50533          	add	a0,a0,a5
        bzero((void*) page2pa(p) + offset, r);
    8020f804:	00048593          	mv	a1,s1
    8020f808:	01350533          	add	a0,a0,s3
    8020f80c:	ffff9097          	auipc	ra,0xffff9
    8020f810:	4d0080e7          	jalr	1232(ra) # 80208cdc <bzero>
    8020f814:	e89ff06f          	j	8020f69c <codeMapper+0x154>
        bzero((void*) page2pa(p), r);
    8020f818:	0009091b          	sext.w	s2,s2
    return page - pages;
    8020f81c:	f8843783          	ld	a5,-120(s0)
    8020f820:	416787b3          	sub	a5,a5,s6
    8020f824:	4037d793          	srai	a5,a5,0x3
    8020f828:	000ab703          	ld	a4,0(s5)
    8020f82c:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f830:	00c7979b          	slliw	a5,a5,0xc
    8020f834:	02079793          	slli	a5,a5,0x20
    8020f838:	0207d793          	srli	a5,a5,0x20
    8020f83c:	00090593          	mv	a1,s2
    8020f840:	01478533          	add	a0,a5,s4
    8020f844:	ffff9097          	auipc	ra,0xffff9
    8020f848:	498080e7          	jalr	1176(ra) # 80208cdc <bzero>
    for (i += r; i < segmentSize; i += r) {
    8020f84c:	012484b3          	add	s1,s1,s2
    8020f850:	07a4f263          	bgeu	s1,s10,8020f8b4 <codeMapper+0x36c>
        if (pageAlloc(&p) != 0) {
    8020f854:	f8840513          	addi	a0,s0,-120
    8020f858:	ffff9097          	auipc	ra,0xffff9
    8020f85c:	664080e7          	jalr	1636(ra) # 80208ebc <pageAlloc>
    8020f860:	00050993          	mv	s3,a0
    8020f864:	08051c63          	bnez	a0,8020f8fc <codeMapper+0x3b4>
    return page - pages;
    8020f868:	f8843603          	ld	a2,-120(s0)
    8020f86c:	41660633          	sub	a2,a2,s6
    8020f870:	40365613          	srai	a2,a2,0x3
    8020f874:	000ab783          	ld	a5,0(s5)
    8020f878:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f87c:	00c6161b          	slliw	a2,a2,0xc
    8020f880:	02061613          	slli	a2,a2,0x20
    8020f884:	02065613          	srli	a2,a2,0x20
        pageInsert(process->pgdir, va + i, page2pa(p), 
    8020f888:	01e00693          	li	a3,30
    8020f88c:	01460633          	add	a2,a2,s4
    8020f890:	009b85b3          	add	a1,s7,s1
    8020f894:	040c3503          	ld	a0,64(s8)
    8020f898:	ffffa097          	auipc	ra,0xffffa
    8020f89c:	9d8080e7          	jalr	-1576(ra) # 80209270 <pageInsert>
        r = MIN(PAGE_SIZE, segmentSize - i);
    8020f8a0:	409d0933          	sub	s2,s10,s1
    8020f8a4:	f72cfae3          	bgeu	s9,s2,8020f818 <codeMapper+0x2d0>
    8020f8a8:	000c8913          	mv	s2,s9
    8020f8ac:	f6dff06f          	j	8020f818 <codeMapper+0x2d0>
            return -1;
    8020f8b0:	fff00993          	li	s3,-1
    }
    return 0;
}
    8020f8b4:	00098513          	mv	a0,s3
    8020f8b8:	07813083          	ld	ra,120(sp)
    8020f8bc:	07013403          	ld	s0,112(sp)
    8020f8c0:	06813483          	ld	s1,104(sp)
    8020f8c4:	06013903          	ld	s2,96(sp)
    8020f8c8:	05813983          	ld	s3,88(sp)
    8020f8cc:	05013a03          	ld	s4,80(sp)
    8020f8d0:	04813a83          	ld	s5,72(sp)
    8020f8d4:	04013b03          	ld	s6,64(sp)
    8020f8d8:	03813b83          	ld	s7,56(sp)
    8020f8dc:	03013c03          	ld	s8,48(sp)
    8020f8e0:	02813c83          	ld	s9,40(sp)
    8020f8e4:	02013d03          	ld	s10,32(sp)
    8020f8e8:	01813d83          	ld	s11,24(sp)
    8020f8ec:	08010113          	addi	sp,sp,128
    8020f8f0:	00008067          	ret
    return 0;
    8020f8f4:	00000993          	li	s3,0
    8020f8f8:	fbdff06f          	j	8020f8b4 <codeMapper+0x36c>
            return -1;
    8020f8fc:	fff00993          	li	s3,-1
    8020f900:	fb5ff06f          	j	8020f8b4 <codeMapper+0x36c>
                return -1;
    8020f904:	fff00993          	li	s3,-1
    8020f908:	fadff06f          	j	8020f8b4 <codeMapper+0x36c>
                return -1;
    8020f90c:	fff00993          	li	s3,-1
    8020f910:	fa5ff06f          	j	8020f8b4 <codeMapper+0x36c>
        p = pa2page(pageLookup(process->pgdir, va + i, &j));
    8020f914:	f8043423          	sd	zero,-120(s0)
            if (pageAlloc(&p) != 0) {
    8020f918:	f8840513          	addi	a0,s0,-120
    8020f91c:	ffff9097          	auipc	ra,0xffff9
    8020f920:	5a0080e7          	jalr	1440(ra) # 80208ebc <pageAlloc>
    8020f924:	fe0510e3          	bnez	a0,8020f904 <codeMapper+0x3bc>
    return page - pages;
    8020f928:	f8843783          	ld	a5,-120(s0)
    8020f92c:	018f7717          	auipc	a4,0x18f7
    8020f930:	5d470713          	addi	a4,a4,1492 # 81b06f00 <pages>
    8020f934:	40e787b3          	sub	a5,a5,a4
    8020f938:	4037d793          	srai	a5,a5,0x3
    8020f93c:	00007717          	auipc	a4,0x7
    8020f940:	ebc73703          	ld	a4,-324(a4) # 802167f8 <__func__.0+0x20>
    8020f944:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f948:	00c7979b          	slliw	a5,a5,0xc
    8020f94c:	02079793          	slli	a5,a5,0x20
    8020f950:	0207d793          	srli	a5,a5,0x20
            pageInsert(process->pgdir, va + i, page2pa(p), 
    8020f954:	01e00693          	li	a3,30
    8020f958:	00100613          	li	a2,1
    8020f95c:	01f61613          	slli	a2,a2,0x1f
    8020f960:	00c78633          	add	a2,a5,a2
    8020f964:	000a0593          	mv	a1,s4
    8020f968:	040c3503          	ld	a0,64(s8)
    8020f96c:	ffffa097          	auipc	ra,0xffffa
    8020f970:	904080e7          	jalr	-1788(ra) # 80209270 <pageInsert>
    8020f974:	e39ff06f          	j	8020f7ac <codeMapper+0x264>
    for (i = r; i < binSize; i += r) {
    8020f978:	00098913          	mv	s2,s3
    int r = 0;
    8020f97c:	00000493          	li	s1,0
    8020f980:	d1dff06f          	j	8020f69c <codeMapper+0x154>
        p = pa2page(pageLookup(process->pgdir, va, &j));
    8020f984:	f8043423          	sd	zero,-120(s0)
            if (pageAlloc(&p) < 0) {
    8020f988:	f8840513          	addi	a0,s0,-120
    8020f98c:	ffff9097          	auipc	ra,0xffff9
    8020f990:	530080e7          	jalr	1328(ra) # 80208ebc <pageAlloc>
    8020f994:	f6054ce3          	bltz	a0,8020f90c <codeMapper+0x3c4>
    return page - pages;
    8020f998:	f8843783          	ld	a5,-120(s0)
    8020f99c:	018f7717          	auipc	a4,0x18f7
    8020f9a0:	56470713          	addi	a4,a4,1380 # 81b06f00 <pages>
    8020f9a4:	40e787b3          	sub	a5,a5,a4
    8020f9a8:	4037d793          	srai	a5,a5,0x3
    8020f9ac:	00007717          	auipc	a4,0x7
    8020f9b0:	e4c73703          	ld	a4,-436(a4) # 802167f8 <__func__.0+0x20>
    8020f9b4:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020f9b8:	00c7979b          	slliw	a5,a5,0xc
    8020f9bc:	02079793          	slli	a5,a5,0x20
    8020f9c0:	0207d793          	srli	a5,a5,0x20
            pageInsert(process->pgdir, va, page2pa(p), 
    8020f9c4:	01e00693          	li	a3,30
    8020f9c8:	00100613          	li	a2,1
    8020f9cc:	01f61613          	slli	a2,a2,0x1f
    8020f9d0:	00c78633          	add	a2,a5,a2
    8020f9d4:	000b8593          	mv	a1,s7
    8020f9d8:	040c3503          	ld	a0,64(s8)
    8020f9dc:	ffffa097          	auipc	ra,0xffffa
    8020f9e0:	894080e7          	jalr	-1900(ra) # 80209270 <pageInsert>
    8020f9e4:	c39ff06f          	j	8020f61c <codeMapper+0xd4>

000000008020f9e8 <myProcess>:
Process* myProcess() {
    8020f9e8:	ff010113          	addi	sp,sp,-16
    8020f9ec:	00113423          	sd	ra,8(sp)
    8020f9f0:	00813023          	sd	s0,0(sp)
    8020f9f4:	01010413          	addi	s0,sp,16
    if (myThread() == NULL) {
    8020f9f8:	00001097          	auipc	ra,0x1
    8020f9fc:	b48080e7          	jalr	-1208(ra) # 80210540 <myThread>
    8020fa00:	00050863          	beqz	a0,8020fa10 <myProcess+0x28>
    return myThread()->process;
    8020fa04:	00001097          	auipc	ra,0x1
    8020fa08:	b3c080e7          	jalr	-1220(ra) # 80210540 <myThread>
    8020fa0c:	41853503          	ld	a0,1048(a0)
}
    8020fa10:	00813083          	ld	ra,8(sp)
    8020fa14:	00013403          	ld	s0,0(sp)
    8020fa18:	01010113          	addi	sp,sp,16
    8020fa1c:	00008067          	ret

000000008020fa20 <getSignalHandler>:
SignalAction *getSignalHandler(Process* p) {
    8020fa20:	ff010113          	addi	sp,sp,-16
    8020fa24:	00813423          	sd	s0,8(sp)
    8020fa28:	01010413          	addi	s0,sp,16
    return (SignalAction*)(PROCESS_SIGNAL_BASE + (u64)(p - processes) * PAGE_SIZE);
    8020fa2c:	01cc3797          	auipc	a5,0x1cc3
    8020fa30:	c5c78793          	addi	a5,a5,-932 # 81ed2688 <processes>
    8020fa34:	40f50533          	sub	a0,a0,a5
    8020fa38:	40455513          	srai	a0,a0,0x4
    8020fa3c:	00007797          	auipc	a5,0x7
    8020fa40:	ddc7b783          	ld	a5,-548(a5) # 80216818 <__func__.0+0x40>
    8020fa44:	02f50533          	mul	a0,a0,a5
    8020fa48:	010407b7          	lui	a5,0x1040
    8020fa4c:	00f50533          	add	a0,a0,a5
}
    8020fa50:	00c51513          	slli	a0,a0,0xc
    8020fa54:	00813403          	ld	s0,8(sp)
    8020fa58:	01010113          	addi	sp,sp,16
    8020fa5c:	00008067          	ret

000000008020fa60 <processInit>:
void processInit() {
    8020fa60:	ff010113          	addi	sp,sp,-16
    8020fa64:	00113423          	sd	ra,8(sp)
    8020fa68:	00813023          	sd	s0,0(sp)
    8020fa6c:	01010413          	addi	s0,sp,16
    printf("Process init start...\n");
    8020fa70:	00007517          	auipc	a0,0x7
    8020fa74:	9f050513          	addi	a0,a0,-1552 # 80216460 <__func__.0+0x10>
    8020fa78:	ffff1097          	auipc	ra,0xffff1
    8020fa7c:	3d8080e7          	jalr	984(ra) # 80200e50 <printf>
    initLock(&freeProcessesLock, "freeProcess");
    8020fa80:	00007597          	auipc	a1,0x7
    8020fa84:	9f858593          	addi	a1,a1,-1544 # 80216478 <__func__.0+0x28>
    8020fa88:	01cc3517          	auipc	a0,0x1cc3
    8020fa8c:	ba050513          	addi	a0,a0,-1120 # 81ed2628 <freeProcessesLock>
    8020fa90:	ffff9097          	auipc	ra,0xffff9
    8020fa94:	d58080e7          	jalr	-680(ra) # 802087e8 <initLock>
    initLock(&processIdLock, "processId");
    8020fa98:	00007597          	auipc	a1,0x7
    8020fa9c:	9f058593          	addi	a1,a1,-1552 # 80216488 <__func__.0+0x38>
    8020faa0:	01cc3517          	auipc	a0,0x1cc3
    8020faa4:	ba050513          	addi	a0,a0,-1120 # 81ed2640 <processIdLock>
    8020faa8:	ffff9097          	auipc	ra,0xffff9
    8020faac:	d40080e7          	jalr	-704(ra) # 802087e8 <initLock>
    initLock(&waitLock, "waitProcess");
    8020fab0:	00007597          	auipc	a1,0x7
    8020fab4:	9e858593          	addi	a1,a1,-1560 # 80216498 <__func__.0+0x48>
    8020fab8:	01cc3517          	auipc	a0,0x1cc3
    8020fabc:	ba050513          	addi	a0,a0,-1120 # 81ed2658 <waitLock>
    8020fac0:	ffff9097          	auipc	ra,0xffff9
    8020fac4:	d28080e7          	jalr	-728(ra) # 802087e8 <initLock>
        LIST_INSERT_HEAD(&freeProcesses, &processes[i], link);
    8020fac8:	020d7797          	auipc	a5,0x20d7
    8020facc:	b407b023          	sd	zero,-1216(a5) # 822e6608 <processes+0x413f80>
    8020fad0:	020d5717          	auipc	a4,0x20d5
    8020fad4:	a8870713          	addi	a4,a4,-1400 # 822e4558 <processes+0x411ed0>
    8020fad8:	020d7797          	auipc	a5,0x20d7
    8020fadc:	b0078793          	addi	a5,a5,-1280 # 822e65d8 <processes+0x413f50>
    8020fae0:	01cc3517          	auipc	a0,0x1cc3
    8020fae4:	ba850513          	addi	a0,a0,-1112 # 81ed2688 <processes>
    8020fae8:	020d9597          	auipc	a1,0x20d9
    8020faec:	ba858593          	addi	a1,a1,-1112 # 822e8690 <freeProcesses>
    8020faf0:	ffffe6b7          	lui	a3,0xffffe
    8020faf4:	f5068693          	addi	a3,a3,-176 # ffffffffffffdf50 <bssEnd+0xffffffff7dc8df50>
    8020faf8:	00c0006f          	j	8020fb04 <processInit+0xa4>
    8020fafc:	00d70733          	add	a4,a4,a3
    8020fb00:	00d787b3          	add	a5,a5,a3
    8020fb04:	00078613          	mv	a2,a5
    8020fb08:	02b7bc23          	sd	a1,56(a5)
    for (i = PROCESS_TOTAL_NUMBER - 1; i >= 0; i--) {
    8020fb0c:	00a78a63          	beq	a5,a0,8020fb20 <processInit+0xc0>
        LIST_INSERT_HEAD(&freeProcesses, &processes[i], link);
    8020fb10:	00f73023          	sd	a5,0(a4)
    8020fb14:	fe0784e3          	beqz	a5,8020fafc <processInit+0x9c>
    8020fb18:	02e63c23          	sd	a4,56(a2)
    8020fb1c:	fe1ff06f          	j	8020fafc <processInit+0x9c>
    8020fb20:	020d9717          	auipc	a4,0x20d9
    8020fb24:	b7070713          	addi	a4,a4,-1168 # 822e8690 <freeProcesses>
    8020fb28:	01cc3797          	auipc	a5,0x1cc3
    8020fb2c:	b6078793          	addi	a5,a5,-1184 # 81ed2688 <processes>
    8020fb30:	00f73023          	sd	a5,0(a4)
    8020fb34:	02e7bc23          	sd	a4,56(a5)
    threadInit();
    8020fb38:	00001097          	auipc	ra,0x1
    8020fb3c:	aa0080e7          	jalr	-1376(ra) # 802105d8 <threadInit>
    w_sscratch((u64)getHartTrapFrame());
    8020fb40:	ffffa097          	auipc	ra,0xffffa
    8020fb44:	69c080e7          	jalr	1692(ra) # 8020a1dc <getHartTrapFrame>
	return x;
}

// Supervisor Scratch register, for early trap handler in trampoline.S.
static inline void w_sscratch(u64 x) {
	asm volatile("csrw sscratch, %0" : : "r" (x));
    8020fb48:	14051073          	csrw	sscratch,a0
    printf("Process init finish!\n");
    8020fb4c:	00007517          	auipc	a0,0x7
    8020fb50:	95c50513          	addi	a0,a0,-1700 # 802164a8 <__func__.0+0x58>
    8020fb54:	ffff1097          	auipc	ra,0xffff1
    8020fb58:	2fc080e7          	jalr	764(ra) # 80200e50 <printf>
}
    8020fb5c:	00813083          	ld	ra,8(sp)
    8020fb60:	00013403          	ld	s0,0(sp)
    8020fb64:	01010113          	addi	sp,sp,16
    8020fb68:	00008067          	ret

000000008020fb6c <generateProcessId>:
u32 generateProcessId(Process *p) {
    8020fb6c:	ff010113          	addi	sp,sp,-16
    8020fb70:	00813423          	sd	s0,8(sp)
    8020fb74:	01010413          	addi	s0,sp,16
    u32 processId = (++nextId << (1 + LOG_PROCESS_NUM)) | (u32)(p - processes);
    8020fb78:	020d9717          	auipc	a4,0x20d9
    8020fb7c:	b1070713          	addi	a4,a4,-1264 # 822e8688 <nextId.3>
    8020fb80:	00072783          	lw	a5,0(a4)
    8020fb84:	0017879b          	addiw	a5,a5,1
    8020fb88:	00f72023          	sw	a5,0(a4)
    8020fb8c:	01cc3717          	auipc	a4,0x1cc3
    8020fb90:	afc70713          	addi	a4,a4,-1284 # 81ed2688 <processes>
    8020fb94:	40e50533          	sub	a0,a0,a4
    8020fb98:	40455513          	srai	a0,a0,0x4
    8020fb9c:	00007717          	auipc	a4,0x7
    8020fba0:	c7c73703          	ld	a4,-900(a4) # 80216818 <__func__.0+0x40>
    8020fba4:	02e50533          	mul	a0,a0,a4
    8020fba8:	00a7979b          	slliw	a5,a5,0xa
    8020fbac:	00f56533          	or	a0,a0,a5
}
    8020fbb0:	0005051b          	sext.w	a0,a0
    8020fbb4:	00813403          	ld	s0,8(sp)
    8020fbb8:	01010113          	addi	sp,sp,16
    8020fbbc:	00008067          	ret

000000008020fbc0 <pid2Process>:
int pid2Process(u32 processId, struct Process **process, int checkPerm) {
    8020fbc0:	fd010113          	addi	sp,sp,-48
    8020fbc4:	02113423          	sd	ra,40(sp)
    8020fbc8:	02813023          	sd	s0,32(sp)
    8020fbcc:	00913c23          	sd	s1,24(sp)
    8020fbd0:	01213823          	sd	s2,16(sp)
    8020fbd4:	01313423          	sd	s3,8(sp)
    8020fbd8:	03010413          	addi	s0,sp,48
    8020fbdc:	00058913          	mv	s2,a1
    if (processId == 0) {
    8020fbe0:	04050c63          	beqz	a0,8020fc38 <pid2Process+0x78>
    p = processes + PROCESS_OFFSET(processId);
    8020fbe4:	1ff57493          	andi	s1,a0,511
    8020fbe8:	000027b7          	lui	a5,0x2
    8020fbec:	0b078793          	addi	a5,a5,176 # 20b0 <_start-0x801fdf50>
    8020fbf0:	02f484b3          	mul	s1,s1,a5
    8020fbf4:	01cc3797          	auipc	a5,0x1cc3
    8020fbf8:	a9478793          	addi	a5,a5,-1388 # 81ed2688 <processes>
    8020fbfc:	00f484b3          	add	s1,s1,a5
    if (p->state == UNUSED || p->processId != processId) {
    8020fc00:	0544a783          	lw	a5,84(s1) # 1054 <_start-0x801fefac>
    8020fc04:	06078a63          	beqz	a5,8020fc78 <pid2Process+0xb8>
    8020fc08:	0484a783          	lw	a5,72(s1)
    8020fc0c:	06a79c63          	bne	a5,a0,8020fc84 <pid2Process+0xc4>
    if (checkPerm) {
    8020fc10:	02061e63          	bnez	a2,8020fc4c <pid2Process+0x8c>
    return 0;
    8020fc14:	00000513          	li	a0,0
        *process = myProcess();
    8020fc18:	00993023          	sd	s1,0(s2)
}
    8020fc1c:	02813083          	ld	ra,40(sp)
    8020fc20:	02013403          	ld	s0,32(sp)
    8020fc24:	01813483          	ld	s1,24(sp)
    8020fc28:	01013903          	ld	s2,16(sp)
    8020fc2c:	00813983          	ld	s3,8(sp)
    8020fc30:	03010113          	addi	sp,sp,48
    8020fc34:	00008067          	ret
        *process = myProcess();
    8020fc38:	00000097          	auipc	ra,0x0
    8020fc3c:	db0080e7          	jalr	-592(ra) # 8020f9e8 <myProcess>
    8020fc40:	00050493          	mv	s1,a0
        return 0;
    8020fc44:	00000513          	li	a0,0
    8020fc48:	fd1ff06f          	j	8020fc18 <pid2Process+0x58>
        if (p != myProcess() && p->parentId != myProcess()->processId) {
    8020fc4c:	00000097          	auipc	ra,0x0
    8020fc50:	d9c080e7          	jalr	-612(ra) # 8020f9e8 <myProcess>
    8020fc54:	fca480e3          	beq	s1,a0,8020fc14 <pid2Process+0x54>
    8020fc58:	04c4a983          	lw	s3,76(s1)
    8020fc5c:	00000097          	auipc	ra,0x0
    8020fc60:	d8c080e7          	jalr	-628(ra) # 8020f9e8 <myProcess>
    8020fc64:	04852783          	lw	a5,72(a0)
    8020fc68:	fb3786e3          	beq	a5,s3,8020fc14 <pid2Process+0x54>
    8020fc6c:	00000493          	li	s1,0
            return -INVALID_PERM;
    8020fc70:	ff800513          	li	a0,-8
    8020fc74:	fa5ff06f          	j	8020fc18 <pid2Process+0x58>
    8020fc78:	00000493          	li	s1,0
        return -INVALID_PROCESS_STATUS;
    8020fc7c:	ff900513          	li	a0,-7
    8020fc80:	f99ff06f          	j	8020fc18 <pid2Process+0x58>
    8020fc84:	00000493          	li	s1,0
    8020fc88:	ff900513          	li	a0,-7
    8020fc8c:	f8dff06f          	j	8020fc18 <pid2Process+0x58>

000000008020fc90 <processFree>:
void processFree(Process *p) {
    8020fc90:	fc010113          	addi	sp,sp,-64
    8020fc94:	02113c23          	sd	ra,56(sp)
    8020fc98:	02813823          	sd	s0,48(sp)
    8020fc9c:	02913423          	sd	s1,40(sp)
    8020fca0:	03213023          	sd	s2,32(sp)
    8020fca4:	01313c23          	sd	s3,24(sp)
    8020fca8:	04010413          	addi	s0,sp,64
    8020fcac:	00050993          	mv	s3,a0
    pgdirFree(p->pgdir);
    8020fcb0:	04053503          	ld	a0,64(a0)
    8020fcb4:	ffff9097          	auipc	ra,0xffff9
    8020fcb8:	448080e7          	jalr	1096(ra) # 802090fc <pgdirFree>
    p->state = ZOMBIE; // new
    8020fcbc:	00400793          	li	a5,4
    8020fcc0:	04f9aa23          	sw	a5,84(s3) # 1054 <_start-0x801fefac>
    for (int fd = 0; fd < NOFILE; fd++) {
    8020fcc4:	07098493          	addi	s1,s3,112
    8020fcc8:	00002937          	lui	s2,0x2
    8020fccc:	07090913          	addi	s2,s2,112 # 2070 <_start-0x801fdf90>
    8020fcd0:	01298933          	add	s2,s3,s2
    8020fcd4:	00c0006f          	j	8020fce0 <processFree+0x50>
    8020fcd8:	00848493          	addi	s1,s1,8
    8020fcdc:	01248e63          	beq	s1,s2,8020fcf8 <processFree+0x68>
        if (p->ofile[fd]) {
    8020fce0:	0004b503          	ld	a0,0(s1)
    8020fce4:	fe050ae3          	beqz	a0,8020fcd8 <processFree+0x48>
            fileclose(f);
    8020fce8:	ffff4097          	auipc	ra,0xffff4
    8020fcec:	254080e7          	jalr	596(ra) # 80203f3c <fileclose>
            p->ofile[fd] = 0;
    8020fcf0:	0004b023          	sd	zero,0(s1)
    8020fcf4:	fe5ff06f          	j	8020fcd8 <processFree+0x48>
    processMapFree(p);
    8020fcf8:	00098513          	mv	a0,s3
    8020fcfc:	ffffb097          	auipc	ra,0xffffb
    8020fd00:	0ec080e7          	jalr	236(ra) # 8020ade8 <processMapFree>
    if (p->parentId > 0) {
    8020fd04:	04c9a503          	lw	a0,76(s3)
    8020fd08:	02051063          	bnez	a0,8020fd28 <processFree+0x98>
}
    8020fd0c:	03813083          	ld	ra,56(sp)
    8020fd10:	03013403          	ld	s0,48(sp)
    8020fd14:	02813483          	ld	s1,40(sp)
    8020fd18:	02013903          	ld	s2,32(sp)
    8020fd1c:	01813983          	ld	s3,24(sp)
    8020fd20:	04010113          	addi	sp,sp,64
    8020fd24:	00008067          	ret
        int r = pid2Process(p->parentId, &parentProcess, 0);
    8020fd28:	00000613          	li	a2,0
    8020fd2c:	fc840593          	addi	a1,s0,-56
    8020fd30:	00000097          	auipc	ra,0x0
    8020fd34:	e90080e7          	jalr	-368(ra) # 8020fbc0 <pid2Process>
        if (r == 0) {
    8020fd38:	fc051ae3          	bnez	a0,8020fd0c <processFree+0x7c>
            wakeup(parentProcess);
    8020fd3c:	fc843503          	ld	a0,-56(s0)
    8020fd40:	00002097          	auipc	ra,0x2
    8020fd44:	f64080e7          	jalr	-156(ra) # 80211ca4 <wakeup>
}
    8020fd48:	fc5ff06f          	j	8020fd0c <processFree+0x7c>

000000008020fd4c <processSetup>:
int processSetup(Process *p) {
    8020fd4c:	fd010113          	addi	sp,sp,-48
    8020fd50:	02113423          	sd	ra,40(sp)
    8020fd54:	02813023          	sd	s0,32(sp)
    8020fd58:	00913c23          	sd	s1,24(sp)
    8020fd5c:	01213823          	sd	s2,16(sp)
    8020fd60:	03010413          	addi	s0,sp,48
    8020fd64:	00050493          	mv	s1,a0
    r = allocPgdir(&page);
    8020fd68:	fd840513          	addi	a0,s0,-40
    8020fd6c:	ffff9097          	auipc	ra,0xffff9
    8020fd70:	75c080e7          	jalr	1884(ra) # 802094c8 <allocPgdir>
    if (r < 0) {
    8020fd74:	18054263          	bltz	a0,8020fef8 <processSetup+0x1ac>
    return page - pages;
    8020fd78:	fd843783          	ld	a5,-40(s0)
    8020fd7c:	018f7717          	auipc	a4,0x18f7
    8020fd80:	18470713          	addi	a4,a4,388 # 81b06f00 <pages>
    8020fd84:	40e787b3          	sub	a5,a5,a4
    8020fd88:	4037d793          	srai	a5,a5,0x3
    8020fd8c:	00007717          	auipc	a4,0x7
    8020fd90:	a6c73703          	ld	a4,-1428(a4) # 802167f8 <__func__.0+0x20>
    8020fd94:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020fd98:	00c7979b          	slliw	a5,a5,0xc
    8020fd9c:	02079793          	slli	a5,a5,0x20
    8020fda0:	0207d793          	srli	a5,a5,0x20
    8020fda4:	00100713          	li	a4,1
    8020fda8:	01f71713          	slli	a4,a4,0x1f
    8020fdac:	00e787b3          	add	a5,a5,a4
    p->pgdir = (u64*) page2pa(page);
    8020fdb0:	04f4b023          	sd	a5,64(s1)
    p->retValue = 0;
    8020fdb4:	00002737          	lui	a4,0x2
    8020fdb8:	00e48733          	add	a4,s1,a4
    8020fdbc:	06072823          	sw	zero,112(a4) # 2070 <_start-0x801fdf90>
    p->state = UNUSED;
    8020fdc0:	0404aa23          	sw	zero,84(s1)
    p->parentId = 0;
    8020fdc4:	0404a623          	sw	zero,76(s1)
    p->heapBottom = USER_HEAP_BOTTOM;
    8020fdc8:	03ec07b7          	lui	a5,0x3ec0
    8020fdcc:	ffd78793          	addi	a5,a5,-3 # 3ebfffd <_start-0x7c340003>
    8020fdd0:	00c79793          	slli	a5,a5,0xc
    8020fdd4:	06f73c23          	sd	a5,120(a4)
    if (rootFileSystem == NULL) {
    8020fdd8:	010a8797          	auipc	a5,0x10a8
    8020fddc:	4007b783          	ld	a5,1024(a5) # 812b81d8 <rootFileSystem>
    8020fde0:	12078e63          	beqz	a5,8020ff1c <processSetup+0x1d0>
    p->cwd = &rootFileSystem->root;
    8020fde4:	000027b7          	lui	a5,0x2
    8020fde8:	00f487b3          	add	a5,s1,a5
    8020fdec:	010a8717          	auipc	a4,0x10a8
    8020fdf0:	3ec73703          	ld	a4,1004(a4) # 812b81d8 <rootFileSystem>
    8020fdf4:	07070713          	addi	a4,a4,112
    8020fdf8:	08e7b423          	sd	a4,136(a5) # 2088 <_start-0x801fdf78>
    p->fileDescription.hard = p->fileDescription.soft = NOFILE;
    8020fdfc:	40000713          	li	a4,1024
    8020fe00:	08e7bc23          	sd	a4,152(a5)
    8020fe04:	0ae7b023          	sd	a4,160(a5)
    pageInsert(p->pgdir, TRAMPOLINE_BASE, (u64)trampoline, 
    8020fe08:	00e00693          	li	a3,14
    8020fe0c:	00002617          	auipc	a2,0x2
    8020fe10:	1f460613          	addi	a2,a2,500 # 80212000 <_trampoline>
    8020fe14:	020005b7          	lui	a1,0x2000
    8020fe18:	fff58593          	addi	a1,a1,-1 # 1ffffff <_start-0x7e200001>
    8020fe1c:	00d59593          	slli	a1,a1,0xd
    8020fe20:	0404b503          	ld	a0,64(s1)
    8020fe24:	ffff9097          	auipc	ra,0xffff9
    8020fe28:	44c080e7          	jalr	1100(ra) # 80209270 <pageInsert>
    pageInsert(p->pgdir, TRAMPOLINE_BASE + PAGE_SIZE, ((u64)trampoline) + PAGE_SIZE, 
    8020fe2c:	00e00693          	li	a3,14
    8020fe30:	00003617          	auipc	a2,0x3
    8020fe34:	1d060613          	addi	a2,a2,464 # 80213000 <trapframe>
    8020fe38:	04000937          	lui	s2,0x4000
    8020fe3c:	fff90593          	addi	a1,s2,-1 # 3ffffff <_start-0x7c200001>
    8020fe40:	00c59593          	slli	a1,a1,0xc
    8020fe44:	0404b503          	ld	a0,64(s1)
    8020fe48:	ffff9097          	auipc	ra,0xffff9
    8020fe4c:	428080e7          	jalr	1064(ra) # 80209270 <pageInsert>
    pageInsert(p->pgdir, SIGNAL_TRAMPOLINE_BASE, (u64)signalTrampoline,
    8020fe50:	01e00693          	li	a3,30
    8020fe54:	00004617          	auipc	a2,0x4
    8020fe58:	1ac60613          	addi	a2,a2,428 # 80214000 <_signalTrampoline>
    8020fe5c:	ffd90593          	addi	a1,s2,-3
    8020fe60:	00c59593          	slli	a1,a1,0xc
    8020fe64:	0404b503          	ld	a0,64(s1)
    8020fe68:	ffff9097          	auipc	ra,0xffff9
    8020fe6c:	408080e7          	jalr	1032(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    8020fe70:	fd840513          	addi	a0,s0,-40
    8020fe74:	ffff9097          	auipc	ra,0xffff9
    8020fe78:	048080e7          	jalr	72(ra) # 80208ebc <pageAlloc>
    8020fe7c:	0a054a63          	bltz	a0,8020ff30 <processSetup+0x1e4>
    pageInsert(kernelPageDirectory, (u64)getSignalHandler(p), page2pa(page), PTE_READ | PTE_WRITE);
    8020fe80:	00048513          	mv	a0,s1
    8020fe84:	00000097          	auipc	ra,0x0
    8020fe88:	b9c080e7          	jalr	-1124(ra) # 8020fa20 <getSignalHandler>
    8020fe8c:	00050593          	mv	a1,a0
    return page - pages;
    8020fe90:	fd843783          	ld	a5,-40(s0)
    8020fe94:	018f7717          	auipc	a4,0x18f7
    8020fe98:	06c70713          	addi	a4,a4,108 # 81b06f00 <pages>
    8020fe9c:	40e787b3          	sub	a5,a5,a4
    8020fea0:	4037d793          	srai	a5,a5,0x3
    8020fea4:	00007717          	auipc	a4,0x7
    8020fea8:	95473703          	ld	a4,-1708(a4) # 802167f8 <__func__.0+0x20>
    8020feac:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020feb0:	00c7979b          	slliw	a5,a5,0xc
    8020feb4:	02079793          	slli	a5,a5,0x20
    8020feb8:	0207d793          	srli	a5,a5,0x20
    8020febc:	00600693          	li	a3,6
    8020fec0:	00100613          	li	a2,1
    8020fec4:	01f61613          	slli	a2,a2,0x1f
    8020fec8:	00c78633          	add	a2,a5,a2
    8020fecc:	0215f517          	auipc	a0,0x215f
    8020fed0:	13450513          	addi	a0,a0,308 # 8236f000 <_pgdir>
    8020fed4:	ffff9097          	auipc	ra,0xffff9
    8020fed8:	39c080e7          	jalr	924(ra) # 80209270 <pageInsert>
}
    8020fedc:	00000513          	li	a0,0
    8020fee0:	02813083          	ld	ra,40(sp)
    8020fee4:	02013403          	ld	s0,32(sp)
    8020fee8:	01813483          	ld	s1,24(sp)
    8020feec:	01013903          	ld	s2,16(sp)
    8020fef0:	03010113          	addi	sp,sp,48
    8020fef4:	00008067          	ret
        panic("setup page alloc error\n");
    8020fef8:	00006697          	auipc	a3,0x6
    8020fefc:	df868693          	addi	a3,a3,-520 # 80215cf0 <__func__.0+0x70>
    8020ff00:	00006617          	auipc	a2,0x6
    8020ff04:	5e860613          	addi	a2,a2,1512 # 802164e8 <__func__.2>
    8020ff08:	08000593          	li	a1,128
    8020ff0c:	00006517          	auipc	a0,0x6
    8020ff10:	5b450513          	addi	a0,a0,1460 # 802164c0 <__func__.0+0x70>
    8020ff14:	ffff1097          	auipc	ra,0xffff1
    8020ff18:	fd4080e7          	jalr	-44(ra) # 80200ee8 <_panic_>
        fsAlloc(&rootFileSystem);
    8020ff1c:	010a8517          	auipc	a0,0x10a8
    8020ff20:	2bc50513          	addi	a0,a0,700 # 812b81d8 <rootFileSystem>
    8020ff24:	ffff4097          	auipc	ra,0xffff4
    8020ff28:	780080e7          	jalr	1920(ra) # 802046a4 <fsAlloc>
    8020ff2c:	eb9ff06f          	j	8020fde4 <processSetup+0x98>
        panic("");
    8020ff30:	00006697          	auipc	a3,0x6
    8020ff34:	cb868693          	addi	a3,a3,-840 # 80215be8 <__func__.0+0x48>
    8020ff38:	00006617          	auipc	a2,0x6
    8020ff3c:	5b060613          	addi	a2,a2,1456 # 802164e8 <__func__.2>
    8020ff40:	09a00593          	li	a1,154
    8020ff44:	00006517          	auipc	a0,0x6
    8020ff48:	57c50513          	addi	a0,a0,1404 # 802164c0 <__func__.0+0x70>
    8020ff4c:	ffff1097          	auipc	ra,0xffff1
    8020ff50:	f9c080e7          	jalr	-100(ra) # 80200ee8 <_panic_>

000000008020ff54 <processAlloc>:
int processAlloc(Process **new, u64 parentId) {
    8020ff54:	fd010113          	addi	sp,sp,-48
    8020ff58:	02113423          	sd	ra,40(sp)
    8020ff5c:	02813023          	sd	s0,32(sp)
    8020ff60:	00913c23          	sd	s1,24(sp)
    8020ff64:	01213823          	sd	s2,16(sp)
    8020ff68:	01313423          	sd	s3,8(sp)
    8020ff6c:	03010413          	addi	s0,sp,48
    if (LIST_EMPTY(&freeProcesses)) {
    8020ff70:	020d8497          	auipc	s1,0x20d8
    8020ff74:	7204b483          	ld	s1,1824(s1) # 822e8690 <freeProcesses>
    8020ff78:	06048c63          	beqz	s1,8020fff0 <processAlloc+0x9c>
    8020ff7c:	00050993          	mv	s3,a0
    8020ff80:	00058913          	mv	s2,a1
    LIST_REMOVE(p, link);
    8020ff84:	0304b783          	ld	a5,48(s1)
    8020ff88:	00078663          	beqz	a5,8020ff94 <processAlloc+0x40>
    8020ff8c:	0384b703          	ld	a4,56(s1)
    8020ff90:	02e7bc23          	sd	a4,56(a5)
    8020ff94:	0384b783          	ld	a5,56(s1)
    8020ff98:	0304b703          	ld	a4,48(s1)
    8020ff9c:	00e7b023          	sd	a4,0(a5)
    if ((r = processSetup(p)) < 0) {
    8020ffa0:	00048513          	mv	a0,s1
    8020ffa4:	00000097          	auipc	ra,0x0
    8020ffa8:	da8080e7          	jalr	-600(ra) # 8020fd4c <processSetup>
    8020ffac:	02054463          	bltz	a0,8020ffd4 <processAlloc+0x80>
    p->processId = generateProcessId(p);
    8020ffb0:	00048513          	mv	a0,s1
    8020ffb4:	00000097          	auipc	ra,0x0
    8020ffb8:	bb8080e7          	jalr	-1096(ra) # 8020fb6c <generateProcessId>
    8020ffbc:	04a4a423          	sw	a0,72(s1)
    p->state = RUNNABLE;
    8020ffc0:	00200793          	li	a5,2
    8020ffc4:	04f4aa23          	sw	a5,84(s1)
    p->parentId = parentId;
    8020ffc8:	0524a623          	sw	s2,76(s1)
    *new = p;
    8020ffcc:	0099b023          	sd	s1,0(s3)
    return 0;
    8020ffd0:	00000513          	li	a0,0
}
    8020ffd4:	02813083          	ld	ra,40(sp)
    8020ffd8:	02013403          	ld	s0,32(sp)
    8020ffdc:	01813483          	ld	s1,24(sp)
    8020ffe0:	01013903          	ld	s2,16(sp)
    8020ffe4:	00813983          	ld	s3,8(sp)
    8020ffe8:	03010113          	addi	sp,sp,48
    8020ffec:	00008067          	ret
        panic("");
    8020fff0:	00006697          	auipc	a3,0x6
    8020fff4:	bf868693          	addi	a3,a3,-1032 # 80215be8 <__func__.0+0x48>
    8020fff8:	00006617          	auipc	a2,0x6
    8020fffc:	50060613          	addi	a2,a2,1280 # 802164f8 <__func__.1>
    80210000:	0a700593          	li	a1,167
    80210004:	00006517          	auipc	a0,0x6
    80210008:	4bc50513          	addi	a0,a0,1212 # 802164c0 <__func__.0+0x70>
    8021000c:	ffff1097          	auipc	ra,0xffff1
    80210010:	edc080e7          	jalr	-292(ra) # 80200ee8 <_panic_>

0000000080210014 <processCreatePriority>:

extern struct Spinlock scheduleListLock;
extern struct ThreadList scheduleList[2];
void processCreatePriority(u8 *binary, u32 size, u32 priority) {
    80210014:	fc010113          	addi	sp,sp,-64
    80210018:	02113c23          	sd	ra,56(sp)
    8021001c:	02813823          	sd	s0,48(sp)
    80210020:	02913423          	sd	s1,40(sp)
    80210024:	03213023          	sd	s2,32(sp)
    80210028:	01313c23          	sd	s3,24(sp)
    8021002c:	04010413          	addi	s0,sp,64
    80210030:	00050493          	mv	s1,a0
    80210034:	00058913          	mv	s2,a1
    80210038:	00060993          	mv	s3,a2
    Thread* th;
    int r = mainThreadAlloc(&th, 0);
    8021003c:	00000593          	li	a1,0
    80210040:	fc840513          	addi	a0,s0,-56
    80210044:	00001097          	auipc	ra,0x1
    80210048:	ee8080e7          	jalr	-280(ra) # 80210f2c <mainThreadAlloc>
    if (r < 0) {
    8021004c:	06054c63          	bltz	a0,802100c4 <processCreatePriority+0xb0>
        return;
    }
    Process* p = th->process;
    80210050:	fc843783          	ld	a5,-56(s0)
    80210054:	4187b683          	ld	a3,1048(a5)
    p->priority = priority;
    80210058:	0536a823          	sw	s3,80(a3)
    u64 entryPoint;
    if (loadElf(binary, size, &entryPoint, p, codeMapper) < 0) {
    8021005c:	fffff717          	auipc	a4,0xfffff
    80210060:	4ec70713          	addi	a4,a4,1260 # 8020f548 <codeMapper>
    80210064:	fc040613          	addi	a2,s0,-64
    80210068:	00090593          	mv	a1,s2
    8021006c:	00048513          	mv	a0,s1
    80210070:	fffff097          	auipc	ra,0xfffff
    80210074:	bb8080e7          	jalr	-1096(ra) # 8020ec28 <loadElf>
    80210078:	06054463          	bltz	a0,802100e0 <processCreatePriority+0xcc>
        panic("process create error\n");
    }
    th->trapframe.epc = entryPoint;
    8021007c:	fc843703          	ld	a4,-56(s0)
    80210080:	fc043783          	ld	a5,-64(s0)
    80210084:	00f73c23          	sd	a5,24(a4)

    // acquireLock(&scheduleListLock);
    LIST_INSERT_TAIL(&scheduleList[0], th, scheduleLink);
    80210088:	020d8697          	auipc	a3,0x20d8
    8021008c:	6806b683          	ld	a3,1664(a3) # 822e8708 <scheduleList>
    80210090:	06068a63          	beqz	a3,80210104 <processCreatePriority+0xf0>
    80210094:	24d73023          	sd	a3,576(a4)
    80210098:	2406b783          	ld	a5,576(a3)
    8021009c:	00078a63          	beqz	a5,802100b0 <processCreatePriority+0x9c>
    802100a0:	24f73023          	sd	a5,576(a4)
    802100a4:	00078693          	mv	a3,a5
    802100a8:	2407b783          	ld	a5,576(a5)
    802100ac:	fe079ae3          	bnez	a5,802100a0 <processCreatePriority+0x8c>
    802100b0:	24e6b023          	sd	a4,576(a3)
    802100b4:	24073783          	ld	a5,576(a4)
    802100b8:	24078793          	addi	a5,a5,576
    802100bc:	24f73423          	sd	a5,584(a4)
    802100c0:	24073023          	sd	zero,576(a4)
    // releaseLock(&scheduleListLock);
}
    802100c4:	03813083          	ld	ra,56(sp)
    802100c8:	03013403          	ld	s0,48(sp)
    802100cc:	02813483          	ld	s1,40(sp)
    802100d0:	02013903          	ld	s2,32(sp)
    802100d4:	01813983          	ld	s3,24(sp)
    802100d8:	04010113          	addi	sp,sp,64
    802100dc:	00008067          	ret
        panic("process create error\n");
    802100e0:	00006697          	auipc	a3,0x6
    802100e4:	3f068693          	addi	a3,a3,1008 # 802164d0 <__func__.0+0x80>
    802100e8:	00006617          	auipc	a2,0x6
    802100ec:	42060613          	addi	a2,a2,1056 # 80216508 <__func__.0>
    802100f0:	0fe00593          	li	a1,254
    802100f4:	00006517          	auipc	a0,0x6
    802100f8:	3cc50513          	addi	a0,a0,972 # 802164c0 <__func__.0+0x70>
    802100fc:	ffff1097          	auipc	ra,0xffff1
    80210100:	dec080e7          	jalr	-532(ra) # 80200ee8 <_panic_>
    LIST_INSERT_TAIL(&scheduleList[0], th, scheduleLink);
    80210104:	24073023          	sd	zero,576(a4)
    80210108:	020d8797          	auipc	a5,0x20d8
    8021010c:	60078793          	addi	a5,a5,1536 # 822e8708 <scheduleList>
    80210110:	00e7b023          	sd	a4,0(a5)
    80210114:	24f73423          	sd	a5,584(a4)
    80210118:	fadff06f          	j	802100c4 <processCreatePriority+0xb0>

000000008021011c <wait>:
        pp->cpuTime.deadChildrenKernel += p->cpuTime.kernel;
        pp->cpuTime.deadChildrenUser += p->cpuTime.user;
    }
}

int wait(int targetProcessId, u64 addr, int flags) {
    8021011c:	f9010113          	addi	sp,sp,-112
    80210120:	06113423          	sd	ra,104(sp)
    80210124:	06813023          	sd	s0,96(sp)
    80210128:	04913c23          	sd	s1,88(sp)
    8021012c:	05213823          	sd	s2,80(sp)
    80210130:	05313423          	sd	s3,72(sp)
    80210134:	05413023          	sd	s4,64(sp)
    80210138:	03513c23          	sd	s5,56(sp)
    8021013c:	03613823          	sd	s6,48(sp)
    80210140:	03713423          	sd	s7,40(sp)
    80210144:	03813023          	sd	s8,32(sp)
    80210148:	01913c23          	sd	s9,24(sp)
    8021014c:	07010413          	addi	s0,sp,112
    80210150:	00050a13          	mv	s4,a0
    80210154:	00058c13          	mv	s8,a1
    80210158:	00060b93          	mv	s7,a2
    Process* p = myProcess();
    8021015c:	00000097          	auipc	ra,0x0
    80210160:	88c080e7          	jalr	-1908(ra) # 8020f9e8 <myProcess>
    80210164:	00050993          	mv	s3,a0

    // acquireLock(&waitLock);

    while (true) {
        haveChildProcess = 0;
        for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    80210168:	00000c93          	li	s9,0
            Process* np = &processes[i];
            // acquireLock(&np->lock);
            if (np->state != UNUSED && np->parentId == p->processId) {
                haveChildProcess = 1;
                if ((targetProcessId == -1 || np->processId == targetProcessId) && np->state == ZOMBIE) {
    8021016c:	fff00a93          	li	s5,-1
    80210170:	000a0b1b          	sext.w	s6,s4
        for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    80210174:	00002937          	lui	s2,0x2
    80210178:	0b090913          	addi	s2,s2,176 # 20b0 <_start-0x801fdf50>
    8021017c:	01cc2797          	auipc	a5,0x1cc2
    80210180:	55478793          	addi	a5,a5,1364 # 81ed26d0 <processes+0x48>
    80210184:	000c8493          	mv	s1,s9
        haveChildProcess = 0;
    80210188:	000c8813          	mv	a6,s9
                if ((targetProcessId == -1 || np->processId == targetProcessId) && np->state == ZOMBIE) {
    8021018c:	00400313          	li	t1,4
                haveChildProcess = 1;
    80210190:	00100893          	li	a7,1
        for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    80210194:	20000613          	li	a2,512
    80210198:	0180006f          	j	802101b0 <wait+0x94>
                if ((targetProcessId == -1 || np->processId == targetProcessId) && np->state == ZOMBIE) {
    8021019c:	02670e63          	beq	a4,t1,802101d8 <wait+0xbc>
                haveChildProcess = 1;
    802101a0:	00088813          	mv	a6,a7
        for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    802101a4:	0014849b          	addiw	s1,s1,1
    802101a8:	012787b3          	add	a5,a5,s2
    802101ac:	14c48a63          	beq	s1,a2,80210300 <wait+0x1e4>
            if (np->state != UNUSED && np->parentId == p->processId) {
    802101b0:	00c7a703          	lw	a4,12(a5)
    802101b4:	fe0708e3          	beqz	a4,802101a4 <wait+0x88>
    802101b8:	0047a503          	lw	a0,4(a5)
    802101bc:	0489a583          	lw	a1,72(s3)
    802101c0:	feb512e3          	bne	a0,a1,802101a4 <wait+0x88>
                if ((targetProcessId == -1 || np->processId == targetProcessId) && np->state == ZOMBIE) {
    802101c4:	fd5a0ce3          	beq	s4,s5,8021019c <wait+0x80>
    802101c8:	0007a683          	lw	a3,0(a5)
                haveChildProcess = 1;
    802101cc:	00088813          	mv	a6,a7
                if ((targetProcessId == -1 || np->processId == targetProcessId) && np->state == ZOMBIE) {
    802101d0:	fd669ae3          	bne	a3,s6,802101a4 <wait+0x88>
    802101d4:	fc9ff06f          	j	8021019c <wait+0x80>
                    pid = np->processId;
    802101d8:	000027b7          	lui	a5,0x2
    802101dc:	0b078793          	addi	a5,a5,176 # 20b0 <_start-0x801fdf50>
    802101e0:	02f487b3          	mul	a5,s1,a5
    802101e4:	01cc2717          	auipc	a4,0x1cc2
    802101e8:	4a470713          	addi	a4,a4,1188 # 81ed2688 <processes>
    802101ec:	00f707b3          	add	a5,a4,a5
    802101f0:	0487a903          	lw	s2,72(a5)
                    if (addr != 0 && copyout(p->pgdir, addr, (char *)&np->retValue, sizeof(np->retValue)) < 0) {
    802101f4:	020c0e63          	beqz	s8,80210230 <wait+0x114>
    802101f8:	00002737          	lui	a4,0x2
    802101fc:	0b070793          	addi	a5,a4,176 # 20b0 <_start-0x801fdf50>
    80210200:	02f487b3          	mul	a5,s1,a5
    80210204:	07070713          	addi	a4,a4,112
    80210208:	00e787b3          	add	a5,a5,a4
    8021020c:	00400693          	li	a3,4
    80210210:	01cc2617          	auipc	a2,0x1cc2
    80210214:	47860613          	addi	a2,a2,1144 # 81ed2688 <processes>
    80210218:	00f60633          	add	a2,a2,a5
    8021021c:	000c0593          	mv	a1,s8
    80210220:	0409b503          	ld	a0,64(s3)
    80210224:	ffffa097          	auipc	ra,0xffffa
    80210228:	914080e7          	jalr	-1772(ra) # 80209b38 <copyout>
    8021022c:	12054a63          	bltz	a0,80210360 <wait+0x244>
    80210230:	00002a37          	lui	s4,0x2
    80210234:	0b0a0a13          	addi	s4,s4,176 # 20b0 <_start-0x801fdf50>
    80210238:	03448a33          	mul	s4,s1,s4
            Process* np = &processes[i];
    8021023c:	01cc2a97          	auipc	s5,0x1cc2
    80210240:	44ca8a93          	addi	s5,s5,1100 # 81ed2688 <processes>
    80210244:	015a0ab3          	add	s5,s4,s5
    Process *pp = p;
    80210248:	f9543c23          	sd	s5,-104(s0)
    while (pp->parentId > 0 && pid2Process(pp->parentId, &pp, false) >= 0) {
    8021024c:	04caa503          	lw	a0,76(s5)
    80210250:	04050463          	beqz	a0,80210298 <wait+0x17c>
        pp->cpuTime.deadChildrenKernel += p->cpuTime.kernel;
    80210254:	000a8993          	mv	s3,s5
    while (pp->parentId > 0 && pid2Process(pp->parentId, &pp, false) >= 0) {
    80210258:	00000613          	li	a2,0
    8021025c:	f9840593          	addi	a1,s0,-104
    80210260:	00000097          	auipc	ra,0x0
    80210264:	960080e7          	jalr	-1696(ra) # 8020fbc0 <pid2Process>
    80210268:	02054863          	bltz	a0,80210298 <wait+0x17c>
        pp->cpuTime.deadChildrenKernel += p->cpuTime.kernel;
    8021026c:	f9843783          	ld	a5,-104(s0)
    80210270:	0287b703          	ld	a4,40(a5)
    80210274:	0189b683          	ld	a3,24(s3)
    80210278:	00d70733          	add	a4,a4,a3
    8021027c:	02e7b423          	sd	a4,40(a5)
        pp->cpuTime.deadChildrenUser += p->cpuTime.user;
    80210280:	0207b703          	ld	a4,32(a5)
    80210284:	0109b683          	ld	a3,16(s3)
    80210288:	00d70733          	add	a4,a4,a3
    8021028c:	02e7b023          	sd	a4,32(a5)
    while (pp->parentId > 0 && pid2Process(pp->parentId, &pp, false) >= 0) {
    80210290:	04c7a503          	lw	a0,76(a5)
    80210294:	fc0512e3          	bnez	a0,80210258 <wait+0x13c>
                        // releaseLock(&waitLock);
                        return -1;
                    }
                    // acquireLock(&freeProcessesLock);
                    updateAncestorsCpuTime(np);
                    np->state = UNUSED;
    80210298:	000027b7          	lui	a5,0x2
    8021029c:	0b078793          	addi	a5,a5,176 # 20b0 <_start-0x801fdf50>
    802102a0:	02f487b3          	mul	a5,s1,a5
    802102a4:	01cc2717          	auipc	a4,0x1cc2
    802102a8:	3e470713          	addi	a4,a4,996 # 81ed2688 <processes>
    802102ac:	00f707b3          	add	a5,a4,a5
    802102b0:	0407aa23          	sw	zero,84(a5)
                    LIST_INSERT_HEAD(&freeProcesses, np, link); 
    802102b4:	020d8717          	auipc	a4,0x20d8
    802102b8:	3dc73703          	ld	a4,988(a4) # 822e8690 <freeProcesses>
    802102bc:	02e7b823          	sd	a4,48(a5)
    802102c0:	00070a63          	beqz	a4,802102d4 <wait+0x1b8>
    802102c4:	01cc2797          	auipc	a5,0x1cc2
    802102c8:	3f478793          	addi	a5,a5,1012 # 81ed26b8 <processes+0x30>
    802102cc:	00fa0a33          	add	s4,s4,a5
    802102d0:	03473c23          	sd	s4,56(a4)
    802102d4:	020d8717          	auipc	a4,0x20d8
    802102d8:	3bc70713          	addi	a4,a4,956 # 822e8690 <freeProcesses>
    802102dc:	01573023          	sd	s5,0(a4)
    802102e0:	000027b7          	lui	a5,0x2
    802102e4:	0b078793          	addi	a5,a5,176 # 20b0 <_start-0x801fdf50>
    802102e8:	02f484b3          	mul	s1,s1,a5
    802102ec:	01cc2797          	auipc	a5,0x1cc2
    802102f0:	39c78793          	addi	a5,a5,924 # 81ed2688 <processes>
    802102f4:	009787b3          	add	a5,a5,s1
    802102f8:	02e7bc23          	sd	a4,56(a5)
                    // printf("[Process Free] Free an process %d\n", (u32)(np - processes));
                    // releaseLock(&freeProcessesLock);
                    // releaseLock(&np->lock);
                    // releaseLock(&waitLock);
                    return pid;
    802102fc:	0140006f          	j	80210310 <wait+0x1f4>
                }
            }
            // releaseLock(&np->lock);
        }

        if (!haveChildProcess) {
    80210300:	06080463          	beqz	a6,80210368 <wait+0x24c>
            // releaseLock(&waitLock);
            return -1;
        }

        if (flags == WNOHANG) {
    80210304:	00100793          	li	a5,1
    80210308:	04fb9063          	bne	s7,a5,80210348 <wait+0x22c>
            // releaseLock(&waitLock);
            return 0;    
    8021030c:	00000913          	li	s2,0
        }
        // printf("[WAIT]porcess id %x wait for %x\n", p->id, p);
        sleep(p, &waitLock);
    }
}
    80210310:	00090513          	mv	a0,s2
    80210314:	06813083          	ld	ra,104(sp)
    80210318:	06013403          	ld	s0,96(sp)
    8021031c:	05813483          	ld	s1,88(sp)
    80210320:	05013903          	ld	s2,80(sp)
    80210324:	04813983          	ld	s3,72(sp)
    80210328:	04013a03          	ld	s4,64(sp)
    8021032c:	03813a83          	ld	s5,56(sp)
    80210330:	03013b03          	ld	s6,48(sp)
    80210334:	02813b83          	ld	s7,40(sp)
    80210338:	02013c03          	ld	s8,32(sp)
    8021033c:	01813c83          	ld	s9,24(sp)
    80210340:	07010113          	addi	sp,sp,112
    80210344:	00008067          	ret
        sleep(p, &waitLock);
    80210348:	01cc2597          	auipc	a1,0x1cc2
    8021034c:	31058593          	addi	a1,a1,784 # 81ed2658 <waitLock>
    80210350:	00098513          	mv	a0,s3
    80210354:	00002097          	auipc	ra,0x2
    80210358:	894080e7          	jalr	-1900(ra) # 80211be8 <sleep>
        haveChildProcess = 0;
    8021035c:	e21ff06f          	j	8021017c <wait+0x60>
                        return -1;
    80210360:	fff00913          	li	s2,-1
    80210364:	fadff06f          	j	80210310 <wait+0x1f4>
            return -1;
    80210368:	fff00913          	li	s2,-1
    8021036c:	fa5ff06f          	j	80210310 <wait+0x1f4>

0000000080210370 <either_copyout>:

// Copy to either a user address, or kernel address,
// depending on usr_dst.
// Returns 0 on success, -1 on error.
int either_copyout(int user_dst, u64 dst, void* src, u64 len) {
    80210370:	fd010113          	addi	sp,sp,-48
    80210374:	02113423          	sd	ra,40(sp)
    80210378:	02813023          	sd	s0,32(sp)
    8021037c:	00913c23          	sd	s1,24(sp)
    80210380:	01213823          	sd	s2,16(sp)
    80210384:	01313423          	sd	s3,8(sp)
    80210388:	01413023          	sd	s4,0(sp)
    8021038c:	03010413          	addi	s0,sp,48
    80210390:	00058913          	mv	s2,a1
    80210394:	00060993          	mv	s3,a2
    80210398:	00068a13          	mv	s4,a3
    if (user_dst) {
    8021039c:	04050263          	beqz	a0,802103e0 <either_copyout+0x70>
        struct Process* p = myProcess();//because only this branch uses p->pgdir, so it need call myProcess
    802103a0:	fffff097          	auipc	ra,0xfffff
    802103a4:	648080e7          	jalr	1608(ra) # 8020f9e8 <myProcess>
        return copyout(p->pgdir, dst, src, len);
    802103a8:	000a0693          	mv	a3,s4
    802103ac:	00098613          	mv	a2,s3
    802103b0:	00090593          	mv	a1,s2
    802103b4:	04053503          	ld	a0,64(a0)
    802103b8:	ffff9097          	auipc	ra,0xffff9
    802103bc:	780080e7          	jalr	1920(ra) # 80209b38 <copyout>
    } else {
        memmove((char*)dst, src, len);
        return 0;
    }
}
    802103c0:	02813083          	ld	ra,40(sp)
    802103c4:	02013403          	ld	s0,32(sp)
    802103c8:	01813483          	ld	s1,24(sp)
    802103cc:	01013903          	ld	s2,16(sp)
    802103d0:	00813983          	ld	s3,8(sp)
    802103d4:	00013a03          	ld	s4,0(sp)
    802103d8:	03010113          	addi	sp,sp,48
    802103dc:	00008067          	ret
    802103e0:	00050493          	mv	s1,a0
        memmove((char*)dst, src, len);
    802103e4:	0006861b          	sext.w	a2,a3
    802103e8:	00098593          	mv	a1,s3
    802103ec:	00090513          	mv	a0,s2
    802103f0:	fffff097          	auipc	ra,0xfffff
    802103f4:	a10080e7          	jalr	-1520(ra) # 8020ee00 <memmove>
        return 0;
    802103f8:	00048513          	mv	a0,s1
    802103fc:	fc5ff06f          	j	802103c0 <either_copyout+0x50>

0000000080210400 <either_memset>:

int either_memset(bool user, u64 dst, u8 value, u64 len) {
    80210400:	fd010113          	addi	sp,sp,-48
    80210404:	02113423          	sd	ra,40(sp)
    80210408:	02813023          	sd	s0,32(sp)
    8021040c:	00913c23          	sd	s1,24(sp)
    80210410:	01213823          	sd	s2,16(sp)
    80210414:	01313423          	sd	s3,8(sp)
    80210418:	03010413          	addi	s0,sp,48
    8021041c:	00058493          	mv	s1,a1
    80210420:	00060913          	mv	s2,a2
    80210424:	00068993          	mv	s3,a3
    if (user) {
    80210428:	02051c63          	bnez	a0,80210460 <either_memset+0x60>
        Process *p = myProcess();
        return memsetOut(p->pgdir, dst, value, len);
    }
    memset((void *)dst, value, len);
    8021042c:	0006861b          	sext.w	a2,a3
    80210430:	00090593          	mv	a1,s2
    80210434:	00048513          	mv	a0,s1
    80210438:	fffff097          	auipc	ra,0xfffff
    8021043c:	934080e7          	jalr	-1740(ra) # 8020ed6c <memset>
    return 0;
    80210440:	00000513          	li	a0,0
}
    80210444:	02813083          	ld	ra,40(sp)
    80210448:	02013403          	ld	s0,32(sp)
    8021044c:	01813483          	ld	s1,24(sp)
    80210450:	01013903          	ld	s2,16(sp)
    80210454:	00813983          	ld	s3,8(sp)
    80210458:	03010113          	addi	sp,sp,48
    8021045c:	00008067          	ret
        Process *p = myProcess();
    80210460:	fffff097          	auipc	ra,0xfffff
    80210464:	588080e7          	jalr	1416(ra) # 8020f9e8 <myProcess>
        return memsetOut(p->pgdir, dst, value, len);
    80210468:	00098693          	mv	a3,s3
    8021046c:	00090613          	mv	a2,s2
    80210470:	00048593          	mv	a1,s1
    80210474:	04053503          	ld	a0,64(a0)
    80210478:	ffff9097          	auipc	ra,0xffff9
    8021047c:	7c8080e7          	jalr	1992(ra) # 80209c40 <memsetOut>
    80210480:	fc5ff06f          	j	80210444 <either_memset+0x44>

0000000080210484 <either_copyin>:

// Copy from either a user address, or kernel address,
// depending on usr_src.
// Returns 0 on success, -1 on error.
int either_copyin(void* dst, int user_src, u64 src, u64 len) {
    80210484:	fd010113          	addi	sp,sp,-48
    80210488:	02113423          	sd	ra,40(sp)
    8021048c:	02813023          	sd	s0,32(sp)
    80210490:	00913c23          	sd	s1,24(sp)
    80210494:	01213823          	sd	s2,16(sp)
    80210498:	01313423          	sd	s3,8(sp)
    8021049c:	01413023          	sd	s4,0(sp)
    802104a0:	03010413          	addi	s0,sp,48
    802104a4:	00050913          	mv	s2,a0
    802104a8:	00060993          	mv	s3,a2
    802104ac:	00068a13          	mv	s4,a3
    if (user_src) {
    802104b0:	04058263          	beqz	a1,802104f4 <either_copyin+0x70>
        struct Process* p = myProcess();//because only this branch uses p->pgdir, so it need call myProcess
    802104b4:	fffff097          	auipc	ra,0xfffff
    802104b8:	534080e7          	jalr	1332(ra) # 8020f9e8 <myProcess>
        return copyin(p->pgdir, dst, src, len);
    802104bc:	000a0693          	mv	a3,s4
    802104c0:	00098613          	mv	a2,s3
    802104c4:	00090593          	mv	a1,s2
    802104c8:	04053503          	ld	a0,64(a0)
    802104cc:	ffff9097          	auipc	ra,0xffff9
    802104d0:	57c080e7          	jalr	1404(ra) # 80209a48 <copyin>
    } else {
        memmove(dst, (char*)src, len);
        return 0;
    }
}
    802104d4:	02813083          	ld	ra,40(sp)
    802104d8:	02013403          	ld	s0,32(sp)
    802104dc:	01813483          	ld	s1,24(sp)
    802104e0:	01013903          	ld	s2,16(sp)
    802104e4:	00813983          	ld	s3,8(sp)
    802104e8:	00013a03          	ld	s4,0(sp)
    802104ec:	03010113          	addi	sp,sp,48
    802104f0:	00008067          	ret
    802104f4:	00058493          	mv	s1,a1
        memmove(dst, (char*)src, len);
    802104f8:	0006861b          	sext.w	a2,a3
    802104fc:	00098593          	mv	a1,s3
    80210500:	fffff097          	auipc	ra,0xfffff
    80210504:	900080e7          	jalr	-1792(ra) # 8020ee00 <memmove>
        return 0;
    80210508:	00048513          	mv	a0,s1
    8021050c:	fc9ff06f          	j	802104d4 <either_copyin+0x50>

0000000080210510 <kernelProcessCpuTimeBegin>:

void kernelProcessCpuTimeBegin() {
    80210510:	ff010113          	addi	sp,sp,-16
    80210514:	00813423          	sd	s0,8(sp)
    80210518:	01010413          	addi	s0,sp,16
    return;
    Process *p = myProcess();
    long currentTime = r_time();
    p->cpuTime.kernel += currentTime - p->processTime.lastKernelTime;
}
    8021051c:	00813403          	ld	s0,8(sp)
    80210520:	01010113          	addi	sp,sp,16
    80210524:	00008067          	ret

0000000080210528 <kernelProcessCpuTimeEnd>:

void kernelProcessCpuTimeEnd() {
    80210528:	ff010113          	addi	sp,sp,-16
    8021052c:	00813423          	sd	s0,8(sp)
    80210530:	01010413          	addi	s0,sp,16
    return;
    Process *p = myProcess();
    p->processTime.lastKernelTime = r_time();
}
    80210534:	00813403          	ld	s0,8(sp)
    80210538:	01010113          	addi	sp,sp,16
    8021053c:	00008067          	ret

0000000080210540 <myThread>:
struct ThreadList scheduleList[2];
Thread *currentThread[HART_TOTAL_NUMBER] = {0};

struct Spinlock freeThreadListLock, scheduleListLock, threadIdLock;

Thread* myThread() {
    80210540:	ff010113          	addi	sp,sp,-16
    80210544:	00813423          	sd	s0,8(sp)
    80210548:	01010413          	addi	s0,sp,16
    asm volatile("mv %0, tp" : "=r" (x) );
    8021054c:	00020713          	mv	a4,tp
    // interruptPush();
    if (currentThread[r_hartid()] == NULL) {
    80210550:	00371713          	slli	a4,a4,0x3
    80210554:	020d8797          	auipc	a5,0x20d8
    80210558:	14478793          	addi	a5,a5,324 # 822e8698 <currentThread>
    8021055c:	00e787b3          	add	a5,a5,a4
    80210560:	0007b503          	ld	a0,0(a5)
    80210564:	00050e63          	beqz	a0,80210580 <myThread+0x40>
    80210568:	00020713          	mv	a4,tp
        // printf("[Kernel]No thread run in the hart %d\n", hartId);
        // interruptPop();
        return NULL;
    }
    // interruptPop();
    return currentThread[r_hartid()];
    8021056c:	00371713          	slli	a4,a4,0x3
    80210570:	020d8797          	auipc	a5,0x20d8
    80210574:	12878793          	addi	a5,a5,296 # 822e8698 <currentThread>
    80210578:	00e787b3          	add	a5,a5,a4
    8021057c:	0007b503          	ld	a0,0(a5)
}
    80210580:	00813403          	ld	s0,8(sp)
    80210584:	01010113          	addi	sp,sp,16
    80210588:	00008067          	ret

000000008021058c <getThreadTopSp>:

u64 getThreadTopSp(Thread* th) {
    8021058c:	ff010113          	addi	sp,sp,-16
    80210590:	00813423          	sd	s0,8(sp)
    80210594:	01010413          	addi	s0,sp,16
    return KERNEL_PROCESS_SP_TOP - (u64)(th - threads) * 10 * PAGE_SIZE;
    80210598:	020d8797          	auipc	a5,0x20d8
    8021059c:	18078793          	addi	a5,a5,384 # 822e8718 <threads>
    802105a0:	40f507b3          	sub	a5,a0,a5
    802105a4:	4047d793          	srai	a5,a5,0x4
    802105a8:	00006717          	auipc	a4,0x6
    802105ac:	27873703          	ld	a4,632(a4) # 80216820 <__func__.0+0x48>
    802105b0:	02e787b3          	mul	a5,a5,a4
    802105b4:	00279513          	slli	a0,a5,0x2
    802105b8:	00f507b3          	add	a5,a0,a5
    802105bc:	00d79793          	slli	a5,a5,0xd
}
    802105c0:	00100513          	li	a0,1
    802105c4:	02451513          	slli	a0,a0,0x24
    802105c8:	40f50533          	sub	a0,a0,a5
    802105cc:	00813403          	ld	s0,8(sp)
    802105d0:	01010113          	addi	sp,sp,16
    802105d4:	00008067          	ret

00000000802105d8 <threadInit>:

extern u64 kernelPageDirectory[];
void threadInit() {
    802105d8:	fe010113          	addi	sp,sp,-32
    802105dc:	00113c23          	sd	ra,24(sp)
    802105e0:	00813823          	sd	s0,16(sp)
    802105e4:	00913423          	sd	s1,8(sp)
    802105e8:	02010413          	addi	s0,sp,32
    initLock(&freeThreadListLock, "freeThread");
    802105ec:	020d8497          	auipc	s1,0x20d8
    802105f0:	0ac48493          	addi	s1,s1,172 # 822e8698 <currentThread>
    802105f4:	00006597          	auipc	a1,0x6
    802105f8:	f2c58593          	addi	a1,a1,-212 # 80216520 <__func__.0+0x18>
    802105fc:	020d8517          	auipc	a0,0x20d8
    80210600:	0c450513          	addi	a0,a0,196 # 822e86c0 <freeThreadListLock>
    80210604:	ffff8097          	auipc	ra,0xffff8
    80210608:	1e4080e7          	jalr	484(ra) # 802087e8 <initLock>
    initLock(&scheduleListLock, "scheduleList");
    8021060c:	00006597          	auipc	a1,0x6
    80210610:	f2458593          	addi	a1,a1,-220 # 80216530 <__func__.0+0x28>
    80210614:	020d8517          	auipc	a0,0x20d8
    80210618:	0c450513          	addi	a0,a0,196 # 822e86d8 <scheduleListLock>
    8021061c:	ffff8097          	auipc	ra,0xffff8
    80210620:	1cc080e7          	jalr	460(ra) # 802087e8 <initLock>
    initLock(&threadIdLock, "threadId");
    80210624:	00006597          	auipc	a1,0x6
    80210628:	f1c58593          	addi	a1,a1,-228 # 80216540 <__func__.0+0x38>
    8021062c:	020d8517          	auipc	a0,0x20d8
    80210630:	0c450513          	addi	a0,a0,196 # 822e86f0 <threadIdLock>
    80210634:	ffff8097          	auipc	ra,0xffff8
    80210638:	1b4080e7          	jalr	436(ra) # 802087e8 <initLock>

    LIST_INIT(&freeThreades);
    LIST_INIT(&scheduleList[0]);
    8021063c:	0604b823          	sd	zero,112(s1)
    LIST_INIT(&scheduleList[1]);
    80210640:	0604bc23          	sd	zero,120(s1)

    int i;
    for (i = PROCESS_TOTAL_NUMBER - 1; i >= 0; i--) {
        threads[i].state = UNUSED;
        threads[i].trapframe.kernelSatp = MAKE_SATP(kernelPageDirectory);
    80210644:	0215f597          	auipc	a1,0x215f
    80210648:	9bc58593          	addi	a1,a1,-1604 # 8236f000 <_pgdir>
    8021064c:	00c5d593          	srli	a1,a1,0xc
    80210650:	fff00793          	li	a5,-1
    80210654:	03f79793          	slli	a5,a5,0x3f
    80210658:	00f5e5b3          	or	a1,a1,a5
    8021065c:	0215e797          	auipc	a5,0x215e
    80210660:	c8c78793          	addi	a5,a5,-884 # 8236e2e8 <threads+0x85bd0>
    80210664:	020d8817          	auipc	a6,0x20d8
    80210668:	0b480813          	addi	a6,a6,180 # 822e8718 <threads>
    8021066c:	00000693          	li	a3,0
        LIST_INSERT_HEAD(&freeThreades, &threads[i], link);
    80210670:	0215e517          	auipc	a0,0x215e
    80210674:	0b050513          	addi	a0,a0,176 # 8236e720 <freeThreades>
    80210678:	0140006f          	j	8021068c <threadInit+0xb4>
    8021067c:	22a6b423          	sd	a0,552(a3)
    for (i = PROCESS_TOTAL_NUMBER - 1; i >= 0; i--) {
    80210680:	bd078713          	addi	a4,a5,-1072
    80210684:	03078663          	beq	a5,a6,802106b0 <threadInit+0xd8>
    80210688:	00070793          	mv	a5,a4
        threads[i].state = UNUSED;
    8021068c:	00068713          	mv	a4,a3
    80210690:	00078693          	mv	a3,a5
    80210694:	2407a823          	sw	zero,592(a5)
        threads[i].trapframe.kernelSatp = MAKE_SATP(kernelPageDirectory);
    80210698:	00b7b023          	sd	a1,0(a5)
        LIST_INSERT_HEAD(&freeThreades, &threads[i], link);
    8021069c:	22e7b023          	sd	a4,544(a5)
    802106a0:	fc070ee3          	beqz	a4,8021067c <threadInit+0xa4>
    802106a4:	22078613          	addi	a2,a5,544
    802106a8:	22c73423          	sd	a2,552(a4)
    802106ac:	fd1ff06f          	j	8021067c <threadInit+0xa4>
    802106b0:	0215e717          	auipc	a4,0x215e
    802106b4:	07070713          	addi	a4,a4,112 # 8236e720 <freeThreades>
    802106b8:	020d8797          	auipc	a5,0x20d8
    802106bc:	06078793          	addi	a5,a5,96 # 822e8718 <threads>
    802106c0:	00f73023          	sd	a5,0(a4)
    802106c4:	22e7b423          	sd	a4,552(a5)
    }
}
    802106c8:	01813083          	ld	ra,24(sp)
    802106cc:	01013403          	ld	s0,16(sp)
    802106d0:	00813483          	ld	s1,8(sp)
    802106d4:	02010113          	addi	sp,sp,32
    802106d8:	00008067          	ret

00000000802106dc <generateThreadId>:

u32 generateThreadId(Thread* th) {
    802106dc:	ff010113          	addi	sp,sp,-16
    802106e0:	00813423          	sd	s0,8(sp)
    802106e4:	01010413          	addi	s0,sp,16
    // acquireLock(&threadIdLock);
    static u32 nextId = 0;
    u32 threadId = (++nextId << (1 + LOG_PROCESS_NUM)) | (u32)(th - threads);
    802106e8:	0215e717          	auipc	a4,0x215e
    802106ec:	03470713          	addi	a4,a4,52 # 8236e71c <nextId.5>
    802106f0:	00072783          	lw	a5,0(a4)
    802106f4:	0017879b          	addiw	a5,a5,1
    802106f8:	00f72023          	sw	a5,0(a4)
    802106fc:	020d8717          	auipc	a4,0x20d8
    80210700:	01c70713          	addi	a4,a4,28 # 822e8718 <threads>
    80210704:	40e50533          	sub	a0,a0,a4
    80210708:	40455513          	srai	a0,a0,0x4
    8021070c:	00006717          	auipc	a4,0x6
    80210710:	11473703          	ld	a4,276(a4) # 80216820 <__func__.0+0x48>
    80210714:	02e50533          	mul	a0,a0,a4
    80210718:	00a7979b          	slliw	a5,a5,0xa
    8021071c:	00f56533          	or	a0,a0,a5
    // releaseLock(&threadIdLock);
    return threadId;
}
    80210720:	0005051b          	sext.w	a0,a0
    80210724:	00813403          	ld	s0,8(sp)
    80210728:	01010113          	addi	sp,sp,16
    8021072c:	00008067          	ret

0000000080210730 <threadFree>:
        asm volatile("ld sp, 0(%0)" : :"r"(&sp): "memory");
        yield();
    }
}

void threadFree(Thread *th) {
    80210730:	fd010113          	addi	sp,sp,-48
    80210734:	02113423          	sd	ra,40(sp)
    80210738:	02813023          	sd	s0,32(sp)
    8021073c:	00913c23          	sd	s1,24(sp)
    80210740:	01213823          	sd	s2,16(sp)
    80210744:	03010413          	addi	s0,sp,48
    80210748:	00050493          	mv	s1,a0
    Process* p = th->process;
    8021074c:	41853903          	ld	s2,1048(a0)
    // acquireLock(&th->lock);
    while (!LIST_EMPTY(&th->waitingSignal)) {
    80210750:	42853503          	ld	a0,1064(a0)
    80210754:	08051863          	bnez	a0,802107e4 <threadFree+0xb4>
        LIST_REMOVE(sc, link);
        signalContextFree(sc);
    }
    // releaseLock(&th->lock);
    // acquireLock(&p->lock);
    if (th->clearChildTid) {
    80210758:	4104b583          	ld	a1,1040(s1)
    8021075c:	08059a63          	bnez	a1,802107f0 <threadFree+0xc0>
        int val = 0;
        copyout(p->pgdir, th->clearChildTid, (char*)&val, sizeof(int));
        futexWake(th->clearChildTid, 1);
    }
    p->threadCount--;
    80210760:	000027b7          	lui	a5,0x2
    80210764:	00f907b3          	add	a5,s2,a5
    80210768:	0907a703          	lw	a4,144(a5) # 2090 <_start-0x801fdf70>
    8021076c:	fff7071b          	addiw	a4,a4,-1
    80210770:	0007069b          	sext.w	a3,a4
    80210774:	08e7a823          	sw	a4,144(a5)
    if (!p->threadCount) {
    80210778:	0a068263          	beqz	a3,8021081c <threadFree+0xec>
    } else {
        // releaseLock(&p->lock);
    }

    // acquireLock(&freeThreadListLock);
    th->state = UNUSED;
    8021077c:	2404a823          	sw	zero,592(s1)
    LIST_INSERT_HEAD(&freeThreades, th, link); //test pipe
    80210780:	0215e797          	auipc	a5,0x215e
    80210784:	fa07b783          	ld	a5,-96(a5) # 8236e720 <freeThreades>
    80210788:	22f4b023          	sd	a5,544(s1)
    8021078c:	00078663          	beqz	a5,80210798 <threadFree+0x68>
    80210790:	22048713          	addi	a4,s1,544
    80210794:	22e7b423          	sd	a4,552(a5)
    80210798:	0215e797          	auipc	a5,0x215e
    8021079c:	f8878793          	addi	a5,a5,-120 # 8236e720 <freeThreades>
    802107a0:	0097b023          	sd	s1,0(a5)
    802107a4:	22f4b423          	sd	a5,552(s1)
    // releaseLock(&freeThreadListLock);
}
    802107a8:	02813083          	ld	ra,40(sp)
    802107ac:	02013403          	ld	s0,32(sp)
    802107b0:	01813483          	ld	s1,24(sp)
    802107b4:	01013903          	ld	s2,16(sp)
    802107b8:	03010113          	addi	sp,sp,48
    802107bc:	00008067          	ret
        LIST_REMOVE(sc, link);
    802107c0:	23853703          	ld	a4,568(a0)
    802107c4:	22e7bc23          	sd	a4,568(a5)
    802107c8:	23853783          	ld	a5,568(a0)
    802107cc:	23053703          	ld	a4,560(a0)
    802107d0:	00e7b023          	sd	a4,0(a5)
        signalContextFree(sc);
    802107d4:	ffffa097          	auipc	ra,0xffffa
    802107d8:	b0c080e7          	jalr	-1268(ra) # 8020a2e0 <signalContextFree>
    while (!LIST_EMPTY(&th->waitingSignal)) {
    802107dc:	4284b503          	ld	a0,1064(s1)
    802107e0:	f6050ce3          	beqz	a0,80210758 <threadFree+0x28>
        LIST_REMOVE(sc, link);
    802107e4:	23053783          	ld	a5,560(a0)
    802107e8:	fc079ce3          	bnez	a5,802107c0 <threadFree+0x90>
    802107ec:	fddff06f          	j	802107c8 <threadFree+0x98>
        int val = 0;
    802107f0:	fc042e23          	sw	zero,-36(s0)
        copyout(p->pgdir, th->clearChildTid, (char*)&val, sizeof(int));
    802107f4:	00400693          	li	a3,4
    802107f8:	fdc40613          	addi	a2,s0,-36
    802107fc:	04093503          	ld	a0,64(s2)
    80210800:	ffff9097          	auipc	ra,0xffff9
    80210804:	338080e7          	jalr	824(ra) # 80209b38 <copyout>
        futexWake(th->clearChildTid, 1);
    80210808:	00100593          	li	a1,1
    8021080c:	4104b503          	ld	a0,1040(s1)
    80210810:	ffffa097          	auipc	ra,0xffffa
    80210814:	844080e7          	jalr	-1980(ra) # 8020a054 <futexWake>
    80210818:	f49ff06f          	j	80210760 <threadFree+0x30>
        p->retValue = th->retValue;
    8021081c:	2844a703          	lw	a4,644(s1)
    80210820:	000027b7          	lui	a5,0x2
    80210824:	00f907b3          	add	a5,s2,a5
    80210828:	06e7a823          	sw	a4,112(a5) # 2070 <_start-0x801fdf90>
        processFree(p);    
    8021082c:	00090513          	mv	a0,s2
    80210830:	fffff097          	auipc	ra,0xfffff
    80210834:	460080e7          	jalr	1120(ra) # 8020fc90 <processFree>
    80210838:	f45ff06f          	j	8021077c <threadFree+0x4c>

000000008021083c <threadDestroy>:
void threadDestroy(Thread *th) {
    8021083c:	fd010113          	addi	sp,sp,-48
    80210840:	02113423          	sd	ra,40(sp)
    80210844:	02813023          	sd	s0,32(sp)
    80210848:	00913c23          	sd	s1,24(sp)
    8021084c:	03010413          	addi	s0,sp,48
    80210850:	00050493          	mv	s1,a0
    threadFree(th);
    80210854:	00000097          	auipc	ra,0x0
    80210858:	edc080e7          	jalr	-292(ra) # 80210730 <threadFree>
    8021085c:	00020793          	mv	a5,tp
    int hartId = r_hartid();
    80210860:	0007879b          	sext.w	a5,a5
    if (currentThread[hartId] == th) {
    80210864:	00379693          	slli	a3,a5,0x3
    80210868:	020d8717          	auipc	a4,0x20d8
    8021086c:	e3070713          	addi	a4,a4,-464 # 822e8698 <currentThread>
    80210870:	00d70733          	add	a4,a4,a3
    80210874:	00073703          	ld	a4,0(a4)
    80210878:	00970c63          	beq	a4,s1,80210890 <threadDestroy+0x54>
}
    8021087c:	02813083          	ld	ra,40(sp)
    80210880:	02013403          	ld	s0,32(sp)
    80210884:	01813483          	ld	s1,24(sp)
    80210888:	03010113          	addi	sp,sp,48
    8021088c:	00008067          	ret
        currentThread[hartId] = NULL;
    80210890:	020d8717          	auipc	a4,0x20d8
    80210894:	e0870713          	addi	a4,a4,-504 # 822e8698 <currentThread>
    80210898:	00d70733          	add	a4,a4,a3
    8021089c:	00073023          	sd	zero,0(a4)
        u64 sp = (u64)kernelStack + (hartId + 1) * KERNEL_STACK_SIZE;
    802108a0:	0017879b          	addiw	a5,a5,1
    802108a4:	0107979b          	slliw	a5,a5,0x10
    802108a8:	0019e717          	auipc	a4,0x19e
    802108ac:	75870713          	addi	a4,a4,1880 # 803af000 <_stack>
    802108b0:	00e787b3          	add	a5,a5,a4
    802108b4:	fcf43c23          	sd	a5,-40(s0)
        asm volatile("ld sp, 0(%0)" : :"r"(&sp): "memory");
    802108b8:	fd840793          	addi	a5,s0,-40
    802108bc:	0007b103          	ld	sp,0(a5)
        yield();
    802108c0:	00001097          	auipc	ra,0x1
    802108c4:	478080e7          	jalr	1144(ra) # 80211d38 <yield>
}
    802108c8:	fb5ff06f          	j	8021087c <threadDestroy+0x40>

00000000802108cc <tid2Thread>:

int tid2Thread(u32 threadId, struct Thread **thread, int checkPerm) {
    802108cc:	fd010113          	addi	sp,sp,-48
    802108d0:	02113423          	sd	ra,40(sp)
    802108d4:	02813023          	sd	s0,32(sp)
    802108d8:	00913c23          	sd	s1,24(sp)
    802108dc:	01213823          	sd	s2,16(sp)
    802108e0:	01313423          	sd	s3,8(sp)
    802108e4:	03010413          	addi	s0,sp,48
    802108e8:	00058913          	mv	s2,a1
    802108ec:	00020793          	mv	a5,tp
    struct Thread* th;
    int hartId = r_hartid();
    802108f0:	0007879b          	sext.w	a5,a5

    if (threadId == 0) {
    802108f4:	08050263          	beqz	a0,80210978 <tid2Thread+0xac>
        *thread = currentThread[hartId];
        return 0;
    }

    th = threads + PROCESS_OFFSET(threadId);
    802108f8:	1ff57493          	andi	s1,a0,511
    802108fc:	43000713          	li	a4,1072
    80210900:	02e484b3          	mul	s1,s1,a4
    80210904:	020d8717          	auipc	a4,0x20d8
    80210908:	e1470713          	addi	a4,a4,-492 # 822e8718 <threads>
    8021090c:	00e484b3          	add	s1,s1,a4

    if (th->state == UNUSED || th->id != threadId) {
    80210910:	2504a703          	lw	a4,592(s1)
    80210914:	06070e63          	beqz	a4,80210990 <tid2Thread+0xc4>
    80210918:	2384a703          	lw	a4,568(s1)
    8021091c:	08a71063          	bne	a4,a0,8021099c <tid2Thread+0xd0>
        *thread = NULL;
        return -ESRCH;
    }

    if (checkPerm) {
    80210920:	02060a63          	beqz	a2,80210954 <tid2Thread+0x88>
        if (th != currentThread[hartId] && th->process->parentId != myProcess()->processId) {
    80210924:	00379793          	slli	a5,a5,0x3
    80210928:	020d8717          	auipc	a4,0x20d8
    8021092c:	d7070713          	addi	a4,a4,-656 # 822e8698 <currentThread>
    80210930:	00f707b3          	add	a5,a4,a5
    80210934:	0007b783          	ld	a5,0(a5)
    80210938:	00978e63          	beq	a5,s1,80210954 <tid2Thread+0x88>
    8021093c:	4184b783          	ld	a5,1048(s1)
    80210940:	04c7a983          	lw	s3,76(a5)
    80210944:	fffff097          	auipc	ra,0xfffff
    80210948:	0a4080e7          	jalr	164(ra) # 8020f9e8 <myProcess>
    8021094c:	04852783          	lw	a5,72(a0)
    80210950:	05379c63          	bne	a5,s3,802109a8 <tid2Thread+0xdc>
            return -EPERM;
        }
    }

    *thread = th;
    return 0;
    80210954:	00000513          	li	a0,0
        *thread = currentThread[hartId];
    80210958:	00993023          	sd	s1,0(s2)
}
    8021095c:	02813083          	ld	ra,40(sp)
    80210960:	02013403          	ld	s0,32(sp)
    80210964:	01813483          	ld	s1,24(sp)
    80210968:	01013903          	ld	s2,16(sp)
    8021096c:	00813983          	ld	s3,8(sp)
    80210970:	03010113          	addi	sp,sp,48
    80210974:	00008067          	ret
        *thread = currentThread[hartId];
    80210978:	00379793          	slli	a5,a5,0x3
    8021097c:	020d8717          	auipc	a4,0x20d8
    80210980:	d1c70713          	addi	a4,a4,-740 # 822e8698 <currentThread>
    80210984:	00f707b3          	add	a5,a4,a5
    80210988:	0007b483          	ld	s1,0(a5)
        return 0;
    8021098c:	fcdff06f          	j	80210958 <tid2Thread+0x8c>
    80210990:	00000493          	li	s1,0
        return -ESRCH;
    80210994:	ffd00513          	li	a0,-3
    80210998:	fc1ff06f          	j	80210958 <tid2Thread+0x8c>
    8021099c:	00000493          	li	s1,0
    802109a0:	ffd00513          	li	a0,-3
    802109a4:	fb5ff06f          	j	80210958 <tid2Thread+0x8c>
    802109a8:	00000493          	li	s1,0
            return -EPERM;
    802109ac:	fff00513          	li	a0,-1
    802109b0:	fa9ff06f          	j	80210958 <tid2Thread+0x8c>

00000000802109b4 <threadSetup>:

extern void userVector();

void threadSetup(Thread* th) {
    802109b4:	fd010113          	addi	sp,sp,-48
    802109b8:	02113423          	sd	ra,40(sp)
    802109bc:	02813023          	sd	s0,32(sp)
    802109c0:	00913c23          	sd	s1,24(sp)
    802109c4:	03010413          	addi	s0,sp,48
    802109c8:	00050493          	mv	s1,a0
    th->chan = 0;
    802109cc:	26053823          	sd	zero,624(a0)
    th->retValue = 0;
    802109d0:	28052223          	sw	zero,644(a0)
    th->state = UNUSED;
    802109d4:	24052823          	sw	zero,592(a0)
    th->reason = 0;
    802109d8:	28052023          	sw	zero,640(a0)
    th->setChildTid = th->clearChildTid = 0;
    802109dc:	40053823          	sd	zero,1040(a0)
    802109e0:	40053423          	sd	zero,1032(a0)
    th->awakeTime = 0;
    802109e4:	22053823          	sd	zero,560(a0)
    th->robustHeadPointer = 0;
    802109e8:	42053023          	sd	zero,1056(a0)
    LIST_INIT(&th->waitingSignal);
    802109ec:	42053423          	sd	zero,1064(a0)
    PhysicalPage *page;
    if (pageAlloc(&page) < 0) {
    802109f0:	fd840513          	addi	a0,s0,-40
    802109f4:	ffff8097          	auipc	ra,0xffff8
    802109f8:	4c8080e7          	jalr	1224(ra) # 80208ebc <pageAlloc>
    802109fc:	38054e63          	bltz	a0,80210d98 <threadSetup+0x3e4>
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE, page2pa(page), PTE_READ | PTE_WRITE);
    80210a00:	00048513          	mv	a0,s1
    80210a04:	00000097          	auipc	ra,0x0
    80210a08:	b88080e7          	jalr	-1144(ra) # 8021058c <getThreadTopSp>
    80210a0c:	00050493          	mv	s1,a0
    return page - pages;
    80210a10:	fd843783          	ld	a5,-40(s0)
    80210a14:	018f6717          	auipc	a4,0x18f6
    80210a18:	4ec70713          	addi	a4,a4,1260 # 81b06f00 <pages>
    80210a1c:	40e787b3          	sub	a5,a5,a4
    80210a20:	4037d793          	srai	a5,a5,0x3
    80210a24:	00006717          	auipc	a4,0x6
    80210a28:	dd473703          	ld	a4,-556(a4) # 802167f8 <__func__.0+0x20>
    80210a2c:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210a30:	00c7979b          	slliw	a5,a5,0xc
    80210a34:	02079793          	slli	a5,a5,0x20
    80210a38:	0207d793          	srli	a5,a5,0x20
    80210a3c:	00600693          	li	a3,6
    80210a40:	00100613          	li	a2,1
    80210a44:	01f61613          	slli	a2,a2,0x1f
    80210a48:	00c78633          	add	a2,a5,a2
    80210a4c:	fffff5b7          	lui	a1,0xfffff
    80210a50:	00b505b3          	add	a1,a0,a1
    80210a54:	0215e517          	auipc	a0,0x215e
    80210a58:	5ac50513          	addi	a0,a0,1452 # 8236f000 <_pgdir>
    80210a5c:	ffff9097          	auipc	ra,0xffff9
    80210a60:	814080e7          	jalr	-2028(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210a64:	fd840513          	addi	a0,s0,-40
    80210a68:	ffff8097          	auipc	ra,0xffff8
    80210a6c:	454080e7          	jalr	1108(ra) # 80208ebc <pageAlloc>
    80210a70:	34054663          	bltz	a0,80210dbc <threadSetup+0x408>
    return page - pages;
    80210a74:	fd843783          	ld	a5,-40(s0)
    80210a78:	018f6717          	auipc	a4,0x18f6
    80210a7c:	48870713          	addi	a4,a4,1160 # 81b06f00 <pages>
    80210a80:	40e787b3          	sub	a5,a5,a4
    80210a84:	4037d793          	srai	a5,a5,0x3
    80210a88:	00006717          	auipc	a4,0x6
    80210a8c:	d7073703          	ld	a4,-656(a4) # 802167f8 <__func__.0+0x20>
    80210a90:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210a94:	00c7979b          	slliw	a5,a5,0xc
    80210a98:	02079793          	slli	a5,a5,0x20
    80210a9c:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 2, page2pa(page), PTE_READ | PTE_WRITE);
    80210aa0:	00600693          	li	a3,6
    80210aa4:	00100613          	li	a2,1
    80210aa8:	01f61613          	slli	a2,a2,0x1f
    80210aac:	00c78633          	add	a2,a5,a2
    80210ab0:	ffffe5b7          	lui	a1,0xffffe
    80210ab4:	00b485b3          	add	a1,s1,a1
    80210ab8:	0215e517          	auipc	a0,0x215e
    80210abc:	54850513          	addi	a0,a0,1352 # 8236f000 <_pgdir>
    80210ac0:	ffff8097          	auipc	ra,0xffff8
    80210ac4:	7b0080e7          	jalr	1968(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210ac8:	fd840513          	addi	a0,s0,-40
    80210acc:	ffff8097          	auipc	ra,0xffff8
    80210ad0:	3f0080e7          	jalr	1008(ra) # 80208ebc <pageAlloc>
    80210ad4:	30054663          	bltz	a0,80210de0 <threadSetup+0x42c>
    return page - pages;
    80210ad8:	fd843783          	ld	a5,-40(s0)
    80210adc:	018f6717          	auipc	a4,0x18f6
    80210ae0:	42470713          	addi	a4,a4,1060 # 81b06f00 <pages>
    80210ae4:	40e787b3          	sub	a5,a5,a4
    80210ae8:	4037d793          	srai	a5,a5,0x3
    80210aec:	00006717          	auipc	a4,0x6
    80210af0:	d0c73703          	ld	a4,-756(a4) # 802167f8 <__func__.0+0x20>
    80210af4:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210af8:	00c7979b          	slliw	a5,a5,0xc
    80210afc:	02079793          	slli	a5,a5,0x20
    80210b00:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 3, page2pa(page), PTE_READ | PTE_WRITE);
    80210b04:	00600693          	li	a3,6
    80210b08:	00100613          	li	a2,1
    80210b0c:	01f61613          	slli	a2,a2,0x1f
    80210b10:	00c78633          	add	a2,a5,a2
    80210b14:	ffffd5b7          	lui	a1,0xffffd
    80210b18:	00b485b3          	add	a1,s1,a1
    80210b1c:	0215e517          	auipc	a0,0x215e
    80210b20:	4e450513          	addi	a0,a0,1252 # 8236f000 <_pgdir>
    80210b24:	ffff8097          	auipc	ra,0xffff8
    80210b28:	74c080e7          	jalr	1868(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210b2c:	fd840513          	addi	a0,s0,-40
    80210b30:	ffff8097          	auipc	ra,0xffff8
    80210b34:	38c080e7          	jalr	908(ra) # 80208ebc <pageAlloc>
    80210b38:	2c054663          	bltz	a0,80210e04 <threadSetup+0x450>
    return page - pages;
    80210b3c:	fd843783          	ld	a5,-40(s0)
    80210b40:	018f6717          	auipc	a4,0x18f6
    80210b44:	3c070713          	addi	a4,a4,960 # 81b06f00 <pages>
    80210b48:	40e787b3          	sub	a5,a5,a4
    80210b4c:	4037d793          	srai	a5,a5,0x3
    80210b50:	00006717          	auipc	a4,0x6
    80210b54:	ca873703          	ld	a4,-856(a4) # 802167f8 <__func__.0+0x20>
    80210b58:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210b5c:	00c7979b          	slliw	a5,a5,0xc
    80210b60:	02079793          	slli	a5,a5,0x20
    80210b64:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 4, page2pa(page), PTE_READ | PTE_WRITE);
    80210b68:	00600693          	li	a3,6
    80210b6c:	00100613          	li	a2,1
    80210b70:	01f61613          	slli	a2,a2,0x1f
    80210b74:	00c78633          	add	a2,a5,a2
    80210b78:	ffffc5b7          	lui	a1,0xffffc
    80210b7c:	00b485b3          	add	a1,s1,a1
    80210b80:	0215e517          	auipc	a0,0x215e
    80210b84:	48050513          	addi	a0,a0,1152 # 8236f000 <_pgdir>
    80210b88:	ffff8097          	auipc	ra,0xffff8
    80210b8c:	6e8080e7          	jalr	1768(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210b90:	fd840513          	addi	a0,s0,-40
    80210b94:	ffff8097          	auipc	ra,0xffff8
    80210b98:	328080e7          	jalr	808(ra) # 80208ebc <pageAlloc>
    80210b9c:	28054663          	bltz	a0,80210e28 <threadSetup+0x474>
    return page - pages;
    80210ba0:	fd843783          	ld	a5,-40(s0)
    80210ba4:	018f6717          	auipc	a4,0x18f6
    80210ba8:	35c70713          	addi	a4,a4,860 # 81b06f00 <pages>
    80210bac:	40e787b3          	sub	a5,a5,a4
    80210bb0:	4037d793          	srai	a5,a5,0x3
    80210bb4:	00006717          	auipc	a4,0x6
    80210bb8:	c4473703          	ld	a4,-956(a4) # 802167f8 <__func__.0+0x20>
    80210bbc:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210bc0:	00c7979b          	slliw	a5,a5,0xc
    80210bc4:	02079793          	slli	a5,a5,0x20
    80210bc8:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 5, page2pa(page), PTE_READ | PTE_WRITE);
    80210bcc:	00600693          	li	a3,6
    80210bd0:	00100613          	li	a2,1
    80210bd4:	01f61613          	slli	a2,a2,0x1f
    80210bd8:	00c78633          	add	a2,a5,a2
    80210bdc:	ffffb5b7          	lui	a1,0xffffb
    80210be0:	00b485b3          	add	a1,s1,a1
    80210be4:	0215e517          	auipc	a0,0x215e
    80210be8:	41c50513          	addi	a0,a0,1052 # 8236f000 <_pgdir>
    80210bec:	ffff8097          	auipc	ra,0xffff8
    80210bf0:	684080e7          	jalr	1668(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210bf4:	fd840513          	addi	a0,s0,-40
    80210bf8:	ffff8097          	auipc	ra,0xffff8
    80210bfc:	2c4080e7          	jalr	708(ra) # 80208ebc <pageAlloc>
    80210c00:	24054663          	bltz	a0,80210e4c <threadSetup+0x498>
    return page - pages;
    80210c04:	fd843783          	ld	a5,-40(s0)
    80210c08:	018f6717          	auipc	a4,0x18f6
    80210c0c:	2f870713          	addi	a4,a4,760 # 81b06f00 <pages>
    80210c10:	40e787b3          	sub	a5,a5,a4
    80210c14:	4037d793          	srai	a5,a5,0x3
    80210c18:	00006717          	auipc	a4,0x6
    80210c1c:	be073703          	ld	a4,-1056(a4) # 802167f8 <__func__.0+0x20>
    80210c20:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210c24:	00c7979b          	slliw	a5,a5,0xc
    80210c28:	02079793          	slli	a5,a5,0x20
    80210c2c:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 6, page2pa(page), PTE_READ | PTE_WRITE);
    80210c30:	00600693          	li	a3,6
    80210c34:	00100613          	li	a2,1
    80210c38:	01f61613          	slli	a2,a2,0x1f
    80210c3c:	00c78633          	add	a2,a5,a2
    80210c40:	ffffa5b7          	lui	a1,0xffffa
    80210c44:	00b485b3          	add	a1,s1,a1
    80210c48:	0215e517          	auipc	a0,0x215e
    80210c4c:	3b850513          	addi	a0,a0,952 # 8236f000 <_pgdir>
    80210c50:	ffff8097          	auipc	ra,0xffff8
    80210c54:	620080e7          	jalr	1568(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210c58:	fd840513          	addi	a0,s0,-40
    80210c5c:	ffff8097          	auipc	ra,0xffff8
    80210c60:	260080e7          	jalr	608(ra) # 80208ebc <pageAlloc>
    80210c64:	20054663          	bltz	a0,80210e70 <threadSetup+0x4bc>
    return page - pages;
    80210c68:	fd843783          	ld	a5,-40(s0)
    80210c6c:	018f6717          	auipc	a4,0x18f6
    80210c70:	29470713          	addi	a4,a4,660 # 81b06f00 <pages>
    80210c74:	40e787b3          	sub	a5,a5,a4
    80210c78:	4037d793          	srai	a5,a5,0x3
    80210c7c:	00006717          	auipc	a4,0x6
    80210c80:	b7c73703          	ld	a4,-1156(a4) # 802167f8 <__func__.0+0x20>
    80210c84:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210c88:	00c7979b          	slliw	a5,a5,0xc
    80210c8c:	02079793          	slli	a5,a5,0x20
    80210c90:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 7, page2pa(page), PTE_READ | PTE_WRITE);
    80210c94:	00600693          	li	a3,6
    80210c98:	00100613          	li	a2,1
    80210c9c:	01f61613          	slli	a2,a2,0x1f
    80210ca0:	00c78633          	add	a2,a5,a2
    80210ca4:	ffff95b7          	lui	a1,0xffff9
    80210ca8:	00b485b3          	add	a1,s1,a1
    80210cac:	0215e517          	auipc	a0,0x215e
    80210cb0:	35450513          	addi	a0,a0,852 # 8236f000 <_pgdir>
    80210cb4:	ffff8097          	auipc	ra,0xffff8
    80210cb8:	5bc080e7          	jalr	1468(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210cbc:	fd840513          	addi	a0,s0,-40
    80210cc0:	ffff8097          	auipc	ra,0xffff8
    80210cc4:	1fc080e7          	jalr	508(ra) # 80208ebc <pageAlloc>
    80210cc8:	1c054663          	bltz	a0,80210e94 <threadSetup+0x4e0>
    return page - pages;
    80210ccc:	fd843783          	ld	a5,-40(s0)
    80210cd0:	018f6717          	auipc	a4,0x18f6
    80210cd4:	23070713          	addi	a4,a4,560 # 81b06f00 <pages>
    80210cd8:	40e787b3          	sub	a5,a5,a4
    80210cdc:	4037d793          	srai	a5,a5,0x3
    80210ce0:	00006717          	auipc	a4,0x6
    80210ce4:	b1873703          	ld	a4,-1256(a4) # 802167f8 <__func__.0+0x20>
    80210ce8:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210cec:	00c7979b          	slliw	a5,a5,0xc
    80210cf0:	02079793          	slli	a5,a5,0x20
    80210cf4:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 8, page2pa(page), PTE_READ | PTE_WRITE);
    80210cf8:	00600693          	li	a3,6
    80210cfc:	00100613          	li	a2,1
    80210d00:	01f61613          	slli	a2,a2,0x1f
    80210d04:	00c78633          	add	a2,a5,a2
    80210d08:	ffff85b7          	lui	a1,0xffff8
    80210d0c:	00b485b3          	add	a1,s1,a1
    80210d10:	0215e517          	auipc	a0,0x215e
    80210d14:	2f050513          	addi	a0,a0,752 # 8236f000 <_pgdir>
    80210d18:	ffff8097          	auipc	ra,0xffff8
    80210d1c:	558080e7          	jalr	1368(ra) # 80209270 <pageInsert>
    if (pageAlloc(&page) < 0) {
    80210d20:	fd840513          	addi	a0,s0,-40
    80210d24:	ffff8097          	auipc	ra,0xffff8
    80210d28:	198080e7          	jalr	408(ra) # 80208ebc <pageAlloc>
    80210d2c:	18054663          	bltz	a0,80210eb8 <threadSetup+0x504>
    return page - pages;
    80210d30:	fd843783          	ld	a5,-40(s0)
    80210d34:	018f6717          	auipc	a4,0x18f6
    80210d38:	1cc70713          	addi	a4,a4,460 # 81b06f00 <pages>
    80210d3c:	40e787b3          	sub	a5,a5,a4
    80210d40:	4037d793          	srai	a5,a5,0x3
    80210d44:	00006717          	auipc	a4,0x6
    80210d48:	ab473703          	ld	a4,-1356(a4) # 802167f8 <__func__.0+0x20>
    80210d4c:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80210d50:	00c7979b          	slliw	a5,a5,0xc
    80210d54:	02079793          	slli	a5,a5,0x20
    80210d58:	0207d793          	srli	a5,a5,0x20
        panic("");
    }
    pageInsert(kernelPageDirectory, getThreadTopSp(th) - PAGE_SIZE * 9, page2pa(page), PTE_READ | PTE_WRITE);
    80210d5c:	00600693          	li	a3,6
    80210d60:	00100613          	li	a2,1
    80210d64:	01f61613          	slli	a2,a2,0x1f
    80210d68:	00c78633          	add	a2,a5,a2
    80210d6c:	ffff75b7          	lui	a1,0xffff7
    80210d70:	00b485b3          	add	a1,s1,a1
    80210d74:	0215e517          	auipc	a0,0x215e
    80210d78:	28c50513          	addi	a0,a0,652 # 8236f000 <_pgdir>
    80210d7c:	ffff8097          	auipc	ra,0xffff8
    80210d80:	4f4080e7          	jalr	1268(ra) # 80209270 <pageInsert>
}
    80210d84:	02813083          	ld	ra,40(sp)
    80210d88:	02013403          	ld	s0,32(sp)
    80210d8c:	01813483          	ld	s1,24(sp)
    80210d90:	03010113          	addi	sp,sp,48
    80210d94:	00008067          	ret
        panic("");
    80210d98:	00005697          	auipc	a3,0x5
    80210d9c:	e5068693          	addi	a3,a3,-432 # 80215be8 <__func__.0+0x48>
    80210da0:	00006617          	auipc	a2,0x6
    80210da4:	95060613          	addi	a2,a2,-1712 # 802166f0 <__func__.4>
    80210da8:	09100593          	li	a1,145
    80210dac:	00005517          	auipc	a0,0x5
    80210db0:	7a450513          	addi	a0,a0,1956 # 80216550 <__func__.0+0x48>
    80210db4:	ffff0097          	auipc	ra,0xffff0
    80210db8:	134080e7          	jalr	308(ra) # 80200ee8 <_panic_>
        panic("");
    80210dbc:	00005697          	auipc	a3,0x5
    80210dc0:	e2c68693          	addi	a3,a3,-468 # 80215be8 <__func__.0+0x48>
    80210dc4:	00006617          	auipc	a2,0x6
    80210dc8:	92c60613          	addi	a2,a2,-1748 # 802166f0 <__func__.4>
    80210dcc:	09500593          	li	a1,149
    80210dd0:	00005517          	auipc	a0,0x5
    80210dd4:	78050513          	addi	a0,a0,1920 # 80216550 <__func__.0+0x48>
    80210dd8:	ffff0097          	auipc	ra,0xffff0
    80210ddc:	110080e7          	jalr	272(ra) # 80200ee8 <_panic_>
        panic("");
    80210de0:	00005697          	auipc	a3,0x5
    80210de4:	e0868693          	addi	a3,a3,-504 # 80215be8 <__func__.0+0x48>
    80210de8:	00006617          	auipc	a2,0x6
    80210dec:	90860613          	addi	a2,a2,-1784 # 802166f0 <__func__.4>
    80210df0:	09900593          	li	a1,153
    80210df4:	00005517          	auipc	a0,0x5
    80210df8:	75c50513          	addi	a0,a0,1884 # 80216550 <__func__.0+0x48>
    80210dfc:	ffff0097          	auipc	ra,0xffff0
    80210e00:	0ec080e7          	jalr	236(ra) # 80200ee8 <_panic_>
        panic("");
    80210e04:	00005697          	auipc	a3,0x5
    80210e08:	de468693          	addi	a3,a3,-540 # 80215be8 <__func__.0+0x48>
    80210e0c:	00006617          	auipc	a2,0x6
    80210e10:	8e460613          	addi	a2,a2,-1820 # 802166f0 <__func__.4>
    80210e14:	09d00593          	li	a1,157
    80210e18:	00005517          	auipc	a0,0x5
    80210e1c:	73850513          	addi	a0,a0,1848 # 80216550 <__func__.0+0x48>
    80210e20:	ffff0097          	auipc	ra,0xffff0
    80210e24:	0c8080e7          	jalr	200(ra) # 80200ee8 <_panic_>
        panic("");
    80210e28:	00005697          	auipc	a3,0x5
    80210e2c:	dc068693          	addi	a3,a3,-576 # 80215be8 <__func__.0+0x48>
    80210e30:	00006617          	auipc	a2,0x6
    80210e34:	8c060613          	addi	a2,a2,-1856 # 802166f0 <__func__.4>
    80210e38:	0a100593          	li	a1,161
    80210e3c:	00005517          	auipc	a0,0x5
    80210e40:	71450513          	addi	a0,a0,1812 # 80216550 <__func__.0+0x48>
    80210e44:	ffff0097          	auipc	ra,0xffff0
    80210e48:	0a4080e7          	jalr	164(ra) # 80200ee8 <_panic_>
        panic("");
    80210e4c:	00005697          	auipc	a3,0x5
    80210e50:	d9c68693          	addi	a3,a3,-612 # 80215be8 <__func__.0+0x48>
    80210e54:	00006617          	auipc	a2,0x6
    80210e58:	89c60613          	addi	a2,a2,-1892 # 802166f0 <__func__.4>
    80210e5c:	0a500593          	li	a1,165
    80210e60:	00005517          	auipc	a0,0x5
    80210e64:	6f050513          	addi	a0,a0,1776 # 80216550 <__func__.0+0x48>
    80210e68:	ffff0097          	auipc	ra,0xffff0
    80210e6c:	080080e7          	jalr	128(ra) # 80200ee8 <_panic_>
        panic("");
    80210e70:	00005697          	auipc	a3,0x5
    80210e74:	d7868693          	addi	a3,a3,-648 # 80215be8 <__func__.0+0x48>
    80210e78:	00006617          	auipc	a2,0x6
    80210e7c:	87860613          	addi	a2,a2,-1928 # 802166f0 <__func__.4>
    80210e80:	0a900593          	li	a1,169
    80210e84:	00005517          	auipc	a0,0x5
    80210e88:	6cc50513          	addi	a0,a0,1740 # 80216550 <__func__.0+0x48>
    80210e8c:	ffff0097          	auipc	ra,0xffff0
    80210e90:	05c080e7          	jalr	92(ra) # 80200ee8 <_panic_>
        panic("");
    80210e94:	00005697          	auipc	a3,0x5
    80210e98:	d5468693          	addi	a3,a3,-684 # 80215be8 <__func__.0+0x48>
    80210e9c:	00006617          	auipc	a2,0x6
    80210ea0:	85460613          	addi	a2,a2,-1964 # 802166f0 <__func__.4>
    80210ea4:	0ad00593          	li	a1,173
    80210ea8:	00005517          	auipc	a0,0x5
    80210eac:	6a850513          	addi	a0,a0,1704 # 80216550 <__func__.0+0x48>
    80210eb0:	ffff0097          	auipc	ra,0xffff0
    80210eb4:	038080e7          	jalr	56(ra) # 80200ee8 <_panic_>
        panic("");
    80210eb8:	00005697          	auipc	a3,0x5
    80210ebc:	d3068693          	addi	a3,a3,-720 # 80215be8 <__func__.0+0x48>
    80210ec0:	00006617          	auipc	a2,0x6
    80210ec4:	83060613          	addi	a2,a2,-2000 # 802166f0 <__func__.4>
    80210ec8:	0b100593          	li	a1,177
    80210ecc:	00005517          	auipc	a0,0x5
    80210ed0:	68450513          	addi	a0,a0,1668 # 80216550 <__func__.0+0x48>
    80210ed4:	ffff0097          	auipc	ra,0xffff0
    80210ed8:	014080e7          	jalr	20(ra) # 80200ee8 <_panic_>

0000000080210edc <getSignalHandlerSp>:

u64 getSignalHandlerSp(Thread *th) {
    80210edc:	ff010113          	addi	sp,sp,-16
    80210ee0:	00813423          	sd	s0,8(sp)
    80210ee4:	01010413          	addi	s0,sp,16
    return SIGNAL_HANDLER_SP_BASE + (th - threads + 1) * PAGE_SIZE * 10;
    80210ee8:	020d8797          	auipc	a5,0x20d8
    80210eec:	83078793          	addi	a5,a5,-2000 # 822e8718 <threads>
    80210ef0:	40f507b3          	sub	a5,a0,a5
    80210ef4:	4047d793          	srai	a5,a5,0x4
    80210ef8:	00006717          	auipc	a4,0x6
    80210efc:	92873703          	ld	a4,-1752(a4) # 80216820 <__func__.0+0x48>
    80210f00:	02e787b3          	mul	a5,a5,a4
    80210f04:	00178793          	addi	a5,a5,1
    80210f08:	00279513          	slli	a0,a5,0x2
    80210f0c:	00f507b3          	add	a5,a0,a5
    80210f10:	00d79793          	slli	a5,a5,0xd
}
    80210f14:	04300513          	li	a0,67
    80210f18:	01e51513          	slli	a0,a0,0x1e
    80210f1c:	00a78533          	add	a0,a5,a0
    80210f20:	00813403          	ld	s0,8(sp)
    80210f24:	01010113          	addi	sp,sp,16
    80210f28:	00008067          	ret

0000000080210f2c <mainThreadAlloc>:

int mainThreadAlloc(Thread **new, u64 parentId) {
    80210f2c:	fc010113          	addi	sp,sp,-64
    80210f30:	02113c23          	sd	ra,56(sp)
    80210f34:	02813823          	sd	s0,48(sp)
    80210f38:	02913423          	sd	s1,40(sp)
    80210f3c:	03213023          	sd	s2,32(sp)
    80210f40:	01313c23          	sd	s3,24(sp)
    80210f44:	04010413          	addi	s0,sp,64
    int r;
    Thread *th;
    // acquireLock(&freeThreadListLock);
    if (LIST_EMPTY(&freeThreades)) {
    80210f48:	0215d497          	auipc	s1,0x215d
    80210f4c:	7d84b483          	ld	s1,2008(s1) # 8236e720 <freeThreades>
    80210f50:	0c048063          	beqz	s1,80211010 <mainThreadAlloc+0xe4>
    80210f54:	00050913          	mv	s2,a0
    80210f58:	00058993          	mv	s3,a1
        panic("");
        *new = NULL;
        return -ESRCH;
    }
    th = LIST_FIRST(&freeThreades);
    LIST_REMOVE(th, link);
    80210f5c:	2204b783          	ld	a5,544(s1)
    80210f60:	00078663          	beqz	a5,80210f6c <mainThreadAlloc+0x40>
    80210f64:	2284b703          	ld	a4,552(s1)
    80210f68:	22e7b423          	sd	a4,552(a5)
    80210f6c:	2284b783          	ld	a5,552(s1)
    80210f70:	2204b703          	ld	a4,544(s1)
    80210f74:	00e7b023          	sd	a4,0(a5)
    // releaseLock(&freeThreadListLock);

    threadSetup(th);
    80210f78:	00048513          	mv	a0,s1
    80210f7c:	00000097          	auipc	ra,0x0
    80210f80:	a38080e7          	jalr	-1480(ra) # 802109b4 <threadSetup>
    th->id = generateThreadId(th);
    80210f84:	00048513          	mv	a0,s1
    80210f88:	fffff097          	auipc	ra,0xfffff
    80210f8c:	754080e7          	jalr	1876(ra) # 802106dc <generateThreadId>
    80210f90:	22a4ac23          	sw	a0,568(s1)
    th->state = RUNNABLE;
    80210f94:	00200793          	li	a5,2
    80210f98:	24f4a823          	sw	a5,592(s1)
    th->trapframe.kernelSp = getThreadTopSp(th);
    80210f9c:	00048513          	mv	a0,s1
    80210fa0:	fffff097          	auipc	ra,0xfffff
    80210fa4:	5ec080e7          	jalr	1516(ra) # 8021058c <getThreadTopSp>
    80210fa8:	00a4b423          	sd	a0,8(s1)
    th->trapframe.sp = USER_STACK_TOP - 24; //argc = 0, argv = 0, envp = 0
    80210fac:	9fd00793          	li	a5,-1539
    80210fb0:	01d79793          	slli	a5,a5,0x1d
    80210fb4:	01a7d793          	srli	a5,a5,0x1a
    80210fb8:	02f4b823          	sd	a5,48(s1)
    Process *process;
    r = processAlloc(&process, parentId);
    80210fbc:	00098593          	mv	a1,s3
    80210fc0:	fc840513          	addi	a0,s0,-56
    80210fc4:	fffff097          	auipc	ra,0xfffff
    80210fc8:	f90080e7          	jalr	-112(ra) # 8020ff54 <processAlloc>
    if (r < 0) {
    80210fcc:	06054463          	bltz	a0,80211034 <mainThreadAlloc+0x108>
        *new = NULL;
        return r;
    }
    // acquireLock(&process->lock);
    th->process = process;
    80210fd0:	fc843783          	ld	a5,-56(s0)
    80210fd4:	40f4bc23          	sd	a5,1048(s1)
    process->threadCount++;
    80210fd8:	00002737          	lui	a4,0x2
    80210fdc:	00e787b3          	add	a5,a5,a4
    80210fe0:	0907a703          	lw	a4,144(a5)
    80210fe4:	0017071b          	addiw	a4,a4,1
    80210fe8:	08e7a823          	sw	a4,144(a5)
    // releaseLock(&process->lock);
    *new = th;
    return 0;
    80210fec:	00000513          	li	a0,0
    *new = th;
    80210ff0:	00993023          	sd	s1,0(s2)
}
    80210ff4:	03813083          	ld	ra,56(sp)
    80210ff8:	03013403          	ld	s0,48(sp)
    80210ffc:	02813483          	ld	s1,40(sp)
    80211000:	02013903          	ld	s2,32(sp)
    80211004:	01813983          	ld	s3,24(sp)
    80211008:	04010113          	addi	sp,sp,64
    8021100c:	00008067          	ret
        panic("");
    80211010:	00005697          	auipc	a3,0x5
    80211014:	bd868693          	addi	a3,a3,-1064 # 80215be8 <__func__.0+0x48>
    80211018:	00005617          	auipc	a2,0x5
    8021101c:	6e860613          	addi	a2,a2,1768 # 80216700 <__func__.3>
    80211020:	0c000593          	li	a1,192
    80211024:	00005517          	auipc	a0,0x5
    80211028:	52c50513          	addi	a0,a0,1324 # 80216550 <__func__.0+0x48>
    8021102c:	ffff0097          	auipc	ra,0xffff0
    80211030:	ebc080e7          	jalr	-324(ra) # 80200ee8 <_panic_>
    80211034:	00000493          	li	s1,0
    80211038:	fb9ff06f          	j	80210ff0 <mainThreadAlloc+0xc4>

000000008021103c <threadAlloc>:

int threadAlloc(Thread **new, Process* process, u64 userSp) {
    8021103c:	fd010113          	addi	sp,sp,-48
    80211040:	02113423          	sd	ra,40(sp)
    80211044:	02813023          	sd	s0,32(sp)
    80211048:	00913c23          	sd	s1,24(sp)
    8021104c:	01213823          	sd	s2,16(sp)
    80211050:	01313423          	sd	s3,8(sp)
    80211054:	01413023          	sd	s4,0(sp)
    80211058:	03010413          	addi	s0,sp,48
    Thread *th;
    // acquireLock(&freeThreadListLock);
    if (LIST_EMPTY(&freeThreades)) {
    8021105c:	0215d497          	auipc	s1,0x215d
    80211060:	6c44b483          	ld	s1,1732(s1) # 8236e720 <freeThreades>
    80211064:	0a048263          	beqz	s1,80211108 <threadAlloc+0xcc>
    80211068:	00050a13          	mv	s4,a0
    8021106c:	00058913          	mv	s2,a1
    80211070:	00060993          	mv	s3,a2
        panic("");
        *new = NULL;
        return -ESRCH;
    }
    th = LIST_FIRST(&freeThreades);
    LIST_REMOVE(th, link);
    80211074:	2204b783          	ld	a5,544(s1)
    80211078:	00078663          	beqz	a5,80211084 <threadAlloc+0x48>
    8021107c:	2284b703          	ld	a4,552(s1)
    80211080:	22e7b423          	sd	a4,552(a5)
    80211084:	2284b783          	ld	a5,552(s1)
    80211088:	2204b703          	ld	a4,544(s1)
    8021108c:	00e7b023          	sd	a4,0(a5)
    // releaseLock(&freeThreadListLock);

    threadSetup(th);
    80211090:	00048513          	mv	a0,s1
    80211094:	00000097          	auipc	ra,0x0
    80211098:	920080e7          	jalr	-1760(ra) # 802109b4 <threadSetup>
    th->id = generateThreadId(th);
    8021109c:	00048513          	mv	a0,s1
    802110a0:	fffff097          	auipc	ra,0xfffff
    802110a4:	63c080e7          	jalr	1596(ra) # 802106dc <generateThreadId>
    802110a8:	22a4ac23          	sw	a0,568(s1)
    th->state = RUNNABLE;
    802110ac:	00200793          	li	a5,2
    802110b0:	24f4a823          	sw	a5,592(s1)
    th->trapframe.kernelSp = getThreadTopSp(th);
    802110b4:	00048513          	mv	a0,s1
    802110b8:	fffff097          	auipc	ra,0xfffff
    802110bc:	4d4080e7          	jalr	1236(ra) # 8021058c <getThreadTopSp>
    802110c0:	00a4b423          	sd	a0,8(s1)
    th->trapframe.sp = userSp;
    802110c4:	0334b823          	sd	s3,48(s1)

    // acquireLock(&process->lock);
    th->process = process;
    802110c8:	4124bc23          	sd	s2,1048(s1)
    process->threadCount++;
    802110cc:	000027b7          	lui	a5,0x2
    802110d0:	00f90933          	add	s2,s2,a5
    802110d4:	09092783          	lw	a5,144(s2)
    802110d8:	0017879b          	addiw	a5,a5,1
    802110dc:	08f92823          	sw	a5,144(s2)
    // releaseLock(&process->lock);

    *new = th;
    802110e0:	009a3023          	sd	s1,0(s4)
    return 0;
}
    802110e4:	00000513          	li	a0,0
    802110e8:	02813083          	ld	ra,40(sp)
    802110ec:	02013403          	ld	s0,32(sp)
    802110f0:	01813483          	ld	s1,24(sp)
    802110f4:	01013903          	ld	s2,16(sp)
    802110f8:	00813983          	ld	s3,8(sp)
    802110fc:	00013a03          	ld	s4,0(sp)
    80211100:	03010113          	addi	sp,sp,48
    80211104:	00008067          	ret
        panic("");
    80211108:	00005697          	auipc	a3,0x5
    8021110c:	ae068693          	addi	a3,a3,-1312 # 80215be8 <__func__.0+0x48>
    80211110:	00005617          	auipc	a2,0x5
    80211114:	60060613          	addi	a2,a2,1536 # 80216710 <__func__.2>
    80211118:	0e000593          	li	a1,224
    8021111c:	00005517          	auipc	a0,0x5
    80211120:	43450513          	addi	a0,a0,1076 # 80216550 <__func__.0+0x48>
    80211124:	ffff0097          	auipc	ra,0xffff0
    80211128:	dc4080e7          	jalr	-572(ra) # 80200ee8 <_panic_>

000000008021112c <threadRun>:

void threadRun(Thread* th) {
    8021112c:	fb010113          	addi	sp,sp,-80
    80211130:	04113423          	sd	ra,72(sp)
    80211134:	04813023          	sd	s0,64(sp)
    80211138:	02913c23          	sd	s1,56(sp)
    8021113c:	03213823          	sd	s2,48(sp)
    80211140:	03313423          	sd	s3,40(sp)
    80211144:	03413023          	sd	s4,32(sp)
    80211148:	01513c23          	sd	s5,24(sp)
    8021114c:	05010413          	addi	s0,sp,80
    80211150:	00050913          	mv	s2,a0
    static volatile int first = 0;
    Trapframe* trapframe = getHartTrapFrame();
    80211154:	ffff9097          	auipc	ra,0xffff9
    80211158:	088080e7          	jalr	136(ra) # 8020a1dc <getHartTrapFrame>
    8021115c:	00050a13          	mv	s4,a0
    80211160:	00020713          	mv	a4,tp
    if (currentThread[r_hartid()]) {
    80211164:	00371713          	slli	a4,a4,0x3
    80211168:	020d7797          	auipc	a5,0x20d7
    8021116c:	53078793          	addi	a5,a5,1328 # 822e8698 <currentThread>
    80211170:	00e787b3          	add	a5,a5,a4
    80211174:	0007b783          	ld	a5,0(a5)
    80211178:	02078463          	beqz	a5,802111a0 <threadRun+0x74>
    8021117c:	00020713          	mv	a4,tp
        bcopy(trapframe, &(currentThread[r_hartid()]->trapframe),
    80211180:	00371713          	slli	a4,a4,0x3
    80211184:	020d7797          	auipc	a5,0x20d7
    80211188:	51478793          	addi	a5,a5,1300 # 822e8698 <currentThread>
    8021118c:	00e787b3          	add	a5,a5,a4
    80211190:	22000613          	li	a2,544
    80211194:	0007b583          	ld	a1,0(a5)
    80211198:	ffff8097          	auipc	ra,0xffff8
    8021119c:	b08080e7          	jalr	-1272(ra) # 80208ca0 <bcopy>
              sizeof(Trapframe));
    }
    
    th->state = RUNNING;
    802111a0:	00300793          	li	a5,3
    802111a4:	24f92823          	sw	a5,592(s2)
    if (th->reason & KERNEL_GIVE_UP) {
    802111a8:	28092783          	lw	a5,640(s2)
    802111ac:	0017f713          	andi	a4,a5,1
    802111b0:	1a071ae3          	bnez	a4,80211b64 <threadRun+0xa38>
    802111b4:	00020713          	mv	a4,tp
        currentThread[r_hartid()] = th;
        bcopy(&currentThread[r_hartid()]->trapframe, trapframe, sizeof(Trapframe));
        asm volatile("ld sp, 0(%0)" : : "r"(&th->currentKernelSp));
        sleepRec();
    } else {
        currentThread[r_hartid()] = th;
    802111b8:	00371713          	slli	a4,a4,0x3
    802111bc:	020d7797          	auipc	a5,0x20d7
    802111c0:	4dc78793          	addi	a5,a5,1244 # 822e8698 <currentThread>
    802111c4:	00e787b3          	add	a5,a5,a4
    802111c8:	0127b023          	sd	s2,0(a5)
        if (first == 0) {
    802111cc:	0215d797          	auipc	a5,0x215d
    802111d0:	54c7a783          	lw	a5,1356(a5) # 8236e718 <first.1>
    802111d4:	120792e3          	bnez	a5,80211af8 <threadRun+0x9cc>
            // File system initialization must be run in the context of a
            // regular process (e.g., because it calls sleep), and thus cannot
            // be run from main().
            first = 1;
    802111d8:	00100793          	li	a5,1
    802111dc:	0215d717          	auipc	a4,0x215d
    802111e0:	52f72e23          	sw	a5,1340(a4) # 8236e718 <first.1>
            extern FileSystem *rootFileSystem;
            if (rootFileSystem == NULL) {
    802111e4:	010a7797          	auipc	a5,0x10a7
    802111e8:	ff47b783          	ld	a5,-12(a5) # 812b81d8 <rootFileSystem>
    802111ec:	1c0784e3          	beqz	a5,80211bb4 <threadRun+0xa88>
                fsAlloc(&rootFileSystem);
            }
            strncpy(rootFileSystem->name, "fat32", 6);
    802111f0:	010a7a97          	auipc	s5,0x10a7
    802111f4:	fe8a8a93          	addi	s5,s5,-24 # 812b81d8 <rootFileSystem>
    802111f8:	000ab503          	ld	a0,0(s5)
    802111fc:	00600613          	li	a2,6
    80211200:	00005597          	auipc	a1,0x5
    80211204:	36058593          	addi	a1,a1,864 # 80216560 <__func__.0+0x58>
    80211208:	00150513          	addi	a0,a0,1
    8021120c:	ffffe097          	auipc	ra,0xffffe
    80211210:	cc8080e7          	jalr	-824(ra) # 8020eed4 <strncpy>
            
            rootFileSystem->read = blockRead;
    80211214:	000ab783          	ld	a5,0(s5)
    80211218:	ffff1717          	auipc	a4,0xffff1
    8021121c:	ca070713          	addi	a4,a4,-864 # 80201eb8 <blockRead>
    80211220:	2ee7b023          	sd	a4,736(a5)
            
            direntInit();
    80211224:	ffff1097          	auipc	ra,0xffff1
    80211228:	eec080e7          	jalr	-276(ra) # 80202110 <direntInit>
            fatInit(rootFileSystem);
    8021122c:	000ab503          	ld	a0,0(s5)
    80211230:	ffff3097          	auipc	ra,0xffff3
    80211234:	7cc080e7          	jalr	1996(ra) # 802049fc <fatInit>
            void testfat();
            testfat();
    80211238:	ffff7097          	auipc	ra,0xffff7
    8021123c:	1c4080e7          	jalr	452(ra) # 802083fc <testfat>

            Dirent* ep = create(AT_FDCWD, "/var/tmp/XXX", T_FILE, O_RDONLY);
    80211240:	00000693          	li	a3,0
    80211244:	00200613          	li	a2,2
    80211248:	00005597          	auipc	a1,0x5
    8021124c:	32058593          	addi	a1,a1,800 # 80216568 <__func__.0+0x60>
    80211250:	f9c00513          	li	a0,-100
    80211254:	ffff3097          	auipc	ra,0xffff3
    80211258:	b08080e7          	jalr	-1272(ra) # 80203d5c <create>
    8021125c:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211260:	00005497          	auipc	s1,0x5
    80211264:	4c048493          	addi	s1,s1,1216 # 80216720 <__func__.0>
    80211268:	00a036b3          	snez	a3,a0
    8021126c:	00048613          	mv	a2,s1
    80211270:	11b00593          	li	a1,283
    80211274:	00005517          	auipc	a0,0x5
    80211278:	2dc50513          	addi	a0,a0,732 # 80216550 <__func__.0+0x48>
    8021127c:	ffff0097          	auipc	ra,0xffff0
    80211280:	cdc080e7          	jalr	-804(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211284:	00098513          	mv	a0,s3
    80211288:	ffff2097          	auipc	ra,0xffff2
    8021128c:	36c080e7          	jalr	876(ra) # 802035f4 <eunlock>
            eput(ep);
    80211290:	00098513          	mv	a0,s3
    80211294:	ffff2097          	auipc	ra,0xffff2
    80211298:	378080e7          	jalr	888(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev", T_DIR, O_RDONLY);
    8021129c:	00000693          	li	a3,0
    802112a0:	00100613          	li	a2,1
    802112a4:	00005597          	auipc	a1,0x5
    802112a8:	2d458593          	addi	a1,a1,724 # 80216578 <__func__.0+0x70>
    802112ac:	f9c00513          	li	a0,-100
    802112b0:	ffff3097          	auipc	ra,0xffff3
    802112b4:	aac080e7          	jalr	-1364(ra) # 80203d5c <create>
    802112b8:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802112bc:	00a036b3          	snez	a3,a0
    802112c0:	00048613          	mv	a2,s1
    802112c4:	11f00593          	li	a1,287
    802112c8:	00005517          	auipc	a0,0x5
    802112cc:	28850513          	addi	a0,a0,648 # 80216550 <__func__.0+0x48>
    802112d0:	ffff0097          	auipc	ra,0xffff0
    802112d4:	c88080e7          	jalr	-888(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802112d8:	00098513          	mv	a0,s3
    802112dc:	ffff2097          	auipc	ra,0xffff2
    802112e0:	318080e7          	jalr	792(ra) # 802035f4 <eunlock>
            eput(ep);
    802112e4:	00098513          	mv	a0,s3
    802112e8:	ffff2097          	auipc	ra,0xffff2
    802112ec:	324080e7          	jalr	804(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/vda2", T_DIR, O_RDONLY); //driver
    802112f0:	00000693          	li	a3,0
    802112f4:	00100613          	li	a2,1
    802112f8:	00005597          	auipc	a1,0x5
    802112fc:	28858593          	addi	a1,a1,648 # 80216580 <__func__.0+0x78>
    80211300:	f9c00513          	li	a0,-100
    80211304:	ffff3097          	auipc	ra,0xffff3
    80211308:	a58080e7          	jalr	-1448(ra) # 80203d5c <create>
    8021130c:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211310:	00a036b3          	snez	a3,a0
    80211314:	00048613          	mv	a2,s1
    80211318:	12300593          	li	a1,291
    8021131c:	00005517          	auipc	a0,0x5
    80211320:	23450513          	addi	a0,a0,564 # 80216550 <__func__.0+0x48>
    80211324:	ffff0097          	auipc	ra,0xffff0
    80211328:	c34080e7          	jalr	-972(ra) # 80200f58 <_assert_>
            ep->head = rootFileSystem;            
    8021132c:	000ab783          	ld	a5,0(s5)
    80211330:	22f9b823          	sd	a5,560(s3)
            eunlock(ep);
    80211334:	00098513          	mv	a0,s3
    80211338:	ffff2097          	auipc	ra,0xffff2
    8021133c:	2bc080e7          	jalr	700(ra) # 802035f4 <eunlock>
            eput(ep);
    80211340:	00098513          	mv	a0,s3
    80211344:	ffff2097          	auipc	ra,0xffff2
    80211348:	2c8080e7          	jalr	712(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/shm", T_DIR, O_RDONLY); //share memory
    8021134c:	00000693          	li	a3,0
    80211350:	00100613          	li	a2,1
    80211354:	00005597          	auipc	a1,0x5
    80211358:	23c58593          	addi	a1,a1,572 # 80216590 <__func__.0+0x88>
    8021135c:	f9c00513          	li	a0,-100
    80211360:	ffff3097          	auipc	ra,0xffff3
    80211364:	9fc080e7          	jalr	-1540(ra) # 80203d5c <create>
    80211368:	00050993          	mv	s3,a0
            assert(ep != NULL);
    8021136c:	00a036b3          	snez	a3,a0
    80211370:	00048613          	mv	a2,s1
    80211374:	12800593          	li	a1,296
    80211378:	00005517          	auipc	a0,0x5
    8021137c:	1d850513          	addi	a0,a0,472 # 80216550 <__func__.0+0x48>
    80211380:	ffff0097          	auipc	ra,0xffff0
    80211384:	bd8080e7          	jalr	-1064(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211388:	00098513          	mv	a0,s3
    8021138c:	ffff2097          	auipc	ra,0xffff2
    80211390:	268080e7          	jalr	616(ra) # 802035f4 <eunlock>
            eput(ep);
    80211394:	00098513          	mv	a0,s3
    80211398:	ffff2097          	auipc	ra,0xffff2
    8021139c:	274080e7          	jalr	628(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/null", T_CHAR, O_RDONLY); //share memory
    802113a0:	00000693          	li	a3,0
    802113a4:	00500613          	li	a2,5
    802113a8:	00005597          	auipc	a1,0x5
    802113ac:	1f858593          	addi	a1,a1,504 # 802165a0 <__func__.0+0x98>
    802113b0:	f9c00513          	li	a0,-100
    802113b4:	ffff3097          	auipc	ra,0xffff3
    802113b8:	9a8080e7          	jalr	-1624(ra) # 80203d5c <create>
    802113bc:	00050993          	mv	s3,a0
            ep->dev = NONE;
    802113c0:	00f00793          	li	a5,15
    802113c4:	22f52423          	sw	a5,552(a0)
            assert(ep != NULL);
    802113c8:	00100693          	li	a3,1
    802113cc:	00048613          	mv	a2,s1
    802113d0:	12d00593          	li	a1,301
    802113d4:	00005517          	auipc	a0,0x5
    802113d8:	17c50513          	addi	a0,a0,380 # 80216550 <__func__.0+0x48>
    802113dc:	ffff0097          	auipc	ra,0xffff0
    802113e0:	b7c080e7          	jalr	-1156(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802113e4:	00098513          	mv	a0,s3
    802113e8:	ffff2097          	auipc	ra,0xffff2
    802113ec:	20c080e7          	jalr	524(ra) # 802035f4 <eunlock>
            ep = create(AT_FDCWD, "/tmp", T_DIR, O_RDONLY); //share memory
    802113f0:	00000693          	li	a3,0
    802113f4:	00100613          	li	a2,1
    802113f8:	00005597          	auipc	a1,0x5
    802113fc:	1b858593          	addi	a1,a1,440 # 802165b0 <__func__.0+0xa8>
    80211400:	f9c00513          	li	a0,-100
    80211404:	ffff3097          	auipc	ra,0xffff3
    80211408:	958080e7          	jalr	-1704(ra) # 80203d5c <create>
    8021140c:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211410:	00a036b3          	snez	a3,a0
    80211414:	00048613          	mv	a2,s1
    80211418:	13000593          	li	a1,304
    8021141c:	00005517          	auipc	a0,0x5
    80211420:	13450513          	addi	a0,a0,308 # 80216550 <__func__.0+0x48>
    80211424:	ffff0097          	auipc	ra,0xffff0
    80211428:	b34080e7          	jalr	-1228(ra) # 80200f58 <_assert_>
            eunlock(ep);
    8021142c:	00098513          	mv	a0,s3
    80211430:	ffff2097          	auipc	ra,0xffff2
    80211434:	1c4080e7          	jalr	452(ra) # 802035f4 <eunlock>
            eput(ep);
    80211438:	00098513          	mv	a0,s3
    8021143c:	ffff2097          	auipc	ra,0xffff2
    80211440:	1d0080e7          	jalr	464(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/zero", T_CHAR, O_RDONLY);
    80211444:	00000693          	li	a3,0
    80211448:	00500613          	li	a2,5
    8021144c:	00005597          	auipc	a1,0x5
    80211450:	16c58593          	addi	a1,a1,364 # 802165b8 <__func__.0+0xb0>
    80211454:	f9c00513          	li	a0,-100
    80211458:	ffff3097          	auipc	ra,0xffff3
    8021145c:	904080e7          	jalr	-1788(ra) # 80203d5c <create>
    80211460:	00050993          	mv	s3,a0
            // panic("");
            assert(ep != NULL);
    80211464:	00a036b3          	snez	a3,a0
    80211468:	00048613          	mv	a2,s1
    8021146c:	13500593          	li	a1,309
    80211470:	00005517          	auipc	a0,0x5
    80211474:	0e050513          	addi	a0,a0,224 # 80216550 <__func__.0+0x48>
    80211478:	ffff0097          	auipc	ra,0xffff0
    8021147c:	ae0080e7          	jalr	-1312(ra) # 80200f58 <_assert_>
            ep->dev = ZERO;
    80211480:	00a00793          	li	a5,10
    80211484:	22f9a423          	sw	a5,552(s3)
            eunlock(ep);
    80211488:	00098513          	mv	a0,s3
    8021148c:	ffff2097          	auipc	ra,0xffff2
    80211490:	168080e7          	jalr	360(ra) # 802035f4 <eunlock>
            // }
            // if (ep == NULL || do_linkat(AT_FDCWD, "/libc.so", AT_FDCWD,
            //                             "/lib/ld-musl-riscv64-sf.so.1") < 0) {
            //     printf("pre_link error!\n");
            // }
            ep = create(AT_FDCWD, "/dev/tty", T_CHAR, O_RDONLY);
    80211494:	00000693          	li	a3,0
    80211498:	00500613          	li	a2,5
    8021149c:	00005597          	auipc	a1,0x5
    802114a0:	12c58593          	addi	a1,a1,300 # 802165c8 <__func__.0+0xc0>
    802114a4:	f9c00513          	li	a0,-100
    802114a8:	ffff3097          	auipc	ra,0xffff3
    802114ac:	8b4080e7          	jalr	-1868(ra) # 80203d5c <create>
    802114b0:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802114b4:	00a036b3          	snez	a3,a0
    802114b8:	00048613          	mv	a2,s1
    802114bc:	14800593          	li	a1,328
    802114c0:	00005517          	auipc	a0,0x5
    802114c4:	09050513          	addi	a0,a0,144 # 80216550 <__func__.0+0x48>
    802114c8:	ffff0097          	auipc	ra,0xffff0
    802114cc:	a90080e7          	jalr	-1392(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802114d0:	00098513          	mv	a0,s3
    802114d4:	ffff2097          	auipc	ra,0xffff2
    802114d8:	120080e7          	jalr	288(ra) # 802035f4 <eunlock>
            eput(ep);
    802114dc:	00098513          	mv	a0,s3
    802114e0:	ffff2097          	auipc	ra,0xffff2
    802114e4:	12c080e7          	jalr	300(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/rtc", T_CHAR, O_RDONLY);
    802114e8:	00000693          	li	a3,0
    802114ec:	00500613          	li	a2,5
    802114f0:	00005597          	auipc	a1,0x5
    802114f4:	0e858593          	addi	a1,a1,232 # 802165d8 <__func__.0+0xd0>
    802114f8:	f9c00513          	li	a0,-100
    802114fc:	ffff3097          	auipc	ra,0xffff3
    80211500:	860080e7          	jalr	-1952(ra) # 80203d5c <create>
    80211504:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211508:	00a036b3          	snez	a3,a0
    8021150c:	00048613          	mv	a2,s1
    80211510:	14c00593          	li	a1,332
    80211514:	00005517          	auipc	a0,0x5
    80211518:	03c50513          	addi	a0,a0,60 # 80216550 <__func__.0+0x48>
    8021151c:	ffff0097          	auipc	ra,0xffff0
    80211520:	a3c080e7          	jalr	-1476(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211524:	00098513          	mv	a0,s3
    80211528:	ffff2097          	auipc	ra,0xffff2
    8021152c:	0cc080e7          	jalr	204(ra) # 802035f4 <eunlock>
            eput(ep);
    80211530:	00098513          	mv	a0,s3
    80211534:	ffff2097          	auipc	ra,0xffff2
    80211538:	0d8080e7          	jalr	216(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/rtc0", T_CHAR, O_RDONLY);
    8021153c:	00000693          	li	a3,0
    80211540:	00500613          	li	a2,5
    80211544:	00005597          	auipc	a1,0x5
    80211548:	0a458593          	addi	a1,a1,164 # 802165e8 <__func__.0+0xe0>
    8021154c:	f9c00513          	li	a0,-100
    80211550:	ffff3097          	auipc	ra,0xffff3
    80211554:	80c080e7          	jalr	-2036(ra) # 80203d5c <create>
    80211558:	00050993          	mv	s3,a0
            assert(ep != NULL);
    8021155c:	00a036b3          	snez	a3,a0
    80211560:	00048613          	mv	a2,s1
    80211564:	15000593          	li	a1,336
    80211568:	00005517          	auipc	a0,0x5
    8021156c:	fe850513          	addi	a0,a0,-24 # 80216550 <__func__.0+0x48>
    80211570:	ffff0097          	auipc	ra,0xffff0
    80211574:	9e8080e7          	jalr	-1560(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211578:	00098513          	mv	a0,s3
    8021157c:	ffff2097          	auipc	ra,0xffff2
    80211580:	078080e7          	jalr	120(ra) # 802035f4 <eunlock>
            eput(ep);
    80211584:	00098513          	mv	a0,s3
    80211588:	ffff2097          	auipc	ra,0xffff2
    8021158c:	084080e7          	jalr	132(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/misc", T_DIR, O_RDONLY);
    80211590:	00000693          	li	a3,0
    80211594:	00100613          	li	a2,1
    80211598:	00005597          	auipc	a1,0x5
    8021159c:	06058593          	addi	a1,a1,96 # 802165f8 <__func__.0+0xf0>
    802115a0:	f9c00513          	li	a0,-100
    802115a4:	ffff2097          	auipc	ra,0xffff2
    802115a8:	7b8080e7          	jalr	1976(ra) # 80203d5c <create>
    802115ac:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802115b0:	00a036b3          	snez	a3,a0
    802115b4:	00048613          	mv	a2,s1
    802115b8:	15400593          	li	a1,340
    802115bc:	00005517          	auipc	a0,0x5
    802115c0:	f9450513          	addi	a0,a0,-108 # 80216550 <__func__.0+0x48>
    802115c4:	ffff0097          	auipc	ra,0xffff0
    802115c8:	994080e7          	jalr	-1644(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802115cc:	00098513          	mv	a0,s3
    802115d0:	ffff2097          	auipc	ra,0xffff2
    802115d4:	024080e7          	jalr	36(ra) # 802035f4 <eunlock>
            eput(ep);
    802115d8:	00098513          	mv	a0,s3
    802115dc:	ffff2097          	auipc	ra,0xffff2
    802115e0:	030080e7          	jalr	48(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/dev/misc/rtc", T_CHAR, O_RDONLY);
    802115e4:	00000693          	li	a3,0
    802115e8:	00500613          	li	a2,5
    802115ec:	00005597          	auipc	a1,0x5
    802115f0:	01c58593          	addi	a1,a1,28 # 80216608 <__func__.0+0x100>
    802115f4:	f9c00513          	li	a0,-100
    802115f8:	ffff2097          	auipc	ra,0xffff2
    802115fc:	764080e7          	jalr	1892(ra) # 80203d5c <create>
    80211600:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211604:	00a036b3          	snez	a3,a0
    80211608:	00048613          	mv	a2,s1
    8021160c:	15800593          	li	a1,344
    80211610:	00005517          	auipc	a0,0x5
    80211614:	f4050513          	addi	a0,a0,-192 # 80216550 <__func__.0+0x48>
    80211618:	ffff0097          	auipc	ra,0xffff0
    8021161c:	940080e7          	jalr	-1728(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211620:	00098513          	mv	a0,s3
    80211624:	ffff2097          	auipc	ra,0xffff2
    80211628:	fd0080e7          	jalr	-48(ra) # 802035f4 <eunlock>
            eput(ep);
    8021162c:	00098513          	mv	a0,s3
    80211630:	ffff2097          	auipc	ra,0xffff2
    80211634:	fdc080e7          	jalr	-36(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc", T_DIR, O_RDONLY);
    80211638:	00000693          	li	a3,0
    8021163c:	00100613          	li	a2,1
    80211640:	00005597          	auipc	a1,0x5
    80211644:	fd858593          	addi	a1,a1,-40 # 80216618 <__func__.0+0x110>
    80211648:	f9c00513          	li	a0,-100
    8021164c:	ffff2097          	auipc	ra,0xffff2
    80211650:	710080e7          	jalr	1808(ra) # 80203d5c <create>
    80211654:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211658:	00a036b3          	snez	a3,a0
    8021165c:	00048613          	mv	a2,s1
    80211660:	15c00593          	li	a1,348
    80211664:	00005517          	auipc	a0,0x5
    80211668:	eec50513          	addi	a0,a0,-276 # 80216550 <__func__.0+0x48>
    8021166c:	ffff0097          	auipc	ra,0xffff0
    80211670:	8ec080e7          	jalr	-1812(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211674:	00098513          	mv	a0,s3
    80211678:	ffff2097          	auipc	ra,0xffff2
    8021167c:	f7c080e7          	jalr	-132(ra) # 802035f4 <eunlock>
            eput(ep);
    80211680:	00098513          	mv	a0,s3
    80211684:	ffff2097          	auipc	ra,0xffff2
    80211688:	f88080e7          	jalr	-120(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/meminfo", T_CHAR, O_RDONLY);
    8021168c:	00000693          	li	a3,0
    80211690:	00500613          	li	a2,5
    80211694:	00005597          	auipc	a1,0x5
    80211698:	f8c58593          	addi	a1,a1,-116 # 80216620 <__func__.0+0x118>
    8021169c:	f9c00513          	li	a0,-100
    802116a0:	ffff2097          	auipc	ra,0xffff2
    802116a4:	6bc080e7          	jalr	1724(ra) # 80203d5c <create>
    802116a8:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802116ac:	00a036b3          	snez	a3,a0
    802116b0:	00048613          	mv	a2,s1
    802116b4:	16000593          	li	a1,352
    802116b8:	00005517          	auipc	a0,0x5
    802116bc:	e9850513          	addi	a0,a0,-360 # 80216550 <__func__.0+0x48>
    802116c0:	ffff0097          	auipc	ra,0xffff0
    802116c4:	898080e7          	jalr	-1896(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802116c8:	00098513          	mv	a0,s3
    802116cc:	ffff2097          	auipc	ra,0xffff2
    802116d0:	f28080e7          	jalr	-216(ra) # 802035f4 <eunlock>
            eput(ep);
    802116d4:	00098513          	mv	a0,s3
    802116d8:	ffff2097          	auipc	ra,0xffff2
    802116dc:	f34080e7          	jalr	-204(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/mounts", T_CHAR, O_RDONLY);
    802116e0:	00000693          	li	a3,0
    802116e4:	00500613          	li	a2,5
    802116e8:	00005597          	auipc	a1,0x5
    802116ec:	f4858593          	addi	a1,a1,-184 # 80216630 <__func__.0+0x128>
    802116f0:	f9c00513          	li	a0,-100
    802116f4:	ffff2097          	auipc	ra,0xffff2
    802116f8:	668080e7          	jalr	1640(ra) # 80203d5c <create>
    802116fc:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211700:	00a036b3          	snez	a3,a0
    80211704:	00048613          	mv	a2,s1
    80211708:	16400593          	li	a1,356
    8021170c:	00005517          	auipc	a0,0x5
    80211710:	e4450513          	addi	a0,a0,-444 # 80216550 <__func__.0+0x48>
    80211714:	ffff0097          	auipc	ra,0xffff0
    80211718:	844080e7          	jalr	-1980(ra) # 80200f58 <_assert_>
            eunlock(ep);
    8021171c:	00098513          	mv	a0,s3
    80211720:	ffff2097          	auipc	ra,0xffff2
    80211724:	ed4080e7          	jalr	-300(ra) # 802035f4 <eunlock>
            eput(ep);
    80211728:	00098513          	mv	a0,s3
    8021172c:	ffff2097          	auipc	ra,0xffff2
    80211730:	ee0080e7          	jalr	-288(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/localtime", T_CHAR, O_RDONLY);
    80211734:	00000693          	li	a3,0
    80211738:	00500613          	li	a2,5
    8021173c:	00005597          	auipc	a1,0x5
    80211740:	f0458593          	addi	a1,a1,-252 # 80216640 <__func__.0+0x138>
    80211744:	f9c00513          	li	a0,-100
    80211748:	ffff2097          	auipc	ra,0xffff2
    8021174c:	614080e7          	jalr	1556(ra) # 80203d5c <create>
    80211750:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211754:	00a036b3          	snez	a3,a0
    80211758:	00048613          	mv	a2,s1
    8021175c:	16800593          	li	a1,360
    80211760:	00005517          	auipc	a0,0x5
    80211764:	df050513          	addi	a0,a0,-528 # 80216550 <__func__.0+0x48>
    80211768:	fffef097          	auipc	ra,0xfffef
    8021176c:	7f0080e7          	jalr	2032(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211770:	00098513          	mv	a0,s3
    80211774:	ffff2097          	auipc	ra,0xffff2
    80211778:	e80080e7          	jalr	-384(ra) # 802035f4 <eunlock>
            eput(ep);
    8021177c:	00098513          	mv	a0,s3
    80211780:	ffff2097          	auipc	ra,0xffff2
    80211784:	e8c080e7          	jalr	-372(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/sys", T_DIR, O_RDONLY);
    80211788:	00000693          	li	a3,0
    8021178c:	00100613          	li	a2,1
    80211790:	00005597          	auipc	a1,0x5
    80211794:	ec058593          	addi	a1,a1,-320 # 80216650 <__func__.0+0x148>
    80211798:	f9c00513          	li	a0,-100
    8021179c:	ffff2097          	auipc	ra,0xffff2
    802117a0:	5c0080e7          	jalr	1472(ra) # 80203d5c <create>
    802117a4:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802117a8:	00a036b3          	snez	a3,a0
    802117ac:	00048613          	mv	a2,s1
    802117b0:	16c00593          	li	a1,364
    802117b4:	00005517          	auipc	a0,0x5
    802117b8:	d9c50513          	addi	a0,a0,-612 # 80216550 <__func__.0+0x48>
    802117bc:	fffef097          	auipc	ra,0xfffef
    802117c0:	79c080e7          	jalr	1948(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802117c4:	00098513          	mv	a0,s3
    802117c8:	ffff2097          	auipc	ra,0xffff2
    802117cc:	e2c080e7          	jalr	-468(ra) # 802035f4 <eunlock>
            eput(ep);
    802117d0:	00098513          	mv	a0,s3
    802117d4:	ffff2097          	auipc	ra,0xffff2
    802117d8:	e38080e7          	jalr	-456(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/sys/kernel", T_DIR, O_RDONLY);
    802117dc:	00000693          	li	a3,0
    802117e0:	00100613          	li	a2,1
    802117e4:	00005597          	auipc	a1,0x5
    802117e8:	e7c58593          	addi	a1,a1,-388 # 80216660 <__func__.0+0x158>
    802117ec:	f9c00513          	li	a0,-100
    802117f0:	ffff2097          	auipc	ra,0xffff2
    802117f4:	56c080e7          	jalr	1388(ra) # 80203d5c <create>
    802117f8:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802117fc:	00a036b3          	snez	a3,a0
    80211800:	00048613          	mv	a2,s1
    80211804:	17000593          	li	a1,368
    80211808:	00005517          	auipc	a0,0x5
    8021180c:	d4850513          	addi	a0,a0,-696 # 80216550 <__func__.0+0x48>
    80211810:	fffef097          	auipc	ra,0xfffef
    80211814:	748080e7          	jalr	1864(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211818:	00098513          	mv	a0,s3
    8021181c:	ffff2097          	auipc	ra,0xffff2
    80211820:	dd8080e7          	jalr	-552(ra) # 802035f4 <eunlock>
            eput(ep);
    80211824:	00098513          	mv	a0,s3
    80211828:	ffff2097          	auipc	ra,0xffff2
    8021182c:	de4080e7          	jalr	-540(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/sys/kernel/osrelease", T_CHAR, O_RDONLY);
    80211830:	00000693          	li	a3,0
    80211834:	00500613          	li	a2,5
    80211838:	00005597          	auipc	a1,0x5
    8021183c:	e4058593          	addi	a1,a1,-448 # 80216678 <__func__.0+0x170>
    80211840:	f9c00513          	li	a0,-100
    80211844:	ffff2097          	auipc	ra,0xffff2
    80211848:	518080e7          	jalr	1304(ra) # 80203d5c <create>
    8021184c:	00050993          	mv	s3,a0
            assert(ep != NULL);
    80211850:	00a036b3          	snez	a3,a0
    80211854:	00048613          	mv	a2,s1
    80211858:	17400593          	li	a1,372
    8021185c:	00005517          	auipc	a0,0x5
    80211860:	cf450513          	addi	a0,a0,-780 # 80216550 <__func__.0+0x48>
    80211864:	fffef097          	auipc	ra,0xfffef
    80211868:	6f4080e7          	jalr	1780(ra) # 80200f58 <_assert_>
            ep->dev = OSRELEASE;
    8021186c:	00c00793          	li	a5,12
    80211870:	22f9a423          	sw	a5,552(s3)
            eunlock(ep);
    80211874:	00098513          	mv	a0,s3
    80211878:	ffff2097          	auipc	ra,0xffff2
    8021187c:	d7c080e7          	jalr	-644(ra) # 802035f4 <eunlock>
            eput(ep);
    80211880:	00098513          	mv	a0,s3
    80211884:	ffff2097          	auipc	ra,0xffff2
    80211888:	d88080e7          	jalr	-632(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/proc/self", T_DIR, O_RDONLY);
    8021188c:	00000693          	li	a3,0
    80211890:	00100613          	li	a2,1
    80211894:	00005597          	auipc	a1,0x5
    80211898:	e0458593          	addi	a1,a1,-508 # 80216698 <__func__.0+0x190>
    8021189c:	f9c00513          	li	a0,-100
    802118a0:	ffff2097          	auipc	ra,0xffff2
    802118a4:	4bc080e7          	jalr	1212(ra) # 80203d5c <create>
    802118a8:	00050993          	mv	s3,a0
            assert(ep != NULL);
    802118ac:	00a036b3          	snez	a3,a0
    802118b0:	00048613          	mv	a2,s1
    802118b4:	17900593          	li	a1,377
    802118b8:	00005517          	auipc	a0,0x5
    802118bc:	c9850513          	addi	a0,a0,-872 # 80216550 <__func__.0+0x48>
    802118c0:	fffef097          	auipc	ra,0xfffef
    802118c4:	698080e7          	jalr	1688(ra) # 80200f58 <_assert_>
            eunlock(ep);
    802118c8:	00098513          	mv	a0,s3
    802118cc:	ffff2097          	auipc	ra,0xffff2
    802118d0:	d28080e7          	jalr	-728(ra) # 802035f4 <eunlock>
            eput(ep);   
    802118d4:	00098513          	mv	a0,s3
    802118d8:	ffff2097          	auipc	ra,0xffff2
    802118dc:	d34080e7          	jalr	-716(ra) # 8020360c <eput>
            if (do_linkat(AT_FDCWD, "/", AT_FDCWD, "/proc/self/exe") < 0) {
    802118e0:	00004697          	auipc	a3,0x4
    802118e4:	58068693          	addi	a3,a3,1408 # 80215e60 <__func__.0+0x1e0>
    802118e8:	f9c00613          	li	a2,-100
    802118ec:	00004597          	auipc	a1,0x4
    802118f0:	56458593          	addi	a1,a1,1380 # 80215e50 <__func__.0+0x1d0>
    802118f4:	f9c00513          	li	a0,-100
    802118f8:	ffff7097          	auipc	ra,0xffff7
    802118fc:	8f4080e7          	jalr	-1804(ra) # 802081ec <do_linkat>
    80211900:	2c054463          	bltz	a0,80211bc8 <threadRun+0xa9c>
                panic("");
            }
            ep = create(AT_FDCWD, "/etc", T_DIR, O_RDONLY);
    80211904:	00000693          	li	a3,0
    80211908:	00100613          	li	a2,1
    8021190c:	00005597          	auipc	a1,0x5
    80211910:	d9c58593          	addi	a1,a1,-612 # 802166a8 <__func__.0+0x1a0>
    80211914:	f9c00513          	li	a0,-100
    80211918:	ffff2097          	auipc	ra,0xffff2
    8021191c:	444080e7          	jalr	1092(ra) # 80203d5c <create>
    80211920:	00050493          	mv	s1,a0
            assert(ep != NULL);
    80211924:	00005997          	auipc	s3,0x5
    80211928:	dfc98993          	addi	s3,s3,-516 # 80216720 <__func__.0>
    8021192c:	00a036b3          	snez	a3,a0
    80211930:	00098613          	mv	a2,s3
    80211934:	18000593          	li	a1,384
    80211938:	00005517          	auipc	a0,0x5
    8021193c:	c1850513          	addi	a0,a0,-1000 # 80216550 <__func__.0+0x48>
    80211940:	fffef097          	auipc	ra,0xfffef
    80211944:	618080e7          	jalr	1560(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211948:	00048513          	mv	a0,s1
    8021194c:	ffff2097          	auipc	ra,0xffff2
    80211950:	ca8080e7          	jalr	-856(ra) # 802035f4 <eunlock>
            eput(ep);
    80211954:	00048513          	mv	a0,s1
    80211958:	ffff2097          	auipc	ra,0xffff2
    8021195c:	cb4080e7          	jalr	-844(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/etc/adjtime", T_CHAR, O_RDONLY);
    80211960:	00000693          	li	a3,0
    80211964:	00500613          	li	a2,5
    80211968:	00005597          	auipc	a1,0x5
    8021196c:	d4858593          	addi	a1,a1,-696 # 802166b0 <__func__.0+0x1a8>
    80211970:	f9c00513          	li	a0,-100
    80211974:	ffff2097          	auipc	ra,0xffff2
    80211978:	3e8080e7          	jalr	1000(ra) # 80203d5c <create>
    8021197c:	00050493          	mv	s1,a0
            assert(ep != NULL);
    80211980:	00a036b3          	snez	a3,a0
    80211984:	00098613          	mv	a2,s3
    80211988:	18400593          	li	a1,388
    8021198c:	00005517          	auipc	a0,0x5
    80211990:	bc450513          	addi	a0,a0,-1084 # 80216550 <__func__.0+0x48>
    80211994:	fffef097          	auipc	ra,0xfffef
    80211998:	5c4080e7          	jalr	1476(ra) # 80200f58 <_assert_>
            eunlock(ep);
    8021199c:	00048513          	mv	a0,s1
    802119a0:	ffff2097          	auipc	ra,0xffff2
    802119a4:	c54080e7          	jalr	-940(ra) # 802035f4 <eunlock>
            eput(ep);
    802119a8:	00048513          	mv	a0,s1
    802119ac:	ffff2097          	auipc	ra,0xffff2
    802119b0:	c60080e7          	jalr	-928(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/etc/localtime", T_CHAR, O_RDONLY);
    802119b4:	00000693          	li	a3,0
    802119b8:	00500613          	li	a2,5
    802119bc:	00005597          	auipc	a1,0x5
    802119c0:	d0458593          	addi	a1,a1,-764 # 802166c0 <__func__.0+0x1b8>
    802119c4:	f9c00513          	li	a0,-100
    802119c8:	ffff2097          	auipc	ra,0xffff2
    802119cc:	394080e7          	jalr	916(ra) # 80203d5c <create>
    802119d0:	00050493          	mv	s1,a0
            eunlock(ep);
    802119d4:	ffff2097          	auipc	ra,0xffff2
    802119d8:	c20080e7          	jalr	-992(ra) # 802035f4 <eunlock>
            eput(ep);
    802119dc:	00048513          	mv	a0,s1
    802119e0:	ffff2097          	auipc	ra,0xffff2
    802119e4:	c2c080e7          	jalr	-980(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/var", T_DIR, O_RDONLY);
    802119e8:	00000693          	li	a3,0
    802119ec:	00100613          	li	a2,1
    802119f0:	00005597          	auipc	a1,0x5
    802119f4:	ce058593          	addi	a1,a1,-800 # 802166d0 <__func__.0+0x1c8>
    802119f8:	f9c00513          	li	a0,-100
    802119fc:	ffff2097          	auipc	ra,0xffff2
    80211a00:	360080e7          	jalr	864(ra) # 80203d5c <create>
    80211a04:	00050493          	mv	s1,a0
            eunlock(ep);
    80211a08:	ffff2097          	auipc	ra,0xffff2
    80211a0c:	bec080e7          	jalr	-1044(ra) # 802035f4 <eunlock>
            eput(ep);
    80211a10:	00048513          	mv	a0,s1
    80211a14:	ffff2097          	auipc	ra,0xffff2
    80211a18:	bf8080e7          	jalr	-1032(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/var/tmp", T_DIR, O_RDONLY);
    80211a1c:	00000693          	li	a3,0
    80211a20:	00100613          	li	a2,1
    80211a24:	00005597          	auipc	a1,0x5
    80211a28:	cb458593          	addi	a1,a1,-844 # 802166d8 <__func__.0+0x1d0>
    80211a2c:	f9c00513          	li	a0,-100
    80211a30:	ffff2097          	auipc	ra,0xffff2
    80211a34:	32c080e7          	jalr	812(ra) # 80203d5c <create>
    80211a38:	00050493          	mv	s1,a0
            eunlock(ep);
    80211a3c:	ffff2097          	auipc	ra,0xffff2
    80211a40:	bb8080e7          	jalr	-1096(ra) # 802035f4 <eunlock>
            eput(ep);
    80211a44:	00048513          	mv	a0,s1
    80211a48:	ffff2097          	auipc	ra,0xffff2
    80211a4c:	bc4080e7          	jalr	-1084(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/var/tmp/XXX", T_FILE, O_RDONLY);
    80211a50:	00000693          	li	a3,0
    80211a54:	00200613          	li	a2,2
    80211a58:	00005597          	auipc	a1,0x5
    80211a5c:	b1058593          	addi	a1,a1,-1264 # 80216568 <__func__.0+0x60>
    80211a60:	f9c00513          	li	a0,-100
    80211a64:	ffff2097          	auipc	ra,0xffff2
    80211a68:	2f8080e7          	jalr	760(ra) # 80203d5c <create>
    80211a6c:	00050493          	mv	s1,a0
            assert(ep != NULL);
    80211a70:	00a036b3          	snez	a3,a0
    80211a74:	00098613          	mv	a2,s3
    80211a78:	19100593          	li	a1,401
    80211a7c:	00005517          	auipc	a0,0x5
    80211a80:	ad450513          	addi	a0,a0,-1324 # 80216550 <__func__.0+0x48>
    80211a84:	fffef097          	auipc	ra,0xfffef
    80211a88:	4d4080e7          	jalr	1236(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211a8c:	00048513          	mv	a0,s1
    80211a90:	ffff2097          	auipc	ra,0xffff2
    80211a94:	b64080e7          	jalr	-1180(ra) # 802035f4 <eunlock>
            eput(ep);
    80211a98:	00048513          	mv	a0,s1
    80211a9c:	ffff2097          	auipc	ra,0xffff2
    80211aa0:	b70080e7          	jalr	-1168(ra) # 8020360c <eput>
            ep = create(AT_FDCWD, "/hello", T_FILE, O_RDONLY);
    80211aa4:	00000693          	li	a3,0
    80211aa8:	00200613          	li	a2,2
    80211aac:	00005597          	auipc	a1,0x5
    80211ab0:	c3c58593          	addi	a1,a1,-964 # 802166e8 <__func__.0+0x1e0>
    80211ab4:	f9c00513          	li	a0,-100
    80211ab8:	ffff2097          	auipc	ra,0xffff2
    80211abc:	2a4080e7          	jalr	676(ra) # 80203d5c <create>
    80211ac0:	00050493          	mv	s1,a0
            assert(ep != NULL);
    80211ac4:	00a036b3          	snez	a3,a0
    80211ac8:	00098613          	mv	a2,s3
    80211acc:	19500593          	li	a1,405
    80211ad0:	00005517          	auipc	a0,0x5
    80211ad4:	a8050513          	addi	a0,a0,-1408 # 80216550 <__func__.0+0x48>
    80211ad8:	fffef097          	auipc	ra,0xfffef
    80211adc:	480080e7          	jalr	1152(ra) # 80200f58 <_assert_>
            eunlock(ep);
    80211ae0:	00048513          	mv	a0,s1
    80211ae4:	ffff2097          	auipc	ra,0xffff2
    80211ae8:	b10080e7          	jalr	-1264(ra) # 802035f4 <eunlock>
            eput(ep);
    80211aec:	00048513          	mv	a0,s1
    80211af0:	ffff2097          	auipc	ra,0xffff2
    80211af4:	b1c080e7          	jalr	-1252(ra) # 8020360c <eput>
    80211af8:	00020713          	mv	a4,tp
            // setNextTimeout();
        }
        bcopy(&(currentThread[r_hartid()]->trapframe), trapframe, sizeof(Trapframe));
    80211afc:	00371713          	slli	a4,a4,0x3
    80211b00:	020d7797          	auipc	a5,0x20d7
    80211b04:	b9878793          	addi	a5,a5,-1128 # 822e8698 <currentThread>
    80211b08:	00e787b3          	add	a5,a5,a4
    80211b0c:	22000613          	li	a2,544
    80211b10:	000a0593          	mv	a1,s4
    80211b14:	0007b503          	ld	a0,0(a5)
    80211b18:	ffff7097          	auipc	ra,0xffff7
    80211b1c:	188080e7          	jalr	392(ra) # 80208ca0 <bcopy>
        u64 sp = getHartKernelTopSp(th);
    80211b20:	00090513          	mv	a0,s2
    80211b24:	ffff8097          	auipc	ra,0xffff8
    80211b28:	6f0080e7          	jalr	1776(ra) # 8020a214 <getHartKernelTopSp>
    80211b2c:	faa43c23          	sd	a0,-72(s0)
        asm volatile("ld sp, 0(%0)" : :"r"(&sp): "memory");
    80211b30:	fb840793          	addi	a5,s0,-72
    80211b34:	0007b103          	ld	sp,0(a5)
        // // releaseLock(&currentProcessLock);
        userTrapReturn();
    80211b38:	ffffd097          	auipc	ra,0xffffd
    80211b3c:	a9c080e7          	jalr	-1380(ra) # 8020e5d4 <userTrapReturn>
    }
}
    80211b40:	04813083          	ld	ra,72(sp)
    80211b44:	04013403          	ld	s0,64(sp)
    80211b48:	03813483          	ld	s1,56(sp)
    80211b4c:	03013903          	ld	s2,48(sp)
    80211b50:	02813983          	ld	s3,40(sp)
    80211b54:	02013a03          	ld	s4,32(sp)
    80211b58:	01813a83          	ld	s5,24(sp)
    80211b5c:	05010113          	addi	sp,sp,80
    80211b60:	00008067          	ret
        th->reason &= ~KERNEL_GIVE_UP;
    80211b64:	ffe7f793          	andi	a5,a5,-2
    80211b68:	28f92023          	sw	a5,640(s2)
    80211b6c:	00020793          	mv	a5,tp
        currentThread[r_hartid()] = th;
    80211b70:	020d7717          	auipc	a4,0x20d7
    80211b74:	b2870713          	addi	a4,a4,-1240 # 822e8698 <currentThread>
    80211b78:	00379793          	slli	a5,a5,0x3
    80211b7c:	00f707b3          	add	a5,a4,a5
    80211b80:	0127b023          	sd	s2,0(a5)
    80211b84:	00020793          	mv	a5,tp
        bcopy(&currentThread[r_hartid()]->trapframe, trapframe, sizeof(Trapframe));
    80211b88:	00379793          	slli	a5,a5,0x3
    80211b8c:	00f70733          	add	a4,a4,a5
    80211b90:	22000613          	li	a2,544
    80211b94:	000a0593          	mv	a1,s4
    80211b98:	00073503          	ld	a0,0(a4)
    80211b9c:	ffff7097          	auipc	ra,0xffff7
    80211ba0:	104080e7          	jalr	260(ra) # 80208ca0 <bcopy>
        asm volatile("ld sp, 0(%0)" : : "r"(&th->currentKernelSp));
    80211ba4:	27890913          	addi	s2,s2,632
    80211ba8:	00093103          	ld	sp,0(s2)
        sleepRec();
    80211bac:	ffffa097          	auipc	ra,0xffffa
    80211bb0:	6f4080e7          	jalr	1780(ra) # 8020c2a0 <sleepRec>
                fsAlloc(&rootFileSystem);
    80211bb4:	010a6517          	auipc	a0,0x10a6
    80211bb8:	62450513          	addi	a0,a0,1572 # 812b81d8 <rootFileSystem>
    80211bbc:	ffff3097          	auipc	ra,0xffff3
    80211bc0:	ae8080e7          	jalr	-1304(ra) # 802046a4 <fsAlloc>
    80211bc4:	e2cff06f          	j	802111f0 <threadRun+0xc4>
                panic("");
    80211bc8:	00004697          	auipc	a3,0x4
    80211bcc:	02068693          	addi	a3,a3,32 # 80215be8 <__func__.0+0x48>
    80211bd0:	00048613          	mv	a2,s1
    80211bd4:	17d00593          	li	a1,381
    80211bd8:	00005517          	auipc	a0,0x5
    80211bdc:	97850513          	addi	a0,a0,-1672 # 80216550 <__func__.0+0x48>
    80211be0:	fffef097          	auipc	ra,0xfffef
    80211be4:	308080e7          	jalr	776(ra) # 80200ee8 <_panic_>

0000000080211be8 <sleep>:

void sleepSave();
void sleep(void* chan, struct Spinlock* lk) { 
    80211be8:	fe010113          	addi	sp,sp,-32
    80211bec:	00113c23          	sd	ra,24(sp)
    80211bf0:	00813823          	sd	s0,16(sp)
    80211bf4:	00913423          	sd	s1,8(sp)
    80211bf8:	01213023          	sd	s2,0(sp)
    80211bfc:	02010413          	addi	s0,sp,32
    80211c00:	00050913          	mv	s2,a0
    Thread* th = myThread();
    80211c04:	fffff097          	auipc	ra,0xfffff
    80211c08:	93c080e7          	jalr	-1732(ra) # 80210540 <myThread>
    80211c0c:	00050493          	mv	s1,a0
    // Once we hold p->lock, we can be
    // guaranteed that we won't miss any wakeup
    // (wakeup locks p->lock),
    // so it's okay to release lk.

    kernelProcessCpuTimeEnd();
    80211c10:	fffff097          	auipc	ra,0xfffff
    80211c14:	918080e7          	jalr	-1768(ra) # 80210528 <kernelProcessCpuTimeEnd>
    // acquireLock(&th->lock);  // DOC: sleeplock1
    // releaseLock(lk);

    // Go to sleep.
    th->chan = (u64)chan;
    80211c18:	2724b823          	sd	s2,624(s1)
    th->state = SLEEPING;
    80211c1c:	00100793          	li	a5,1
    80211c20:	24f4a823          	sw	a5,592(s1)
    th->reason |= KERNEL_GIVE_UP;
    80211c24:	2804a783          	lw	a5,640(s1)
    80211c28:	0017e793          	ori	a5,a5,1
    80211c2c:	28f4a023          	sw	a5,640(s1)
    // releaseLock(&th->lock);

    if (hasKillSignal(th)) {
    80211c30:	00048513          	mv	a0,s1
    80211c34:	ffff9097          	auipc	ra,0xffff9
    80211c38:	bb8080e7          	jalr	-1096(ra) # 8020a7ec <hasKillSignal>
    80211c3c:	04051463          	bnez	a0,80211c84 <sleep+0x9c>
        threadDestroy(th);
    }    

	asm volatile("sd sp, 0(%0)" : :"r"(&th->currentKernelSp));
    80211c40:	27848793          	addi	a5,s1,632
    80211c44:	0027b023          	sd	sp,0(a5)

    sleepSave();
    80211c48:	ffffa097          	auipc	ra,0xffffa
    80211c4c:	5f8080e7          	jalr	1528(ra) # 8020c240 <sleepSave>

    // // Tidy up.
    // acquireLock(&th->lock);  // DOC: sleeplock1
    th->chan = 0;
    80211c50:	2604b823          	sd	zero,624(s1)
    // releaseLock(&th->lock);

    kernelProcessCpuTimeBegin();
    80211c54:	fffff097          	auipc	ra,0xfffff
    80211c58:	8bc080e7          	jalr	-1860(ra) # 80210510 <kernelProcessCpuTimeBegin>
    
    if (hasKillSignal(th)) {
    80211c5c:	00048513          	mv	a0,s1
    80211c60:	ffff9097          	auipc	ra,0xffff9
    80211c64:	b8c080e7          	jalr	-1140(ra) # 8020a7ec <hasKillSignal>
    80211c68:	02051663          	bnez	a0,80211c94 <sleep+0xac>
        threadDestroy(th);    
    }    
    // Reacquire original lock.
    // acquireLock(lk);
}
    80211c6c:	01813083          	ld	ra,24(sp)
    80211c70:	01013403          	ld	s0,16(sp)
    80211c74:	00813483          	ld	s1,8(sp)
    80211c78:	00013903          	ld	s2,0(sp)
    80211c7c:	02010113          	addi	sp,sp,32
    80211c80:	00008067          	ret
        threadDestroy(th);
    80211c84:	00048513          	mv	a0,s1
    80211c88:	fffff097          	auipc	ra,0xfffff
    80211c8c:	bb4080e7          	jalr	-1100(ra) # 8021083c <threadDestroy>
    80211c90:	fb1ff06f          	j	80211c40 <sleep+0x58>
        threadDestroy(th);    
    80211c94:	00048513          	mv	a0,s1
    80211c98:	fffff097          	auipc	ra,0xfffff
    80211c9c:	ba4080e7          	jalr	-1116(ra) # 8021083c <threadDestroy>
}
    80211ca0:	fcdff06f          	j	80211c6c <sleep+0x84>

0000000080211ca4 <wakeup>:

void wakeup(void* channel) {
    80211ca4:	fc010113          	addi	sp,sp,-64
    80211ca8:	02113c23          	sd	ra,56(sp)
    80211cac:	02813823          	sd	s0,48(sp)
    80211cb0:	02913423          	sd	s1,40(sp)
    80211cb4:	03213023          	sd	s2,32(sp)
    80211cb8:	01313c23          	sd	s3,24(sp)
    80211cbc:	01413823          	sd	s4,16(sp)
    80211cc0:	01513423          	sd	s5,8(sp)
    80211cc4:	04010413          	addi	s0,sp,64
    80211cc8:	00050a13          	mv	s4,a0
    for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    80211ccc:	020d7497          	auipc	s1,0x20d7
    80211cd0:	a4c48493          	addi	s1,s1,-1460 # 822e8718 <threads>
    80211cd4:	0215d917          	auipc	s2,0x215d
    80211cd8:	a4490913          	addi	s2,s2,-1468 # 8236e718 <first.1>
        if (&threads[i] != myThread()) {
            // acquireLock(&threads[i].lock);
            if (threads[i].state == SLEEPING && threads[i].chan == (u64)channel) {
    80211cdc:	00100993          	li	s3,1
                threads[i].state = RUNNABLE;
    80211ce0:	00200a93          	li	s5,2
    80211ce4:	00c0006f          	j	80211cf0 <wakeup+0x4c>
    for (int i = 0; i < PROCESS_TOTAL_NUMBER; ++i) {
    80211ce8:	43048493          	addi	s1,s1,1072
    80211cec:	03248463          	beq	s1,s2,80211d14 <wakeup+0x70>
        if (&threads[i] != myThread()) {
    80211cf0:	fffff097          	auipc	ra,0xfffff
    80211cf4:	850080e7          	jalr	-1968(ra) # 80210540 <myThread>
    80211cf8:	fe9508e3          	beq	a0,s1,80211ce8 <wakeup+0x44>
            if (threads[i].state == SLEEPING && threads[i].chan == (u64)channel) {
    80211cfc:	2504a783          	lw	a5,592(s1)
    80211d00:	ff3794e3          	bne	a5,s3,80211ce8 <wakeup+0x44>
    80211d04:	2704b783          	ld	a5,624(s1)
    80211d08:	fefa10e3          	bne	s4,a5,80211ce8 <wakeup+0x44>
                threads[i].state = RUNNABLE;
    80211d0c:	2554a823          	sw	s5,592(s1)
    80211d10:	fd9ff06f          	j	80211ce8 <wakeup+0x44>
                // printf("wake up thread %lx\n", threads[i].id);
            }
            // releaseLock(&threads[i].lock);
        }
    }
}
    80211d14:	03813083          	ld	ra,56(sp)
    80211d18:	03013403          	ld	s0,48(sp)
    80211d1c:	02813483          	ld	s1,40(sp)
    80211d20:	02013903          	ld	s2,32(sp)
    80211d24:	01813983          	ld	s3,24(sp)
    80211d28:	01013a03          	ld	s4,16(sp)
    80211d2c:	00813a83          	ld	s5,8(sp)
    80211d30:	04010113          	addi	sp,sp,64
    80211d34:	00008067          	ret

0000000080211d38 <yield>:
extern struct ThreadList scheduleList[2];

static int processTimeCount[HART_TOTAL_NUMBER] = {0};
static int processBelongList[HART_TOTAL_NUMBER] = {0};

void yield() {
    80211d38:	fd010113          	addi	sp,sp,-48
    80211d3c:	02113423          	sd	ra,40(sp)
    80211d40:	02813023          	sd	s0,32(sp)
    80211d44:	00913c23          	sd	s1,24(sp)
    80211d48:	01213823          	sd	s2,16(sp)
    80211d4c:	01313423          	sd	s3,8(sp)
    80211d50:	01413023          	sd	s4,0(sp)
    80211d54:	03010413          	addi	s0,sp,48
    80211d58:	00020a13          	mv	s4,tp
    int hartId = r_hartid();
    80211d5c:	000a0a1b          	sext.w	s4,s4
    int count = processTimeCount[hartId];
    80211d60:	002a1713          	slli	a4,s4,0x2
    80211d64:	0215d797          	auipc	a5,0x215d
    80211d68:	9c478793          	addi	a5,a5,-1596 # 8236e728 <processTimeCount>
    80211d6c:	00e787b3          	add	a5,a5,a4
    80211d70:	0007a983          	lw	s3,0(a5)
    int point = processBelongList[hartId];
    80211d74:	0187a903          	lw	s2,24(a5)
    struct Thread* thread = myThread(); 
    80211d78:	ffffe097          	auipc	ra,0xffffe
    80211d7c:	7c8080e7          	jalr	1992(ra) # 80210540 <myThread>
    80211d80:	00050493          	mv	s1,a0
    // acquireLock(&scheduleListLock);
    if (thread && thread->state == RUNNING) {
    80211d84:	00050863          	beqz	a0,80211d94 <yield+0x5c>
    80211d88:	25052703          	lw	a4,592(a0)
    80211d8c:	00300793          	li	a5,3
    80211d90:	00f70c63          	beq	a4,a5,80211da8 <yield+0x70>
        if (thread->reason & KERNEL_GIVE_UP) {
            bcopy(getHartTrapFrame(), &thread->trapframe, sizeof(Trapframe));
        }
        thread->state = RUNNABLE;
    }
    while ((count == 0) || !thread || (thread->state != RUNNABLE)/* || thread->awakeTime > r_time()*/) {
    80211d94:	00200513          	li	a0,2
        if (thread)
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], thread, scheduleLink);
    80211d98:	020d7697          	auipc	a3,0x20d7
    80211d9c:	97068693          	addi	a3,a3,-1680 # 822e8708 <scheduleList>
        if (LIST_EMPTY(&scheduleList[point]))
            point ^= 1;
        if (!(LIST_EMPTY(&scheduleList[point]))) {
            thread = LIST_FIRST(&scheduleList[point]);
            LIST_REMOVE(thread, scheduleLink);
            count = 1;
    80211da0:	00100593          	li	a1,1
    80211da4:	0980006f          	j	80211e3c <yield+0x104>
        if (thread->reason & KERNEL_GIVE_UP) {
    80211da8:	28052783          	lw	a5,640(a0)
    80211dac:	0017f793          	andi	a5,a5,1
    80211db0:	00079863          	bnez	a5,80211dc0 <yield+0x88>
        thread->state = RUNNABLE;
    80211db4:	00200793          	li	a5,2
    80211db8:	24f4a823          	sw	a5,592(s1)
    80211dbc:	fd9ff06f          	j	80211d94 <yield+0x5c>
            bcopy(getHartTrapFrame(), &thread->trapframe, sizeof(Trapframe));
    80211dc0:	ffff8097          	auipc	ra,0xffff8
    80211dc4:	41c080e7          	jalr	1052(ra) # 8020a1dc <getHartTrapFrame>
    80211dc8:	22000613          	li	a2,544
    80211dcc:	00048593          	mv	a1,s1
    80211dd0:	ffff7097          	auipc	ra,0xffff7
    80211dd4:	ed0080e7          	jalr	-304(ra) # 80208ca0 <bcopy>
    80211dd8:	fddff06f          	j	80211db4 <yield+0x7c>
        if (thread)
    80211ddc:	02048663          	beqz	s1,80211e08 <yield+0xd0>
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], thread, scheduleLink);
    80211de0:	00194793          	xori	a5,s2,1
    80211de4:	00379713          	slli	a4,a5,0x3
    80211de8:	00e68733          	add	a4,a3,a4
    80211dec:	00073703          	ld	a4,0(a4)
    80211df0:	0a071663          	bnez	a4,80211e9c <yield+0x164>
    80211df4:	2404b023          	sd	zero,576(s1)
    80211df8:	00379793          	slli	a5,a5,0x3
    80211dfc:	00f687b3          	add	a5,a3,a5
    80211e00:	0097b023          	sd	s1,0(a5)
    80211e04:	24f4b423          	sd	a5,584(s1)
        if (LIST_EMPTY(&scheduleList[point]))
    80211e08:	00391793          	slli	a5,s2,0x3
    80211e0c:	00f687b3          	add	a5,a3,a5
    80211e10:	0007b783          	ld	a5,0(a5)
    80211e14:	0a078e63          	beqz	a5,80211ed0 <yield+0x198>
            LIST_REMOVE(thread, scheduleLink);
    80211e18:	2407b703          	ld	a4,576(a5)
    80211e1c:	00070663          	beqz	a4,80211e28 <yield+0xf0>
    80211e20:	2487b603          	ld	a2,584(a5)
    80211e24:	24c73423          	sd	a2,584(a4)
    80211e28:	2487b703          	ld	a4,584(a5)
    80211e2c:	2407b603          	ld	a2,576(a5)
    80211e30:	00c73023          	sd	a2,0(a4)
    80211e34:	00078493          	mv	s1,a5
            count = 1;
    80211e38:	00058993          	mv	s3,a1
    while ((count == 0) || !thread || (thread->state != RUNNABLE)/* || thread->awakeTime > r_time()*/) {
    80211e3c:	fa0980e3          	beqz	s3,80211ddc <yield+0xa4>
    80211e40:	fc0484e3          	beqz	s1,80211e08 <yield+0xd0>
    80211e44:	2504a783          	lw	a5,592(s1)
    80211e48:	f8a79ce3          	bne	a5,a0,80211de0 <yield+0xa8>
        // releaseLock(&scheduleListLock);
        // acquireLock(&scheduleListLock);
    }
    // releaseLock(&scheduleListLock);
    count--;
    processTimeCount[hartId] = count;
    80211e4c:	002a1a13          	slli	s4,s4,0x2
    80211e50:	0215d797          	auipc	a5,0x215d
    80211e54:	8d878793          	addi	a5,a5,-1832 # 8236e728 <processTimeCount>
    80211e58:	014787b3          	add	a5,a5,s4
    count--;
    80211e5c:	fff9899b          	addiw	s3,s3,-1
    processTimeCount[hartId] = count;
    80211e60:	0137a023          	sw	s3,0(a5)
    processBelongList[hartId] = point;
    80211e64:	0127ac23          	sw	s2,24(a5)
    // printf("hartID %d yield thread %lx, the process is %lx\n", hartId, thread->id, thread->process->processId);
    if (thread->awakeTime > 0) {
    80211e68:	2304b783          	ld	a5,560(s1)
    80211e6c:	06079e63          	bnez	a5,80211ee8 <yield+0x1b0>
        getHartTrapFrame()->a0 = 0;
        thread->awakeTime = 0;
    }
    // futexClear(thread);
    threadRun(thread);
    80211e70:	00048513          	mv	a0,s1
    80211e74:	fffff097          	auipc	ra,0xfffff
    80211e78:	2b8080e7          	jalr	696(ra) # 8021112c <threadRun>
    80211e7c:	02813083          	ld	ra,40(sp)
    80211e80:	02013403          	ld	s0,32(sp)
    80211e84:	01813483          	ld	s1,24(sp)
    80211e88:	01013903          	ld	s2,16(sp)
    80211e8c:	00813983          	ld	s3,8(sp)
    80211e90:	00013a03          	ld	s4,0(sp)
    80211e94:	03010113          	addi	sp,sp,48
    80211e98:	00008067          	ret
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], thread, scheduleLink);
    80211e9c:	24e4b023          	sd	a4,576(s1)
    80211ea0:	24073783          	ld	a5,576(a4)
    80211ea4:	00078a63          	beqz	a5,80211eb8 <yield+0x180>
    80211ea8:	24f4b023          	sd	a5,576(s1)
    80211eac:	00078713          	mv	a4,a5
    80211eb0:	2407b783          	ld	a5,576(a5)
    80211eb4:	fe079ae3          	bnez	a5,80211ea8 <yield+0x170>
    80211eb8:	24973023          	sd	s1,576(a4)
    80211ebc:	2404b783          	ld	a5,576(s1)
    80211ec0:	24078793          	addi	a5,a5,576
    80211ec4:	24f4b423          	sd	a5,584(s1)
    80211ec8:	2404b023          	sd	zero,576(s1)
    80211ecc:	f3dff06f          	j	80211e08 <yield+0xd0>
            point ^= 1;
    80211ed0:	00194913          	xori	s2,s2,1
        if (!(LIST_EMPTY(&scheduleList[point]))) {
    80211ed4:	00391793          	slli	a5,s2,0x3
    80211ed8:	00f687b3          	add	a5,a3,a5
    80211edc:	0007b783          	ld	a5,0(a5)
    80211ee0:	f4078ee3          	beqz	a5,80211e3c <yield+0x104>
    80211ee4:	f35ff06f          	j	80211e18 <yield+0xe0>
        getHartTrapFrame()->a0 = 0;
    80211ee8:	ffff8097          	auipc	ra,0xffff8
    80211eec:	2f4080e7          	jalr	756(ra) # 8020a1dc <getHartTrapFrame>
    80211ef0:	06053823          	sd	zero,112(a0)
        thread->awakeTime = 0;
    80211ef4:	2204b823          	sd	zero,560(s1)
    80211ef8:	f79ff06f          	j	80211e70 <yield+0x138>
	...

0000000080212000 <_trampoline>:
    80212000:	14051573          	csrrw	a0,sscratch,a0
    80212004:	02153423          	sd	ra,40(a0)
    80212008:	02253823          	sd	sp,48(a0)
    8021200c:	02353c23          	sd	gp,56(a0)
    80212010:	04453023          	sd	tp,64(a0)
    80212014:	04553423          	sd	t0,72(a0)
    80212018:	04653823          	sd	t1,80(a0)
    8021201c:	04753c23          	sd	t2,88(a0)
    80212020:	06853023          	sd	s0,96(a0)
    80212024:	06953423          	sd	s1,104(a0)
    80212028:	06b53c23          	sd	a1,120(a0)
    8021202c:	08c53023          	sd	a2,128(a0)
    80212030:	08d53423          	sd	a3,136(a0)
    80212034:	08e53823          	sd	a4,144(a0)
    80212038:	08f53c23          	sd	a5,152(a0)
    8021203c:	0b053023          	sd	a6,160(a0)
    80212040:	0b153423          	sd	a7,168(a0)
    80212044:	0b253823          	sd	s2,176(a0)
    80212048:	0b353c23          	sd	s3,184(a0)
    8021204c:	0d453023          	sd	s4,192(a0)
    80212050:	0d553423          	sd	s5,200(a0)
    80212054:	0d653823          	sd	s6,208(a0)
    80212058:	0d753c23          	sd	s7,216(a0)
    8021205c:	0f853023          	sd	s8,224(a0)
    80212060:	0f953423          	sd	s9,232(a0)
    80212064:	0fa53823          	sd	s10,240(a0)
    80212068:	0fb53c23          	sd	s11,248(a0)
    8021206c:	11c53023          	sd	t3,256(a0)
    80212070:	11d53423          	sd	t4,264(a0)
    80212074:	11e53823          	sd	t5,272(a0)
    80212078:	11f53c23          	sd	t6,280(a0)
    8021207c:	12053027          	fsd	ft0,288(a0)
    80212080:	12153427          	fsd	ft1,296(a0)
    80212084:	12253827          	fsd	ft2,304(a0)
    80212088:	12353c27          	fsd	ft3,312(a0)
    8021208c:	14453027          	fsd	ft4,320(a0)
    80212090:	14553427          	fsd	ft5,328(a0)
    80212094:	14653827          	fsd	ft6,336(a0)
    80212098:	14753c27          	fsd	ft7,344(a0)
    8021209c:	16853027          	fsd	fs0,352(a0)
    802120a0:	16953427          	fsd	fs1,360(a0)
    802120a4:	16a53827          	fsd	fa0,368(a0)
    802120a8:	16b53c27          	fsd	fa1,376(a0)
    802120ac:	18c53027          	fsd	fa2,384(a0)
    802120b0:	18d53427          	fsd	fa3,392(a0)
    802120b4:	18e53827          	fsd	fa4,400(a0)
    802120b8:	18f53c27          	fsd	fa5,408(a0)
    802120bc:	1b053027          	fsd	fa6,416(a0)
    802120c0:	1b153427          	fsd	fa7,424(a0)
    802120c4:	1b253827          	fsd	fs2,432(a0)
    802120c8:	1b353c27          	fsd	fs3,440(a0)
    802120cc:	1d453027          	fsd	fs4,448(a0)
    802120d0:	1d553427          	fsd	fs5,456(a0)
    802120d4:	1d653827          	fsd	fs6,464(a0)
    802120d8:	1d753c27          	fsd	fs7,472(a0)
    802120dc:	1f853027          	fsd	fs8,480(a0)
    802120e0:	1f953427          	fsd	fs9,488(a0)
    802120e4:	1fa53827          	fsd	fs10,496(a0)
    802120e8:	1fb53c27          	fsd	fs11,504(a0)
    802120ec:	21c53027          	fsd	ft8,512(a0)
    802120f0:	21d53427          	fsd	ft9,520(a0)
    802120f4:	21e53827          	fsd	ft10,528(a0)
    802120f8:	21f53c27          	fsd	ft11,536(a0)
    802120fc:	140022f3          	csrr	t0,sscratch
    80212100:	06553823          	sd	t0,112(a0)
    80212104:	00853103          	ld	sp,8(a0)
    80212108:	02053203          	ld	tp,32(a0)
    8021210c:	01053283          	ld	t0,16(a0)
    80212110:	14102373          	csrr	t1,sepc
    80212114:	00653c23          	sd	t1,24(a0)
    80212118:	00053303          	ld	t1,0(a0)
    8021211c:	18031073          	csrw	satp,t1
    80212120:	12000073          	sfence.vma
    80212124:	00028067          	jr	t0

0000000080212128 <userReturn>:
    80212128:	18059073          	csrw	satp,a1
    8021212c:	12000073          	sfence.vma
    80212130:	07053283          	ld	t0,112(a0)
    80212134:	14029073          	csrw	sscratch,t0
    80212138:	01853303          	ld	t1,24(a0)
    8021213c:	14131073          	csrw	sepc,t1
    80212140:	02853083          	ld	ra,40(a0)
    80212144:	03053103          	ld	sp,48(a0)
    80212148:	03853183          	ld	gp,56(a0)
    8021214c:	04053203          	ld	tp,64(a0)
    80212150:	04853283          	ld	t0,72(a0)
    80212154:	05053303          	ld	t1,80(a0)
    80212158:	05853383          	ld	t2,88(a0)
    8021215c:	06053403          	ld	s0,96(a0)
    80212160:	06853483          	ld	s1,104(a0)
    80212164:	07853583          	ld	a1,120(a0)
    80212168:	08053603          	ld	a2,128(a0)
    8021216c:	08853683          	ld	a3,136(a0)
    80212170:	09053703          	ld	a4,144(a0)
    80212174:	09853783          	ld	a5,152(a0)
    80212178:	0a053803          	ld	a6,160(a0)
    8021217c:	0a853883          	ld	a7,168(a0)
    80212180:	0b053903          	ld	s2,176(a0)
    80212184:	0b853983          	ld	s3,184(a0)
    80212188:	0c053a03          	ld	s4,192(a0)
    8021218c:	0c853a83          	ld	s5,200(a0)
    80212190:	0d053b03          	ld	s6,208(a0)
    80212194:	0d853b83          	ld	s7,216(a0)
    80212198:	0e053c03          	ld	s8,224(a0)
    8021219c:	0e853c83          	ld	s9,232(a0)
    802121a0:	0f053d03          	ld	s10,240(a0)
    802121a4:	0f853d83          	ld	s11,248(a0)
    802121a8:	10053e03          	ld	t3,256(a0)
    802121ac:	10853e83          	ld	t4,264(a0)
    802121b0:	11053f03          	ld	t5,272(a0)
    802121b4:	11853f83          	ld	t6,280(a0)
    802121b8:	12053007          	fld	ft0,288(a0)
    802121bc:	12853087          	fld	ft1,296(a0)
    802121c0:	13053107          	fld	ft2,304(a0)
    802121c4:	13853187          	fld	ft3,312(a0)
    802121c8:	14053207          	fld	ft4,320(a0)
    802121cc:	14853287          	fld	ft5,328(a0)
    802121d0:	15053307          	fld	ft6,336(a0)
    802121d4:	15853387          	fld	ft7,344(a0)
    802121d8:	16053407          	fld	fs0,352(a0)
    802121dc:	16853487          	fld	fs1,360(a0)
    802121e0:	17053507          	fld	fa0,368(a0)
    802121e4:	17853587          	fld	fa1,376(a0)
    802121e8:	18053607          	fld	fa2,384(a0)
    802121ec:	18853687          	fld	fa3,392(a0)
    802121f0:	19053707          	fld	fa4,400(a0)
    802121f4:	19853787          	fld	fa5,408(a0)
    802121f8:	1a053807          	fld	fa6,416(a0)
    802121fc:	1a853887          	fld	fa7,424(a0)
    80212200:	1b053907          	fld	fs2,432(a0)
    80212204:	1b853987          	fld	fs3,440(a0)
    80212208:	1c053a07          	fld	fs4,448(a0)
    8021220c:	1c853a87          	fld	fs5,456(a0)
    80212210:	1d053b07          	fld	fs6,464(a0)
    80212214:	1d853b87          	fld	fs7,472(a0)
    80212218:	1e053c07          	fld	fs8,480(a0)
    8021221c:	1e853c87          	fld	fs9,488(a0)
    80212220:	1f053d07          	fld	fs10,496(a0)
    80212224:	1f853d87          	fld	fs11,504(a0)
    80212228:	20053e07          	fld	ft8,512(a0)
    8021222c:	20853e87          	fld	ft9,520(a0)
    80212230:	21053f07          	fld	ft10,528(a0)
    80212234:	21853f87          	fld	ft11,536(a0)
    80212238:	14051573          	csrrw	a0,sscratch,a0
    8021223c:	10200073          	sret
	...

0000000080213000 <trapframe>:
	...

0000000080214000 <_signalTrampoline>:
    80214000:	08b00893          	li	a7,139
    80214004:	00000073          	ecall
	...
