
target/vmlinux.img:     file format elf64-littleriscv


Disassembly of section .text:

0000000080200000 <_start>:
    80200000:	82aa                	mv	t0,a0
    80200002:	02c2                	slli	t0,t0,0x10
    80200004:	00015117          	auipc	sp,0x15
    80200008:	ffc10113          	addi	sp,sp,-4 # 80215000 <_stack>
    8020000c:	9116                	add	sp,sp,t0
    8020000e:	006000ef          	jal	ra,80200014 <main>

0000000080200012 <loop>:
    80200012:	a001                	j	80200012 <loop>

0000000080200014 <main>:
    asm volatile("mv tp, %0" : : "r" (hartId & 0x7));
}

//void ffff(int);
u8 binary[1024];
void main(u64 hartId) {
    80200014:	7179                	addi	sp,sp,-48
    80200016:	f406                	sd	ra,40(sp)
    80200018:	f022                	sd	s0,32(sp)
    8020001a:	ec26                	sd	s1,24(sp)
    8020001c:	1800                	addi	s0,sp,48
    8020001e:	84aa                	mv	s1,a0
    asm volatile("mv tp, %0" : : "r" (hartId & 0x7));
    80200020:	00757793          	andi	a5,a0,7
    80200024:	823e                	mv	tp,a5
    initHartId(hartId);

    if (mainCount == 1000) {
    80200026:	00055717          	auipc	a4,0x55
    8020002a:	fda72703          	lw	a4,-38(a4) # 80255000 <mainCount>
    8020002e:	3e800793          	li	a5,1000
    80200032:	12f71063          	bne	a4,a5,80200152 <main+0x13e>
        extern u64 bssStart[];
        extern u64 bssEnd[];
        for (u64 *i = bssStart; i < bssEnd; i++) {
    80200036:	00056717          	auipc	a4,0x56
    8020003a:	fca70713          	addi	a4,a4,-54 # 80256000 <binary>
    8020003e:	0016e797          	auipc	a5,0x16e
    80200042:	fc278793          	addi	a5,a5,-62 # 8036e000 <bssEnd>
    80200046:	02f77063          	bgeu	a4,a5,80200066 <main+0x52>
    8020004a:	87ba                	mv	a5,a4
    8020004c:	0016e717          	auipc	a4,0x16e
    80200050:	fb370713          	addi	a4,a4,-77 # 8036dfff <_pgdir+0xfff>
    80200054:	8f1d                	sub	a4,a4,a5
    80200056:	9b61                	andi	a4,a4,-8
    80200058:	0721                	addi	a4,a4,8
    8020005a:	973e                	add	a4,a4,a5
            *i = 0;
    8020005c:	0007b023          	sd	zero,0(a5)
        for (u64 *i = bssStart; i < bssEnd; i++) {
    80200060:	07a1                	addi	a5,a5,8
    80200062:	fee79de3          	bne	a5,a4,8020005c <main+0x48>
        }
        mainCount = mainCount + 1;
    80200066:	00055717          	auipc	a4,0x55
    8020006a:	f9a70713          	addi	a4,a4,-102 # 80255000 <mainCount>
    8020006e:	431c                	lw	a5,0(a4)
    80200070:	2785                	addiw	a5,a5,1
    80200072:	c31c                	sw	a5,0(a4)

        consoleInit();
    80200074:	00000097          	auipc	ra,0x0
    80200078:	13a080e7          	jalr	314(ra) # 802001ae <consoleInit>
        printLockInit();
    8020007c:	00000097          	auipc	ra,0x0
    80200080:	42e080e7          	jalr	1070(ra) # 802004aa <printLockInit>
        printf("Hello, risc-v!\nBoot hartId: %ld \n\n", hartId);
    80200084:	85a6                	mv	a1,s1
    80200086:	00004517          	auipc	a0,0x4
    8020008a:	f7a50513          	addi	a0,a0,-134 # 80204000 <textEnd>
    8020008e:	00000097          	auipc	ra,0x0
    80200092:	444080e7          	jalr	1092(ra) # 802004d2 <printf>

        memoryInit();
    80200096:	00001097          	auipc	ra,0x1
    8020009a:	b8c080e7          	jalr	-1140(ra) # 80200c22 <memoryInit>
    8020009e:	4785                	li	a5,1
            }
            printf("finish %d\n", j);
        }*/
        for (int i = 1; i < 5; ++ i) {
            if (i != hartId) {
                unsigned long mask = 1 << i;
    802000a0:	4f85                	li	t6,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    return a0;
}

inline void setMode(int hartId) {
	register u64 a7 asm ("a7") = 0x48534D;
    802000a2:	00485eb7          	lui	t4,0x485
    802000a6:	34de8e93          	addi	t4,t4,845 # 48534d <_start-0x7fd7acb3>
	register u64 a0 asm ("a0") = hartId;
	register u64 a1 asm ("a1") = 0x80200000;
    802000aa:	40100e13          	li	t3,1025
    802000ae:	0e56                	slli	t3,t3,0x15
	register u64 a2 asm ("a2") = 19260817; // priv
    802000b0:	0125e337          	lui	t1,0x125e
    802000b4:	59130313          	addi	t1,t1,1425 # 125e591 <_start-0x7efa1a6f>
        for (int i = 1; i < 5; ++ i) {
    802000b8:	4f15                	li	t5,5
    802000ba:	a021                	j	802000c2 <main+0xae>
    802000bc:	0785                	addi	a5,a5,1
    802000be:	03e78a63          	beq	a5,t5,802000f2 <main+0xde>
    802000c2:	0007871b          	sext.w	a4,a5
            if (i != hartId) {
    802000c6:	fe978be3          	beq	a5,s1,802000bc <main+0xa8>
                unsigned long mask = 1 << i;
    802000ca:	00ef973b          	sllw	a4,t6,a4
    802000ce:	fce43c23          	sd	a4,-40(s0)
	register u64 a7 asm ("a7") = 0x48534D;
    802000d2:	88f6                	mv	a7,t4
	register u64 a0 asm ("a0") = hartId;
    802000d4:	853e                	mv	a0,a5
	register u64 a1 asm ("a1") = 0x80200000;
    802000d6:	85f2                	mv	a1,t3
	register u64 a2 asm ("a2") = 19260817; // priv
    802000d8:	861a                	mv	a2,t1
	register u64 a6 asm ("a6") = 0; // funcid
    802000da:	4801                	li	a6,0
	asm volatile ("ecall" : "+r" (a0) : "r"(a0), "r"(a1), "r"(a2), "r"(a6), "r" (a7) : "memory");
    802000dc:	00000073          	ecall
		SBI_CALL(which, arg0, arg1, arg2, 0)
#define SBI_CALL_4(which, arg0, arg1, arg2, arg3) \
		SBI_CALL(which, arg0, arg1, arg2, arg3)

static inline void sbi_send_ipi(const unsigned long* hart_mask) {
    SBI_CALL_1(SBI_SEND_IPI, hart_mask);
    802000e0:	fd840513          	addi	a0,s0,-40
    802000e4:	4581                	li	a1,0
    802000e6:	4601                	li	a2,0
    802000e8:	4681                	li	a3,0
    802000ea:	4891                	li	a7,4
    802000ec:	00000073          	ecall
    802000f0:	b7f1                	j	802000bc <main+0xa8>
                }*/
                //printf("%d\n", sum);
            }
        }
        //printf("end\n");
        __sync_synchronize();
    802000f2:	0ff0000f          	fence
        printf("%d\n", mainCount);
    802000f6:	00055497          	auipc	s1,0x55
    802000fa:	f0a48493          	addi	s1,s1,-246 # 80255000 <mainCount>
    802000fe:	408c                	lw	a1,0(s1)
    80200100:	00004517          	auipc	a0,0x4
    80200104:	07050513          	addi	a0,a0,112 # 80204170 <digits+0xe0>
    80200108:	00000097          	auipc	ra,0x0
    8020010c:	3ca080e7          	jalr	970(ra) # 802004d2 <printf>
        trapInit();
    80200110:	00002097          	auipc	ra,0x2
    80200114:	0e8080e7          	jalr	232(ra) # 802021f8 <trapInit>
        processInit();
    80200118:	00002097          	auipc	ra,0x2
    8020011c:	956080e7          	jalr	-1706(ra) # 80201a6e <processInit>

        PROCESS_CREATE_PRIORITY(ForkTest, 1);
    80200120:	4605                	li	a2,1
    80200122:	00055597          	auipc	a1,0x55
    80200126:	ee25a583          	lw	a1,-286(a1) # 80255004 <binaryForkTestSize>
    8020012a:	00005517          	auipc	a0,0x5
    8020012e:	f0650513          	addi	a0,a0,-250 # 80205030 <binaryForkTestStart>
    80200132:	00002097          	auipc	ra,0x2
    80200136:	b1c080e7          	jalr	-1252(ra) # 80201c4e <processCreatePriority>

        yield();
    8020013a:	00002097          	auipc	ra,0x2
    8020013e:	c5a080e7          	jalr	-934(ra) # 80201d94 <yield>

        /*printf("reach end\n");*/
        mainCount++;
    80200142:	409c                	lw	a5,0(s1)
    80200144:	2785                	addiw	a5,a5,1
    80200146:	c09c                	sw	a5,0(s1)
        while (hartId != 4 || mainCount != 1005) {};

        PROCESS_CREATE_PRIORITY(ForkTest, 1);
        yield();
    }
    80200148:	70a2                	ld	ra,40(sp)
    8020014a:	7402                	ld	s0,32(sp)
    8020014c:	64e2                	ld	s1,24(sp)
    8020014e:	6145                	addi	sp,sp,48
    80200150:	8082                	ret
        __sync_synchronize();
    80200152:	0ff0000f          	fence
        printf("Hello, risc-v!\nCurrent hartId: %ld \n\n", hartId);
    80200156:	85aa                	mv	a1,a0
    80200158:	00004517          	auipc	a0,0x4
    8020015c:	ed050513          	addi	a0,a0,-304 # 80204028 <textEnd+0x28>
    80200160:	00000097          	auipc	ra,0x0
    80200164:	372080e7          	jalr	882(ra) # 802004d2 <printf>
        mainCount++;
    80200168:	00055717          	auipc	a4,0x55
    8020016c:	e9870713          	addi	a4,a4,-360 # 80255000 <mainCount>
    80200170:	431c                	lw	a5,0(a4)
    80200172:	2785                	addiw	a5,a5,1
    80200174:	c31c                	sw	a5,0(a4)
        while (hartId != 4 || mainCount != 1005) {};
    80200176:	4791                	li	a5,4
    80200178:	863a                	mv	a2,a4
    8020017a:	3ed00693          	li	a3,1005
    8020017e:	00f49063          	bne	s1,a5,8020017e <main+0x16a>
    80200182:	4218                	lw	a4,0(a2)
    80200184:	2701                	sext.w	a4,a4
    80200186:	fed71ce3          	bne	a4,a3,8020017e <main+0x16a>
        PROCESS_CREATE_PRIORITY(ForkTest, 1);
    8020018a:	4605                	li	a2,1
    8020018c:	00055597          	auipc	a1,0x55
    80200190:	e785a583          	lw	a1,-392(a1) # 80255004 <binaryForkTestSize>
    80200194:	00005517          	auipc	a0,0x5
    80200198:	e9c50513          	addi	a0,a0,-356 # 80205030 <binaryForkTestStart>
    8020019c:	00002097          	auipc	ra,0x2
    802001a0:	ab2080e7          	jalr	-1358(ra) # 80201c4e <processCreatePriority>
        yield();
    802001a4:	00002097          	auipc	ra,0x2
    802001a8:	bf0080e7          	jalr	-1040(ra) # 80201d94 <yield>
    802001ac:	bf71                	j	80200148 <main+0x134>

00000000802001ae <consoleInit>:
#include <Type.h>
#include <Driver.h>

void consoleInit() {
    802001ae:	1141                	addi	sp,sp,-16
    802001b0:	e422                	sd	s0,8(sp)
    802001b2:	0800                	addi	s0,sp,16
    // todo
}
    802001b4:	6422                	ld	s0,8(sp)
    802001b6:	0141                	addi	sp,sp,16
    802001b8:	8082                	ret

00000000802001ba <consoleInterrupt>:

void consoleInterrupt(int c) {
    802001ba:	1141                	addi	sp,sp,-16
    802001bc:	e422                	sd	s0,8(sp)
    802001be:	0800                	addi	s0,sp,16
    // todo

    802001c0:	6422                	ld	s0,8(sp)
    802001c2:	0141                	addi	sp,sp,16
    802001c4:	8082                	ret

00000000802001c6 <print>:

static void print(const char *fmt, va_list ap) {
    int i, c;
    char *s;

    for (i = 0; fmt[i]; i++) {
    802001c6:	00054783          	lbu	a5,0(a0)
    802001ca:	2c078f63          	beqz	a5,802004a8 <print+0x2e2>
static void print(const char *fmt, va_list ap) {
    802001ce:	711d                	addi	sp,sp,-96
    802001d0:	eca2                	sd	s0,88(sp)
    802001d2:	e8a6                	sd	s1,80(sp)
    802001d4:	e4ca                	sd	s2,72(sp)
    802001d6:	e0ce                	sd	s3,64(sp)
    802001d8:	fc52                	sd	s4,56(sp)
    802001da:	f856                	sd	s5,48(sp)
    802001dc:	f45a                	sd	s6,40(sp)
    802001de:	f05e                	sd	s7,32(sp)
    802001e0:	1080                	addi	s0,sp,96
    802001e2:	882a                	mv	a6,a0
    for (i = 0; fmt[i]; i++) {
    802001e4:	86aa                	mv	a3,a0
    802001e6:	4701                	li	a4,0
        if (fmt[i] != '%'){
    802001e8:	02500313          	li	t1,37
            putchar(fmt[i]);
            continue;
        }
        c = fmt[++i];
        bool l = false;
        if (c == 'l') {
    802001ec:	06c00913          	li	s2,108
            l = true;
            c = fmt[++i];
        }
        switch (c) {
    802001f0:	06400e93          	li	t4,100
        bool l = false;
    802001f4:	4981                	li	s3,0
        buf[i++] = digits[x % base];
    802001f6:	00004e17          	auipc	t3,0x4
    802001fa:	e9ae0e13          	addi	t3,t3,-358 # 80204090 <digits>
    802001fe:	4629                	li	a2,10
    } while((x /= base) != 0);
    80200200:	4fa5                	li	t6,9
        buf[i++] = '-';
    80200202:	02d00a13          	li	s4,45
        switch (c) {
    80200206:	07300493          	li	s1,115
    while (*s) {
    8020020a:	02800a93          	li	s5,40
        switch (c) {
    8020020e:	07800393          	li	t2,120
    } while((x /= base) != 0);
    80200212:	4f3d                	li	t5,15
        switch (c) {
    80200214:	06300293          	li	t0,99
    80200218:	a00d                	j	8020023a <print+0x74>
            if (fmt[i] == '\n') {
    8020021a:	0ac78063          	beq	a5,a2,802002ba <print+0xf4>
#define SBI_REMOTE_SFENCE_VMA 6
#define SBI_REMOTE_SFENCE_VMA_ASID 7
#define SBI_SHUTDOWN 8

inline void putchar(char c) {
    register u64 a0 asm ("a0") = (u64) c;
    8020021e:	0006c503          	lbu	a0,0(a3)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    80200222:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    80200224:	00000073          	ecall
            continue;
    80200228:	86ba                	mv	a3,a4
    for (i = 0; fmt[i]; i++) {
    8020022a:	0016871b          	addiw	a4,a3,1
    8020022e:	00e806b3          	add	a3,a6,a4
    80200232:	0006c783          	lbu	a5,0(a3)
    80200236:	24078f63          	beqz	a5,80200494 <print+0x2ce>
        if (fmt[i] != '%'){
    8020023a:	fe6790e3          	bne	a5,t1,8020021a <print+0x54>
        c = fmt[++i];
    8020023e:	0017069b          	addiw	a3,a4,1
    80200242:	00d807b3          	add	a5,a6,a3
    80200246:	0007c783          	lbu	a5,0(a5)
        if (c == 'l') {
    8020024a:	07278d63          	beq	a5,s2,802002c4 <print+0xfe>
        switch (c) {
    8020024e:	11d78d63          	beq	a5,t4,80200368 <print+0x1a2>
        bool l = false;
    80200252:	874e                	mv	a4,s3
        switch (c) {
    80200254:	08fed263          	bge	t4,a5,802002d8 <print+0x112>
    80200258:	1c978f63          	beq	a5,s1,80200436 <print+0x270>
    8020025c:	22779363          	bne	a5,t2,80200482 <print+0x2bc>
                } else {
                    printInt((i64) va_arg(ap, i32), 10, true);
                }
                break;
            case 'x':
                if (l) {
    80200260:	16070f63          	beqz	a4,802003de <print+0x218>
                    printInt(va_arg(ap, u64), 16, false);
    80200264:	00858b13          	addi	s6,a1,8
    80200268:	619c                	ld	a5,0(a1)
    8020026a:	fa040513          	addi	a0,s0,-96
    i = 0;
    8020026e:	85ce                	mv	a1,s3
        buf[i++] = digits[x % base];
    80200270:	88ae                	mv	a7,a1
    80200272:	2585                	addiw	a1,a1,1
    80200274:	00f7f713          	andi	a4,a5,15
    80200278:	9772                	add	a4,a4,t3
    8020027a:	00074703          	lbu	a4,0(a4)
    8020027e:	00e50023          	sb	a4,0(a0)
    } while((x /= base) != 0);
    80200282:	873e                	mv	a4,a5
    80200284:	8391                	srli	a5,a5,0x4
    80200286:	0505                	addi	a0,a0,1
    80200288:	feef64e3          	bltu	t5,a4,80200270 <print+0xaa>
    while (--i >= 0) {
    8020028c:	0208c563          	bltz	a7,802002b6 <print+0xf0>
    80200290:	fa040793          	addi	a5,s0,-96
    80200294:	97c6                	add	a5,a5,a7
    80200296:	f9f40713          	addi	a4,s0,-97
    8020029a:	9746                	add	a4,a4,a7
    8020029c:	1882                	slli	a7,a7,0x20
    8020029e:	0208d893          	srli	a7,a7,0x20
    802002a2:	41170733          	sub	a4,a4,a7
    register u64 a0 asm ("a0") = (u64) c;
    802002a6:	0007c503          	lbu	a0,0(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    802002aa:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802002ac:	00000073          	ecall
    802002b0:	17fd                	addi	a5,a5,-1
    802002b2:	fee79ae3          	bne	a5,a4,802002a6 <print+0xe0>
                    printInt(va_arg(ap, u64), 16, false);
    802002b6:	85da                	mv	a1,s6
}
    802002b8:	bf8d                	j	8020022a <print+0x64>
    register u64 a0 asm ("a0") = (u64) c;
    802002ba:	4535                	li	a0,13
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    802002bc:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802002be:	00000073          	ecall
};
    802002c2:	bfb1                	j	8020021e <print+0x58>
            c = fmt[++i];
    802002c4:	0027069b          	addiw	a3,a4,2
    802002c8:	00d807b3          	add	a5,a6,a3
    802002cc:	0007c783          	lbu	a5,0(a5)
        switch (c) {
    802002d0:	03d78163          	beq	a5,t4,802002f2 <print+0x12c>
            l = true;
    802002d4:	4705                	li	a4,1
    802002d6:	bfbd                	j	80200254 <print+0x8e>
        switch (c) {
    802002d8:	1a678063          	beq	a5,t1,80200478 <print+0x2b2>
    802002dc:	1a579363          	bne	a5,t0,80200482 <print+0x2bc>
                putchar(va_arg(ap, u32));
    802002e0:	00858793          	addi	a5,a1,8
    register u64 a0 asm ("a0") = (u64) c;
    802002e4:	0005c503          	lbu	a0,0(a1)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    802002e8:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802002ea:	00000073          	ecall
    802002ee:	85be                	mv	a1,a5
};
    802002f0:	bf2d                	j	8020022a <print+0x64>
                    printInt(va_arg(ap, i64), 10, true);
    802002f2:	00858b13          	addi	s6,a1,8
    802002f6:	0005bb83          	ld	s7,0(a1)
        x = -xx;
    802002fa:	43fbd713          	srai	a4,s7,0x3f
    802002fe:	017747b3          	xor	a5,a4,s7
    80200302:	8f99                	sub	a5,a5,a4
        bool l = false;
    80200304:	fa040513          	addi	a0,s0,-96
    80200308:	85ce                	mv	a1,s3
        buf[i++] = digits[x % base];
    8020030a:	88ae                	mv	a7,a1
    8020030c:	2585                	addiw	a1,a1,1
    8020030e:	02c7f733          	remu	a4,a5,a2
    80200312:	9772                	add	a4,a4,t3
    80200314:	00074703          	lbu	a4,0(a4)
    80200318:	00e50023          	sb	a4,0(a0)
    } while((x /= base) != 0);
    8020031c:	873e                	mv	a4,a5
    8020031e:	02c7d7b3          	divu	a5,a5,a2
    80200322:	0505                	addi	a0,a0,1
    80200324:	feefe3e3          	bltu	t6,a4,8020030a <print+0x144>
    if (sign) {
    80200328:	000bda63          	bgez	s7,8020033c <print+0x176>
        buf[i++] = '-';
    8020032c:	fc058793          	addi	a5,a1,-64
    80200330:	008785b3          	add	a1,a5,s0
    80200334:	ff458023          	sb	s4,-32(a1)
    80200338:	0028859b          	addiw	a1,a7,2
    while (--i >= 0) {
    8020033c:	02b05463          	blez	a1,80200364 <print+0x19e>
    80200340:	fa040793          	addi	a5,s0,-96
    80200344:	97ae                	add	a5,a5,a1
    80200346:	f9f40713          	addi	a4,s0,-97
    8020034a:	972e                	add	a4,a4,a1
    8020034c:	35fd                	addiw	a1,a1,-1
    8020034e:	1582                	slli	a1,a1,0x20
    80200350:	9181                	srli	a1,a1,0x20
    80200352:	8f0d                	sub	a4,a4,a1
    register u64 a0 asm ("a0") = (u64) c;
    80200354:	fff7c503          	lbu	a0,-1(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    80200358:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020035a:	00000073          	ecall
    8020035e:	17fd                	addi	a5,a5,-1
    80200360:	fee79ae3          	bne	a5,a4,80200354 <print+0x18e>
                    printInt(va_arg(ap, i64), 10, true);
    80200364:	85da                	mv	a1,s6
}
    80200366:	b5d1                	j	8020022a <print+0x64>
                    printInt((i64) va_arg(ap, i32), 10, true);
    80200368:	00858b13          	addi	s6,a1,8
    8020036c:	419c                	lw	a5,0(a1)
    8020036e:	8bbe                	mv	s7,a5
        x = -xx;
    80200370:	43f7d713          	srai	a4,a5,0x3f
    80200374:	8fb9                	xor	a5,a5,a4
    80200376:	8f99                	sub	a5,a5,a4
        buf[i++] = '-';
    80200378:	fa040513          	addi	a0,s0,-96
    8020037c:	874e                	mv	a4,s3
        buf[i++] = digits[x % base];
    8020037e:	88ba                	mv	a7,a4
    80200380:	2705                	addiw	a4,a4,1
    80200382:	02c7f5b3          	remu	a1,a5,a2
    80200386:	95f2                	add	a1,a1,t3
    80200388:	0005c583          	lbu	a1,0(a1)
    8020038c:	00b50023          	sb	a1,0(a0)
    } while((x /= base) != 0);
    80200390:	85be                	mv	a1,a5
    80200392:	02c7d7b3          	divu	a5,a5,a2
    80200396:	0505                	addi	a0,a0,1
    80200398:	febfe3e3          	bltu	t6,a1,8020037e <print+0x1b8>
    if (sign) {
    8020039c:	000bda63          	bgez	s7,802003b0 <print+0x1ea>
        buf[i++] = '-';
    802003a0:	fc070793          	addi	a5,a4,-64
    802003a4:	00878733          	add	a4,a5,s0
    802003a8:	ff470023          	sb	s4,-32(a4)
    802003ac:	0028871b          	addiw	a4,a7,2
    while (--i >= 0) {
    802003b0:	02e05563          	blez	a4,802003da <print+0x214>
    802003b4:	fa040793          	addi	a5,s0,-96
    802003b8:	97ba                	add	a5,a5,a4
    802003ba:	f9f40593          	addi	a1,s0,-97
    802003be:	95ba                	add	a1,a1,a4
    802003c0:	377d                	addiw	a4,a4,-1
    802003c2:	1702                	slli	a4,a4,0x20
    802003c4:	9301                	srli	a4,a4,0x20
    802003c6:	40e58733          	sub	a4,a1,a4
    register u64 a0 asm ("a0") = (u64) c;
    802003ca:	fff7c503          	lbu	a0,-1(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    802003ce:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802003d0:	00000073          	ecall
    802003d4:	17fd                	addi	a5,a5,-1
    802003d6:	fef71ae3          	bne	a4,a5,802003ca <print+0x204>
                    printInt((i64) va_arg(ap, i32), 10, true);
    802003da:	85da                	mv	a1,s6
}
    802003dc:	b5b9                	j	8020022a <print+0x64>
                } else {
                    printInt((u64) va_arg(ap, u32), 16, false);
    802003de:	00858b13          	addi	s6,a1,8
        x = xx;
    802003e2:	0005e783          	lwu	a5,0(a1)
    802003e6:	fa040513          	addi	a0,s0,-96
    i = 0;
    802003ea:	85ce                	mv	a1,s3
        buf[i++] = digits[x % base];
    802003ec:	88ae                	mv	a7,a1
    802003ee:	2585                	addiw	a1,a1,1
    802003f0:	00f7f713          	andi	a4,a5,15
    802003f4:	9772                	add	a4,a4,t3
    802003f6:	00074703          	lbu	a4,0(a4)
    802003fa:	00e50023          	sb	a4,0(a0)
    } while((x /= base) != 0);
    802003fe:	873e                	mv	a4,a5
    80200400:	8391                	srli	a5,a5,0x4
    80200402:	0505                	addi	a0,a0,1
    80200404:	feef64e3          	bltu	t5,a4,802003ec <print+0x226>
    while (--i >= 0) {
    80200408:	0208c563          	bltz	a7,80200432 <print+0x26c>
    8020040c:	fa040793          	addi	a5,s0,-96
    80200410:	97c6                	add	a5,a5,a7
    80200412:	f9f40713          	addi	a4,s0,-97
    80200416:	9746                	add	a4,a4,a7
    80200418:	1882                	slli	a7,a7,0x20
    8020041a:	0208d893          	srli	a7,a7,0x20
    8020041e:	41170733          	sub	a4,a4,a7
    register u64 a0 asm ("a0") = (u64) c;
    80200422:	0007c503          	lbu	a0,0(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    80200426:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    80200428:	00000073          	ecall
    8020042c:	17fd                	addi	a5,a5,-1
    8020042e:	fee79ae3          	bne	a5,a4,80200422 <print+0x25c>
                    printInt((u64) va_arg(ap, u32), 16, false);
    80200432:	85da                	mv	a1,s6
}
    80200434:	bbdd                	j	8020022a <print+0x64>
                }
                break;
            case 's':
                if ((s = va_arg(ap, char*)) == 0) {
    80200436:	00858b13          	addi	s6,a1,8
    8020043a:	619c                	ld	a5,0(a1)
    8020043c:	c791                	beqz	a5,80200448 <print+0x282>
    while (*s) {
    8020043e:	0007c703          	lbu	a4,0(a5)
    80200442:	e315                	bnez	a4,80200466 <print+0x2a0>
                if ((s = va_arg(ap, char*)) == 0) {
    80200444:	85da                	mv	a1,s6
    80200446:	b3d5                	j	8020022a <print+0x64>
                    s = "(null)";
    80200448:	00004797          	auipc	a5,0x4
    8020044c:	c0878793          	addi	a5,a5,-1016 # 80204050 <textEnd+0x50>
    while (*s) {
    80200450:	8756                	mv	a4,s5
    80200452:	a811                	j	80200466 <print+0x2a0>
        putchar(*s++);
    80200454:	0785                	addi	a5,a5,1
    register u64 a0 asm ("a0") = (u64) c;
    80200456:	fff7c503          	lbu	a0,-1(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    8020045a:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020045c:	00000073          	ecall
    while (*s) {
    80200460:	0007c703          	lbu	a4,0(a5)
    80200464:	cb01                	beqz	a4,80200474 <print+0x2ae>
        if (*s == '\n') {
    80200466:	fec717e3          	bne	a4,a2,80200454 <print+0x28e>
    register u64 a0 asm ("a0") = (u64) c;
    8020046a:	4535                	li	a0,13
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    8020046c:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020046e:	00000073          	ecall
};
    80200472:	b7cd                	j	80200454 <print+0x28e>
                if ((s = va_arg(ap, char*)) == 0) {
    80200474:	85da                	mv	a1,s6
    80200476:	bb55                	j	8020022a <print+0x64>
    register u64 a0 asm ("a0") = (u64) c;
    80200478:	851a                	mv	a0,t1
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    8020047a:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020047c:	00000073          	ecall
};
    80200480:	b36d                	j	8020022a <print+0x64>
    register u64 a0 asm ("a0") = (u64) c;
    80200482:	851a                	mv	a0,t1
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    80200484:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    80200486:	00000073          	ecall
    register u64 a0 asm ("a0") = (u64) c;
    8020048a:	0ff7f513          	zext.b	a0,a5
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020048e:	00000073          	ecall
};
    80200492:	bb61                	j	8020022a <print+0x64>
                putchar('%');
                putchar(c);
                break;
        }
    }
}
    80200494:	6466                	ld	s0,88(sp)
    80200496:	64c6                	ld	s1,80(sp)
    80200498:	6926                	ld	s2,72(sp)
    8020049a:	6986                	ld	s3,64(sp)
    8020049c:	7a62                	ld	s4,56(sp)
    8020049e:	7ac2                	ld	s5,48(sp)
    802004a0:	7b22                	ld	s6,40(sp)
    802004a2:	7b82                	ld	s7,32(sp)
    802004a4:	6125                	addi	sp,sp,96
    802004a6:	8082                	ret
    802004a8:	8082                	ret

00000000802004aa <printLockInit>:
inline void printLockInit(void) {
    802004aa:	1141                	addi	sp,sp,-16
    802004ac:	e406                	sd	ra,8(sp)
    802004ae:	e022                	sd	s0,0(sp)
    802004b0:	0800                	addi	s0,sp,16
    initLock(&printLock, "printLock");
    802004b2:	00004597          	auipc	a1,0x4
    802004b6:	ba658593          	addi	a1,a1,-1114 # 80204058 <textEnd+0x58>
    802004ba:	00056517          	auipc	a0,0x56
    802004be:	f4650513          	addi	a0,a0,-186 # 80256400 <printLock>
    802004c2:	00002097          	auipc	ra,0x2
    802004c6:	1aa080e7          	jalr	426(ra) # 8020266c <initLock>
}
    802004ca:	60a2                	ld	ra,8(sp)
    802004cc:	6402                	ld	s0,0(sp)
    802004ce:	0141                	addi	sp,sp,16
    802004d0:	8082                	ret

00000000802004d2 <printf>:

void printf(const char *fmt, ...) {
    802004d2:	7159                	addi	sp,sp,-112
    802004d4:	f406                	sd	ra,40(sp)
    802004d6:	f022                	sd	s0,32(sp)
    802004d8:	ec26                	sd	s1,24(sp)
    802004da:	e84a                	sd	s2,16(sp)
    802004dc:	1800                	addi	s0,sp,48
    802004de:	84aa                	mv	s1,a0
    802004e0:	e40c                	sd	a1,8(s0)
    802004e2:	e810                	sd	a2,16(s0)
    802004e4:	ec14                	sd	a3,24(s0)
    802004e6:	f018                	sd	a4,32(s0)
    802004e8:	f41c                	sd	a5,40(s0)
    802004ea:	03043823          	sd	a6,48(s0)
    802004ee:	03143c23          	sd	a7,56(s0)
    acquireLock(&printLock);
    802004f2:	00056917          	auipc	s2,0x56
    802004f6:	f0e90913          	addi	s2,s2,-242 # 80256400 <printLock>
    802004fa:	854a                	mv	a0,s2
    802004fc:	00002097          	auipc	ra,0x2
    80200500:	1b6080e7          	jalr	438(ra) # 802026b2 <acquireLock>
    va_list ap;
    va_start(ap, fmt);
    80200504:	00840593          	addi	a1,s0,8
    80200508:	fcb43c23          	sd	a1,-40(s0)
    print(fmt, ap);
    8020050c:	8526                	mv	a0,s1
    8020050e:	00000097          	auipc	ra,0x0
    80200512:	cb8080e7          	jalr	-840(ra) # 802001c6 <print>
    va_end(ap);
    releaseLock(&printLock);
    80200516:	854a                	mv	a0,s2
    80200518:	00002097          	auipc	ra,0x2
    8020051c:	20c080e7          	jalr	524(ra) # 80202724 <releaseLock>
}
    80200520:	70a2                	ld	ra,40(sp)
    80200522:	7402                	ld	s0,32(sp)
    80200524:	64e2                	ld	s1,24(sp)
    80200526:	6942                	ld	s2,16(sp)
    80200528:	6165                	addi	sp,sp,112
    8020052a:	8082                	ret

000000008020052c <_panic_>:

void _panic_(const char *file, int line, const char *fmt, ...) {
    8020052c:	7159                	addi	sp,sp,-112
    8020052e:	fc06                	sd	ra,56(sp)
    80200530:	f822                	sd	s0,48(sp)
    80200532:	f426                	sd	s1,40(sp)
    80200534:	f04a                	sd	s2,32(sp)
    80200536:	ec4e                	sd	s3,24(sp)
    80200538:	e852                	sd	s4,16(sp)
    8020053a:	0080                	addi	s0,sp,64
    8020053c:	892a                	mv	s2,a0
    8020053e:	89ae                	mv	s3,a1
    80200540:	84b2                	mv	s1,a2
    80200542:	e414                	sd	a3,8(s0)
    80200544:	e818                	sd	a4,16(s0)
    80200546:	ec1c                	sd	a5,24(s0)
    80200548:	03043023          	sd	a6,32(s0)
    8020054c:	03143423          	sd	a7,40(s0)
    acquireLock(&printLock);
    80200550:	00056a17          	auipc	s4,0x56
    80200554:	eb0a0a13          	addi	s4,s4,-336 # 80256400 <printLock>
    80200558:	8552                	mv	a0,s4
    8020055a:	00002097          	auipc	ra,0x2
    8020055e:	158080e7          	jalr	344(ra) # 802026b2 <acquireLock>
    printf("panic at %s: %d: ", file, line);
    80200562:	864e                	mv	a2,s3
    80200564:	85ca                	mv	a1,s2
    80200566:	00004517          	auipc	a0,0x4
    8020056a:	b0250513          	addi	a0,a0,-1278 # 80204068 <textEnd+0x68>
    8020056e:	00000097          	auipc	ra,0x0
    80200572:	f64080e7          	jalr	-156(ra) # 802004d2 <printf>
    va_list ap;
    va_start(ap, fmt);
    80200576:	00840593          	addi	a1,s0,8
    8020057a:	fcb43423          	sd	a1,-56(s0)
    print(fmt, ap);
    8020057e:	8526                	mv	a0,s1
    80200580:	00000097          	auipc	ra,0x0
    80200584:	c46080e7          	jalr	-954(ra) # 802001c6 <print>
    register u64 a0 asm ("a0") = (u64) c;
    80200588:	4529                	li	a0,10
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    8020058a:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020058c:	00000073          	ecall
    va_end(ap);
    putchar('\n');
    releaseLock(&printLock);
    80200590:	8552                	mv	a0,s4
    80200592:	00002097          	auipc	ra,0x2
    80200596:	192080e7          	jalr	402(ra) # 80202724 <releaseLock>
    while (true);
    8020059a:	a001                	j	8020059a <_panic_+0x6e>

000000008020059c <_assert_>:
}

void _assert_(const char* file, int line, int statement) {
    if (!statement) {
    8020059c:	c211                	beqz	a2,802005a0 <_assert_+0x4>
    8020059e:	8082                	ret
void _assert_(const char* file, int line, int statement) {
    802005a0:	1141                	addi	sp,sp,-16
    802005a2:	e406                	sd	ra,8(sp)
    802005a4:	e022                	sd	s0,0(sp)
    802005a6:	0800                	addi	s0,sp,16
        _panic_(file, line, "assert failed\n");
    802005a8:	00004617          	auipc	a2,0x4
    802005ac:	ad860613          	addi	a2,a2,-1320 # 80204080 <textEnd+0x80>
    802005b0:	00000097          	auipc	ra,0x0
    802005b4:	f7c080e7          	jalr	-132(ra) # 8020052c <_panic_>

00000000802005b8 <sd_cmd>:
{
	return spi_xfer(0xFF);
}

static u8 sd_cmd(u8 cmd, u32 arg, u8 crc)
{
    802005b8:	1101                	addi	sp,sp,-32
    802005ba:	ec06                	sd	ra,24(sp)
    802005bc:	e822                	sd	s0,16(sp)
    802005be:	e426                	sd	s1,8(sp)
    802005c0:	1000                	addi	s0,sp,32
	unsigned long n;
	u8 r;

	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_HOLD;
    802005c2:	100507b7          	lui	a5,0x10050
    802005c6:	4709                	li	a4,2
    802005c8:	cf98                	sw	a4,24(a5)
	REG32(spi, SPI_REG_TXFIFO) = d;
    802005ca:	0ff00713          	li	a4,255
    802005ce:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    802005d0:	10050737          	lui	a4,0x10050
    802005d4:	477c                	lw	a5,76(a4)
	} while (r < 0);
    802005d6:	fe07cfe3          	bltz	a5,802005d4 <sd_cmd+0x1c>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802005da:	2501                	sext.w	a0,a0
    802005dc:	100507b7          	lui	a5,0x10050
    802005e0:	c7a8                	sw	a0,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    802005e2:	10050737          	lui	a4,0x10050
    802005e6:	477c                	lw	a5,76(a4)
	} while (r < 0);
    802005e8:	fe07cfe3          	bltz	a5,802005e6 <sd_cmd+0x2e>
	sd_dummy();
	spi_xfer(cmd);
	spi_xfer(arg >> 24);
    802005ec:	0185d79b          	srliw	a5,a1,0x18
	REG32(spi, SPI_REG_TXFIFO) = d;
    802005f0:	10050737          	lui	a4,0x10050
    802005f4:	c73c                	sw	a5,72(a4)
		r = REG32(spi, SPI_REG_RXFIFO);
    802005f6:	477c                	lw	a5,76(a4)
	} while (r < 0);
    802005f8:	fe07cfe3          	bltz	a5,802005f6 <sd_cmd+0x3e>
	spi_xfer(arg >> 16);
    802005fc:	0105d79b          	srliw	a5,a1,0x10
    80200600:	0ff7f793          	zext.b	a5,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200604:	10050737          	lui	a4,0x10050
    80200608:	c73c                	sw	a5,72(a4)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020060a:	477c                	lw	a5,76(a4)
	} while (r < 0);
    8020060c:	fe07cfe3          	bltz	a5,8020060a <sd_cmd+0x52>
	spi_xfer(arg >> 8);
    80200610:	0085d79b          	srliw	a5,a1,0x8
    80200614:	0ff7f793          	zext.b	a5,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200618:	10050737          	lui	a4,0x10050
    8020061c:	c73c                	sw	a5,72(a4)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020061e:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200620:	fe07cfe3          	bltz	a5,8020061e <sd_cmd+0x66>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200624:	0ff5f593          	zext.b	a1,a1
    80200628:	100507b7          	lui	a5,0x10050
    8020062c:	c7ac                	sw	a1,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020062e:	10050737          	lui	a4,0x10050
    80200632:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200634:	fe07cfe3          	bltz	a5,80200632 <sd_cmd+0x7a>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200638:	0006079b          	sext.w	a5,a2
    8020063c:	10050737          	lui	a4,0x10050
    80200640:	c73c                	sw	a5,72(a4)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200642:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200644:	fe07cfe3          	bltz	a5,80200642 <sd_cmd+0x8a>
    80200648:	3e800693          	li	a3,1000
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020064c:	10050737          	lui	a4,0x10050
    80200650:	04870593          	addi	a1,a4,72 # 10050048 <_start-0x701affb8>
    80200654:	0ff00613          	li	a2,255
    80200658:	c190                	sw	a2,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020065a:	477c                	lw	a5,76(a4)
    8020065c:	0007849b          	sext.w	s1,a5
	} while (r < 0);
    80200660:	fe07cde3          	bltz	a5,8020065a <sd_cmd+0xa2>
	spi_xfer(crc);

	n = 1000;
	do {
		r = sd_dummy();
		if (!(r & 0x80)) {
    80200664:	0184979b          	slliw	a5,s1,0x18
    80200668:	4187d79b          	sraiw	a5,a5,0x18
    8020066c:	0007dc63          	bgez	a5,80200684 <sd_cmd+0xcc>
			//printf("sd:cmd: %x\r\n", r);
			goto done;
		}
	} while (--n > 0);
    80200670:	16fd                	addi	a3,a3,-1
    80200672:	f2fd                	bnez	a3,80200658 <sd_cmd+0xa0>
	printf("sd_cmd: timeout\n");
    80200674:	00004517          	auipc	a0,0x4
    80200678:	a3450513          	addi	a0,a0,-1484 # 802040a8 <digits+0x18>
    8020067c:	00000097          	auipc	ra,0x0
    80200680:	e56080e7          	jalr	-426(ra) # 802004d2 <printf>
done:
	return r;
}
    80200684:	0ff4f513          	zext.b	a0,s1
    80200688:	60e2                	ld	ra,24(sp)
    8020068a:	6442                	ld	s0,16(sp)
    8020068c:	64a2                	ld	s1,8(sp)
    8020068e:	6105                	addi	sp,sp,32
    80200690:	8082                	ret

0000000080200692 <sd_cmd0>:
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
	//for (a = 0; a < 1000000; a++) a = a;
}

static int sd_cmd0(void)
{
    80200692:	1141                	addi	sp,sp,-16
    80200694:	e406                	sd	ra,8(sp)
    80200696:	e022                	sd	s0,0(sp)
    80200698:	0800                	addi	s0,sp,16
	int rc;
	//printf("CMD0");
	rc = (sd_cmd(0x40, 0, 0x95) != 0x01);
    8020069a:	09500613          	li	a2,149
    8020069e:	4581                	li	a1,0
    802006a0:	04000513          	li	a0,64
    802006a4:	00000097          	auipc	ra,0x0
    802006a8:	f14080e7          	jalr	-236(ra) # 802005b8 <sd_cmd>
    802006ac:	2501                	sext.w	a0,a0
    802006ae:	157d                	addi	a0,a0,-1
    802006b0:	00a03533          	snez	a0,a0
	REG32(spi, SPI_REG_TXFIFO) = d;
    802006b4:	100507b7          	lui	a5,0x10050
    802006b8:	0ff00713          	li	a4,255
    802006bc:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    802006be:	10050737          	lui	a4,0x10050
    802006c2:	477c                	lw	a5,76(a4)
	} while (r < 0);
    802006c4:	fe07cfe3          	bltz	a5,802006c2 <sd_cmd0+0x30>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    802006c8:	100507b7          	lui	a5,0x10050
    802006cc:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	sd_cmd_end();
	return rc;
}
    802006d0:	60a2                	ld	ra,8(sp)
    802006d2:	6402                	ld	s0,0(sp)
    802006d4:	0141                	addi	sp,sp,16
    802006d6:	8082                	ret

00000000802006d8 <sdRead>:
#define SPIN_UPDATE(i)	(!((i) & ((1 << SPIN_SHIFT)-1)))
#define SPIN_INDEX(i)	(((i) >> SPIN_SHIFT) & 0x3)

//static const char spinner[] = { '-', '/', '|', '\\' };

int sdRead(u8 *buf, u64 startSector, u32 sectorNumber) {
    802006d8:	1101                	addi	sp,sp,-32
    802006da:	ec06                	sd	ra,24(sp)
    802006dc:	e822                	sd	s0,16(sp)
    802006de:	e426                	sd	s1,8(sp)
    802006e0:	e04a                	sd	s2,0(sp)
    802006e2:	1000                	addi	s0,sp,32
    802006e4:	84aa                	mv	s1,a0
    802006e6:	8932                	mv	s2,a2
	int rc = 0;

	//printf("CMD18");
	//printf("LOADING  ");

	if (sd_cmd(0x52, startSector * 512, 0xE1) != 0x00) {
    802006e8:	0e100613          	li	a2,225
    802006ec:	0095959b          	slliw	a1,a1,0x9
    802006f0:	05200513          	li	a0,82
    802006f4:	00000097          	auipc	ra,0x0
    802006f8:	ec4080e7          	jalr	-316(ra) # 802005b8 <sd_cmd>
    802006fc:	e905                	bnez	a0,8020072c <sdRead+0x54>
    802006fe:	20048813          	addi	a6,s1,512
    80200702:	fff9079b          	addiw	a5,s2,-1
    80200706:	02079713          	slli	a4,a5,0x20
    8020070a:	01775793          	srli	a5,a4,0x17
    8020070e:	40078793          	addi	a5,a5,1024
    80200712:	00f48eb3          	add	t4,s1,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200716:	10050637          	lui	a2,0x10050
    8020071a:	0ff00f13          	li	t5,255
    8020071e:	857a                	mv	a0,t5
		long n;

		crc = 0;
		n = 512;
		//printf("%d\n", __LINE__);
		while (sd_dummy() != 0xFE);
    80200720:	0fe00e13          	li	t3,254
		crc = 0;
    80200724:	4f81                	li	t6,0
	crc ^= (crc & 0xff) << 5;
    80200726:	6889                	lui	a7,0x2
    80200728:	1881                	addi	a7,a7,-32
    8020072a:	a075                	j	802007d6 <sdRead+0xfe>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020072c:	100507b7          	lui	a5,0x10050
    80200730:	0ff00713          	li	a4,255
    80200734:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200736:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    80200738:	fe074fe3          	bltz	a4,80200736 <sdRead+0x5e>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    8020073c:	100507b7          	lui	a5,0x10050
    80200740:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
		return 1;
    80200744:	4485                	li	s1,1
    80200746:	aa3d                	j	80200884 <sdRead+0x1ac>
		//printf("%d\n", __LINE__);
		do {
			u8 x = sd_dummy();
			*p++ = x;
    80200748:	8596                	mv	a1,t0
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020074a:	00a32023          	sw	a0,0(t1)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020074e:	467c                	lw	a5,76(a2)
    80200750:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    80200754:	fe07cde3          	bltz	a5,8020074e <sdRead+0x76>
	return r;
    80200758:	0ff6f693          	zext.b	a3,a3
			*p++ = x;
    8020075c:	00158293          	addi	t0,a1,1
    80200760:	00d58023          	sb	a3,0(a1)
	crc = (u8)(crc >> 8) | (crc << 8);
    80200764:	0087579b          	srliw	a5,a4,0x8
    80200768:	0087171b          	slliw	a4,a4,0x8
    8020076c:	8fd9                	or	a5,a5,a4
    8020076e:	17c2                	slli	a5,a5,0x30
    80200770:	93c1                	srli	a5,a5,0x30
	crc ^= data;
    80200772:	8fb5                	xor	a5,a5,a3
	crc ^= (u8)(crc >> 4) & 0xf;
    80200774:	0047d71b          	srliw	a4,a5,0x4
    80200778:	8b3d                	andi	a4,a4,15
    8020077a:	8f3d                	xor	a4,a4,a5
	crc ^= crc << 12;
    8020077c:	00c7179b          	slliw	a5,a4,0xc
    80200780:	8f3d                	xor	a4,a4,a5
	crc ^= (crc & 0xff) << 5;
    80200782:	0107179b          	slliw	a5,a4,0x10
    80200786:	0107d79b          	srliw	a5,a5,0x10
    8020078a:	0057979b          	slliw	a5,a5,0x5
    8020078e:	00f8f7b3          	and	a5,a7,a5
    80200792:	8f3d                	xor	a4,a4,a5
    80200794:	1742                	slli	a4,a4,0x30
    80200796:	9341                	srli	a4,a4,0x30
			crc = crc16_round(crc, x);
		} while (--n > 0);
    80200798:	fb0298e3          	bne	t0,a6,80200748 <sdRead+0x70>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020079c:	05e62423          	sw	t5,72(a2) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    802007a0:	467c                	lw	a5,76(a2)
    802007a2:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    802007a6:	fe07cde3          	bltz	a5,802007a0 <sdRead+0xc8>

		crc_exp = ((u16)sd_dummy() << 8);
    802007aa:	0ff6f693          	zext.b	a3,a3
    802007ae:	0086969b          	slliw	a3,a3,0x8
    802007b2:	16c2                	slli	a3,a3,0x30
    802007b4:	92c1                	srli	a3,a3,0x30
	REG32(spi, SPI_REG_TXFIFO) = d;
    802007b6:	05e62423          	sw	t5,72(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    802007ba:	467c                	lw	a5,76(a2)
    802007bc:	0007859b          	sext.w	a1,a5
	} while (r < 0);
    802007c0:	fe07cde3          	bltz	a5,802007ba <sdRead+0xe2>
		crc_exp |= sd_dummy();
    802007c4:	0ff5f793          	zext.b	a5,a1

		if (crc != crc_exp) {
    802007c8:	8fd5                	or	a5,a5,a3
    802007ca:	02e79863          	bne	a5,a4,802007fa <sdRead+0x122>
			printf("\b- CRC mismatch ");
			rc = 1;
			break;
		}
	} while (--sectorNumber > 0);
    802007ce:	20080813          	addi	a6,a6,512
    802007d2:	09d80a63          	beq	a6,t4,80200866 <sdRead+0x18e>
    802007d6:	e0080593          	addi	a1,a6,-512
	REG32(spi, SPI_REG_TXFIFO) = d;
    802007da:	04860693          	addi	a3,a2,72
    802007de:	c288                	sw	a0,0(a3)
		r = REG32(spi, SPI_REG_RXFIFO);
    802007e0:	467c                	lw	a5,76(a2)
    802007e2:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    802007e6:	fe07cde3          	bltz	a5,802007e0 <sdRead+0x108>
		while (sd_dummy() != 0xFE);
    802007ea:	0ff77713          	zext.b	a4,a4
    802007ee:	ffc718e3          	bne	a4,t3,802007de <sdRead+0x106>
		crc = 0;
    802007f2:	877e                	mv	a4,t6
	REG32(spi, SPI_REG_TXFIFO) = d;
    802007f4:	04860313          	addi	t1,a2,72
    802007f8:	bf89                	j	8020074a <sdRead+0x72>
			printf("\b- CRC mismatch ");
    802007fa:	00004517          	auipc	a0,0x4
    802007fe:	8c650513          	addi	a0,a0,-1850 # 802040c0 <digits+0x30>
    80200802:	00000097          	auipc	ra,0x0
    80200806:	cd0080e7          	jalr	-816(ra) # 802004d2 <printf>
			rc = 1;
    8020080a:	4485                	li	s1,1
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020080c:	100507b7          	lui	a5,0x10050
    80200810:	0ff00713          	li	a4,255
    80200814:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200816:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    80200818:	fe074fe3          	bltz	a4,80200816 <sdRead+0x13e>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    8020081c:	100507b7          	lui	a5,0x10050
    80200820:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	sd_cmd_end();

	sd_cmd(0x4C, 0, 0x01);
    80200824:	4605                	li	a2,1
    80200826:	4581                	li	a1,0
    80200828:	04c00513          	li	a0,76
    8020082c:	00000097          	auipc	ra,0x0
    80200830:	d8c080e7          	jalr	-628(ra) # 802005b8 <sd_cmd>
	int timeout = 0xfff;
	while (timeout--) {
    80200834:	6605                	lui	a2,0x1
    80200836:	1679                	addi	a2,a2,-2
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200838:	100506b7          	lui	a3,0x10050
    8020083c:	04868893          	addi	a7,a3,72 # 10050048 <_start-0x701affb8>
    80200840:	0ff00593          	li	a1,255
    80200844:	882e                	mv	a6,a1
	while (timeout--) {
    80200846:	557d                	li	a0,-1
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200848:	0108a023          	sw	a6,0(a7) # 2000 <_start-0x801fe000>
		r = REG32(spi, SPI_REG_RXFIFO);
    8020084c:	46fc                	lw	a5,76(a3)
    8020084e:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80200852:	fe07cde3          	bltz	a5,8020084c <sdRead+0x174>
		int tmp = sd_dummy();
		if (tmp == 0xFF) {
    80200856:	0ff77713          	zext.b	a4,a4
    8020085a:	00b70863          	beq	a4,a1,8020086a <sdRead+0x192>
	while (timeout--) {
    8020085e:	367d                	addiw	a2,a2,-1
    80200860:	fea614e3          	bne	a2,a0,80200848 <sdRead+0x170>
    80200864:	a021                	j	8020086c <sdRead+0x194>
	int rc = 0;
    80200866:	4481                	li	s1,0
    80200868:	b755                	j	8020080c <sdRead+0x134>
			break;
		}
	}
	if (!timeout) {
    8020086a:	c605                	beqz	a2,80200892 <sdRead+0x1ba>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020086c:	100507b7          	lui	a5,0x10050
    80200870:	0ff00713          	li	a4,255
    80200874:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200876:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    80200878:	fe074fe3          	bltz	a4,80200876 <sdRead+0x19e>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    8020087c:	100507b7          	lui	a5,0x10050
    80200880:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
		panic("");
	}
	sd_cmd_end();

	return rc;
}
    80200884:	8526                	mv	a0,s1
    80200886:	60e2                	ld	ra,24(sp)
    80200888:	6442                	ld	s0,16(sp)
    8020088a:	64a2                	ld	s1,8(sp)
    8020088c:	6902                	ld	s2,0(sp)
    8020088e:	6105                	addi	sp,sp,32
    80200890:	8082                	ret
		panic("");
    80200892:	00004617          	auipc	a2,0x4
    80200896:	82660613          	addi	a2,a2,-2010 # 802040b8 <digits+0x28>
    8020089a:	0d200593          	li	a1,210
    8020089e:	00004517          	auipc	a0,0x4
    802008a2:	83a50513          	addi	a0,a0,-1990 # 802040d8 <digits+0x48>
    802008a6:	00000097          	auipc	ra,0x0
    802008aa:	c86080e7          	jalr	-890(ra) # 8020052c <_panic_>

00000000802008ae <sdWrite>:

int sdWrite(u8 *buf, u64 startSector, u32 sectorNumber) {
    802008ae:	1101                	addi	sp,sp,-32
    802008b0:	ec06                	sd	ra,24(sp)
    802008b2:	e822                	sd	s0,16(sp)
    802008b4:	e426                	sd	s1,8(sp)
    802008b6:	e04a                	sd	s2,0(sp)
    802008b8:	1000                	addi	s0,sp,32
    802008ba:	84aa                	mv	s1,a0
    802008bc:	8932                	mv	s2,a2
	if (sd_cmd(25 | 0x40, startSector * 512, 0) != 0) {
    802008be:	4601                	li	a2,0
    802008c0:	0095959b          	slliw	a1,a1,0x9
    802008c4:	05900513          	li	a0,89
    802008c8:	00000097          	auipc	ra,0x0
    802008cc:	cf0080e7          	jalr	-784(ra) # 802005b8 <sd_cmd>
    802008d0:	e531                	bnez	a0,8020091c <sdWrite+0x6e>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802008d2:	100507b7          	lui	a5,0x10050
    802008d6:	0ff00713          	li	a4,255
    802008da:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    802008dc:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    802008de:	fe074fe3          	bltz	a4,802008dc <sdWrite+0x2e>
		return 1;
	}
	sd_dummy();

	u8 *p = buf;
	while (sectorNumber--) {
    802008e2:	fff9079b          	addiw	a5,s2,-1
    802008e6:	0c090f63          	beqz	s2,802009c4 <sdWrite+0x116>
    802008ea:	20048593          	addi	a1,s1,512
    802008ee:	40048e13          	addi	t3,s1,1024
    802008f2:	02079713          	slli	a4,a5,0x20
    802008f6:	01775793          	srli	a5,a4,0x17
    802008fa:	9e3e                	add	t3,t3,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    802008fc:	10050737          	lui	a4,0x10050
    80200900:	04870613          	addi	a2,a4,72 # 10050048 <_start-0x701affb8>
    80200904:	0fc00f93          	li	t6,252
    80200908:	0ff00813          	li	a6,255
    8020090c:	6785                	lui	a5,0x1
    8020090e:	ffe78f13          	addi	t5,a5,-2 # ffe <_start-0x801ff002>
    80200912:	8342                	mv	t1,a6
		sd_dummy();
		sd_dummy();
		int timeout = 0xfff;
		while (--timeout) {
			int x = sd_dummy();
			if (5 == (x & 0x1f)) {
    80200914:	4895                	li	a7,5
    80200916:	fff78e93          	addi	t4,a5,-1
    8020091a:	a081                	j	8020095a <sdWrite+0xac>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020091c:	100507b7          	lui	a5,0x10050
    80200920:	0ff00713          	li	a4,255
    80200924:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200926:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    80200928:	fe074fe3          	bltz	a4,80200926 <sdWrite+0x78>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    8020092c:	100507b7          	lui	a5,0x10050
    80200930:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
		return 1;
    80200934:	4505                	li	a0,1
    80200936:	a0d5                	j	80200a1a <sdWrite+0x16c>
    80200938:	8576                	mv	a0,t4
		}
		if (timeout == 0) {
			panic("");
		}
		timeout = 0xfff;
		while (--timeout) {
    8020093a:	357d                	addiw	a0,a0,-1
    8020093c:	c919                	beqz	a0,80200952 <sdWrite+0xa4>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020093e:	01062023          	sw	a6,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200942:	477c                	lw	a5,76(a4)
    80200944:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    80200948:	fe07cde3          	bltz	a5,80200942 <sdWrite+0x94>
			int x = sd_dummy();
			if (x) {
    8020094c:	0ff6f693          	zext.b	a3,a3
    80200950:	d6ed                	beqz	a3,8020093a <sdWrite+0x8c>
	while (sectorNumber--) {
    80200952:	20058593          	addi	a1,a1,512
    80200956:	07c58763          	beq	a1,t3,802009c4 <sdWrite+0x116>
    8020095a:	e0058693          	addi	a3,a1,-512
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020095e:	01f62023          	sw	t6,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200962:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200964:	fe07cfe3          	bltz	a5,80200962 <sdWrite+0xb4>
			spi_xfer(*p++);
    80200968:	0685                	addi	a3,a3,1
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020096a:	fff6c783          	lbu	a5,-1(a3)
    8020096e:	c21c                	sw	a5,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200970:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200972:	fe07cfe3          	bltz	a5,80200970 <sdWrite+0xc2>
		} while (--n > 0);
    80200976:	feb699e3          	bne	a3,a1,80200968 <sdWrite+0xba>
	REG32(spi, SPI_REG_TXFIFO) = d;
    8020097a:	01062023          	sw	a6,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    8020097e:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200980:	fe07cfe3          	bltz	a5,8020097e <sdWrite+0xd0>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200984:	01062023          	sw	a6,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200988:	477c                	lw	a5,76(a4)
	} while (r < 0);
    8020098a:	fe07cfe3          	bltz	a5,80200988 <sdWrite+0xda>
    8020098e:	857a                	mv	a0,t5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200990:	00662023          	sw	t1,0(a2)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200994:	477c                	lw	a5,76(a4)
    80200996:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    8020099a:	fe07cde3          	bltz	a5,80200994 <sdWrite+0xe6>
			if (5 == (x & 0x1f)) {
    8020099e:	8afd                	andi	a3,a3,31
    802009a0:	f9168ce3          	beq	a3,a7,80200938 <sdWrite+0x8a>
		while (--timeout) {
    802009a4:	357d                	addiw	a0,a0,-1
    802009a6:	f56d                	bnez	a0,80200990 <sdWrite+0xe2>
			panic("");
    802009a8:	00003617          	auipc	a2,0x3
    802009ac:	71060613          	addi	a2,a2,1808 # 802040b8 <digits+0x28>
    802009b0:	0f100593          	li	a1,241
    802009b4:	00003517          	auipc	a0,0x3
    802009b8:	72450513          	addi	a0,a0,1828 # 802040d8 <digits+0x48>
    802009bc:	00000097          	auipc	ra,0x0
    802009c0:	b70080e7          	jalr	-1168(ra) # 8020052c <_panic_>
	REG32(spi, SPI_REG_TXFIFO) = d;
    802009c4:	100507b7          	lui	a5,0x10050
    802009c8:	0fd00713          	li	a4,253
    802009cc:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    802009ce:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    802009d0:	fe074fe3          	bltz	a4,802009ce <sdWrite+0x120>
    802009d4:	6605                	lui	a2,0x1
    802009d6:	1679                	addi	a2,a2,-2
	REG32(spi, SPI_REG_TXFIFO) = d;
    802009d8:	100506b7          	lui	a3,0x10050
    802009dc:	04868813          	addi	a6,a3,72 # 10050048 <_start-0x701affb8>
    802009e0:	0ff00593          	li	a1,255
    802009e4:	852e                	mv	a0,a1
    802009e6:	00a82023          	sw	a0,0(a6)
		r = REG32(spi, SPI_REG_RXFIFO);
    802009ea:	46fc                	lw	a5,76(a3)
    802009ec:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    802009f0:	fe07cde3          	bltz	a5,802009ea <sdWrite+0x13c>

	spi_xfer(0xFD);
	int timeout = 0xfff;
	while (--timeout) {
		int x = sd_dummy();
		if (x == 0xFF) {
    802009f4:	0ff77713          	zext.b	a4,a4
    802009f8:	00b70463          	beq	a4,a1,80200a00 <sdWrite+0x152>
	while (--timeout) {
    802009fc:	367d                	addiw	a2,a2,-1
    802009fe:	f665                	bnez	a2,802009e6 <sdWrite+0x138>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200a00:	100507b7          	lui	a5,0x10050
    80200a04:	0ff00713          	li	a4,255
    80200a08:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200a0a:	47f8                	lw	a4,76(a5)
	} while (r < 0);
    80200a0c:	fe074fe3          	bltz	a4,80200a0a <sdWrite+0x15c>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80200a10:	100507b7          	lui	a5,0x10050
    80200a14:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
			break;
		}
	}
	sd_cmd_end();

	return 0;
    80200a18:	4501                	li	a0,0
}
    80200a1a:	60e2                	ld	ra,24(sp)
    80200a1c:	6442                	ld	s0,16(sp)
    80200a1e:	64a2                	ld	s1,8(sp)
    80200a20:	6902                	ld	s2,0(sp)
    80200a22:	6105                	addi	sp,sp,32
    80200a24:	8082                	ret

0000000080200a26 <sdInit>:

int sdInit(void) {
    80200a26:	7179                	addi	sp,sp,-48
    80200a28:	f406                	sd	ra,40(sp)
    80200a2a:	f022                	sd	s0,32(sp)
    80200a2c:	ec26                	sd	s1,24(sp)
    80200a2e:	e84a                	sd	s2,16(sp)
    80200a30:	e44e                	sd	s3,8(sp)
    80200a32:	e052                	sd	s4,0(sp)
    80200a34:	1800                	addi	s0,sp,48
	REG32(uart, UART_REG_TXCTRL) = UART_TXEN;
    80200a36:	100107b7          	lui	a5,0x10010
    80200a3a:	4705                	li	a4,1
    80200a3c:	c798                	sw	a4,8(a5)
	REG32(spi, SPI_REG_FMT) = 0x80000;
    80200a3e:	100507b7          	lui	a5,0x10050
    80200a42:	00080737          	lui	a4,0x80
    80200a46:	c3b8                	sw	a4,64(a5)
	REG32(spi, SPI_REG_CSDEF) |= 1;
    80200a48:	4bd8                	lw	a4,20(a5)
    80200a4a:	00176713          	ori	a4,a4,1
    80200a4e:	cbd8                	sw	a4,20(a5)
	REG32(spi, SPI_REG_CSID) = 0;
    80200a50:	0007a823          	sw	zero,16(a5) # 10050010 <_start-0x701afff0>
	REG32(spi, SPI_REG_SCKDIV) = f;
    80200a54:	6705                	lui	a4,0x1
    80200a56:	1779                	addi	a4,a4,-2
    80200a58:	c398                	sw	a4,0(a5)
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_OFF;
    80200a5a:	470d                	li	a4,3
    80200a5c:	cf98                	sw	a4,24(a5)
    80200a5e:	46a9                	li	a3,10
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200a60:	10050737          	lui	a4,0x10050
    80200a64:	04870593          	addi	a1,a4,72 # 10050048 <_start-0x701affb8>
    80200a68:	0ff00613          	li	a2,255
    80200a6c:	c190                	sw	a2,0(a1)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200a6e:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200a70:	fe07cfe3          	bltz	a5,80200a6e <sdInit+0x48>
	for (i = 10; i > 0; i--) {
    80200a74:	16fd                	addi	a3,a3,-1
    80200a76:	fafd                	bnez	a3,80200a6c <sdInit+0x46>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80200a78:	100507b7          	lui	a5,0x10050
    80200a7c:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>

	sd_poweron(4094);
	sd_cmd0();
    80200a80:	00000097          	auipc	ra,0x0
    80200a84:	c12080e7          	jalr	-1006(ra) # 80200692 <sd_cmd0>
	//sd_poweron(4094);
	printf("INIT\n");
    80200a88:	00003517          	auipc	a0,0x3
    80200a8c:	65850513          	addi	a0,a0,1624 # 802040e0 <digits+0x50>
    80200a90:	00000097          	auipc	ra,0x0
    80200a94:	a42080e7          	jalr	-1470(ra) # 802004d2 <printf>
	if (sd_cmd0() ||
    80200a98:	00000097          	auipc	ra,0x0
    80200a9c:	bfa080e7          	jalr	-1030(ra) # 80200692 <sd_cmd0>
    80200aa0:	892a                	mv	s2,a0
    80200aa2:	e95d                	bnez	a0,80200b58 <sdInit+0x132>
	rc = (sd_cmd(0x48, 0x000001AA, 0x87) != 0x01);
    80200aa4:	08700613          	li	a2,135
    80200aa8:	1aa00593          	li	a1,426
    80200aac:	04800513          	li	a0,72
    80200ab0:	00000097          	auipc	ra,0x0
    80200ab4:	b08080e7          	jalr	-1272(ra) # 802005b8 <sd_cmd>
    80200ab8:	0005071b          	sext.w	a4,a0
    80200abc:	177d                	addi	a4,a4,-1
    80200abe:	00e03633          	snez	a2,a4
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200ac2:	100507b7          	lui	a5,0x10050
    80200ac6:	0ff00713          	li	a4,255
    80200aca:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200acc:	10050737          	lui	a4,0x10050
    80200ad0:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200ad2:	fe07cfe3          	bltz	a5,80200ad0 <sdInit+0xaa>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200ad6:	100507b7          	lui	a5,0x10050
    80200ada:	0ff00713          	li	a4,255
    80200ade:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200ae0:	10050737          	lui	a4,0x10050
    80200ae4:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200ae6:	fe07cfe3          	bltz	a5,80200ae4 <sdInit+0xbe>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200aea:	100507b7          	lui	a5,0x10050
    80200aee:	0ff00713          	li	a4,255
    80200af2:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200af4:	100506b7          	lui	a3,0x10050
    80200af8:	46fc                	lw	a5,76(a3)
    80200afa:	0007871b          	sext.w	a4,a5
	} while (r < 0);
    80200afe:	fe07cde3          	bltz	a5,80200af8 <sdInit+0xd2>
	rc |= ((sd_dummy() & 0xF) != 0x1); /* voltage */
    80200b02:	8b3d                	andi	a4,a4,15
    80200b04:	fff70793          	addi	a5,a4,-1 # 1004ffff <_start-0x701b0001>
    80200b08:	00f03733          	snez	a4,a5
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200b0c:	100507b7          	lui	a5,0x10050
    80200b10:	0ff00693          	li	a3,255
    80200b14:	c7b4                	sw	a3,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200b16:	100505b7          	lui	a1,0x10050
    80200b1a:	45fc                	lw	a5,76(a1)
    80200b1c:	0007869b          	sext.w	a3,a5
	} while (r < 0);
    80200b20:	fe07cde3          	bltz	a5,80200b1a <sdInit+0xf4>
	rc |= (sd_dummy() != 0xAA); /* check pattern */
    80200b24:	0ff6f793          	zext.b	a5,a3
    80200b28:	f5678793          	addi	a5,a5,-170 # 1004ff56 <_start-0x701b00aa>
    80200b2c:	00f037b3          	snez	a5,a5
    80200b30:	8fd9                	or	a5,a5,a4
    80200b32:	00f66733          	or	a4,a2,a5
    80200b36:	0ff77713          	zext.b	a4,a4
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200b3a:	100507b7          	lui	a5,0x10050
    80200b3e:	0ff00693          	li	a3,255
    80200b42:	c7b4                	sw	a3,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200b44:	100506b7          	lui	a3,0x10050
    80200b48:	46fc                	lw	a5,76(a3)
	} while (r < 0);
    80200b4a:	fe07cfe3          	bltz	a5,80200b48 <sdInit+0x122>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80200b4e:	100507b7          	lui	a5,0x10050
    80200b52:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	if (sd_cmd0() ||
    80200b56:	c31d                	beqz	a4,80200b7c <sdInit+0x156>
	    sd_cmd8() ||
	    sd_acmd41() ||
	    sd_cmd58() ||
	    sd_cmd16()) {
		printf("ERROR");
    80200b58:	00003517          	auipc	a0,0x3
    80200b5c:	59850513          	addi	a0,a0,1432 # 802040f0 <digits+0x60>
    80200b60:	00000097          	auipc	ra,0x0
    80200b64:	972080e7          	jalr	-1678(ra) # 802004d2 <printf>
		return 1;
    80200b68:	4905                	li	s2,1
	REG32(spi, SPI_REG_SCKDIV) = (F_CLK / 16666666UL);
	printf("BOOT");

	__asm__ __volatile__ ("fence.i" : : : "memory");
	return 0;
}
    80200b6a:	854a                	mv	a0,s2
    80200b6c:	70a2                	ld	ra,40(sp)
    80200b6e:	7402                	ld	s0,32(sp)
    80200b70:	64e2                	ld	s1,24(sp)
    80200b72:	6942                	ld	s2,16(sp)
    80200b74:	69a2                	ld	s3,8(sp)
    80200b76:	6a02                	ld	s4,0(sp)
    80200b78:	6145                	addi	sp,sp,48
    80200b7a:	8082                	ret
	printf("ACMD41");
    80200b7c:	00003517          	auipc	a0,0x3
    80200b80:	56c50513          	addi	a0,a0,1388 # 802040e8 <digits+0x58>
    80200b84:	00000097          	auipc	ra,0x0
    80200b88:	94e080e7          	jalr	-1714(ra) # 802004d2 <printf>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200b8c:	100504b7          	lui	s1,0x10050
    80200b90:	0ff00a13          	li	s4,255
	} while (r == 0x01);
    80200b94:	4985                	li	s3,1
	sd_cmd(0x77, 0, 0x65);
    80200b96:	06500613          	li	a2,101
    80200b9a:	4581                	li	a1,0
    80200b9c:	07700513          	li	a0,119
    80200ba0:	00000097          	auipc	ra,0x0
    80200ba4:	a18080e7          	jalr	-1512(ra) # 802005b8 <sd_cmd>
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200ba8:	0544a423          	sw	s4,72(s1) # 10050048 <_start-0x701affb8>
		r = REG32(spi, SPI_REG_RXFIFO);
    80200bac:	44fc                	lw	a5,76(s1)
	} while (r < 0);
    80200bae:	fe07cfe3          	bltz	a5,80200bac <sdInit+0x186>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80200bb2:	0004ac23          	sw	zero,24(s1)
		r = sd_cmd(0x69, 0x40000000, 0x77); /* HCS = 1 */
    80200bb6:	07700613          	li	a2,119
    80200bba:	400005b7          	lui	a1,0x40000
    80200bbe:	06900513          	li	a0,105
    80200bc2:	00000097          	auipc	ra,0x0
    80200bc6:	9f6080e7          	jalr	-1546(ra) # 802005b8 <sd_cmd>
	} while (r == 0x01);
    80200bca:	fd3506e3          	beq	a0,s3,80200b96 <sdInit+0x170>
	    sd_cmd8() ||
    80200bce:	f549                	bnez	a0,80200b58 <sdInit+0x132>
	rc = (sd_cmd(0x50, 0x200, 0x15) != 0x00);
    80200bd0:	4655                	li	a2,21
    80200bd2:	20000593          	li	a1,512
    80200bd6:	05000513          	li	a0,80
    80200bda:	00000097          	auipc	ra,0x0
    80200bde:	9de080e7          	jalr	-1570(ra) # 802005b8 <sd_cmd>
    80200be2:	86aa                	mv	a3,a0
	REG32(spi, SPI_REG_TXFIFO) = d;
    80200be4:	100507b7          	lui	a5,0x10050
    80200be8:	0ff00713          	li	a4,255
    80200bec:	c7b8                	sw	a4,72(a5)
		r = REG32(spi, SPI_REG_RXFIFO);
    80200bee:	10050737          	lui	a4,0x10050
    80200bf2:	477c                	lw	a5,76(a4)
	} while (r < 0);
    80200bf4:	fe07cfe3          	bltz	a5,80200bf2 <sdInit+0x1cc>
	REG32(spi, SPI_REG_CSMODE) = SPI_CSMODE_AUTO;
    80200bf8:	100507b7          	lui	a5,0x10050
    80200bfc:	0007ac23          	sw	zero,24(a5) # 10050018 <_start-0x701affe8>
	    sd_cmd58() ||
    80200c00:	fea1                	bnez	a3,80200b58 <sdInit+0x132>
	REG32(spi, SPI_REG_SCKDIV) = (F_CLK / 16666666UL);
    80200c02:	100507b7          	lui	a5,0x10050
    80200c06:	03c00713          	li	a4,60
    80200c0a:	c398                	sw	a4,0(a5)
	printf("BOOT");
    80200c0c:	00003517          	auipc	a0,0x3
    80200c10:	4ec50513          	addi	a0,a0,1260 # 802040f8 <digits+0x68>
    80200c14:	00000097          	auipc	ra,0x0
    80200c18:	8be080e7          	jalr	-1858(ra) # 802004d2 <printf>
	__asm__ __volatile__ ("fence.i" : : : "memory");
    80200c1c:	0000100f          	fence.i
	return 0;
    80200c20:	b7a9                	j	80200b6a <sdInit+0x144>

0000000080200c22 <memoryInit>:
    pageInsert(kernelPageDirectory, 1ll << 35, page2pa(p), PTE_READ | PTE_WRITE);
    *((u32*)page2pa(p)) = 65536;
    printf("value1 of %lx:  %d\n", 1ll << 35, *((u32*)(1ll<<35)));
}

void memoryInit() {
    80200c22:	715d                	addi	sp,sp,-80
    80200c24:	e486                	sd	ra,72(sp)
    80200c26:	e0a2                	sd	s0,64(sp)
    80200c28:	fc26                	sd	s1,56(sp)
    80200c2a:	f84a                	sd	s2,48(sp)
    80200c2c:	f44e                	sd	s3,40(sp)
    80200c2e:	f052                	sd	s4,32(sp)
    80200c30:	ec56                	sd	s5,24(sp)
    80200c32:	0880                	addi	s0,sp,80
    printf("Memory init start...\n");
    80200c34:	00003517          	auipc	a0,0x3
    80200c38:	4cc50513          	addi	a0,a0,1228 # 80204100 <digits+0x70>
    80200c3c:	00000097          	auipc	ra,0x0
    80200c40:	896080e7          	jalr	-1898(ra) # 802004d2 <printf>
    u32 n = PA2PPN(kernelEnd);
    80200c44:	0016d817          	auipc	a6,0x16d
    80200c48:	3bc80813          	addi	a6,a6,956 # 8036e000 <bssEnd>
    80200c4c:	00c85813          	srli	a6,a6,0xc
    80200c50:	0008061b          	sext.w	a2,a6
    80200c54:	1842                	slli	a6,a6,0x30
    80200c56:	03085813          	srli	a6,a6,0x30
    for (i = 0; i < n; i++) {
    80200c5a:	3e080a63          	beqz	a6,8020104e <memoryInit+0x42c>
    80200c5e:	00055797          	auipc	a5,0x55
    80200c62:	7ca78793          	addi	a5,a5,1994 # 80256428 <pages+0x10>
    80200c66:	fff8069b          	addiw	a3,a6,-1
    80200c6a:	1682                	slli	a3,a3,0x20
    80200c6c:	9281                	srli	a3,a3,0x20
    80200c6e:	00169713          	slli	a4,a3,0x1
    80200c72:	9736                	add	a4,a4,a3
    80200c74:	070e                	slli	a4,a4,0x3
    80200c76:	00055697          	auipc	a3,0x55
    80200c7a:	7ca68693          	addi	a3,a3,1994 # 80256440 <pages+0x28>
    80200c7e:	9736                	add	a4,a4,a3
        pages[i].ref = 1;
    80200c80:	4685                	li	a3,1
    80200c82:	c394                	sw	a3,0(a5)
    for (i = 0; i < n; i++) {
    80200c84:	07e1                	addi	a5,a5,24
    80200c86:	fee79ee3          	bne	a5,a4,80200c82 <memoryInit+0x60>
    LIST_INIT(&freePages);
    80200c8a:	00115797          	auipc	a5,0x115
    80200c8e:	7807b723          	sd	zero,1934(a5) # 80316418 <freePages>
    for (; i < n; i++) {
    80200c92:	823d                	srli	a2,a2,0xf
    80200c94:	8a05                	andi	a2,a2,1
    80200c96:	ee59                	bnez	a2,80200d34 <memoryInit+0x112>
    80200c98:	00115717          	auipc	a4,0x115
    80200c9c:	78073703          	ld	a4,1920(a4) # 80316418 <freePages>
void memoryInit() {
    80200ca0:	8642                	mv	a2,a6
        pages[i].ref = 0;
    80200ca2:	00055597          	auipc	a1,0x55
    80200ca6:	77658593          	addi	a1,a1,1910 # 80256418 <pages>
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    80200caa:	00115317          	auipc	t1,0x115
    80200cae:	76e30313          	addi	t1,t1,1902 # 80316418 <freePages>
    for (; i < n; i++) {
    80200cb2:	68a1                	lui	a7,0x8
    80200cb4:	a02d                	j	80200cde <memoryInit+0xbc>
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    80200cb6:	00151793          	slli	a5,a0,0x1
    80200cba:	97aa                	add	a5,a5,a0
    80200cbc:	078e                	slli	a5,a5,0x3
    80200cbe:	97ae                	add	a5,a5,a1
    80200cc0:	e71c                	sd	a5,8(a4)
    80200cc2:	02061693          	slli	a3,a2,0x20
    80200cc6:	9281                	srli	a3,a3,0x20
    80200cc8:	00169793          	slli	a5,a3,0x1
    80200ccc:	00d78733          	add	a4,a5,a3
    80200cd0:	070e                	slli	a4,a4,0x3
    80200cd2:	972e                	add	a4,a4,a1
    80200cd4:	00673423          	sd	t1,8(a4)
    for (; i < n; i++) {
    80200cd8:	2605                	addiw	a2,a2,1
    80200cda:	03167063          	bgeu	a2,a7,80200cfa <memoryInit+0xd8>
        pages[i].ref = 0;
    80200cde:	02061513          	slli	a0,a2,0x20
    80200ce2:	9101                	srli	a0,a0,0x20
    80200ce4:	00151793          	slli	a5,a0,0x1
    80200ce8:	00a786b3          	add	a3,a5,a0
    80200cec:	068e                	slli	a3,a3,0x3
    80200cee:	96ae                	add	a3,a3,a1
    80200cf0:	0006a823          	sw	zero,16(a3)
        LIST_INSERT_HEAD(&freePages, &pages[i], link);
    80200cf4:	e298                	sd	a4,0(a3)
    80200cf6:	f361                	bnez	a4,80200cb6 <memoryInit+0x94>
    80200cf8:	b7e9                	j	80200cc2 <memoryInit+0xa0>
    80200cfa:	00180693          	addi	a3,a6,1
    80200cfe:	6621                	lui	a2,0x8
    80200d00:	4781                	li	a5,0
    80200d02:	00d66663          	bltu	a2,a3,80200d0e <memoryInit+0xec>
    80200d06:	67a1                	lui	a5,0x8
    80200d08:	37fd                	addiw	a5,a5,-1
    80200d0a:	410787bb          	subw	a5,a5,a6
    80200d0e:	00115697          	auipc	a3,0x115
    80200d12:	70a68693          	addi	a3,a3,1802 # 80316418 <freePages>
    80200d16:	e298                	sd	a4,0(a3)
    80200d18:	010787bb          	addw	a5,a5,a6
    80200d1c:	1782                	slli	a5,a5,0x20
    80200d1e:	9381                	srli	a5,a5,0x20
    80200d20:	00179713          	slli	a4,a5,0x1
    80200d24:	97ba                	add	a5,a5,a4
    80200d26:	078e                	slli	a5,a5,0x3
    80200d28:	00055717          	auipc	a4,0x55
    80200d2c:	6f070713          	addi	a4,a4,1776 # 80256418 <pages>
    80200d30:	97ba                	add	a5,a5,a4
    80200d32:	e794                	sd	a3,8(a5)
    pageInsert(kernelPageDirectory, UART_V, UART, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200d34:	0c600693          	li	a3,198
    80200d38:	10000637          	lui	a2,0x10000
    80200d3c:	3f100593          	li	a1,1009
    80200d40:	05f2                	slli	a1,a1,0x1c
    80200d42:	0016c517          	auipc	a0,0x16c
    80200d46:	2be50513          	addi	a0,a0,702 # 8036d000 <_pgdir>
    80200d4a:	00000097          	auipc	ra,0x0
    80200d4e:	6a8080e7          	jalr	1704(ra) # 802013f2 <pageInsert>
    80200d52:	01f814b7          	lui	s1,0x1f81
    80200d56:	04b6                	slli	s1,s1,0xd
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200d58:	fc100993          	li	s3,-63
    80200d5c:	1982                	slli	s3,s3,0x20
    80200d5e:	0016ca97          	auipc	s5,0x16c
    80200d62:	2a2a8a93          	addi	s5,s5,674 # 8036d000 <_pgdir>
    for (u64 i = 0; i < 0x10000; i += PAGE_SIZE) {
    80200d66:	6a05                	lui	s4,0x1
    80200d68:	003f0937          	lui	s2,0x3f0
    80200d6c:	20190913          	addi	s2,s2,513 # 3f0201 <_start-0x7fe0fdff>
    80200d70:	0942                	slli	s2,s2,0x10
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200d72:	0c600693          	li	a3,198
    80200d76:	01348633          	add	a2,s1,s3
    80200d7a:	85a6                	mv	a1,s1
    80200d7c:	8556                	mv	a0,s5
    80200d7e:	00000097          	auipc	ra,0x0
    80200d82:	674080e7          	jalr	1652(ra) # 802013f2 <pageInsert>
    for (u64 i = 0; i < 0x10000; i += PAGE_SIZE) {
    80200d86:	94d2                	add	s1,s1,s4
    80200d88:	ff2495e3          	bne	s1,s2,80200d72 <memoryInit+0x150>
    80200d8c:	00fc34b7          	lui	s1,0xfc3
    80200d90:	04ba                	slli	s1,s1,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200d92:	fc100993          	li	s3,-63
    80200d96:	1982                	slli	s3,s3,0x20
    80200d98:	0016ca97          	auipc	s5,0x16c
    80200d9c:	268a8a93          	addi	s5,s5,616 # 8036d000 <_pgdir>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80200da0:	6a05                	lui	s4,0x1
    80200da2:	00fc3937          	lui	s2,0xfc3
    80200da6:	0905                	addi	s2,s2,1
    80200da8:	093a                	slli	s2,s2,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200daa:	0c600693          	li	a3,198
    80200dae:	01348633          	add	a2,s1,s3
    80200db2:	85a6                	mv	a1,s1
    80200db4:	8556                	mv	a0,s5
    80200db6:	00000097          	auipc	ra,0x0
    80200dba:	63c080e7          	jalr	1596(ra) # 802013f2 <pageInsert>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80200dbe:	94d2                	add	s1,s1,s4
    80200dc0:	ff2495e3          	bne	s1,s2,80200daa <memoryInit+0x188>
    80200dc4:	1f8614b7          	lui	s1,0x1f861
    80200dc8:	04a6                	slli	s1,s1,0x9
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200dca:	fc100993          	li	s3,-63
    80200dce:	1982                	slli	s3,s3,0x20
    80200dd0:	0016ca97          	auipc	s5,0x16c
    80200dd4:	230a8a93          	addi	s5,s5,560 # 8036d000 <_pgdir>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80200dd8:	6a05                	lui	s4,0x1
    80200dda:	00fc3937          	lui	s2,0xfc3
    80200dde:	08190913          	addi	s2,s2,129 # fc3081 <_start-0x7f23cf7f>
    80200de2:	093a                	slli	s2,s2,0xe
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200de4:	0c600693          	li	a3,198
    80200de8:	01348633          	add	a2,s1,s3
    80200dec:	85a6                	mv	a1,s1
    80200dee:	8556                	mv	a0,s5
    80200df0:	00000097          	auipc	ra,0x0
    80200df4:	602080e7          	jalr	1538(ra) # 802013f2 <pageInsert>
    for (u64 i = 0; i < 0x4000; i += PAGE_SIZE) {
    80200df8:	94d2                	add	s1,s1,s4
    80200dfa:	ff2495e3          	bne	s1,s2,80200de4 <memoryInit+0x1c2>
    pageInsert(kernelPageDirectory, SPI_CTRL_ADDR, SPI_CTRL_ADDR, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200dfe:	0c600693          	li	a3,198
    80200e02:	10050637          	lui	a2,0x10050
    80200e06:	100505b7          	lui	a1,0x10050
    80200e0a:	0016c517          	auipc	a0,0x16c
    80200e0e:	1f650513          	addi	a0,a0,502 # 8036d000 <_pgdir>
    80200e12:	00000097          	auipc	ra,0x0
    80200e16:	5e0080e7          	jalr	1504(ra) # 802013f2 <pageInsert>
    pageInsert(kernelPageDirectory, UART_CTRL_ADDR, UART_CTRL_ADDR, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200e1a:	0c600693          	li	a3,198
    80200e1e:	10010637          	lui	a2,0x10010
    80200e22:	100105b7          	lui	a1,0x10010
    80200e26:	0016c517          	auipc	a0,0x16c
    80200e2a:	1da50513          	addi	a0,a0,474 # 8036d000 <_pgdir>
    80200e2e:	00000097          	auipc	ra,0x0
    80200e32:	5c4080e7          	jalr	1476(ra) # 802013f2 <pageInsert>
    va = pa = (u64)kernelStart;
    80200e36:	fffff917          	auipc	s2,0xfffff
    80200e3a:	1ca90913          	addi	s2,s2,458 # 80200000 <_start>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80200e3e:	00003497          	auipc	s1,0x3
    80200e42:	1c248493          	addi	s1,s1,450 # 80204000 <textEnd>
    80200e46:	02997363          	bgeu	s2,s1,80200e6c <memoryInit+0x24a>
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_EXECUTE | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200e4a:	0016ca17          	auipc	s4,0x16c
    80200e4e:	1b6a0a13          	addi	s4,s4,438 # 8036d000 <_pgdir>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80200e52:	6985                	lui	s3,0x1
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_EXECUTE | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200e54:	0ce00693          	li	a3,206
    80200e58:	864a                	mv	a2,s2
    80200e5a:	85ca                	mv	a1,s2
    80200e5c:	8552                	mv	a0,s4
    80200e5e:	00000097          	auipc	ra,0x0
    80200e62:	594080e7          	jalr	1428(ra) # 802013f2 <pageInsert>
    for (u64 i = 0; va + i < (u64)textEnd; i += PAGE_SIZE) {
    80200e66:	994e                	add	s2,s2,s3
    80200e68:	fe9966e3          	bltu	s2,s1,80200e54 <memoryInit+0x232>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80200e6c:	47c5                	li	a5,17
    80200e6e:	07ee                	slli	a5,a5,0x1b
    80200e70:	02f4f463          	bgeu	s1,a5,80200e98 <memoryInit+0x276>
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200e74:	0016ca17          	auipc	s4,0x16c
    80200e78:	18ca0a13          	addi	s4,s4,396 # 8036d000 <_pgdir>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80200e7c:	6985                	lui	s3,0x1
    80200e7e:	893e                	mv	s2,a5
        pageInsert(kernelPageDirectory, va + i, pa + i, PTE_READ | PTE_WRITE | PTE_ACCESSED | PTE_DIRTY);
    80200e80:	0c600693          	li	a3,198
    80200e84:	8626                	mv	a2,s1
    80200e86:	85a6                	mv	a1,s1
    80200e88:	8552                	mv	a0,s4
    80200e8a:	00000097          	auipc	ra,0x0
    80200e8e:	568080e7          	jalr	1384(ra) # 802013f2 <pageInsert>
    for (u64 i = 0; va + i < PHYSICAL_MEMORY_TOP; i += PAGE_SIZE) {
    80200e92:	94ce                	add	s1,s1,s3
    80200e94:	ff24e6e3          	bltu	s1,s2,80200e80 <memoryInit+0x25e>
    pageInsert(kernelPageDirectory, TRAMPOLINE_BASE, (u64)trampoline, 
    80200e98:	0ce00693          	li	a3,206
    80200e9c:	00002617          	auipc	a2,0x2
    80200ea0:	16460613          	addi	a2,a2,356 # 80203000 <_trampoline>
    80200ea4:	040005b7          	lui	a1,0x4000
    80200ea8:	15fd                	addi	a1,a1,-1
    80200eaa:	05b2                	slli	a1,a1,0xc
    80200eac:	0016c517          	auipc	a0,0x16c
    80200eb0:	15450513          	addi	a0,a0,340 # 8036d000 <_pgdir>
    80200eb4:	00000097          	auipc	ra,0x0
    80200eb8:	53e080e7          	jalr	1342(ra) # 802013f2 <pageInsert>
    w_satp(MAKE_SATP(kernelPageDirectory));
    80200ebc:	0016ca97          	auipc	s5,0x16c
    80200ec0:	144a8a93          	addi	s5,s5,324 # 8036d000 <_pgdir>
    80200ec4:	00cad793          	srli	a5,s5,0xc
    80200ec8:	577d                	li	a4,-1
    80200eca:	177e                	slli	a4,a4,0x3f
    80200ecc:	8fd9                	or	a5,a5,a4
#define MAKE_SATP(pagetable) (SATP_SV39 | (((u64)pagetable) >> 12))

// supervisor address translation and protection;
// holds the address of the page table.
static inline void w_satp(u64 x) {
	asm volatile("csrw satp, %0" : : "r" (x));
    80200ece:	18079073          	csrw	satp,a5

// flush the TLB.
static inline void sfence_vma() {
	// the zero, zero means flush all TLB entries.
	// asm volatile("sfence.vma zero, zero");
	asm volatile("sfence.vma");
    80200ed2:	12000073          	sfence.vma
    initFreePages();
    virtualMemory();
    startPage();
    printf("Memory init finish!\n");
    80200ed6:	00003517          	auipc	a0,0x3
    80200eda:	24250513          	addi	a0,a0,578 # 80204118 <digits+0x88>
    80200ede:	fffff097          	auipc	ra,0xfffff
    80200ee2:	5f4080e7          	jalr	1524(ra) # 802004d2 <printf>
    printf("Test memory start...\n");
    80200ee6:	00003517          	auipc	a0,0x3
    80200eea:	24a50513          	addi	a0,a0,586 # 80204130 <digits+0xa0>
    80200eee:	fffff097          	auipc	ra,0xfffff
    80200ef2:	5e4080e7          	jalr	1508(ra) # 802004d2 <printf>
    pageAlloc(&p);
    80200ef6:	fb840513          	addi	a0,s0,-72
    80200efa:	00000097          	auipc	ra,0x0
    80200efe:	27c080e7          	jalr	636(ra) # 80201176 <pageAlloc>
    u32 ref;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    80200f02:	00055a17          	auipc	s4,0x55
    80200f06:	516a0a13          	addi	s4,s4,1302 # 80256418 <pages>
    80200f0a:	fb843583          	ld	a1,-72(s0)
    80200f0e:	414585b3          	sub	a1,a1,s4
    80200f12:	858d                	srai	a1,a1,0x3
    80200f14:	00003997          	auipc	s3,0x3
    80200f18:	5bc9b983          	ld	s3,1468(s3) # 802044d0 <rodataEnd+0x4>
    80200f1c:	033585b3          	mul	a1,a1,s3
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80200f20:	00c5959b          	slliw	a1,a1,0xc
    80200f24:	1582                	slli	a1,a1,0x20
    80200f26:	9181                	srli	a1,a1,0x20
    80200f28:	4485                	li	s1,1
    80200f2a:	01f49913          	slli	s2,s1,0x1f
    printf("alloced page1:  %lx\n", page2pa(p));
    80200f2e:	95ca                	add	a1,a1,s2
    80200f30:	00003517          	auipc	a0,0x3
    80200f34:	21850513          	addi	a0,a0,536 # 80204148 <digits+0xb8>
    80200f38:	fffff097          	auipc	ra,0xfffff
    80200f3c:	59a080e7          	jalr	1434(ra) # 802004d2 <printf>
    return page - pages;
    80200f40:	fb843603          	ld	a2,-72(s0)
    80200f44:	41460633          	sub	a2,a2,s4
    80200f48:	860d                	srai	a2,a2,0x3
    80200f4a:	03360633          	mul	a2,a2,s3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80200f4e:	00c6161b          	slliw	a2,a2,0xc
    80200f52:	1602                	slli	a2,a2,0x20
    80200f54:	9201                	srli	a2,a2,0x20
    pageInsert(kernelPageDirectory, 1ll << 35, page2pa(p), PTE_READ | PTE_WRITE);
    80200f56:	4699                	li	a3,6
    80200f58:	964a                	add	a2,a2,s2
    80200f5a:	02349593          	slli	a1,s1,0x23
    80200f5e:	8556                	mv	a0,s5
    80200f60:	00000097          	auipc	ra,0x0
    80200f64:	492080e7          	jalr	1170(ra) # 802013f2 <pageInsert>
    return page - pages;
    80200f68:	fb843783          	ld	a5,-72(s0)
    80200f6c:	414787b3          	sub	a5,a5,s4
    80200f70:	878d                	srai	a5,a5,0x3
    80200f72:	033787b3          	mul	a5,a5,s3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80200f76:	00c7979b          	slliw	a5,a5,0xc
    80200f7a:	1782                	slli	a5,a5,0x20
    80200f7c:	9381                	srli	a5,a5,0x20
    *((u32*)page2pa(p)) = 147893;
    80200f7e:	97ca                	add	a5,a5,s2
    80200f80:	00024737          	lui	a4,0x24
    80200f84:	1b570713          	addi	a4,a4,437 # 241b5 <_start-0x801dbe4b>
    80200f88:	c398                	sw	a4,0(a5)
    printf("value1 of %lx:  %d\n", 1ll << 35, *((u32*)(1ll<<35)));
    80200f8a:	148e                	slli	s1,s1,0x23
    80200f8c:	4090                	lw	a2,0(s1)
    80200f8e:	85a6                	mv	a1,s1
    80200f90:	00003517          	auipc	a0,0x3
    80200f94:	1d050513          	addi	a0,a0,464 # 80204160 <digits+0xd0>
    80200f98:	fffff097          	auipc	ra,0xfffff
    80200f9c:	53a080e7          	jalr	1338(ra) # 802004d2 <printf>
    pageAlloc(&p);
    80200fa0:	fb840513          	addi	a0,s0,-72
    80200fa4:	00000097          	auipc	ra,0x0
    80200fa8:	1d2080e7          	jalr	466(ra) # 80201176 <pageAlloc>
    return page - pages;
    80200fac:	fb843583          	ld	a1,-72(s0)
    80200fb0:	414585b3          	sub	a1,a1,s4
    80200fb4:	858d                	srai	a1,a1,0x3
    80200fb6:	033585b3          	mul	a1,a1,s3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80200fba:	00c5959b          	slliw	a1,a1,0xc
    80200fbe:	1582                	slli	a1,a1,0x20
    80200fc0:	9181                	srli	a1,a1,0x20
    printf("alloced page2:  %lx\n", page2pa(p));
    80200fc2:	95ca                	add	a1,a1,s2
    80200fc4:	00003517          	auipc	a0,0x3
    80200fc8:	1b450513          	addi	a0,a0,436 # 80204178 <digits+0xe8>
    80200fcc:	fffff097          	auipc	ra,0xfffff
    80200fd0:	506080e7          	jalr	1286(ra) # 802004d2 <printf>
    return page - pages;
    80200fd4:	fb843603          	ld	a2,-72(s0)
    80200fd8:	41460633          	sub	a2,a2,s4
    80200fdc:	860d                	srai	a2,a2,0x3
    80200fde:	03360633          	mul	a2,a2,s3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80200fe2:	00c6161b          	slliw	a2,a2,0xc
    80200fe6:	1602                	slli	a2,a2,0x20
    80200fe8:	9201                	srli	a2,a2,0x20
    pageInsert(kernelPageDirectory, 1ll << 35, page2pa(p), PTE_READ | PTE_WRITE);
    80200fea:	4699                	li	a3,6
    80200fec:	964a                	add	a2,a2,s2
    80200fee:	85a6                	mv	a1,s1
    80200ff0:	8556                	mv	a0,s5
    80200ff2:	00000097          	auipc	ra,0x0
    80200ff6:	400080e7          	jalr	1024(ra) # 802013f2 <pageInsert>
    return page - pages;
    80200ffa:	fb843783          	ld	a5,-72(s0)
    80200ffe:	414787b3          	sub	a5,a5,s4
    80201002:	878d                	srai	a5,a5,0x3
    80201004:	033787b3          	mul	a5,a5,s3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80201008:	00c7979b          	slliw	a5,a5,0xc
    8020100c:	1782                	slli	a5,a5,0x20
    8020100e:	9381                	srli	a5,a5,0x20
    *((u32*)page2pa(p)) = 65536;
    80201010:	993e                	add	s2,s2,a5
    80201012:	67c1                	lui	a5,0x10
    80201014:	00f92023          	sw	a5,0(s2)
    printf("value1 of %lx:  %d\n", 1ll << 35, *((u32*)(1ll<<35)));
    80201018:	4090                	lw	a2,0(s1)
    8020101a:	85a6                	mv	a1,s1
    8020101c:	00003517          	auipc	a0,0x3
    80201020:	14450513          	addi	a0,a0,324 # 80204160 <digits+0xd0>
    80201024:	fffff097          	auipc	ra,0xfffff
    80201028:	4ae080e7          	jalr	1198(ra) # 802004d2 <printf>
    testMemory();
    printf("Test memory finish!\n");
    8020102c:	00003517          	auipc	a0,0x3
    80201030:	16450513          	addi	a0,a0,356 # 80204190 <digits+0x100>
    80201034:	fffff097          	auipc	ra,0xfffff
    80201038:	49e080e7          	jalr	1182(ra) # 802004d2 <printf>
}
    8020103c:	60a6                	ld	ra,72(sp)
    8020103e:	6406                	ld	s0,64(sp)
    80201040:	74e2                	ld	s1,56(sp)
    80201042:	7942                	ld	s2,48(sp)
    80201044:	79a2                	ld	s3,40(sp)
    80201046:	7a02                	ld	s4,32(sp)
    80201048:	6ae2                	ld	s5,24(sp)
    8020104a:	6161                	addi	sp,sp,80
    8020104c:	8082                	ret
    LIST_INIT(&freePages);
    8020104e:	00115797          	auipc	a5,0x115
    80201052:	3c07b523          	sd	zero,970(a5) # 80316418 <freePages>
    for (; i < n; i++) {
    80201056:	b189                	j	80200c98 <memoryInit+0x76>

0000000080201058 <bcopy>:

void bcopy(void *src, void *dst, u32 len) {
    80201058:	1141                	addi	sp,sp,-16
    8020105a:	e422                	sd	s0,8(sp)
    8020105c:	0800                	addi	s0,sp,16
    void *finish = src + len;
    8020105e:	02061693          	slli	a3,a2,0x20
    80201062:	9281                	srli	a3,a3,0x20
    80201064:	96aa                	add	a3,a3,a0

    if (len <= 7) {
    80201066:	479d                	li	a5,7
    80201068:	06c7f063          	bgeu	a5,a2,802010c8 <bcopy+0x70>
            src++;
            dst++;
        }
        return;
    }
    while (((u64)src) & 7) {
    8020106c:	00757793          	andi	a5,a0,7
    80201070:	cb91                	beqz	a5,80201084 <bcopy+0x2c>
        *(u8*)dst = *(u8*)src;
    80201072:	00054783          	lbu	a5,0(a0)
    80201076:	00f58023          	sb	a5,0(a1) # 4000000 <_start-0x7c200000>
        src++;
    8020107a:	0505                	addi	a0,a0,1
        dst++;
    8020107c:	0585                	addi	a1,a1,1
    while (((u64)src) & 7) {
    8020107e:	00757793          	andi	a5,a0,7
    80201082:	fbe5                	bnez	a5,80201072 <bcopy+0x1a>
    }
    while (src + 7 < finish) {
    80201084:	00750793          	addi	a5,a0,7
    80201088:	04d7fb63          	bgeu	a5,a3,802010de <bcopy+0x86>
    8020108c:	ff868813          	addi	a6,a3,-8
    80201090:	40a80833          	sub	a6,a6,a0
    80201094:	ff887813          	andi	a6,a6,-8
    80201098:	0821                	addi	a6,a6,8
    8020109a:	010507b3          	add	a5,a0,a6
    8020109e:	872e                	mv	a4,a1
        *(u64*)dst = *(u64*)src;
    802010a0:	6110                	ld	a2,0(a0)
    802010a2:	e310                	sd	a2,0(a4)
        src += 8;
    802010a4:	0521                	addi	a0,a0,8
        dst += 8;
    802010a6:	0721                	addi	a4,a4,8
    while (src + 7 < finish) {
    802010a8:	fef51ce3          	bne	a0,a5,802010a0 <bcopy+0x48>
        dst += 8;
    802010ac:	95c2                	add	a1,a1,a6
    }
    while (src < finish){
    802010ae:	00d7fa63          	bgeu	a5,a3,802010c2 <bcopy+0x6a>
        *(u8*)dst = *(u8*)src;
    802010b2:	0007c703          	lbu	a4,0(a5)
    802010b6:	00e58023          	sb	a4,0(a1)
        src++;
    802010ba:	0785                	addi	a5,a5,1
        dst++;
    802010bc:	0585                	addi	a1,a1,1
    while (src < finish){
    802010be:	fef69ae3          	bne	a3,a5,802010b2 <bcopy+0x5a>
    }
}
    802010c2:	6422                	ld	s0,8(sp)
    802010c4:	0141                	addi	sp,sp,16
    802010c6:	8082                	ret
        while (src < finish) {
    802010c8:	fed57de3          	bgeu	a0,a3,802010c2 <bcopy+0x6a>
            *(u8*)dst = *(u8*)src;
    802010cc:	00054783          	lbu	a5,0(a0)
    802010d0:	00f58023          	sb	a5,0(a1)
            src++;
    802010d4:	0505                	addi	a0,a0,1
            dst++;
    802010d6:	0585                	addi	a1,a1,1
        while (src < finish) {
    802010d8:	fea69ae3          	bne	a3,a0,802010cc <bcopy+0x74>
    802010dc:	b7dd                	j	802010c2 <bcopy+0x6a>
    while (src + 7 < finish) {
    802010de:	87aa                	mv	a5,a0
    802010e0:	b7f9                	j	802010ae <bcopy+0x56>

00000000802010e2 <bzero>:

void bzero(void *start, u32 len) {
    802010e2:	1141                	addi	sp,sp,-16
    802010e4:	e422                	sd	s0,8(sp)
    802010e6:	0800                	addi	s0,sp,16
    void *finish = start + len;
    802010e8:	02059713          	slli	a4,a1,0x20
    802010ec:	9301                	srli	a4,a4,0x20
    802010ee:	972a                	add	a4,a4,a0

    if (len <= 7) {
    802010f0:	479d                	li	a5,7
    802010f2:	04b7f463          	bgeu	a5,a1,8020113a <bzero+0x58>
        while (start < finish) {
            *(u8*)start++ = 0;
        }
        return;
    }
    while (((u64) start) & 7) {
    802010f6:	00757793          	andi	a5,a0,7
    802010fa:	c799                	beqz	a5,80201108 <bzero+0x26>
        *(u8*)start++ = 0;
    802010fc:	0505                	addi	a0,a0,1
    802010fe:	fe050fa3          	sb	zero,-1(a0)
    while (((u64) start) & 7) {
    80201102:	00757793          	andi	a5,a0,7
    80201106:	fbfd                	bnez	a5,802010fc <bzero+0x1a>
    }
    while (start + 7 < finish) {
    80201108:	00750793          	addi	a5,a0,7
    8020110c:	02e7ff63          	bgeu	a5,a4,8020114a <bzero+0x68>
    80201110:	ff870793          	addi	a5,a4,-8
    80201114:	8f89                	sub	a5,a5,a0
    80201116:	9be1                	andi	a5,a5,-8
    80201118:	07a1                	addi	a5,a5,8
    8020111a:	97aa                	add	a5,a5,a0
        *(u64*)start = 0;
    8020111c:	00053023          	sd	zero,0(a0)
        start += 8;
    80201120:	0521                	addi	a0,a0,8
    while (start + 7 < finish) {
    80201122:	fef51de3          	bne	a0,a5,8020111c <bzero+0x3a>
    }
    while (start < finish) {
    80201126:	00e7f763          	bgeu	a5,a4,80201134 <bzero+0x52>
        *(u8*)start++ = 0;
    8020112a:	0785                	addi	a5,a5,1
    8020112c:	fe078fa3          	sb	zero,-1(a5)
    while (start < finish) {
    80201130:	fef71de3          	bne	a4,a5,8020112a <bzero+0x48>
    }
    80201134:	6422                	ld	s0,8(sp)
    80201136:	0141                	addi	sp,sp,16
    80201138:	8082                	ret
        while (start < finish) {
    8020113a:	fee57de3          	bgeu	a0,a4,80201134 <bzero+0x52>
            *(u8*)start++ = 0;
    8020113e:	0505                	addi	a0,a0,1
    80201140:	fe050fa3          	sb	zero,-1(a0)
        while (start < finish) {
    80201144:	fea71de3          	bne	a4,a0,8020113e <bzero+0x5c>
    80201148:	b7f5                	j	80201134 <bzero+0x52>
    while (start + 7 < finish) {
    8020114a:	87aa                	mv	a5,a0
    8020114c:	bfe9                	j	80201126 <bzero+0x44>

000000008020114e <pageLockInit>:
#include <Spinlock.h>

extern PageList freePages;
struct Spinlock pageListLock;

inline void pageLockInit(void) {
    8020114e:	1141                	addi	sp,sp,-16
    80201150:	e406                	sd	ra,8(sp)
    80201152:	e022                	sd	s0,0(sp)
    80201154:	0800                	addi	s0,sp,16
    initLock(&pageListLock, "pageListLock");
    80201156:	00003597          	auipc	a1,0x3
    8020115a:	05258593          	addi	a1,a1,82 # 802041a8 <digits+0x118>
    8020115e:	00115517          	auipc	a0,0x115
    80201162:	2c250513          	addi	a0,a0,706 # 80316420 <pageListLock>
    80201166:	00001097          	auipc	ra,0x1
    8020116a:	506080e7          	jalr	1286(ra) # 8020266c <initLock>
}
    8020116e:	60a2                	ld	ra,8(sp)
    80201170:	6402                	ld	s0,0(sp)
    80201172:	0141                	addi	sp,sp,16
    80201174:	8082                	ret

0000000080201176 <pageAlloc>:

int pageAlloc(PhysicalPage **pp) {
    80201176:	1101                	addi	sp,sp,-32
    80201178:	ec06                	sd	ra,24(sp)
    8020117a:	e822                	sd	s0,16(sp)
    8020117c:	e426                	sd	s1,8(sp)
    8020117e:	e04a                	sd	s2,0(sp)
    80201180:	1000                	addi	s0,sp,32
    80201182:	892a                	mv	s2,a0
    acquireLock(&pageListLock);
    80201184:	00115517          	auipc	a0,0x115
    80201188:	29c50513          	addi	a0,a0,668 # 80316420 <pageListLock>
    8020118c:	00001097          	auipc	ra,0x1
    80201190:	526080e7          	jalr	1318(ra) # 802026b2 <acquireLock>
    PhysicalPage *page;
    if ((page = LIST_FIRST(&freePages)) != NULL) {
    80201194:	00115497          	auipc	s1,0x115
    80201198:	2844b483          	ld	s1,644(s1) # 80316418 <freePages>
    8020119c:	c0b5                	beqz	s1,80201200 <pageAlloc+0x8a>
        releaseLock(&pageListLock);
    8020119e:	00115517          	auipc	a0,0x115
    802011a2:	28250513          	addi	a0,a0,642 # 80316420 <pageListLock>
    802011a6:	00001097          	auipc	ra,0x1
    802011aa:	57e080e7          	jalr	1406(ra) # 80202724 <releaseLock>
        *pp = page;
    802011ae:	00993023          	sd	s1,0(s2)
        LIST_REMOVE(page, link);
    802011b2:	609c                	ld	a5,0(s1)
    802011b4:	c399                	beqz	a5,802011ba <pageAlloc+0x44>
    802011b6:	6498                	ld	a4,8(s1)
    802011b8:	e798                	sd	a4,8(a5)
    802011ba:	649c                	ld	a5,8(s1)
    802011bc:	6098                	ld	a4,0(s1)
    802011be:	e398                	sd	a4,0(a5)
    return page - pages;
    802011c0:	00055797          	auipc	a5,0x55
    802011c4:	25878793          	addi	a5,a5,600 # 80256418 <pages>
    802011c8:	40f487b3          	sub	a5,s1,a5
    802011cc:	878d                	srai	a5,a5,0x3
    802011ce:	00003717          	auipc	a4,0x3
    802011d2:	30273703          	ld	a4,770(a4) # 802044d0 <rodataEnd+0x4>
    802011d6:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802011da:	00c7979b          	slliw	a5,a5,0xc
    802011de:	1782                	slli	a5,a5,0x20
    802011e0:	9381                	srli	a5,a5,0x20
        bzero((void*)page2pa(page), PAGE_SIZE);
    802011e2:	6585                	lui	a1,0x1
    802011e4:	4505                	li	a0,1
    802011e6:	057e                	slli	a0,a0,0x1f
    802011e8:	953e                	add	a0,a0,a5
    802011ea:	00000097          	auipc	ra,0x0
    802011ee:	ef8080e7          	jalr	-264(ra) # 802010e2 <bzero>
        return 0;
    802011f2:	4501                	li	a0,0
    }
    releaseLock(&pageListLock);
    printf("there's no physical page left!\n");
    *pp = NULL;
    return -NO_FREE_MEMORY;
}
    802011f4:	60e2                	ld	ra,24(sp)
    802011f6:	6442                	ld	s0,16(sp)
    802011f8:	64a2                	ld	s1,8(sp)
    802011fa:	6902                	ld	s2,0(sp)
    802011fc:	6105                	addi	sp,sp,32
    802011fe:	8082                	ret
    releaseLock(&pageListLock);
    80201200:	00115517          	auipc	a0,0x115
    80201204:	22050513          	addi	a0,a0,544 # 80316420 <pageListLock>
    80201208:	00001097          	auipc	ra,0x1
    8020120c:	51c080e7          	jalr	1308(ra) # 80202724 <releaseLock>
    printf("there's no physical page left!\n");
    80201210:	00003517          	auipc	a0,0x3
    80201214:	fa850513          	addi	a0,a0,-88 # 802041b8 <digits+0x128>
    80201218:	fffff097          	auipc	ra,0xfffff
    8020121c:	2ba080e7          	jalr	698(ra) # 802004d2 <printf>
    *pp = NULL;
    80201220:	00093023          	sd	zero,0(s2)
    return -NO_FREE_MEMORY;
    80201224:	5571                	li	a0,-4
    80201226:	b7f9                	j	802011f4 <pageAlloc+0x7e>

0000000080201228 <pageWalk>:

static int pageWalk(u64 *pgdir, u64 va, bool create, u64 **pte) {
    80201228:	7159                	addi	sp,sp,-112
    8020122a:	f486                	sd	ra,104(sp)
    8020122c:	f0a2                	sd	s0,96(sp)
    8020122e:	eca6                	sd	s1,88(sp)
    80201230:	e8ca                	sd	s2,80(sp)
    80201232:	e4ce                	sd	s3,72(sp)
    80201234:	e0d2                	sd	s4,64(sp)
    80201236:	fc56                	sd	s5,56(sp)
    80201238:	f85a                	sd	s6,48(sp)
    8020123a:	f45e                	sd	s7,40(sp)
    8020123c:	f062                	sd	s8,32(sp)
    8020123e:	ec66                	sd	s9,24(sp)
    80201240:	e86a                	sd	s10,16(sp)
    80201242:	1880                	addi	s0,sp,112
    80201244:	892e                	mv	s2,a1
    80201246:	8b32                	mv	s6,a2
    80201248:	8ab6                	mv	s5,a3
    8020124a:	49f9                	li	s3,30
    return page - pages;
    8020124c:	00055d17          	auipc	s10,0x55
    80201250:	1ccd0d13          	addi	s10,s10,460 # 80256418 <pages>
    80201254:	00003c97          	auipc	s9,0x3
    80201258:	27cc8c93          	addi	s9,s9,636 # 802044d0 <rodataEnd+0x4>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020125c:	4b85                	li	s7,1
    8020125e:	0bfe                	slli	s7,s7,0x1f
                return ret;
            }
            (*addr) = page2pte(pp) | PTE_VALID;
            pp->ref++;
        }
        addr = (u64*)PTE2PA(*addr);
    80201260:	fff00a37          	lui	s4,0xfff00
    80201264:	008a5a13          	srli	s4,s4,0x8
    for (level = 2; level > 0; level--) {
    80201268:	4c31                	li	s8,12
    8020126a:	a821                	j	80201282 <pageWalk+0x5a>
                *pte = NULL;
    8020126c:	000ab023          	sd	zero,0(s5)
                return 0;
    80201270:	4501                	li	a0,0
    80201272:	a895                	j	802012e6 <pageWalk+0xbe>
        addr = (u64*)PTE2PA(*addr);
    80201274:	6088                	ld	a0,0(s1)
    80201276:	050a                	slli	a0,a0,0x2
    80201278:	01457533          	and	a0,a0,s4
    for (level = 2; level > 0; level--) {
    8020127c:	39dd                	addiw	s3,s3,-9
    8020127e:	05898b63          	beq	s3,s8,802012d4 <pageWalk+0xac>
        addr += GET_PAGE_TABLE_INDEX(va, level);
    80201282:	013957b3          	srl	a5,s2,s3
    80201286:	1ff7f793          	andi	a5,a5,511
    8020128a:	078e                	slli	a5,a5,0x3
    8020128c:	00f504b3          	add	s1,a0,a5
        if (!(*addr) & PTE_VALID) {
    80201290:	609c                	ld	a5,0(s1)
    80201292:	f3ed                	bnez	a5,80201274 <pageWalk+0x4c>
            if (!create) {
    80201294:	fc0b0ce3          	beqz	s6,8020126c <pageWalk+0x44>
            int ret = pageAlloc(&pp);
    80201298:	f9840513          	addi	a0,s0,-104
    8020129c:	00000097          	auipc	ra,0x0
    802012a0:	eda080e7          	jalr	-294(ra) # 80201176 <pageAlloc>
            if (ret < 0) {
    802012a4:	04054163          	bltz	a0,802012e6 <pageWalk+0xbe>
            (*addr) = page2pte(pp) | PTE_VALID;
    802012a8:	f9843703          	ld	a4,-104(s0)
    return page - pages;
    802012ac:	41a707b3          	sub	a5,a4,s10
    802012b0:	878d                	srai	a5,a5,0x3
    802012b2:	000cb683          	ld	a3,0(s9)
    802012b6:	02d787b3          	mul	a5,a5,a3
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802012ba:	00c7979b          	slliw	a5,a5,0xc
    802012be:	1782                	slli	a5,a5,0x20
    802012c0:	9381                	srli	a5,a5,0x20
    802012c2:	97de                	add	a5,a5,s7
#define PTE2PERM(pte) (((u64)(pte)) & ~((1ull << 54) - (1ull << 10)))
#define PTE2PA(pte) (((((u64)(pte)) & ((1ull << 54) - (1ull << 10))) >> PERM_WIDTH) << PAGE_SHIFT)
#define PA2PTE(pa) ((((u64)(pa)) >> PAGE_SHIFT) << PERM_WIDTH)

inline u64 page2pte(PhysicalPage *page) {
    return (page2pa(page) >> PAGE_SHIFT) << PERM_WIDTH;
    802012c4:	8389                	srli	a5,a5,0x2
    802012c6:	0017e793          	ori	a5,a5,1
    802012ca:	e09c                	sd	a5,0(s1)
            pp->ref++;
    802012cc:	4b1c                	lw	a5,16(a4)
    802012ce:	2785                	addiw	a5,a5,1
    802012d0:	cb1c                	sw	a5,16(a4)
    802012d2:	b74d                	j	80201274 <pageWalk+0x4c>
    }
    *pte = addr + GET_PAGE_TABLE_INDEX(va, 0);
    802012d4:	00c95913          	srli	s2,s2,0xc
    802012d8:	1ff97913          	andi	s2,s2,511
    802012dc:	090e                	slli	s2,s2,0x3
    802012de:	954a                	add	a0,a0,s2
    802012e0:	00aab023          	sd	a0,0(s5)
    return 0;
    802012e4:	4501                	li	a0,0
}
    802012e6:	70a6                	ld	ra,104(sp)
    802012e8:	7406                	ld	s0,96(sp)
    802012ea:	64e6                	ld	s1,88(sp)
    802012ec:	6946                	ld	s2,80(sp)
    802012ee:	69a6                	ld	s3,72(sp)
    802012f0:	6a06                	ld	s4,64(sp)
    802012f2:	7ae2                	ld	s5,56(sp)
    802012f4:	7b42                	ld	s6,48(sp)
    802012f6:	7ba2                	ld	s7,40(sp)
    802012f8:	7c02                	ld	s8,32(sp)
    802012fa:	6ce2                	ld	s9,24(sp)
    802012fc:	6d42                	ld	s10,16(sp)
    802012fe:	6165                	addi	sp,sp,112
    80201300:	8082                	ret

0000000080201302 <pageLookup>:

u64 pageLookup(u64 *pgdir, u64 va, u64 **pte) {
    80201302:	7179                	addi	sp,sp,-48
    80201304:	f406                	sd	ra,40(sp)
    80201306:	f022                	sd	s0,32(sp)
    80201308:	ec26                	sd	s1,24(sp)
    8020130a:	1800                	addi	s0,sp,48
    8020130c:	84b2                	mv	s1,a2
    u64 *entry;
    pageWalk(pgdir, va, false, &entry);
    8020130e:	fd840693          	addi	a3,s0,-40
    80201312:	4601                	li	a2,0
    80201314:	00000097          	auipc	ra,0x0
    80201318:	f14080e7          	jalr	-236(ra) # 80201228 <pageWalk>

    if (entry == NULL || !(*entry & PTE_VALID)) {
    8020131c:	fd843783          	ld	a5,-40(s0)
    80201320:	c38d                	beqz	a5,80201342 <pageLookup+0x40>
    80201322:	6388                	ld	a0,0(a5)
    80201324:	8905                	andi	a0,a0,1
    80201326:	c909                	beqz	a0,80201338 <pageLookup+0x36>
        return 0;
    }
    if (pte) {
    80201328:	c091                	beqz	s1,8020132c <pageLookup+0x2a>
        *pte = entry;
    8020132a:	e09c                	sd	a5,0(s1)
    }
    return PTE2PA(*entry);
    8020132c:	6388                	ld	a0,0(a5)
    8020132e:	050a                	slli	a0,a0,0x2
    80201330:	fff007b7          	lui	a5,0xfff00
    80201334:	83a1                	srli	a5,a5,0x8
    80201336:	8d7d                	and	a0,a0,a5
}
    80201338:	70a2                	ld	ra,40(sp)
    8020133a:	7402                	ld	s0,32(sp)
    8020133c:	64e2                	ld	s1,24(sp)
    8020133e:	6145                	addi	sp,sp,48
    80201340:	8082                	ret
        return 0;
    80201342:	4501                	li	a0,0
    80201344:	bfd5                	j	80201338 <pageLookup+0x36>

0000000080201346 <pageFree>:

void pageFree(PhysicalPage *page) {
    if (page->ref > 0) {
    80201346:	491c                	lw	a5,16(a0)
    80201348:	c391                	beqz	a5,8020134c <pageFree+0x6>
    8020134a:	8082                	ret
void pageFree(PhysicalPage *page) {
    8020134c:	1101                	addi	sp,sp,-32
    8020134e:	ec06                	sd	ra,24(sp)
    80201350:	e822                	sd	s0,16(sp)
    80201352:	e426                	sd	s1,8(sp)
    80201354:	1000                	addi	s0,sp,32
    80201356:	84aa                	mv	s1,a0
        return;
    }
    if (page->ref == 0) {
        acquireLock(&pageListLock);
    80201358:	00115517          	auipc	a0,0x115
    8020135c:	0c850513          	addi	a0,a0,200 # 80316420 <pageListLock>
    80201360:	00001097          	auipc	ra,0x1
    80201364:	352080e7          	jalr	850(ra) # 802026b2 <acquireLock>
        LIST_INSERT_HEAD(&freePages, page, link);
    80201368:	00115797          	auipc	a5,0x115
    8020136c:	0b07b783          	ld	a5,176(a5) # 80316418 <freePages>
    80201370:	e09c                	sd	a5,0(s1)
    80201372:	c391                	beqz	a5,80201376 <pageFree+0x30>
    80201374:	e784                	sd	s1,8(a5)
    80201376:	00115797          	auipc	a5,0x115
    8020137a:	0a278793          	addi	a5,a5,162 # 80316418 <freePages>
    8020137e:	e384                	sd	s1,0(a5)
    80201380:	e49c                	sd	a5,8(s1)
        releaseLock(&pageListLock);
    80201382:	00115517          	auipc	a0,0x115
    80201386:	09e50513          	addi	a0,a0,158 # 80316420 <pageListLock>
    8020138a:	00001097          	auipc	ra,0x1
    8020138e:	39a080e7          	jalr	922(ra) # 80202724 <releaseLock>
    }
}
    80201392:	60e2                	ld	ra,24(sp)
    80201394:	6442                	ld	s0,16(sp)
    80201396:	64a2                	ld	s1,8(sp)
    80201398:	6105                	addi	sp,sp,32
    8020139a:	8082                	ret

000000008020139c <pageRemove>:

void pageRemove(u64 *pgdir, u64 va) {
    8020139c:	1101                	addi	sp,sp,-32
    8020139e:	ec06                	sd	ra,24(sp)
    802013a0:	e822                	sd	s0,16(sp)
    802013a2:	1000                	addi	s0,sp,32
    u64 *pte;
    u64 pa = pageLookup(pgdir, va, &pte);
    802013a4:	fe840613          	addi	a2,s0,-24
    802013a8:	00000097          	auipc	ra,0x0
    802013ac:	f5a080e7          	jalr	-166(ra) # 80201302 <pageLookup>

    // tlb flush
    if (pa < PHYSICAL_ADDRESS_BASE || pa >= PHYSICAL_MEMORY_TOP) {
    802013b0:	800007b7          	lui	a5,0x80000
    802013b4:	953e                	add	a0,a0,a5
    802013b6:	080007b7          	lui	a5,0x8000
    802013ba:	00f56663          	bltu	a0,a5,802013c6 <pageRemove+0x2a>
    }
    PhysicalPage *page = pa2page(pa);
    page->ref--;
    pageFree(page);
    *pte = 0;
}
    802013be:	60e2                	ld	ra,24(sp)
    802013c0:	6442                	ld	s0,16(sp)
    802013c2:	6105                	addi	sp,sp,32
    802013c4:	8082                	ret
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    802013c6:	8131                	srli	a0,a0,0xc
    return pages + ppn;
    802013c8:	00151793          	slli	a5,a0,0x1
    802013cc:	953e                	add	a0,a0,a5
    802013ce:	050e                	slli	a0,a0,0x3
    802013d0:	00055797          	auipc	a5,0x55
    802013d4:	04878793          	addi	a5,a5,72 # 80256418 <pages>
    802013d8:	953e                	add	a0,a0,a5
    page->ref--;
    802013da:	491c                	lw	a5,16(a0)
    802013dc:	37fd                	addiw	a5,a5,-1
    802013de:	c91c                	sw	a5,16(a0)
    pageFree(page);
    802013e0:	00000097          	auipc	ra,0x0
    802013e4:	f66080e7          	jalr	-154(ra) # 80201346 <pageFree>
    *pte = 0;
    802013e8:	fe843783          	ld	a5,-24(s0)
    802013ec:	0007b023          	sd	zero,0(a5)
    802013f0:	b7f9                	j	802013be <pageRemove+0x22>

00000000802013f2 <pageInsert>:

int pageInsert(u64 *pgdir, u64 va, u64 pa, u64 perm) {
    802013f2:	715d                	addi	sp,sp,-80
    802013f4:	e486                	sd	ra,72(sp)
    802013f6:	e0a2                	sd	s0,64(sp)
    802013f8:	fc26                	sd	s1,56(sp)
    802013fa:	f84a                	sd	s2,48(sp)
    802013fc:	f44e                	sd	s3,40(sp)
    802013fe:	f052                	sd	s4,32(sp)
    80201400:	ec56                	sd	s5,24(sp)
    80201402:	0880                	addi	s0,sp,80
    80201404:	8aaa                	mv	s5,a0
    80201406:	84b2                	mv	s1,a2
    80201408:	89b6                	mv	s3,a3
    u64 *pte;
    va = DOWN_ALIGN(va, PAGE_SIZE);
    8020140a:	77fd                	lui	a5,0xfffff
    8020140c:	00f5fa33          	and	s4,a1,a5
    pa = DOWN_ALIGN(pa, PAGE_SIZE);
    perm |= PTE_ACCESSED | PTE_DIRTY;
    int ret = pageWalk(pgdir, va, true, &pte);
    80201410:	fb840693          	addi	a3,s0,-72
    80201414:	4605                	li	a2,1
    80201416:	85d2                	mv	a1,s4
    80201418:	00000097          	auipc	ra,0x0
    8020141c:	e10080e7          	jalr	-496(ra) # 80201228 <pageWalk>
    if (ret < 0) {
    80201420:	04054b63          	bltz	a0,80201476 <pageInsert+0x84>
        return ret;
    }
    if (pte != NULL && (*pte & PTE_VALID)) {
    80201424:	fb843903          	ld	s2,-72(s0)
    80201428:	00090663          	beqz	s2,80201434 <pageInsert+0x42>
    8020142c:	00093783          	ld	a5,0(s2)
    80201430:	8b85                	andi	a5,a5,1
    80201432:	ebb9                	bnez	a5,80201488 <pageInsert+0x96>
    pa = DOWN_ALIGN(pa, PAGE_SIZE);
    80201434:	77fd                	lui	a5,0xfffff
    80201436:	00f4f633          	and	a2,s1,a5
        pageRemove(pgdir, va);
    }
    if (pa >= PHYSICAL_ADDRESS_BASE && pa < PHYSICAL_MEMORY_TOP) {
    8020143a:	800007b7          	lui	a5,0x80000
    8020143e:	97b2                	add	a5,a5,a2
    80201440:	08000737          	lui	a4,0x8000
    80201444:	00e7ff63          	bgeu	a5,a4,80201462 <pageInsert+0x70>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    80201448:	00c7d713          	srli	a4,a5,0xc
    return pages + ppn;
    8020144c:	83ad                	srli	a5,a5,0xb
    8020144e:	97ba                	add	a5,a5,a4
    80201450:	078e                	slli	a5,a5,0x3
    80201452:	00055717          	auipc	a4,0x55
    80201456:	fc670713          	addi	a4,a4,-58 # 80256418 <pages>
    8020145a:	97ba                	add	a5,a5,a4
        pa2page(pa)->ref++;
    8020145c:	4b98                	lw	a4,16(a5)
    8020145e:	2705                	addiw	a4,a4,1
    80201460:	cb98                	sw	a4,16(a5)
    }
    *pte = PA2PTE(pa) | perm | PTE_VALID;
    80201462:	8209                	srli	a2,a2,0x2
    80201464:	01366633          	or	a2,a2,s3
    80201468:	0c166613          	ori	a2,a2,193
    8020146c:	00c93023          	sd	a2,0(s2)
    80201470:	12000073          	sfence.vma
    sfence_vma();
    return 0;
    80201474:	4501                	li	a0,0
}
    80201476:	60a6                	ld	ra,72(sp)
    80201478:	6406                	ld	s0,64(sp)
    8020147a:	74e2                	ld	s1,56(sp)
    8020147c:	7942                	ld	s2,48(sp)
    8020147e:	79a2                	ld	s3,40(sp)
    80201480:	7a02                	ld	s4,32(sp)
    80201482:	6ae2                	ld	s5,24(sp)
    80201484:	6161                	addi	sp,sp,80
    80201486:	8082                	ret
        pageRemove(pgdir, va);
    80201488:	85d2                	mv	a1,s4
    8020148a:	8556                	mv	a0,s5
    8020148c:	00000097          	auipc	ra,0x0
    80201490:	f10080e7          	jalr	-240(ra) # 8020139c <pageRemove>
    80201494:	b745                	j	80201434 <pageInsert+0x42>

0000000080201496 <allocPgdir>:

int allocPgdir(PhysicalPage **page) {
    80201496:	1101                	addi	sp,sp,-32
    80201498:	ec06                	sd	ra,24(sp)
    8020149a:	e822                	sd	s0,16(sp)
    8020149c:	e426                	sd	s1,8(sp)
    8020149e:	1000                	addi	s0,sp,32
    802014a0:	84aa                	mv	s1,a0
    int r;
    if ((r = pageAlloc(page)) < 0) {
    802014a2:	00000097          	auipc	ra,0x0
    802014a6:	cd4080e7          	jalr	-812(ra) # 80201176 <pageAlloc>
    802014aa:	00054763          	bltz	a0,802014b8 <allocPgdir+0x22>
        return r;
    }
    (*page)->ref++;
    802014ae:	6098                	ld	a4,0(s1)
    802014b0:	4b1c                	lw	a5,16(a4)
    802014b2:	2785                	addiw	a5,a5,1
    802014b4:	cb1c                	sw	a5,16(a4)
    return 0;
    802014b6:	4501                	li	a0,0
}
    802014b8:	60e2                	ld	ra,24(sp)
    802014ba:	6442                	ld	s0,16(sp)
    802014bc:	64a2                	ld	s1,8(sp)
    802014be:	6105                	addi	sp,sp,32
    802014c0:	8082                	ret

00000000802014c2 <pageout>:

void pageout(u64 *pgdir, u64 badAddr) {
    802014c2:	7179                	addi	sp,sp,-48
    802014c4:	f406                	sd	ra,40(sp)
    802014c6:	f022                	sd	s0,32(sp)
    802014c8:	ec26                	sd	s1,24(sp)
    802014ca:	e84a                	sd	s2,16(sp)
    802014cc:	1800                	addi	s0,sp,48
    if (badAddr <= PAGE_SIZE) {
    802014ce:	6785                	lui	a5,0x1
    802014d0:	06b7f863          	bgeu	a5,a1,80201540 <pageout+0x7e>
    802014d4:	892a                	mv	s2,a0
    802014d6:	84ae                	mv	s1,a1
        panic("^^^^^^^^^^TOO LOW^^^^^^^^^^^\n");
    }
    printf("pageout at %lx\n", badAddr);
    802014d8:	00003517          	auipc	a0,0x3
    802014dc:	d2850513          	addi	a0,a0,-728 # 80204200 <digits+0x170>
    802014e0:	fffff097          	auipc	ra,0xfffff
    802014e4:	ff2080e7          	jalr	-14(ra) # 802004d2 <printf>
    PhysicalPage *page;
    if (pageAlloc(&page) < 0) {
    802014e8:	fd840513          	addi	a0,s0,-40
    802014ec:	00000097          	auipc	ra,0x0
    802014f0:	c8a080e7          	jalr	-886(ra) # 80201176 <pageAlloc>
    802014f4:	06054463          	bltz	a0,8020155c <pageout+0x9a>
    return page - pages;
    802014f8:	fd843783          	ld	a5,-40(s0)
    802014fc:	00055717          	auipc	a4,0x55
    80201500:	f1c70713          	addi	a4,a4,-228 # 80256418 <pages>
    80201504:	8f99                	sub	a5,a5,a4
    80201506:	878d                	srai	a5,a5,0x3
    80201508:	00003717          	auipc	a4,0x3
    8020150c:	fc873703          	ld	a4,-56(a4) # 802044d0 <rodataEnd+0x4>
    80201510:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80201514:	00c7979b          	slliw	a5,a5,0xc
    80201518:	1782                	slli	a5,a5,0x20
    8020151a:	9381                	srli	a5,a5,0x20
        panic("");
    }
    if (pageInsert(pgdir, badAddr, page2pa(page), 
    8020151c:	46d9                	li	a3,22
    8020151e:	4605                	li	a2,1
    80201520:	067e                	slli	a2,a2,0x1f
    80201522:	963e                	add	a2,a2,a5
    80201524:	85a6                	mv	a1,s1
    80201526:	854a                	mv	a0,s2
    80201528:	00000097          	auipc	ra,0x0
    8020152c:	eca080e7          	jalr	-310(ra) # 802013f2 <pageInsert>
    80201530:	04054463          	bltz	a0,80201578 <pageout+0xb6>
        PTE_USER | PTE_READ | PTE_WRITE) < 0) {
        panic("");
    }
}
    80201534:	70a2                	ld	ra,40(sp)
    80201536:	7402                	ld	s0,32(sp)
    80201538:	64e2                	ld	s1,24(sp)
    8020153a:	6942                	ld	s2,16(sp)
    8020153c:	6145                	addi	sp,sp,48
    8020153e:	8082                	ret
        panic("^^^^^^^^^^TOO LOW^^^^^^^^^^^\n");
    80201540:	00003617          	auipc	a2,0x3
    80201544:	c9860613          	addi	a2,a2,-872 # 802041d8 <digits+0x148>
    80201548:	07b00593          	li	a1,123
    8020154c:	00003517          	auipc	a0,0x3
    80201550:	cac50513          	addi	a0,a0,-852 # 802041f8 <digits+0x168>
    80201554:	fffff097          	auipc	ra,0xfffff
    80201558:	fd8080e7          	jalr	-40(ra) # 8020052c <_panic_>
        panic("");
    8020155c:	00003617          	auipc	a2,0x3
    80201560:	b5c60613          	addi	a2,a2,-1188 # 802040b8 <digits+0x28>
    80201564:	08000593          	li	a1,128
    80201568:	00003517          	auipc	a0,0x3
    8020156c:	c9050513          	addi	a0,a0,-880 # 802041f8 <digits+0x168>
    80201570:	fffff097          	auipc	ra,0xfffff
    80201574:	fbc080e7          	jalr	-68(ra) # 8020052c <_panic_>
        panic("");
    80201578:	00003617          	auipc	a2,0x3
    8020157c:	b4060613          	addi	a2,a2,-1216 # 802040b8 <digits+0x28>
    80201580:	08400593          	li	a1,132
    80201584:	00003517          	auipc	a0,0x3
    80201588:	c7450513          	addi	a0,a0,-908 # 802041f8 <digits+0x168>
    8020158c:	fffff097          	auipc	ra,0xfffff
    80201590:	fa0080e7          	jalr	-96(ra) # 8020052c <_panic_>

0000000080201594 <cowHandler>:

void cowHandler(u64 *pgdir, u64 badAddr) {
    80201594:	7139                	addi	sp,sp,-64
    80201596:	fc06                	sd	ra,56(sp)
    80201598:	f822                	sd	s0,48(sp)
    8020159a:	f426                	sd	s1,40(sp)
    8020159c:	f04a                	sd	s2,32(sp)
    8020159e:	ec4e                	sd	s3,24(sp)
    802015a0:	e852                	sd	s4,16(sp)
    802015a2:	0080                	addi	s0,sp,64
    802015a4:	89aa                	mv	s3,a0
    802015a6:	8a2e                	mv	s4,a1
    u64 *pte;
    u64 pa = pageLookup(pgdir, badAddr, &pte);
    802015a8:	fc840613          	addi	a2,s0,-56
    802015ac:	00000097          	auipc	ra,0x0
    802015b0:	d56080e7          	jalr	-682(ra) # 80201302 <pageLookup>
    if (!(*pte & PTE_COW)) {
    802015b4:	fc843783          	ld	a5,-56(s0)
    802015b8:	639c                	ld	a5,0(a5)
    802015ba:	1007f793          	andi	a5,a5,256
    802015be:	cfbd                	beqz	a5,8020163c <cowHandler+0xa8>
    802015c0:	892a                	mv	s2,a0
        printf("access denied");
        return;
    }
    PhysicalPage *page;
    int r = pageAlloc(&page);
    802015c2:	fc040513          	addi	a0,s0,-64
    802015c6:	00000097          	auipc	ra,0x0
    802015ca:	bb0080e7          	jalr	-1104(ra) # 80201176 <pageAlloc>
    if (r < 0) {
    802015ce:	08054063          	bltz	a0,8020164e <cowHandler+0xba>
    return page - pages;
    802015d2:	fc043483          	ld	s1,-64(s0)
    802015d6:	00055797          	auipc	a5,0x55
    802015da:	e4278793          	addi	a5,a5,-446 # 80256418 <pages>
    802015de:	8c9d                	sub	s1,s1,a5
    802015e0:	848d                	srai	s1,s1,0x3
    802015e2:	00003797          	auipc	a5,0x3
    802015e6:	eee7b783          	ld	a5,-274(a5) # 802044d0 <rodataEnd+0x4>
    802015ea:	02f484b3          	mul	s1,s1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802015ee:	00c4949b          	slliw	s1,s1,0xc
    802015f2:	1482                	slli	s1,s1,0x20
    802015f4:	9081                	srli	s1,s1,0x20
    802015f6:	4785                	li	a5,1
    802015f8:	07fe                	slli	a5,a5,0x1f
    802015fa:	94be                	add	s1,s1,a5
        panic("");
        return;
    }
    pageInsert(pgdir, badAddr, page2pa(page), (PTE2PERM(*pte) | PTE_WRITE) & ~PTE_COW);
    802015fc:	fc843783          	ld	a5,-56(s0)
    80201600:	6394                	ld	a3,0(a5)
    80201602:	57fd                	li	a5,-1
    80201604:	17da                	slli	a5,a5,0x36
    80201606:	2fb78793          	addi	a5,a5,763
    8020160a:	8efd                	and	a3,a3,a5
    8020160c:	0046e693          	ori	a3,a3,4
    80201610:	8626                	mv	a2,s1
    80201612:	85d2                	mv	a1,s4
    80201614:	854e                	mv	a0,s3
    80201616:	00000097          	auipc	ra,0x0
    8020161a:	ddc080e7          	jalr	-548(ra) # 802013f2 <pageInsert>
    bcopy((void*) pa, (void*) page2pa(page), PAGE_SIZE);
    8020161e:	6605                	lui	a2,0x1
    80201620:	85a6                	mv	a1,s1
    80201622:	854a                	mv	a0,s2
    80201624:	00000097          	auipc	ra,0x0
    80201628:	a34080e7          	jalr	-1484(ra) # 80201058 <bcopy>
}
    8020162c:	70e2                	ld	ra,56(sp)
    8020162e:	7442                	ld	s0,48(sp)
    80201630:	74a2                	ld	s1,40(sp)
    80201632:	7902                	ld	s2,32(sp)
    80201634:	69e2                	ld	s3,24(sp)
    80201636:	6a42                	ld	s4,16(sp)
    80201638:	6121                	addi	sp,sp,64
    8020163a:	8082                	ret
        printf("access denied");
    8020163c:	00003517          	auipc	a0,0x3
    80201640:	bd450513          	addi	a0,a0,-1068 # 80204210 <digits+0x180>
    80201644:	fffff097          	auipc	ra,0xfffff
    80201648:	e8e080e7          	jalr	-370(ra) # 802004d2 <printf>
        return;
    8020164c:	b7c5                	j	8020162c <cowHandler+0x98>
        panic("");
    8020164e:	00003617          	auipc	a2,0x3
    80201652:	a6a60613          	addi	a2,a2,-1430 # 802040b8 <digits+0x28>
    80201656:	09200593          	li	a1,146
    8020165a:	00003517          	auipc	a0,0x3
    8020165e:	b9e50513          	addi	a0,a0,-1122 # 802041f8 <digits+0x168>
    80201662:	fffff097          	auipc	ra,0xfffff
    80201666:	eca080e7          	jalr	-310(ra) # 8020052c <_panic_>

000000008020166a <loadElf>:
    u8 *ph_table = 0;
    u16 entry_cnt;
    u16 entry_size;
    int r;

    if (size < 4 || !is_elf_format(binary)) {
    8020166a:	478d                	li	a5,3
    8020166c:	0cb7d863          	bge	a5,a1,8020173c <loadElf+0xd2>
    int (*map)(u64 va, u32 segmentSize, u8 *bin, u32 binSize, void *userData)) {
    80201670:	711d                	addi	sp,sp,-96
    80201672:	ec86                	sd	ra,88(sp)
    80201674:	e8a2                	sd	s0,80(sp)
    80201676:	e4a6                	sd	s1,72(sp)
    80201678:	e0ca                	sd	s2,64(sp)
    8020167a:	fc4e                	sd	s3,56(sp)
    8020167c:	f852                	sd	s4,48(sp)
    8020167e:	f456                	sd	s5,40(sp)
    80201680:	f05a                	sd	s6,32(sp)
    80201682:	ec5e                	sd	s7,24(sp)
    80201684:	e862                	sd	s8,16(sp)
    80201686:	e466                	sd	s9,8(sp)
    80201688:	1080                	addi	s0,sp,96
    8020168a:	8b2a                	mv	s6,a0
    8020168c:	8cb2                	mv	s9,a2
    8020168e:	8bb6                	mv	s7,a3
    80201690:	8c3a                	mv	s8,a4
    if (magic[0] == ELF_MAGIC0 &&
    80201692:	00054703          	lbu	a4,0(a0)
    80201696:	07f00793          	li	a5,127
        return -NOT_ELF_FILE;
    8020169a:	5569                	li	a0,-6
    if (magic[0] == ELF_MAGIC0 &&
    8020169c:	08f71363          	bne	a4,a5,80201722 <loadElf+0xb8>
    802016a0:	001b4703          	lbu	a4,1(s6)
    802016a4:	04500793          	li	a5,69
    802016a8:	06f71d63          	bne	a4,a5,80201722 <loadElf+0xb8>
        magic[1] == ELF_MAGIC1 &&
    802016ac:	002b4703          	lbu	a4,2(s6)
    802016b0:	04c00793          	li	a5,76
    802016b4:	06f71763          	bne	a4,a5,80201722 <loadElf+0xb8>
    if (size < 4 || !is_elf_format(binary)) {
    802016b8:	003b4703          	lbu	a4,3(s6)
    802016bc:	04600793          	li	a5,70
    802016c0:	08f71063          	bne	a4,a5,80201740 <loadElf+0xd6>
    }

    ph_table = binary + ehdr->phoff;
    802016c4:	020b3903          	ld	s2,32(s6)
    802016c8:	995a                	add	s2,s2,s6
    entry_cnt = ehdr->phnum;
    802016ca:	038b5783          	lhu	a5,56(s6)
    entry_size = ehdr->phentsize;
    802016ce:	036b5a83          	lhu	s5,54(s6)

    while (entry_cnt--) {
    802016d2:	fff7849b          	addiw	s1,a5,-1
    802016d6:	14c2                	slli	s1,s1,0x30
    802016d8:	90c1                	srli	s1,s1,0x30
    802016da:	cf9d                	beqz	a5,80201718 <loadElf+0xae>
        phdr = (Phdr*)ph_table;
        if (phdr->type == PT_LOAD) {
    802016dc:	4a05                	li	s4,1
    while (entry_cnt--) {
    802016de:	69c1                	lui	s3,0x10
    802016e0:	19fd                	addi	s3,s3,-1
    802016e2:	a809                	j	802016f4 <loadElf+0x8a>
            r = map(phdr->vaddr, phdr->memsz, binary + phdr->offset, phdr->filesz, userData);
            if (r < 0) {
                return r;
            }
        }
        ph_table += entry_size;
    802016e4:	9956                	add	s2,s2,s5
    while (entry_cnt--) {
    802016e6:	34fd                	addiw	s1,s1,-1
    802016e8:	14c2                	slli	s1,s1,0x30
    802016ea:	90c1                	srli	s1,s1,0x30
    802016ec:	0004879b          	sext.w	a5,s1
    802016f0:	03378463          	beq	a5,s3,80201718 <loadElf+0xae>
        if (phdr->type == PT_LOAD) {
    802016f4:	00092783          	lw	a5,0(s2)
    802016f8:	ff4796e3          	bne	a5,s4,802016e4 <loadElf+0x7a>
            r = map(phdr->vaddr, phdr->memsz, binary + phdr->offset, phdr->filesz, userData);
    802016fc:	00893603          	ld	a2,8(s2)
    80201700:	875e                	mv	a4,s7
    80201702:	02092683          	lw	a3,32(s2)
    80201706:	965a                	add	a2,a2,s6
    80201708:	02892583          	lw	a1,40(s2)
    8020170c:	01093503          	ld	a0,16(s2)
    80201710:	9c02                	jalr	s8
            if (r < 0) {
    80201712:	fc0559e3          	bgez	a0,802016e4 <loadElf+0x7a>
    80201716:	a031                	j	80201722 <loadElf+0xb8>
    }
    
    *entry = ehdr->entry;
    80201718:	018b3783          	ld	a5,24(s6)
    8020171c:	00fcb023          	sd	a5,0(s9)
    return 0;
    80201720:	4501                	li	a0,0
    80201722:	60e6                	ld	ra,88(sp)
    80201724:	6446                	ld	s0,80(sp)
    80201726:	64a6                	ld	s1,72(sp)
    80201728:	6906                	ld	s2,64(sp)
    8020172a:	79e2                	ld	s3,56(sp)
    8020172c:	7a42                	ld	s4,48(sp)
    8020172e:	7aa2                	ld	s5,40(sp)
    80201730:	7b02                	ld	s6,32(sp)
    80201732:	6be2                	ld	s7,24(sp)
    80201734:	6c42                	ld	s8,16(sp)
    80201736:	6ca2                	ld	s9,8(sp)
    80201738:	6125                	addi	sp,sp,96
    8020173a:	8082                	ret
        return -NOT_ELF_FILE;
    8020173c:	5569                	li	a0,-6
    8020173e:	8082                	ret
        return -NOT_ELF_FILE;
    80201740:	5569                	li	a0,-6
    80201742:	b7c5                	j	80201722 <loadElf+0xb8>

0000000080201744 <kernelVector>:
.globl kernelTrap
.section .text
.globl kernelVector
.align 2
kernelVector:
    addi sp, sp, -256
    80201744:	7111                	addi	sp,sp,-256

    sd ra, 0(sp)
    80201746:	e006                	sd	ra,0(sp)
    sd sp, 8(sp)
    80201748:	e40a                	sd	sp,8(sp)
    sd gp, 16(sp)
    8020174a:	e80e                	sd	gp,16(sp)
    sd tp, 24(sp)
    8020174c:	ec12                	sd	tp,24(sp)
    sd t0, 32(sp)
    8020174e:	f016                	sd	t0,32(sp)
    sd t1, 40(sp)
    80201750:	f41a                	sd	t1,40(sp)
    sd t2, 48(sp)
    80201752:	f81e                	sd	t2,48(sp)
    sd s0, 56(sp)
    80201754:	fc22                	sd	s0,56(sp)
    sd s1, 64(sp)
    80201756:	e0a6                	sd	s1,64(sp)
    sd a0, 72(sp)
    80201758:	e4aa                	sd	a0,72(sp)
    sd a1, 80(sp)
    8020175a:	e8ae                	sd	a1,80(sp)
    sd a2, 88(sp)
    8020175c:	ecb2                	sd	a2,88(sp)
    sd a3, 96(sp)
    8020175e:	f0b6                	sd	a3,96(sp)
    sd a4, 104(sp)
    80201760:	f4ba                	sd	a4,104(sp)
    sd a5, 112(sp)
    80201762:	f8be                	sd	a5,112(sp)
    sd a6, 120(sp)
    80201764:	fcc2                	sd	a6,120(sp)
    sd a7, 128(sp)
    80201766:	e146                	sd	a7,128(sp)
    sd s2, 136(sp)
    80201768:	e54a                	sd	s2,136(sp)
    sd s3, 144(sp)
    8020176a:	e94e                	sd	s3,144(sp)
    sd s4, 152(sp)
    8020176c:	ed52                	sd	s4,152(sp)
    sd s5, 160(sp)
    8020176e:	f156                	sd	s5,160(sp)
    sd s6, 168(sp)
    80201770:	f55a                	sd	s6,168(sp)
    sd s7, 176(sp)
    80201772:	f95e                	sd	s7,176(sp)
    sd s8, 184(sp)
    80201774:	fd62                	sd	s8,184(sp)
    sd s9, 192(sp)
    80201776:	e1e6                	sd	s9,192(sp)
    sd s10, 200(sp)
    80201778:	e5ea                	sd	s10,200(sp)
    sd s11, 208(sp)
    8020177a:	e9ee                	sd	s11,208(sp)
    sd t3, 216(sp)
    8020177c:	edf2                	sd	t3,216(sp)
    sd t4, 224(sp)
    8020177e:	f1f6                	sd	t4,224(sp)
    sd t5, 232(sp)
    80201780:	f5fa                	sd	t5,232(sp)
    sd t6, 240(sp)
    80201782:	f9fe                	sd	t6,240(sp)

	// call the C trap handler in trap.c
    call kernelTrap
    80201784:	37d000ef          	jal	ra,80202300 <kernelTrap>
    ld ra, 0(sp)
    80201788:	6082                	ld	ra,0(sp)
    ld sp, 8(sp)
    8020178a:	6122                	ld	sp,8(sp)
    ld gp, 16(sp)
    8020178c:	61c2                	ld	gp,16(sp)
    // not this, in case we moved CPUs: ld tp, 24(sp)
    ld t0, 32(sp)
    8020178e:	7282                	ld	t0,32(sp)
    ld t1, 40(sp)
    80201790:	7322                	ld	t1,40(sp)
    ld t2, 48(sp)
    80201792:	73c2                	ld	t2,48(sp)
    ld s0, 56(sp)
    80201794:	7462                	ld	s0,56(sp)
    ld s1, 64(sp)
    80201796:	6486                	ld	s1,64(sp)
    ld a0, 72(sp)
    80201798:	6526                	ld	a0,72(sp)
    ld a1, 80(sp)
    8020179a:	65c6                	ld	a1,80(sp)
    ld a2, 88(sp)
    8020179c:	6666                	ld	a2,88(sp)
    ld a3, 96(sp)
    8020179e:	7686                	ld	a3,96(sp)
    ld a4, 104(sp)
    802017a0:	7726                	ld	a4,104(sp)
    ld a5, 112(sp)
    802017a2:	77c6                	ld	a5,112(sp)
    ld a6, 120(sp)
    802017a4:	7866                	ld	a6,120(sp)
    ld a7, 128(sp)
    802017a6:	688a                	ld	a7,128(sp)
    ld s2, 136(sp)
    802017a8:	692a                	ld	s2,136(sp)
    ld s3, 144(sp)
    802017aa:	69ca                	ld	s3,144(sp)
    ld s4, 152(sp)
    802017ac:	6a6a                	ld	s4,152(sp)
    ld s5, 160(sp)
    802017ae:	7a8a                	ld	s5,160(sp)
    ld s6, 168(sp)
    802017b0:	7b2a                	ld	s6,168(sp)
    ld s7, 176(sp)
    802017b2:	7bca                	ld	s7,176(sp)
    ld s8, 184(sp)
    802017b4:	7c6a                	ld	s8,184(sp)
    ld s9, 192(sp)
    802017b6:	6c8e                	ld	s9,192(sp)
    ld s10, 200(sp)
    802017b8:	6d2e                	ld	s10,200(sp)
    ld s11, 208(sp)
    802017ba:	6dce                	ld	s11,208(sp)
    ld t3, 216(sp)
    802017bc:	6e6e                	ld	t3,216(sp)
    ld t4, 224(sp)
    802017be:	7e8e                	ld	t4,224(sp)
    ld t5, 232(sp)
    802017c0:	7f2e                	ld	t5,232(sp)
    ld t6, 240(sp)
    802017c2:	7fce                	ld	t6,240(sp)

    addi sp, sp, 256
    802017c4:	6111                	addi	sp,sp,256
    sret
    802017c6:	10200073          	sret

00000000802017ca <codeMapper>:

    *new = p;
    return 0;
}

int codeMapper(u64 va, u32 segmentSize, u8 *binary, u32 binSize, void *userData) {
    802017ca:	7119                	addi	sp,sp,-128
    802017cc:	fc86                	sd	ra,120(sp)
    802017ce:	f8a2                	sd	s0,112(sp)
    802017d0:	f4a6                	sd	s1,104(sp)
    802017d2:	f0ca                	sd	s2,96(sp)
    802017d4:	ecce                	sd	s3,88(sp)
    802017d6:	e8d2                	sd	s4,80(sp)
    802017d8:	e4d6                	sd	s5,72(sp)
    802017da:	e0da                	sd	s6,64(sp)
    802017dc:	fc5e                	sd	s7,56(sp)
    802017de:	f862                	sd	s8,48(sp)
    802017e0:	f466                	sd	s9,40(sp)
    802017e2:	f06a                	sd	s10,32(sp)
    802017e4:	ec6e                	sd	s11,24(sp)
    802017e6:	0100                	addi	s0,sp,128
    802017e8:	8baa                	mv	s7,a0
    802017ea:	8d2e                	mv	s10,a1
    802017ec:	8db2                	mv	s11,a2
    802017ee:	89b6                	mv	s3,a3
    802017f0:	8c3a                	mv	s8,a4
    Process *process = (Process*)userData;
    PhysicalPage *p = NULL;
    802017f2:	f8043423          	sd	zero,-120(s0)
    u64 i;
    int r = 0;
    u64 offset = va - DOWN_ALIGN(va, PAGE_SIZE);
    802017f6:	03451793          	slli	a5,a0,0x34
    802017fa:	0347d913          	srli	s2,a5,0x34
    u64* j;

    if (offset > 0) {
    802017fe:	e39d                	bnez	a5,80201824 <codeMapper+0x5a>
                PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        }
        r = MIN(binSize, PAGE_SIZE - offset);
        bcopy(binary, (void*) page2pa(p) + offset, r);
    }
    for (i = r; i < binSize; i += r) {
    80201800:	02069993          	slli	s3,a3,0x20
    80201804:	0209d993          	srli	s3,s3,0x20
    80201808:	26098063          	beqz	s3,80201a68 <codeMapper+0x29e>
    u32 ref;
} PhysicalPage;

inline u32 page2PPN(PhysicalPage *page) {
    extern PhysicalPage pages[];
    return page - pages;
    8020180c:	00055b17          	auipc	s6,0x55
    80201810:	c0cb0b13          	addi	s6,s6,-1012 # 80256418 <pages>
    80201814:	00003a97          	auipc	s5,0x3
    80201818:	cbca8a93          	addi	s5,s5,-836 # 802044d0 <rodataEnd+0x4>
    return pages + ppn;
}


inline u64 page2pa(PhysicalPage *page) {
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020181c:	4a05                	li	s4,1
    8020181e:	0a7e                	slli	s4,s4,0x1f
        if (pageAlloc(&p) != 0) {
            return -1;
        }
        pageInsert(process->pgdir, va + i, page2pa(p), 
            PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        r = MIN(PAGE_SIZE, binSize - i);
    80201820:	6c85                	lui	s9,0x1
    80201822:	a0c5                	j	80201902 <codeMapper+0x138>
        p = pa2page(pageLookup(process->pgdir, va, &j));
    80201824:	f8040613          	addi	a2,s0,-128
    80201828:	85aa                	mv	a1,a0
    8020182a:	13073503          	ld	a0,304(a4)
    8020182e:	00000097          	auipc	ra,0x0
    80201832:	ad4080e7          	jalr	-1324(ra) # 80201302 <pageLookup>
}

inline PhysicalPage* pa2page(u64 pa) {
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    80201836:	800007b7          	lui	a5,0x80000
    8020183a:	00f50733          	add	a4,a0,a5
    8020183e:	8331                	srli	a4,a4,0xc
    return pages + ppn;
    80201840:	1702                	slli	a4,a4,0x20
    80201842:	9301                	srli	a4,a4,0x20
    80201844:	00171793          	slli	a5,a4,0x1
    80201848:	97ba                	add	a5,a5,a4
    8020184a:	078e                	slli	a5,a5,0x3
    8020184c:	00055717          	auipc	a4,0x55
    80201850:	bcc70713          	addi	a4,a4,-1076 # 80256418 <pages>
    80201854:	973e                	add	a4,a4,a5
    80201856:	f8e43423          	sd	a4,-120(s0)
        r = MIN(binSize, PAGE_SIZE - offset);
    8020185a:	1982                	slli	s3,s3,0x20
    8020185c:	0209d993          	srli	s3,s3,0x20
    80201860:	6485                	lui	s1,0x1
    80201862:	412484b3          	sub	s1,s1,s2
    80201866:	0099f363          	bgeu	s3,s1,8020186c <codeMapper+0xa2>
    8020186a:	84ce                	mv	s1,s3
    8020186c:	2481                	sext.w	s1,s1
    return page - pages;
    8020186e:	878d                	srai	a5,a5,0x3
    80201870:	00003717          	auipc	a4,0x3
    80201874:	c6073703          	ld	a4,-928(a4) # 802044d0 <rodataEnd+0x4>
    80201878:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    8020187c:	00c7979b          	slliw	a5,a5,0xc
    80201880:	1782                	slli	a5,a5,0x20
    80201882:	9381                	srli	a5,a5,0x20
        bcopy(binary, (void*) page2pa(p) + offset, r);
    80201884:	4585                	li	a1,1
    80201886:	05fe                	slli	a1,a1,0x1f
    80201888:	95ca                	add	a1,a1,s2
    8020188a:	8626                	mv	a2,s1
    8020188c:	95be                	add	a1,a1,a5
    8020188e:	856e                	mv	a0,s11
    80201890:	fffff097          	auipc	ra,0xfffff
    80201894:	7c8080e7          	jalr	1992(ra) # 80201058 <bcopy>
    for (i = r; i < binSize; i += r) {
    80201898:	8926                	mv	s2,s1
    8020189a:	f734e9e3          	bltu	s1,s3,8020180c <codeMapper+0x42>
        bcopy(binary + i, (void*) page2pa(p), r);
    }

    offset = va + i - DOWN_ALIGN(va + i, PAGE_SIZE);
    8020189e:	012b85b3          	add	a1,s7,s2
    802018a2:	03459793          	slli	a5,a1,0x34
    802018a6:	0347d993          	srli	s3,a5,0x34
    if (offset > 0) {
    802018aa:	e3cd                	bnez	a5,8020194c <codeMapper+0x182>
                PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        }
        r = MIN(segmentSize - i, PAGE_SIZE - offset);
        bzero((void*) page2pa(p) + offset, r);
    }
    for (i += r; i < segmentSize; i += r) {
    802018ac:	94ca                	add	s1,s1,s2
    802018ae:	1d02                	slli	s10,s10,0x20
    802018b0:	020d5d13          	srli	s10,s10,0x20
    802018b4:	1ba4f663          	bgeu	s1,s10,80201a60 <codeMapper+0x296>
    return page - pages;
    802018b8:	00055b17          	auipc	s6,0x55
    802018bc:	b60b0b13          	addi	s6,s6,-1184 # 80256418 <pages>
    802018c0:	00003a97          	auipc	s5,0x3
    802018c4:	c10a8a93          	addi	s5,s5,-1008 # 802044d0 <rodataEnd+0x4>
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802018c8:	4a05                	li	s4,1
    802018ca:	0a7e                	slli	s4,s4,0x1f
        if (pageAlloc(&p) != 0) {
            return -1;
        }
        pageInsert(process->pgdir, va + i, page2pa(p), 
            PTE_EXECUTE | PTE_READ | PTE_WRITE | PTE_USER);
        r = MIN(PAGE_SIZE, segmentSize - i);
    802018cc:	6c85                	lui	s9,0x1
    802018ce:	a21d                	j	802019f4 <codeMapper+0x22a>
        r = MIN(PAGE_SIZE, binSize - i);
    802018d0:	2481                	sext.w	s1,s1
    return page - pages;
    802018d2:	f8843583          	ld	a1,-120(s0)
    802018d6:	416585b3          	sub	a1,a1,s6
    802018da:	858d                	srai	a1,a1,0x3
    802018dc:	000ab783          	ld	a5,0(s5)
    802018e0:	02f585b3          	mul	a1,a1,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802018e4:	00c5959b          	slliw	a1,a1,0xc
    802018e8:	1582                	slli	a1,a1,0x20
    802018ea:	9181                	srli	a1,a1,0x20
        bcopy(binary + i, (void*) page2pa(p), r);
    802018ec:	8626                	mv	a2,s1
    802018ee:	95d2                	add	a1,a1,s4
    802018f0:	012d8533          	add	a0,s11,s2
    802018f4:	fffff097          	auipc	ra,0xfffff
    802018f8:	764080e7          	jalr	1892(ra) # 80201058 <bcopy>
    for (i = r; i < binSize; i += r) {
    802018fc:	9926                	add	s2,s2,s1
    802018fe:	fb3970e3          	bgeu	s2,s3,8020189e <codeMapper+0xd4>
        if (pageAlloc(&p) != 0) {
    80201902:	f8840513          	addi	a0,s0,-120
    80201906:	00000097          	auipc	ra,0x0
    8020190a:	870080e7          	jalr	-1936(ra) # 80201176 <pageAlloc>
    8020190e:	12051863          	bnez	a0,80201a3e <codeMapper+0x274>
    return page - pages;
    80201912:	f8843603          	ld	a2,-120(s0)
    80201916:	41660633          	sub	a2,a2,s6
    8020191a:	860d                	srai	a2,a2,0x3
    8020191c:	000ab783          	ld	a5,0(s5)
    80201920:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80201924:	00c6161b          	slliw	a2,a2,0xc
    80201928:	1602                	slli	a2,a2,0x20
    8020192a:	9201                	srli	a2,a2,0x20
        pageInsert(process->pgdir, va + i, page2pa(p), 
    8020192c:	46f9                	li	a3,30
    8020192e:	9652                	add	a2,a2,s4
    80201930:	012b85b3          	add	a1,s7,s2
    80201934:	130c3503          	ld	a0,304(s8)
    80201938:	00000097          	auipc	ra,0x0
    8020193c:	aba080e7          	jalr	-1350(ra) # 802013f2 <pageInsert>
        r = MIN(PAGE_SIZE, binSize - i);
    80201940:	412984b3          	sub	s1,s3,s2
    80201944:	f89cf6e3          	bgeu	s9,s1,802018d0 <codeMapper+0x106>
    80201948:	84e6                	mv	s1,s9
    8020194a:	b759                	j	802018d0 <codeMapper+0x106>
        p = pa2page(pageLookup(process->pgdir, va + i, &j));
    8020194c:	f8040613          	addi	a2,s0,-128
    80201950:	130c3503          	ld	a0,304(s8)
    80201954:	00000097          	auipc	ra,0x0
    80201958:	9ae080e7          	jalr	-1618(ra) # 80201302 <pageLookup>
    return ppn2page((pa - PHYSICAL_ADDRESS_BASE) >> PAGE_SHIFT);
    8020195c:	800007b7          	lui	a5,0x80000
    80201960:	00f50733          	add	a4,a0,a5
    80201964:	8331                	srli	a4,a4,0xc
    return pages + ppn;
    80201966:	1702                	slli	a4,a4,0x20
    80201968:	9301                	srli	a4,a4,0x20
    8020196a:	00171793          	slli	a5,a4,0x1
    8020196e:	97ba                	add	a5,a5,a4
    80201970:	078e                	slli	a5,a5,0x3
    80201972:	00055717          	auipc	a4,0x55
    80201976:	aa670713          	addi	a4,a4,-1370 # 80256418 <pages>
    8020197a:	973e                	add	a4,a4,a5
    8020197c:	f8e43423          	sd	a4,-120(s0)
        r = MIN(segmentSize - i, PAGE_SIZE - offset);
    80201980:	020d1493          	slli	s1,s10,0x20
    80201984:	9081                	srli	s1,s1,0x20
    80201986:	6705                	lui	a4,0x1
    80201988:	41370733          	sub	a4,a4,s3
    8020198c:	412484b3          	sub	s1,s1,s2
    80201990:	00977363          	bgeu	a4,s1,80201996 <codeMapper+0x1cc>
    80201994:	84ba                	mv	s1,a4
    80201996:	2481                	sext.w	s1,s1
    return page - pages;
    80201998:	878d                	srai	a5,a5,0x3
    8020199a:	00003717          	auipc	a4,0x3
    8020199e:	b3673703          	ld	a4,-1226(a4) # 802044d0 <rodataEnd+0x4>
    802019a2:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802019a6:	00c7979b          	slliw	a5,a5,0xc
    802019aa:	1782                	slli	a5,a5,0x20
    802019ac:	9381                	srli	a5,a5,0x20
        bzero((void*) page2pa(p) + offset, r);
    802019ae:	4705                	li	a4,1
    802019b0:	077e                	slli	a4,a4,0x1f
    802019b2:	00e98533          	add	a0,s3,a4
    802019b6:	85a6                	mv	a1,s1
    802019b8:	953e                	add	a0,a0,a5
    802019ba:	fffff097          	auipc	ra,0xfffff
    802019be:	728080e7          	jalr	1832(ra) # 802010e2 <bzero>
    802019c2:	b5ed                	j	802018ac <codeMapper+0xe2>
        bzero((void*) page2pa(p), r);
    802019c4:	2901                	sext.w	s2,s2
    return page - pages;
    802019c6:	f8843783          	ld	a5,-120(s0)
    802019ca:	416787b3          	sub	a5,a5,s6
    802019ce:	878d                	srai	a5,a5,0x3
    802019d0:	000ab703          	ld	a4,0(s5)
    802019d4:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    802019d8:	00c7979b          	slliw	a5,a5,0xc
    802019dc:	1782                	slli	a5,a5,0x20
    802019de:	9381                	srli	a5,a5,0x20
    802019e0:	85ca                	mv	a1,s2
    802019e2:	01478533          	add	a0,a5,s4
    802019e6:	fffff097          	auipc	ra,0xfffff
    802019ea:	6fc080e7          	jalr	1788(ra) # 802010e2 <bzero>
    for (i += r; i < segmentSize; i += r) {
    802019ee:	94ca                	add	s1,s1,s2
    802019f0:	05a4f863          	bgeu	s1,s10,80201a40 <codeMapper+0x276>
        if (pageAlloc(&p) != 0) {
    802019f4:	f8840513          	addi	a0,s0,-120
    802019f8:	fffff097          	auipc	ra,0xfffff
    802019fc:	77e080e7          	jalr	1918(ra) # 80201176 <pageAlloc>
    80201a00:	89aa                	mv	s3,a0
    80201a02:	e12d                	bnez	a0,80201a64 <codeMapper+0x29a>
    return page - pages;
    80201a04:	f8843603          	ld	a2,-120(s0)
    80201a08:	41660633          	sub	a2,a2,s6
    80201a0c:	860d                	srai	a2,a2,0x3
    80201a0e:	000ab783          	ld	a5,0(s5)
    80201a12:	02f60633          	mul	a2,a2,a5
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80201a16:	00c6161b          	slliw	a2,a2,0xc
    80201a1a:	1602                	slli	a2,a2,0x20
    80201a1c:	9201                	srli	a2,a2,0x20
        pageInsert(process->pgdir, va + i, page2pa(p), 
    80201a1e:	46f9                	li	a3,30
    80201a20:	9652                	add	a2,a2,s4
    80201a22:	009b85b3          	add	a1,s7,s1
    80201a26:	130c3503          	ld	a0,304(s8)
    80201a2a:	00000097          	auipc	ra,0x0
    80201a2e:	9c8080e7          	jalr	-1592(ra) # 802013f2 <pageInsert>
        r = MIN(PAGE_SIZE, segmentSize - i);
    80201a32:	409d0933          	sub	s2,s10,s1
    80201a36:	f92cf7e3          	bgeu	s9,s2,802019c4 <codeMapper+0x1fa>
    80201a3a:	8966                	mv	s2,s9
    80201a3c:	b761                	j	802019c4 <codeMapper+0x1fa>
            return -1;
    80201a3e:	59fd                	li	s3,-1
    }
    return 0;
}
    80201a40:	854e                	mv	a0,s3
    80201a42:	70e6                	ld	ra,120(sp)
    80201a44:	7446                	ld	s0,112(sp)
    80201a46:	74a6                	ld	s1,104(sp)
    80201a48:	7906                	ld	s2,96(sp)
    80201a4a:	69e6                	ld	s3,88(sp)
    80201a4c:	6a46                	ld	s4,80(sp)
    80201a4e:	6aa6                	ld	s5,72(sp)
    80201a50:	6b06                	ld	s6,64(sp)
    80201a52:	7be2                	ld	s7,56(sp)
    80201a54:	7c42                	ld	s8,48(sp)
    80201a56:	7ca2                	ld	s9,40(sp)
    80201a58:	7d02                	ld	s10,32(sp)
    80201a5a:	6de2                	ld	s11,24(sp)
    80201a5c:	6109                	addi	sp,sp,128
    80201a5e:	8082                	ret
    return 0;
    80201a60:	4981                	li	s3,0
    80201a62:	bff9                	j	80201a40 <codeMapper+0x276>
            return -1;
    80201a64:	59fd                	li	s3,-1
    80201a66:	bfe9                	j	80201a40 <codeMapper+0x276>
    for (i = r; i < binSize; i += r) {
    80201a68:	894e                	mv	s2,s3
    int r = 0;
    80201a6a:	4481                	li	s1,0
    80201a6c:	b581                	j	802018ac <codeMapper+0xe2>

0000000080201a6e <processInit>:
void processInit() {
    80201a6e:	1141                	addi	sp,sp,-16
    80201a70:	e406                	sd	ra,8(sp)
    80201a72:	e022                	sd	s0,0(sp)
    80201a74:	0800                	addi	s0,sp,16
    printf("Process init start...\n");
    80201a76:	00002517          	auipc	a0,0x2
    80201a7a:	7aa50513          	addi	a0,a0,1962 # 80204220 <digits+0x190>
    80201a7e:	fffff097          	auipc	ra,0xfffff
    80201a82:	a54080e7          	jalr	-1452(ra) # 802004d2 <printf>
    LIST_INIT(&scheduleList[0]);
    80201a86:	00115797          	auipc	a5,0x115
    80201a8a:	9b278793          	addi	a5,a5,-1614 # 80316438 <scheduleList>
    80201a8e:	0007b023          	sd	zero,0(a5)
    LIST_INIT(&scheduleList[1]);
    80201a92:	0007b423          	sd	zero,8(a5)
        processes[i].trapframe.kernelSatp = MAKE_SATP(kernelPageDirectory);
    80201a96:	0016b597          	auipc	a1,0x16b
    80201a9a:	56a58593          	addi	a1,a1,1386 # 8036d000 <_pgdir>
    80201a9e:	81b1                	srli	a1,a1,0xc
    80201aa0:	57fd                	li	a5,-1
    80201aa2:	17fe                	slli	a5,a5,0x3f
    80201aa4:	8ddd                	or	a1,a1,a5
    80201aa6:	0016b797          	auipc	a5,0x16b
    80201aaa:	86a78793          	addi	a5,a5,-1942 # 8036c310 <processes+0x55ea8>
    80201aae:	00115817          	auipc	a6,0x115
    80201ab2:	9ba80813          	addi	a6,a6,-1606 # 80316468 <processes>
    80201ab6:	4681                	li	a3,0
        LIST_INSERT_HEAD(&freeProcesses, &processes[i], link);
    80201ab8:	0016b517          	auipc	a0,0x16b
    80201abc:	9c050513          	addi	a0,a0,-1600 # 8036c478 <freeProcesses>
    80201ac0:	a801                	j	80201ad0 <processInit+0x62>
    80201ac2:	12a6b423          	sd	a0,296(a3)
    for (i = PROCESS_TOTAL_NUMBER - 1; i >= 0; i--) {
    80201ac6:	ea878713          	addi	a4,a5,-344
    80201aca:	03078063          	beq	a5,a6,80201aea <processInit+0x7c>
    80201ace:	87ba                	mv	a5,a4
        processes[i].state = UNUSED;
    80201ad0:	8736                	mv	a4,a3
    80201ad2:	86be                	mv	a3,a5
    80201ad4:	1407aa23          	sw	zero,340(a5)
        processes[i].trapframe.kernelSatp = MAKE_SATP(kernelPageDirectory);
    80201ad8:	e38c                	sd	a1,0(a5)
        LIST_INSERT_HEAD(&freeProcesses, &processes[i], link);
    80201ada:	12e7b023          	sd	a4,288(a5)
    80201ade:	d375                	beqz	a4,80201ac2 <processInit+0x54>
    80201ae0:	12078613          	addi	a2,a5,288
    80201ae4:	12c73423          	sd	a2,296(a4)
    80201ae8:	bfe9                	j	80201ac2 <processInit+0x54>
    80201aea:	0016b717          	auipc	a4,0x16b
    80201aee:	98e70713          	addi	a4,a4,-1650 # 8036c478 <freeProcesses>
    80201af2:	00115797          	auipc	a5,0x115
    80201af6:	97678793          	addi	a5,a5,-1674 # 80316468 <processes>
    80201afa:	e31c                	sd	a5,0(a4)
    80201afc:	12e7b423          	sd	a4,296(a5)
	return x;
}

// Supervisor Scratch register, for early trap handler in trampoline.S.
static inline void w_sscratch(u64 x) {
	asm volatile("csrw sscratch, %0" : : "r" (x));
    80201b00:	00001797          	auipc	a5,0x1
    80201b04:	62278793          	addi	a5,a5,1570 # 80203122 <trapframe>
    80201b08:	14079073          	csrw	sscratch,a5
    printf("Process init finish!\n");
    80201b0c:	00002517          	auipc	a0,0x2
    80201b10:	72c50513          	addi	a0,a0,1836 # 80204238 <digits+0x1a8>
    80201b14:	fffff097          	auipc	ra,0xfffff
    80201b18:	9be080e7          	jalr	-1602(ra) # 802004d2 <printf>
}
    80201b1c:	60a2                	ld	ra,8(sp)
    80201b1e:	6402                	ld	s0,0(sp)
    80201b20:	0141                	addi	sp,sp,16
    80201b22:	8082                	ret

0000000080201b24 <generateProcessId>:
u32 generateProcessId(Process *p) {
    80201b24:	1141                	addi	sp,sp,-16
    80201b26:	e422                	sd	s0,8(sp)
    80201b28:	0800                	addi	s0,sp,16
    return (++nextId << (1 + LOG_PROCESS_NUM)) | idx;
    80201b2a:	0016b717          	auipc	a4,0x16b
    80201b2e:	94670713          	addi	a4,a4,-1722 # 8036c470 <nextId.2>
    80201b32:	431c                	lw	a5,0(a4)
    80201b34:	2785                	addiw	a5,a5,1
    80201b36:	c31c                	sw	a5,0(a4)
    u32 idx = p - processes;
    80201b38:	00115717          	auipc	a4,0x115
    80201b3c:	93070713          	addi	a4,a4,-1744 # 80316468 <processes>
    80201b40:	8d19                	sub	a0,a0,a4
    80201b42:	850d                	srai	a0,a0,0x3
    80201b44:	00003717          	auipc	a4,0x3
    80201b48:	99473703          	ld	a4,-1644(a4) # 802044d8 <rodataEnd+0xc>
    80201b4c:	02e50533          	mul	a0,a0,a4
    return (++nextId << (1 + LOG_PROCESS_NUM)) | idx;
    80201b50:	00b7979b          	slliw	a5,a5,0xb
    80201b54:	8d5d                	or	a0,a0,a5
}
    80201b56:	2501                	sext.w	a0,a0
    80201b58:	6422                	ld	s0,8(sp)
    80201b5a:	0141                	addi	sp,sp,16
    80201b5c:	8082                	ret

0000000080201b5e <processAlloc>:
int processAlloc(Process **new, u64 parentId) {
    80201b5e:	7139                	addi	sp,sp,-64
    80201b60:	fc06                	sd	ra,56(sp)
    80201b62:	f822                	sd	s0,48(sp)
    80201b64:	f426                	sd	s1,40(sp)
    80201b66:	f04a                	sd	s2,32(sp)
    80201b68:	ec4e                	sd	s3,24(sp)
    80201b6a:	e852                	sd	s4,16(sp)
    80201b6c:	0080                	addi	s0,sp,64
    80201b6e:	89aa                	mv	s3,a0
    if (LIST_EMPTY(&freeProcesses)) {
    80201b70:	0016b497          	auipc	s1,0x16b
    80201b74:	9084b483          	ld	s1,-1784(s1) # 8036c478 <freeProcesses>
    80201b78:	c8e9                	beqz	s1,80201c4a <processAlloc+0xec>
    80201b7a:	8a2e                	mv	s4,a1
    LIST_REMOVE(p, link);
    80201b7c:	1204b783          	ld	a5,288(s1)
    80201b80:	c789                	beqz	a5,80201b8a <processAlloc+0x2c>
    80201b82:	1284b703          	ld	a4,296(s1)
    80201b86:	12e7b423          	sd	a4,296(a5)
    80201b8a:	1284b783          	ld	a5,296(s1)
    80201b8e:	1204b703          	ld	a4,288(s1)
    80201b92:	e398                	sd	a4,0(a5)
    r = allocPgdir(&page);
    80201b94:	fc840513          	addi	a0,s0,-56
    80201b98:	00000097          	auipc	ra,0x0
    80201b9c:	8fe080e7          	jalr	-1794(ra) # 80201496 <allocPgdir>
    if (r < 0) {
    80201ba0:	08054763          	bltz	a0,80201c2e <processAlloc+0xd0>
    return page - pages;
    80201ba4:	fc843783          	ld	a5,-56(s0)
    80201ba8:	00055717          	auipc	a4,0x55
    80201bac:	87070713          	addi	a4,a4,-1936 # 80256418 <pages>
    80201bb0:	8f99                	sub	a5,a5,a4
    80201bb2:	878d                	srai	a5,a5,0x3
    80201bb4:	00003717          	auipc	a4,0x3
    80201bb8:	91c73703          	ld	a4,-1764(a4) # 802044d0 <rodataEnd+0x4>
    80201bbc:	02e787b3          	mul	a5,a5,a4
    return PHYSICAL_ADDRESS_BASE + (page2PPN(page) << PAGE_SHIFT);
    80201bc0:	00c7979b          	slliw	a5,a5,0xc
    80201bc4:	1782                	slli	a5,a5,0x20
    80201bc6:	9381                	srli	a5,a5,0x20
    80201bc8:	4705                	li	a4,1
    80201bca:	077e                	slli	a4,a4,0x1f
    80201bcc:	00e78533          	add	a0,a5,a4
    p->pgdir = (u64*) page2pa(page);
    80201bd0:	12a4b823          	sd	a0,304(s1)
    pageInsert(p->pgdir, TRAMPOLINE_BASE, (u64)trampoline, 
    80201bd4:	46b9                	li	a3,14
    80201bd6:	00001617          	auipc	a2,0x1
    80201bda:	42a60613          	addi	a2,a2,1066 # 80203000 <_trampoline>
    80201bde:	04000937          	lui	s2,0x4000
    80201be2:	197d                	addi	s2,s2,-1
    80201be4:	00c91593          	slli	a1,s2,0xc
    80201be8:	00000097          	auipc	ra,0x0
    80201bec:	80a080e7          	jalr	-2038(ra) # 802013f2 <pageInsert>
    p->id = generateProcessId(p);
    80201bf0:	8526                	mv	a0,s1
    80201bf2:	00000097          	auipc	ra,0x0
    80201bf6:	f32080e7          	jalr	-206(ra) # 80201b24 <generateProcessId>
    80201bfa:	12a4ac23          	sw	a0,312(s1)
    p->state = RUNNABLE;
    80201bfe:	4789                	li	a5,2
    80201c00:	14f4aa23          	sw	a5,340(s1)
    p->parentId = parentId;
    80201c04:	1344ae23          	sw	s4,316(s1)
    p->trapframe.kernelSp = (u64)kernelStack + KERNEL_STACK_SIZE;
    80201c08:	00023797          	auipc	a5,0x23
    80201c0c:	3f878793          	addi	a5,a5,1016 # 80225000 <_stack+0x10000>
    80201c10:	e49c                	sd	a5,8(s1)
    p->trapframe.sp = USER_STACK_TOP;
    80201c12:	0932                	slli	s2,s2,0xc
    80201c14:	0324b823          	sd	s2,48(s1)
    return 0;
    80201c18:	4501                	li	a0,0
        *new = NULL;
    80201c1a:	0099b023          	sd	s1,0(s3) # 10000 <_start-0x801f0000>
}
    80201c1e:	70e2                	ld	ra,56(sp)
    80201c20:	7442                	ld	s0,48(sp)
    80201c22:	74a2                	ld	s1,40(sp)
    80201c24:	7902                	ld	s2,32(sp)
    80201c26:	69e2                	ld	s3,24(sp)
    80201c28:	6a42                	ld	s4,16(sp)
    80201c2a:	6121                	addi	sp,sp,64
    80201c2c:	8082                	ret
        panic("setup page alloc error\n");
    80201c2e:	00002617          	auipc	a2,0x2
    80201c32:	62260613          	addi	a2,a2,1570 # 80204250 <digits+0x1c0>
    80201c36:	02a00593          	li	a1,42
    80201c3a:	00002517          	auipc	a0,0x2
    80201c3e:	62e50513          	addi	a0,a0,1582 # 80204268 <digits+0x1d8>
    80201c42:	fffff097          	auipc	ra,0xfffff
    80201c46:	8ea080e7          	jalr	-1814(ra) # 8020052c <_panic_>
        return -NO_FREE_PROCESS;
    80201c4a:	556d                	li	a0,-5
    80201c4c:	b7f9                	j	80201c1a <processAlloc+0xbc>

0000000080201c4e <processCreatePriority>:

void processCreatePriority(u8 *binary, u32 size, u32 priority) {
    80201c4e:	7139                	addi	sp,sp,-64
    80201c50:	fc06                	sd	ra,56(sp)
    80201c52:	f822                	sd	s0,48(sp)
    80201c54:	f426                	sd	s1,40(sp)
    80201c56:	f04a                	sd	s2,32(sp)
    80201c58:	ec4e                	sd	s3,24(sp)
    80201c5a:	e852                	sd	s4,16(sp)
    80201c5c:	0080                	addi	s0,sp,64
    80201c5e:	892a                	mv	s2,a0
    80201c60:	89ae                	mv	s3,a1
    80201c62:	8a32                	mv	s4,a2
    Process *p;

    int r = processAlloc(&p, 0);
    80201c64:	4581                	li	a1,0
    80201c66:	fc840513          	addi	a0,s0,-56
    80201c6a:	00000097          	auipc	ra,0x0
    80201c6e:	ef4080e7          	jalr	-268(ra) # 80201b5e <processAlloc>
    if (r < 0) {
    80201c72:	06054263          	bltz	a0,80201cd6 <processCreatePriority+0x88>
        return;
    }
    p->priority = priority;
    80201c76:	fc843483          	ld	s1,-56(s0)
    80201c7a:	1544a823          	sw	s4,336(s1)
    u64 entryPoint;
    if (loadElf(binary, size, &entryPoint, p, codeMapper) < 0) {
    80201c7e:	00000717          	auipc	a4,0x0
    80201c82:	b4c70713          	addi	a4,a4,-1204 # 802017ca <codeMapper>
    80201c86:	86a6                	mv	a3,s1
    80201c88:	fc040613          	addi	a2,s0,-64
    80201c8c:	85ce                	mv	a1,s3
    80201c8e:	854a                	mv	a0,s2
    80201c90:	00000097          	auipc	ra,0x0
    80201c94:	9da080e7          	jalr	-1574(ra) # 8020166a <loadElf>
    80201c98:	04054763          	bltz	a0,80201ce6 <processCreatePriority+0x98>
        panic("process create error\n");
    }
    p->trapframe.epc = entryPoint;
    80201c9c:	fc043783          	ld	a5,-64(s0)
    80201ca0:	ec9c                	sd	a5,24(s1)

    LIST_INSERT_TAIL(&scheduleList[0], p, scheduleLink);
    80201ca2:	00114717          	auipc	a4,0x114
    80201ca6:	79673703          	ld	a4,1942(a4) # 80316438 <scheduleList>
    80201caa:	cf21                	beqz	a4,80201d02 <processCreatePriority+0xb4>
    80201cac:	14e4b023          	sd	a4,320(s1)
    80201cb0:	14073783          	ld	a5,320(a4)
    80201cb4:	c799                	beqz	a5,80201cc2 <processCreatePriority+0x74>
    80201cb6:	14f4b023          	sd	a5,320(s1)
    80201cba:	873e                	mv	a4,a5
    80201cbc:	1407b783          	ld	a5,320(a5)
    80201cc0:	fbfd                	bnez	a5,80201cb6 <processCreatePriority+0x68>
    80201cc2:	14973023          	sd	s1,320(a4)
    80201cc6:	1404b783          	ld	a5,320(s1)
    80201cca:	14078793          	addi	a5,a5,320
    80201cce:	14f4b423          	sd	a5,328(s1)
    80201cd2:	1404b023          	sd	zero,320(s1)
}
    80201cd6:	70e2                	ld	ra,56(sp)
    80201cd8:	7442                	ld	s0,48(sp)
    80201cda:	74a2                	ld	s1,40(sp)
    80201cdc:	7902                	ld	s2,32(sp)
    80201cde:	69e2                	ld	s3,24(sp)
    80201ce0:	6a42                	ld	s4,16(sp)
    80201ce2:	6121                	addi	sp,sp,64
    80201ce4:	8082                	ret
        panic("process create error\n");
    80201ce6:	00002617          	auipc	a2,0x2
    80201cea:	59260613          	addi	a2,a2,1426 # 80204278 <digits+0x1e8>
    80201cee:	08f00593          	li	a1,143
    80201cf2:	00002517          	auipc	a0,0x2
    80201cf6:	57650513          	addi	a0,a0,1398 # 80204268 <digits+0x1d8>
    80201cfa:	fffff097          	auipc	ra,0xfffff
    80201cfe:	832080e7          	jalr	-1998(ra) # 8020052c <_panic_>
    LIST_INSERT_TAIL(&scheduleList[0], p, scheduleLink);
    80201d02:	1404b023          	sd	zero,320(s1)
    80201d06:	00114797          	auipc	a5,0x114
    80201d0a:	73278793          	addi	a5,a5,1842 # 80316438 <scheduleList>
    80201d0e:	e384                	sd	s1,0(a5)
    80201d10:	14f4b423          	sd	a5,328(s1)
    80201d14:	b7c9                	j	80201cd6 <processCreatePriority+0x88>

0000000080201d16 <processRun>:

void processRun(Process *p) {
    80201d16:	1101                	addi	sp,sp,-32
    80201d18:	ec06                	sd	ra,24(sp)
    80201d1a:	e822                	sd	s0,16(sp)
    80201d1c:	e426                	sd	s1,8(sp)
    80201d1e:	e04a                	sd	s2,0(sp)
    80201d20:	1000                	addi	s0,sp,32
    80201d22:	892a                	mv	s2,a0
    asm volatile("mv %0, tp" : "=r" (x) );
    80201d24:	8492                	mv	s1,tp
    int hartId = r_hartid();
    80201d26:	2481                	sext.w	s1,s1
    if (currentProcess[hartId]) {
    80201d28:	00349713          	slli	a4,s1,0x3
    80201d2c:	00114797          	auipc	a5,0x114
    80201d30:	70c78793          	addi	a5,a5,1804 # 80316438 <scheduleList>
    80201d34:	97ba                	add	a5,a5,a4
    80201d36:	6b8c                	ld	a1,16(a5)
    80201d38:	c999                	beqz	a1,80201d4e <processRun+0x38>
        bcopy(trapframe, &(currentProcess[hartId]->trapframe), sizeof(Trapframe));
    80201d3a:	12000613          	li	a2,288
    80201d3e:	00001517          	auipc	a0,0x1
    80201d42:	3e450513          	addi	a0,a0,996 # 80203122 <trapframe>
    80201d46:	fffff097          	auipc	ra,0xfffff
    80201d4a:	312080e7          	jalr	786(ra) # 80201058 <bcopy>
    }
    currentProcess[hartId] = p;
    80201d4e:	048e                	slli	s1,s1,0x3
    80201d50:	00114797          	auipc	a5,0x114
    80201d54:	6e878793          	addi	a5,a5,1768 # 80316438 <scheduleList>
    80201d58:	97a6                	add	a5,a5,s1
    80201d5a:	0127b823          	sd	s2,16(a5)
    bcopy(&(currentProcess[hartId]->trapframe), trapframe, sizeof(Trapframe));
    80201d5e:	12000613          	li	a2,288
    80201d62:	00001597          	auipc	a1,0x1
    80201d66:	3c058593          	addi	a1,a1,960 # 80203122 <trapframe>
    80201d6a:	854a                	mv	a0,s2
    80201d6c:	fffff097          	auipc	ra,0xfffff
    80201d70:	2ec080e7          	jalr	748(ra) # 80201058 <bcopy>
    userTrapReturn();
    80201d74:	00000097          	auipc	ra,0x0
    80201d78:	65e080e7          	jalr	1630(ra) # 802023d2 <userTrapReturn>
}
    80201d7c:	60e2                	ld	ra,24(sp)
    80201d7e:	6442                	ld	s0,16(sp)
    80201d80:	64a2                	ld	s1,8(sp)
    80201d82:	6902                	ld	s2,0(sp)
    80201d84:	6105                	addi	sp,sp,32
    80201d86:	8082                	ret

0000000080201d88 <wakeup>:

void wakeup(void *channel) {
    80201d88:	1141                	addi	sp,sp,-16
    80201d8a:	e422                	sd	s0,8(sp)
    80201d8c:	0800                	addi	s0,sp,16
    // todo
}
    80201d8e:	6422                	ld	s0,8(sp)
    80201d90:	0141                	addi	sp,sp,16
    80201d92:	8082                	ret

0000000080201d94 <yield>:

void yield() {
    80201d94:	1101                	addi	sp,sp,-32
    80201d96:	ec06                	sd	ra,24(sp)
    80201d98:	e822                	sd	s0,16(sp)
    80201d9a:	e426                	sd	s1,8(sp)
    80201d9c:	1000                	addi	s0,sp,32
    80201d9e:	8792                	mv	a5,tp
    static int count = 0;
    static int point = 0;
    int hartId = r_hartid();
    Process* next_env = currentProcess[hartId];
    80201da0:	2781                	sext.w	a5,a5
    80201da2:	078e                	slli	a5,a5,0x3
    80201da4:	00114717          	auipc	a4,0x114
    80201da8:	69470713          	addi	a4,a4,1684 # 80316438 <scheduleList>
    80201dac:	97ba                	add	a5,a5,a4
    80201dae:	6b84                	ld	s1,16(a5)
    while ((count == 0) || (next_env == NULL) || (next_env->state != RUNNABLE)) {
    80201db0:	0016a697          	auipc	a3,0x16a
    80201db4:	6bc6a683          	lw	a3,1724(a3) # 8036c46c <point.1>
    80201db8:	0016a597          	auipc	a1,0x16a
    80201dbc:	6b05a583          	lw	a1,1712(a1) # 8036c468 <count.0>
    80201dc0:	4801                	li	a6,0
    80201dc2:	4301                	li	t1,0
    80201dc4:	4889                	li	a7,2
        if (next_env != NULL) {
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], next_env, scheduleLink);
    80201dc6:	863a                	mv	a2,a4
        }
        if (LIST_EMPTY(&scheduleList[point])) {
            point = 1 - point;
    80201dc8:	4e05                	li	t3,1
    80201dca:	4505                	li	a0,1
    while ((count == 0) || (next_env == NULL) || (next_env->state != RUNNABLE)) {
    80201dcc:	a0a1                	j	80201e14 <yield+0x80>
        if (next_env != NULL) {
    80201dce:	cc99                	beqz	s1,80201dec <yield+0x58>
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], next_env, scheduleLink);
    80201dd0:	0016c793          	xori	a5,a3,1
    80201dd4:	00379713          	slli	a4,a5,0x3
    80201dd8:	9732                	add	a4,a4,a2
    80201dda:	6318                	ld	a4,0(a4)
    80201ddc:	e349                	bnez	a4,80201e5e <yield+0xca>
    80201dde:	1404b023          	sd	zero,320(s1)
    80201de2:	078e                	slli	a5,a5,0x3
    80201de4:	97b2                	add	a5,a5,a2
    80201de6:	e384                	sd	s1,0(a5)
    80201de8:	14f4b423          	sd	a5,328(s1)
        if (LIST_EMPTY(&scheduleList[point])) {
    80201dec:	00369793          	slli	a5,a3,0x3
    80201df0:	97b2                	add	a5,a5,a2
    80201df2:	6384                	ld	s1,0(a5)
    80201df4:	c8d9                	beqz	s1,80201e8a <yield+0xf6>
        }
        if (LIST_EMPTY(&scheduleList[point])) {
            panic("No Env is RUNNABLE\n");
        }
        next_env = LIST_FIRST(&scheduleList[point]);
        LIST_REMOVE(next_env, scheduleLink);
    80201df6:	1404b783          	ld	a5,320(s1)
    80201dfa:	c789                	beqz	a5,80201e04 <yield+0x70>
    80201dfc:	1484b703          	ld	a4,328(s1)
    80201e00:	14e7b423          	sd	a4,328(a5)
    80201e04:	1484b783          	ld	a5,328(s1)
    80201e08:	1404b703          	ld	a4,320(s1)
    80201e0c:	e398                	sd	a4,0(a5)
        count = next_env->priority;
    80201e0e:	1504a583          	lw	a1,336(s1)
    80201e12:	882a                	mv	a6,a0
    while ((count == 0) || (next_env == NULL) || (next_env->state != RUNNABLE)) {
    80201e14:	ddcd                	beqz	a1,80201dce <yield+0x3a>
    80201e16:	d8f9                	beqz	s1,80201dec <yield+0x58>
    80201e18:	1544a783          	lw	a5,340(s1)
    80201e1c:	fb179ae3          	bne	a5,a7,80201dd0 <yield+0x3c>
    80201e20:	00030663          	beqz	t1,80201e2c <yield+0x98>
    80201e24:	0016a797          	auipc	a5,0x16a
    80201e28:	64d7a423          	sw	a3,1608(a5) # 8036c46c <point.1>
    }
    count--;
    80201e2c:	35fd                	addiw	a1,a1,-1
    80201e2e:	0016a797          	auipc	a5,0x16a
    80201e32:	62b7ad23          	sw	a1,1594(a5) # 8036c468 <count.0>
    printf("\nyield %d\n", next_env->id);
    80201e36:	1384a583          	lw	a1,312(s1)
    80201e3a:	00002517          	auipc	a0,0x2
    80201e3e:	46e50513          	addi	a0,a0,1134 # 802042a8 <digits+0x218>
    80201e42:	ffffe097          	auipc	ra,0xffffe
    80201e46:	690080e7          	jalr	1680(ra) # 802004d2 <printf>
    processRun(next_env);
    80201e4a:	8526                	mv	a0,s1
    80201e4c:	00000097          	auipc	ra,0x0
    80201e50:	eca080e7          	jalr	-310(ra) # 80201d16 <processRun>
}
    80201e54:	60e2                	ld	ra,24(sp)
    80201e56:	6442                	ld	s0,16(sp)
    80201e58:	64a2                	ld	s1,8(sp)
    80201e5a:	6105                	addi	sp,sp,32
    80201e5c:	8082                	ret
            LIST_INSERT_TAIL(&scheduleList[point ^ 1], next_env, scheduleLink);
    80201e5e:	14e4b023          	sd	a4,320(s1)
    80201e62:	14073783          	ld	a5,320(a4)
    80201e66:	c799                	beqz	a5,80201e74 <yield+0xe0>
    80201e68:	14f4b023          	sd	a5,320(s1)
    80201e6c:	873e                	mv	a4,a5
    80201e6e:	1407b783          	ld	a5,320(a5)
    80201e72:	fbfd                	bnez	a5,80201e68 <yield+0xd4>
    80201e74:	14973023          	sd	s1,320(a4)
    80201e78:	1404b783          	ld	a5,320(s1)
    80201e7c:	14078793          	addi	a5,a5,320
    80201e80:	14f4b423          	sd	a5,328(s1)
    80201e84:	1404b023          	sd	zero,320(s1)
    80201e88:	b795                	j	80201dec <yield+0x58>
            point = 1 - point;
    80201e8a:	40de06bb          	subw	a3,t3,a3
        if (LIST_EMPTY(&scheduleList[point])) {
    80201e8e:	00369793          	slli	a5,a3,0x3
    80201e92:	97b2                	add	a5,a5,a2
    80201e94:	6384                	ld	s1,0(a5)
    80201e96:	c099                	beqz	s1,80201e9c <yield+0x108>
    80201e98:	832a                	mv	t1,a0
    80201e9a:	bfb1                	j	80201df6 <yield+0x62>
    80201e9c:	00080663          	beqz	a6,80201ea8 <yield+0x114>
    80201ea0:	0016a797          	auipc	a5,0x16a
    80201ea4:	5cb7a423          	sw	a1,1480(a5) # 8036c468 <count.0>
    80201ea8:	0016a797          	auipc	a5,0x16a
    80201eac:	5cd7a223          	sw	a3,1476(a5) # 8036c46c <point.1>
            panic("No Env is RUNNABLE\n");
    80201eb0:	00002617          	auipc	a2,0x2
    80201eb4:	3e060613          	addi	a2,a2,992 # 80204290 <digits+0x200>
    80201eb8:	0b100593          	li	a1,177
    80201ebc:	00002517          	auipc	a0,0x2
    80201ec0:	3ac50513          	addi	a0,a0,940 # 80204268 <digits+0x1d8>
    80201ec4:	ffffe097          	auipc	ra,0xffffe
    80201ec8:	668080e7          	jalr	1640(ra) # 8020052c <_panic_>

0000000080201ecc <processFork>:

void processFork() {
    80201ecc:	7175                	addi	sp,sp,-144
    80201ece:	e506                	sd	ra,136(sp)
    80201ed0:	e122                	sd	s0,128(sp)
    80201ed2:	fca6                	sd	s1,120(sp)
    80201ed4:	f8ca                	sd	s2,112(sp)
    80201ed6:	f4ce                	sd	s3,104(sp)
    80201ed8:	f0d2                	sd	s4,96(sp)
    80201eda:	ecd6                	sd	s5,88(sp)
    80201edc:	e8da                	sd	s6,80(sp)
    80201ede:	e4de                	sd	s7,72(sp)
    80201ee0:	e0e2                	sd	s8,64(sp)
    80201ee2:	fc66                	sd	s9,56(sp)
    80201ee4:	f86a                	sd	s10,48(sp)
    80201ee6:	f46e                	sd	s11,40(sp)
    80201ee8:	0900                	addi	s0,sp,144
    80201eea:	8492                	mv	s1,tp
    Process *process;
    int hartId = r_hartid();
    80201eec:	2481                	sext.w	s1,s1
    int r = processAlloc(&process, currentProcess[hartId]->id);
    80201eee:	00349713          	slli	a4,s1,0x3
    80201ef2:	00114797          	auipc	a5,0x114
    80201ef6:	54678793          	addi	a5,a5,1350 # 80316438 <scheduleList>
    80201efa:	97ba                	add	a5,a5,a4
    80201efc:	6b9c                	ld	a5,16(a5)
    80201efe:	1387e583          	lwu	a1,312(a5)
    80201f02:	f8840513          	addi	a0,s0,-120
    80201f06:	00000097          	auipc	ra,0x0
    80201f0a:	c58080e7          	jalr	-936(ra) # 80201b5e <processAlloc>
    if (r < 0) {
    80201f0e:	08054e63          	bltz	a0,80201faa <processFork+0xde>
        currentProcess[hartId]->trapframe.a0 = r;
        panic("");
        return;
    }
    process->priority = currentProcess[hartId]->priority;
    80201f12:	f8843583          	ld	a1,-120(s0)
    80201f16:	00114917          	auipc	s2,0x114
    80201f1a:	52290913          	addi	s2,s2,1314 # 80316438 <scheduleList>
    80201f1e:	00349793          	slli	a5,s1,0x3
    80201f22:	97ca                	add	a5,a5,s2
    80201f24:	6b9c                	ld	a5,16(a5)
    80201f26:	1507a783          	lw	a5,336(a5)
    80201f2a:	14f5a823          	sw	a5,336(a1)
    bcopy(trapframe, &process->trapframe, sizeof(Trapframe));
    80201f2e:	12000613          	li	a2,288
    80201f32:	00001517          	auipc	a0,0x1
    80201f36:	1f050513          	addi	a0,a0,496 # 80203122 <trapframe>
    80201f3a:	fffff097          	auipc	ra,0xfffff
    80201f3e:	11e080e7          	jalr	286(ra) # 80201058 <bcopy>
    process->trapframe.a0 = 0;
    80201f42:	f8843783          	ld	a5,-120(s0)
    80201f46:	0607b823          	sd	zero,112(a5)
    LIST_INSERT_TAIL(&scheduleList[0], process, scheduleLink);
    80201f4a:	00093683          	ld	a3,0(s2)
    80201f4e:	c6c1                	beqz	a3,80201fd6 <processFork+0x10a>
    80201f50:	14d7b023          	sd	a3,320(a5)
    80201f54:	1406b703          	ld	a4,320(a3)
    80201f58:	c719                	beqz	a4,80201f66 <processFork+0x9a>
    80201f5a:	14e7b023          	sd	a4,320(a5)
    80201f5e:	86ba                	mv	a3,a4
    80201f60:	14073703          	ld	a4,320(a4)
    80201f64:	fb7d                	bnez	a4,80201f5a <processFork+0x8e>
    80201f66:	14f6b023          	sd	a5,320(a3)
    80201f6a:	1407b703          	ld	a4,320(a5)
    80201f6e:	14070713          	addi	a4,a4,320
    80201f72:	14e7b423          	sd	a4,328(a5)
    80201f76:	1407b023          	sd	zero,320(a5)
    trapframe->a0 = process->id;
    80201f7a:	1387e783          	lwu	a5,312(a5)
    80201f7e:	00001717          	auipc	a4,0x1
    80201f82:	20f73a23          	sd	a5,532(a4) # 80203192 <trapframe+0x70>
    80201f86:	00200db7          	lui	s11,0x200
    80201f8a:	4d01                	li	s10,0

    u64 i, j, k;
    for (i = 0; i < 512; i++) {
        if (!(currentProcess[hartId]->pgdir[i] & PTE_VALID)) {
    80201f8c:	048e                	slli	s1,s1,0x3
    80201f8e:	00114797          	auipc	a5,0x114
    80201f92:	4aa78793          	addi	a5,a5,1194 # 80316438 <scheduleList>
    80201f96:	97a6                	add	a5,a5,s1
    80201f98:	f6f43c23          	sd	a5,-136(s0)
            continue;
        }
        u64 *pa = (u64*) PTE2PA(currentProcess[hartId]->pgdir[i]);
    80201f9c:	fff00cb7          	lui	s9,0xfff00
            for (k = 0; k < 512; k++) {
                if (!(pa2[k] & PTE_VALID)) {
                    continue;
                }
                u64 va = (i << 30) + (j << 21) + (k << 12);
                if (va == TRAMPOLINE_BASE) {
    80201fa0:	04000a37          	lui	s4,0x4000
    80201fa4:	1a7d                	addi	s4,s4,-1
    80201fa6:	0a32                	slli	s4,s4,0xc
    80201fa8:	a0d9                	j	8020206e <processFork+0x1a2>
        currentProcess[hartId]->trapframe.a0 = r;
    80201faa:	048e                	slli	s1,s1,0x3
    80201fac:	00114717          	auipc	a4,0x114
    80201fb0:	48c70713          	addi	a4,a4,1164 # 80316438 <scheduleList>
    80201fb4:	9726                	add	a4,a4,s1
    80201fb6:	6b18                	ld	a4,16(a4)
    80201fb8:	fb28                	sd	a0,112(a4)
        panic("");
    80201fba:	00002617          	auipc	a2,0x2
    80201fbe:	0fe60613          	addi	a2,a2,254 # 802040b8 <digits+0x28>
    80201fc2:	0c200593          	li	a1,194
    80201fc6:	00002517          	auipc	a0,0x2
    80201fca:	2a250513          	addi	a0,a0,674 # 80204268 <digits+0x1d8>
    80201fce:	ffffe097          	auipc	ra,0xffffe
    80201fd2:	55e080e7          	jalr	1374(ra) # 8020052c <_panic_>
    LIST_INSERT_TAIL(&scheduleList[0], process, scheduleLink);
    80201fd6:	1407b023          	sd	zero,320(a5)
    80201fda:	00114717          	auipc	a4,0x114
    80201fde:	45e70713          	addi	a4,a4,1118 # 80316438 <scheduleList>
    80201fe2:	e31c                	sd	a5,0(a4)
    80201fe4:	14e7b423          	sd	a4,328(a5)
    80201fe8:	bf49                	j	80201f7a <processFork+0xae>
                }
                if (pa2[k] & PTE_WRITE) {
                    pa2[k] |= PTE_COW;
                    pa2[k] &= ~PTE_WRITE;
                }
                pageInsert(process->pgdir, va, PTE2PA(pa2[k]), PTE2PERM(pa2[k]));
    80201fea:	6294                	ld	a3,0(a3)
    80201fec:	00269613          	slli	a2,a3,0x2
    80201ff0:	0166f6b3          	and	a3,a3,s6
    80201ff4:	01567633          	and	a2,a2,s5
    80201ff8:	85a6                	mv	a1,s1
    80201ffa:	f8843783          	ld	a5,-120(s0)
    80201ffe:	1307b503          	ld	a0,304(a5)
    80202002:	fffff097          	auipc	ra,0xfffff
    80202006:	3f0080e7          	jalr	1008(ra) # 802013f2 <pageInsert>
            for (k = 0; k < 512; k++) {
    8020200a:	0921                	addi	s2,s2,8
    8020200c:	6785                	lui	a5,0x1
    8020200e:	94be                	add	s1,s1,a5
    80202010:	02998363          	beq	s3,s1,80202036 <processFork+0x16a>
                if (!(pa2[k] & PTE_VALID)) {
    80202014:	86ca                	mv	a3,s2
    80202016:	00093783          	ld	a5,0(s2)
    8020201a:	0017f713          	andi	a4,a5,1
    8020201e:	d775                	beqz	a4,8020200a <processFork+0x13e>
                if (va == TRAMPOLINE_BASE) {
    80202020:	ff4485e3          	beq	s1,s4,8020200a <processFork+0x13e>
                if (pa2[k] & PTE_WRITE) {
    80202024:	0047f713          	andi	a4,a5,4
    80202028:	d369                	beqz	a4,80201fea <processFork+0x11e>
                    pa2[k] &= ~PTE_WRITE;
    8020202a:	9bed                	andi	a5,a5,-5
    8020202c:	1007e793          	ori	a5,a5,256
    80202030:	00f93023          	sd	a5,0(s2)
    80202034:	bf5d                	j	80201fea <processFork+0x11e>
        for (j = 0; j < 512; j++) {
    80202036:	0ba1                	addi	s7,s7,8
    80202038:	002007b7          	lui	a5,0x200
    8020203c:	99be                	add	s3,s3,a5
    8020203e:	03898163          	beq	s3,s8,80202060 <processFork+0x194>
            if (!(pa[j] & PTE_VALID)) {
    80202042:	000bb783          	ld	a5,0(s7)
    80202046:	0017f713          	andi	a4,a5,1
    8020204a:	d775                	beqz	a4,80202036 <processFork+0x16a>
            u64 *pa2 = (u64*) PTE2PA(pa[j]);
    8020204c:	078a                	slli	a5,a5,0x2
    8020204e:	008cd713          	srli	a4,s9,0x8
    80202052:	00e7f933          	and	s2,a5,a4
                u64 va = (i << 30) + (j << 21) + (k << 12);
    80202056:	ffe004b7          	lui	s1,0xffe00
    8020205a:	94ce                	add	s1,s1,s3
                pageInsert(process->pgdir, va, PTE2PA(pa2[k]), PTE2PERM(pa2[k]));
    8020205c:	8aba                	mv	s5,a4
    8020205e:	bf5d                	j	80202014 <processFork+0x148>
    for (i = 0; i < 512; i++) {
    80202060:	0d21                	addi	s10,s10,8
    80202062:	400007b7          	lui	a5,0x40000
    80202066:	9dbe                	add	s11,s11,a5
    80202068:	6785                	lui	a5,0x1
    8020206a:	02fd0c63          	beq	s10,a5,802020a2 <processFork+0x1d6>
        if (!(currentProcess[hartId]->pgdir[i] & PTE_VALID)) {
    8020206e:	f7843783          	ld	a5,-136(s0)
    80202072:	6b9c                	ld	a5,16(a5)
    80202074:	1307b783          	ld	a5,304(a5) # 1130 <_start-0x801feed0>
    80202078:	97ea                	add	a5,a5,s10
    8020207a:	639c                	ld	a5,0(a5)
    8020207c:	0017f713          	andi	a4,a5,1
    80202080:	d365                	beqz	a4,80202060 <processFork+0x194>
        u64 *pa = (u64*) PTE2PA(currentProcess[hartId]->pgdir[i]);
    80202082:	078a                	slli	a5,a5,0x2
    80202084:	008cd713          	srli	a4,s9,0x8
    80202088:	00e7fbb3          	and	s7,a5,a4
        for (j = 0; j < 512; j++) {
    8020208c:	01bd1c13          	slli	s8,s10,0x1b
    80202090:	402007b7          	lui	a5,0x40200
    80202094:	9c3e                	add	s8,s8,a5
        u64 *pa = (u64*) PTE2PA(currentProcess[hartId]->pgdir[i]);
    80202096:	89ee                	mv	s3,s11
                pageInsert(process->pgdir, va, PTE2PA(pa2[k]), PTE2PERM(pa2[k]));
    80202098:	5b7d                	li	s6,-1
    8020209a:	1b5a                	slli	s6,s6,0x36
    8020209c:	3ffb0b13          	addi	s6,s6,1023
    802020a0:	b74d                	j	80202042 <processFork+0x176>

// flush the TLB.
static inline void sfence_vma() {
	// the zero, zero means flush all TLB entries.
	// asm volatile("sfence.vma zero, zero");
	asm volatile("sfence.vma");
    802020a2:	12000073          	sfence.vma
            }
        }
    }
    sfence_vma();
    return;
    802020a6:	60aa                	ld	ra,136(sp)
    802020a8:	640a                	ld	s0,128(sp)
    802020aa:	74e6                	ld	s1,120(sp)
    802020ac:	7946                	ld	s2,112(sp)
    802020ae:	79a6                	ld	s3,104(sp)
    802020b0:	7a06                	ld	s4,96(sp)
    802020b2:	6ae6                	ld	s5,88(sp)
    802020b4:	6b46                	ld	s6,80(sp)
    802020b6:	6ba6                	ld	s7,72(sp)
    802020b8:	6c06                	ld	s8,64(sp)
    802020ba:	7ce2                	ld	s9,56(sp)
    802020bc:	7d42                	ld	s10,48(sp)
    802020be:	7da2                	ld	s11,40(sp)
    802020c0:	6149                	addi	sp,sp,144
    802020c2:	8082                	ret

00000000802020c4 <syscallPutchar>:
    [SYSCALL_FORK]              syscallFork,
    [SYSCALL_PUT_STRING]        syscallPutString
};

extern Trapframe trapframe[];
void syscallPutchar() {
    802020c4:	1141                	addi	sp,sp,-16
    802020c6:	e422                	sd	s0,8(sp)
    802020c8:	0800                	addi	s0,sp,16
#define SBI_REMOTE_SFENCE_VMA 6
#define SBI_REMOTE_SFENCE_VMA_ASID 7
#define SBI_SHUTDOWN 8

inline void putchar(char c) {
    register u64 a0 asm ("a0") = (u64) c;
    802020ca:	00001517          	auipc	a0,0x1
    802020ce:	0c854503          	lbu	a0,200(a0) # 80203192 <trapframe+0x70>
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    802020d2:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802020d4:	00000073          	ecall
    putchar(trapframe->a0);
}
    802020d8:	6422                	ld	s0,8(sp)
    802020da:	0141                	addi	sp,sp,16
    802020dc:	8082                	ret

00000000802020de <syscallGetProcessId>:

void syscallGetProcessId() {
    802020de:	1141                	addi	sp,sp,-16
    802020e0:	e422                	sd	s0,8(sp)
    802020e2:	0800                	addi	s0,sp,16

}
    802020e4:	6422                	ld	s0,8(sp)
    802020e6:	0141                	addi	sp,sp,16
    802020e8:	8082                	ret

00000000802020ea <syscallYield>:

void syscallYield() {
    802020ea:	1141                	addi	sp,sp,-16
    802020ec:	e422                	sd	s0,8(sp)
    802020ee:	0800                	addi	s0,sp,16

}
    802020f0:	6422                	ld	s0,8(sp)
    802020f2:	0141                	addi	sp,sp,16
    802020f4:	8082                	ret

00000000802020f6 <syscallFork>:

void syscallFork() {
    802020f6:	1141                	addi	sp,sp,-16
    802020f8:	e406                	sd	ra,8(sp)
    802020fa:	e022                	sd	s0,0(sp)
    802020fc:	0800                	addi	s0,sp,16
    processFork();
    802020fe:	00000097          	auipc	ra,0x0
    80202102:	dce080e7          	jalr	-562(ra) # 80201ecc <processFork>
}
    80202106:	60a2                	ld	ra,8(sp)
    80202108:	6402                	ld	s0,0(sp)
    8020210a:	0141                	addi	sp,sp,16
    8020210c:	8082                	ret

000000008020210e <syscallPutString>:

void syscallPutString() {
    8020210e:	7139                	addi	sp,sp,-64
    80202110:	fc06                	sd	ra,56(sp)
    80202112:	f822                	sd	s0,48(sp)
    80202114:	f426                	sd	s1,40(sp)
    80202116:	f04a                	sd	s2,32(sp)
    80202118:	ec4e                	sd	s3,24(sp)
    8020211a:	0080                	addi	s0,sp,64
    u64 va = trapframe->a0;
    8020211c:	00001797          	auipc	a5,0x1
    80202120:	00678793          	addi	a5,a5,6 # 80203122 <trapframe>
    80202124:	0707b983          	ld	s3,112(a5)
    int len = trapframe->a1;
    80202128:	7fa4                	ld	s1,120(a5)
    8020212a:	0004891b          	sext.w	s2,s1
    asm volatile("mv %0, tp" : "=r" (x) );
    8020212e:	8792                	mv	a5,tp
    extern Process *currentProcess[HART_TOTAL_NUMBER];
    int hartId = r_hartid();
    u64* pte;
    u64 pa = pageLookup(currentProcess[hartId]->pgdir, va, &pte);
    80202130:	2781                	sext.w	a5,a5
    80202132:	078e                	slli	a5,a5,0x3
    80202134:	00114717          	auipc	a4,0x114
    80202138:	31470713          	addi	a4,a4,788 # 80316448 <currentProcess>
    8020213c:	97ba                	add	a5,a5,a4
    8020213e:	639c                	ld	a5,0(a5)
    80202140:	fc840613          	addi	a2,s0,-56
    80202144:	85ce                	mv	a1,s3
    80202146:	1307b503          	ld	a0,304(a5)
    8020214a:	fffff097          	auipc	ra,0xfffff
    8020214e:	1b8080e7          	jalr	440(ra) # 80201302 <pageLookup>
    if (pa == 0) {
    80202152:	c90d                	beqz	a0,80202184 <syscallPutString+0x76>
        panic("Syscall put string address error!\nThe virtual address is %x, the length is %x\n", va, len);
    }
    char* start = (char*) pa;
    80202154:	87aa                	mv	a5,a0
    while (len--) {
    80202156:	02090063          	beqz	s2,80202176 <syscallPutString+0x68>
    8020215a:	fff4871b          	addiw	a4,s1,-1
    8020215e:	1702                	slli	a4,a4,0x20
    80202160:	9301                	srli	a4,a4,0x20
    80202162:	0705                	addi	a4,a4,1
    80202164:	972a                	add	a4,a4,a0
    register u64 a0 asm ("a0") = (u64) c;
    80202166:	0007c503          	lbu	a0,0(a5)
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_PUTCHAR;
    8020216a:	4885                	li	a7,1
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    8020216c:	00000073          	ecall
        putchar(*start);
        start++;
    80202170:	0785                	addi	a5,a5,1
    while (len--) {
    80202172:	fee79ae3          	bne	a5,a4,80202166 <syscallPutString+0x58>
    }
    80202176:	70e2                	ld	ra,56(sp)
    80202178:	7442                	ld	s0,48(sp)
    8020217a:	74a2                	ld	s1,40(sp)
    8020217c:	7902                	ld	s2,32(sp)
    8020217e:	69e2                	ld	s3,24(sp)
    80202180:	6121                	addi	sp,sp,64
    80202182:	8082                	ret
        panic("Syscall put string address error!\nThe virtual address is %x, the length is %x\n", va, len);
    80202184:	874a                	mv	a4,s2
    80202186:	86ce                	mv	a3,s3
    80202188:	00002617          	auipc	a2,0x2
    8020218c:	13060613          	addi	a2,a2,304 # 802042b8 <digits+0x228>
    80202190:	02900593          	li	a1,41
    80202194:	00002517          	auipc	a0,0x2
    80202198:	17450513          	addi	a0,a0,372 # 80204308 <digits+0x278>
    8020219c:	ffffe097          	auipc	ra,0xffffe
    802021a0:	390080e7          	jalr	912(ra) # 8020052c <_panic_>

00000000802021a4 <setNextTimeout>:
#include <Process.h>
#include <Riscv.h>

static u32 ticks;

void setNextTimeout() {
    802021a4:	1141                	addi	sp,sp,-16
    802021a6:	e422                	sd	s0,8(sp)
    802021a8:	0800                	addi	s0,sp,16
	asm volatile("rdtime %0" : "=r" (x) );
    802021aa:	c0102573          	rdtime	a0
    SBI_CALL_1(SBI_SET_TIMER, r_time() + INTERVAL);
    802021ae:	000317b7          	lui	a5,0x31
    802021b2:	d4078793          	addi	a5,a5,-704 # 30d40 <_start-0x801cf2c0>
    802021b6:	953e                	add	a0,a0,a5
    802021b8:	4581                	li	a1,0
    802021ba:	4601                	li	a2,0
    802021bc:	4681                	li	a3,0
    802021be:	4881                	li	a7,0
    802021c0:	00000073          	ecall
}
    802021c4:	6422                	ld	s0,8(sp)
    802021c6:	0141                	addi	sp,sp,16
    802021c8:	8082                	ret

00000000802021ca <timerTick>:

void timerTick() {
    802021ca:	1141                	addi	sp,sp,-16
    802021cc:	e406                	sd	ra,8(sp)
    802021ce:	e022                	sd	s0,0(sp)
    802021d0:	0800                	addi	s0,sp,16
    ticks++;
    802021d2:	0016a517          	auipc	a0,0x16a
    802021d6:	2ae50513          	addi	a0,a0,686 # 8036c480 <ticks>
    802021da:	411c                	lw	a5,0(a0)
    802021dc:	2785                	addiw	a5,a5,1
    802021de:	c11c                	sw	a5,0(a0)
    wakeup(&ticks);
    802021e0:	00000097          	auipc	ra,0x0
    802021e4:	ba8080e7          	jalr	-1112(ra) # 80201d88 <wakeup>
    setNextTimeout();
    802021e8:	00000097          	auipc	ra,0x0
    802021ec:	fbc080e7          	jalr	-68(ra) # 802021a4 <setNextTimeout>
    802021f0:	60a2                	ld	ra,8(sp)
    802021f2:	6402                	ld	s0,0(sp)
    802021f4:	0141                	addi	sp,sp,16
    802021f6:	8082                	ret

00000000802021f8 <trapInit>:
#include <Trap.h>
#include <Process.h>
#include <Page.h>
#include <Syscall.h>

void trapInit() {
    802021f8:	1141                	addi	sp,sp,-16
    802021fa:	e406                	sd	ra,8(sp)
    802021fc:	e022                	sd	s0,0(sp)
    802021fe:	0800                	addi	s0,sp,16
    printf("Trap init start...\n");
    80202200:	00002517          	auipc	a0,0x2
    80202204:	11850513          	addi	a0,a0,280 # 80204318 <digits+0x288>
    80202208:	ffffe097          	auipc	ra,0xffffe
    8020220c:	2ca080e7          	jalr	714(ra) # 802004d2 <printf>
	asm volatile("csrw stvec, %0" : : "r" (x));
    80202210:	fffff797          	auipc	a5,0xfffff
    80202214:	53478793          	addi	a5,a5,1332 # 80201744 <kernelVector>
    80202218:	10579073          	csrw	stvec,a5
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020221c:	100027f3          	csrr	a5,sstatus
    w_stvec((u64)kernelVector);
    w_sstatus(r_sstatus() | SSTATUS_SIE | SSTATUS_SPIE);
    80202220:	0227e793          	ori	a5,a5,34
    asm volatile("csrw sstatus, %0" : : "r" (x));
    80202224:	10079073          	csrw	sstatus,a5
    asm volatile("csrr %0, sie" : "=r" (x) );
    80202228:	104027f3          	csrr	a5,sie
    w_sie(r_sie() | SIE_SEIE | SIE_SSIE | SIE_STIE);
    8020222c:	2227e793          	ori	a5,a5,546
	asm volatile("csrw sie, %0" : : "r" (x));
    80202230:	10479073          	csrw	sie,a5
    setNextTimeout();
    80202234:	00000097          	auipc	ra,0x0
    80202238:	f70080e7          	jalr	-144(ra) # 802021a4 <setNextTimeout>
    printf("Trap init finish!\n");
    8020223c:	00002517          	auipc	a0,0x2
    80202240:	0f450513          	addi	a0,a0,244 # 80204330 <digits+0x2a0>
    80202244:	ffffe097          	auipc	ra,0xffffe
    80202248:	28e080e7          	jalr	654(ra) # 802004d2 <printf>
}
    8020224c:	60a2                	ld	ra,8(sp)
    8020224e:	6402                	ld	s0,0(sp)
    80202250:	0141                	addi	sp,sp,16
    80202252:	8082                	ret

0000000080202254 <trapDevice>:
	asm volatile("csrr %0, scause" : "=r" (x) );
    80202254:	142027f3          	csrr	a5,scause
    #ifdef QEMU
    if ((scause & SCAUSE_INTERRUPT) && 
    ((scause & SCAUSE_EXCEPTION_CODE) == SCAUSE_SUPERVISOR_EXTERNAL)) {
    #else
    // todo
    if ((scause & SCAUSE_INTERRUPT) && 
    80202258:	0007c463          	bltz	a5,80202260 <trapDevice+0xc>
    if ((scause & SCAUSE_INTERRUPT) &&
    ((scause & SCAUSE_EXCEPTION_CODE) == SCAUSE_SUPERVISOR_TIMER)) {
        timerTick();
        return TIMER_INTERRUPT;
    }
    return UNKNOWN_DEVICE;
    8020225c:	4501                	li	a0,0
}
    8020225e:	8082                	ret
int trapDevice() {
    80202260:	1101                	addi	sp,sp,-32
    80202262:	ec06                	sd	ra,24(sp)
    80202264:	e822                	sd	s0,16(sp)
    80202266:	e426                	sd	s1,8(sp)
    80202268:	1000                	addi	s0,sp,32
    ((scause & SCAUSE_EXCEPTION_CODE) == SCAUSE_SUPERVISOR_EXTERNAL)) {
    8020226a:	0786                	slli	a5,a5,0x1
    8020226c:	8385                	srli	a5,a5,0x1
    if ((scause & SCAUSE_INTERRUPT) && 
    8020226e:	4725                	li	a4,9
    80202270:	00e78b63          	beq	a5,a4,80202286 <trapDevice+0x32>
    if ((scause & SCAUSE_INTERRUPT) &&
    80202274:	4715                	li	a4,5
    return UNKNOWN_DEVICE;
    80202276:	4501                	li	a0,0
    if ((scause & SCAUSE_INTERRUPT) &&
    80202278:	06e78e63          	beq	a5,a4,802022f4 <trapDevice+0xa0>
}
    8020227c:	60e2                	ld	ra,24(sp)
    8020227e:	6442                	ld	s0,16(sp)
    80202280:	64a2                	ld	s1,8(sp)
    80202282:	6105                	addi	sp,sp,32
    80202284:	8082                	ret
	asm volatile("mv %0, tp" : "=r" (x) );
    80202286:	8712                	mv	a4,tp
void userTrapReturn();

inline static u32 interruptServed() {
    int hart = r_tp();
    #ifndef QEMU
    return *(u32*)PLIC_MCLAIM(hart);
    80202288:	00d7171b          	slliw	a4,a4,0xd
    8020228c:	1f8617b7          	lui	a5,0x1f861
    80202290:	07a6                	slli	a5,a5,0x9
    80202292:	97ba                	add	a5,a5,a4
    80202294:	43c4                	lw	s1,4(a5)
        int irq = interruptServed();
    80202296:	0004869b          	sext.w	a3,s1
        if (irq == UART_IRQ) {
    8020229a:	02100793          	li	a5,33
    8020229e:	02f68563          	beq	a3,a5,802022c8 <trapDevice+0x74>
        } else if (irq == DISK_IRQ) {
    802022a2:	47ed                	li	a5,27
    802022a4:	02f68963          	beq	a3,a5,802022d6 <trapDevice+0x82>
        return SOFTWARE_TRAP;
    802022a8:	4505                	li	a0,1
        } else if (irq) {
    802022aa:	dae9                	beqz	a3,8020227c <trapDevice+0x28>
            panic("unexpected interrupt irq = %d\n", irq);
    802022ac:	00002617          	auipc	a2,0x2
    802022b0:	09c60613          	addi	a2,a2,156 # 80204348 <digits+0x2b8>
    802022b4:	02500593          	li	a1,37
    802022b8:	00002517          	auipc	a0,0x2
    802022bc:	0b050513          	addi	a0,a0,176 # 80204368 <digits+0x2d8>
    802022c0:	ffffe097          	auipc	ra,0xffffe
    802022c4:	26c080e7          	jalr	620(ra) # 8020052c <_panic_>
};

inline int getchar() {
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_GETCHAR;
    802022c8:	4889                	li	a7,2
    register u64 a0 asm ("a0");
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    802022ca:	00000073          	ecall
    return a0;
    802022ce:	2501                	sext.w	a0,a0
            if (c != -1) {
    802022d0:	57fd                	li	a5,-1
    802022d2:	00f51c63          	bne	a0,a5,802022ea <trapDevice+0x96>
    802022d6:	8712                	mv	a4,tp
}

inline static void interruptCompleted(int irq) {
    int hart = r_tp();
    #ifndef QEMU
    *(u32*)PLIC_MCLAIM(hart) = irq;
    802022d8:	00d7171b          	slliw	a4,a4,0xd
    802022dc:	1f8617b7          	lui	a5,0x1f861
    802022e0:	07a6                	slli	a5,a5,0x9
    802022e2:	97ba                	add	a5,a5,a4
    802022e4:	c3c4                	sw	s1,4(a5)
        return SOFTWARE_TRAP;
    802022e6:	4505                	li	a0,1
    #else
    *(u32*)PLIC_SCLAIM(hart) = irq;
    #endif
}
    802022e8:	bf51                	j	8020227c <trapDevice+0x28>
                consoleInterrupt(c);
    802022ea:	ffffe097          	auipc	ra,0xffffe
    802022ee:	ed0080e7          	jalr	-304(ra) # 802001ba <consoleInterrupt>
    802022f2:	b7d5                	j	802022d6 <trapDevice+0x82>
        timerTick();
    802022f4:	00000097          	auipc	ra,0x0
    802022f8:	ed6080e7          	jalr	-298(ra) # 802021ca <timerTick>
        return TIMER_INTERRUPT;
    802022fc:	4509                	li	a0,2
    802022fe:	bfbd                	j	8020227c <trapDevice+0x28>

0000000080202300 <kernelTrap>:

void kernelTrap() {
    80202300:	1101                	addi	sp,sp,-32
    80202302:	ec06                	sd	ra,24(sp)
    80202304:	e822                	sd	s0,16(sp)
    80202306:	e426                	sd	s1,8(sp)
    80202308:	e04a                	sd	s2,0(sp)
    8020230a:	1000                	addi	s0,sp,32
    printf("kernel trap\n");
    8020230c:	00002517          	auipc	a0,0x2
    80202310:	06450513          	addi	a0,a0,100 # 80204370 <digits+0x2e0>
    80202314:	ffffe097          	auipc	ra,0xffffe
    80202318:	1be080e7          	jalr	446(ra) # 802004d2 <printf>
    asm volatile("csrr %0, sepc" : "=r" (x) );
    8020231c:	14102973          	csrr	s2,sepc
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    80202320:	100024f3          	csrr	s1,sstatus
    u64 sepc = r_sepc();
    u64 sstatus = r_sstatus();

    if (!(sstatus & SSTATUS_SPP)) {
    80202324:	1004f793          	andi	a5,s1,256
    80202328:	cb85                	beqz	a5,80202358 <kernelTrap+0x58>
    8020232a:	100027f3          	csrr	a5,sstatus
	return (x & SSTATUS_SIE) != 0;
    8020232e:	8b89                	andi	a5,a5,2
        panic("kernel trap not from supervisor mode");
    }
    if (intr_get()) {
    80202330:	e3b1                	bnez	a5,80202374 <kernelTrap+0x74>
        panic("kernel trap while interrupts enbled");
    }
    
    int device = trapDevice();
    80202332:	00000097          	auipc	ra,0x0
    80202336:	f22080e7          	jalr	-222(ra) # 80202254 <trapDevice>
    if (device == UNKNOWN_DEVICE) {
    8020233a:	c939                	beqz	a0,80202390 <kernelTrap+0x90>
    asm volatile("mv %0, tp" : "=r" (x) );
    8020233c:	8792                	mv	a5,tp
        panic("kernel trap");
    }
    extern Process *currentProcess[HART_TOTAL_NUMBER];
    int hartId = r_hartid();
    if (device == TIMER_INTERRUPT && currentProcess[hartId] != NULL &&
    8020233e:	4709                	li	a4,2
    80202340:	06e50663          	beq	a0,a4,802023ac <kernelTrap+0xac>
  	asm volatile("csrw sepc, %0" : : "r" (x));
    80202344:	14191073          	csrw	sepc,s2
    asm volatile("csrw sstatus, %0" : : "r" (x));
    80202348:	10049073          	csrw	sstatus,s1
        currentProcess[hartId]->state == RUNNING) {
        yield();
    }
    w_sepc(sepc);
    w_sstatus(sstatus);
}
    8020234c:	60e2                	ld	ra,24(sp)
    8020234e:	6442                	ld	s0,16(sp)
    80202350:	64a2                	ld	s1,8(sp)
    80202352:	6902                	ld	s2,0(sp)
    80202354:	6105                	addi	sp,sp,32
    80202356:	8082                	ret
        panic("kernel trap not from supervisor mode");
    80202358:	00002617          	auipc	a2,0x2
    8020235c:	02860613          	addi	a2,a2,40 # 80204380 <digits+0x2f0>
    80202360:	03d00593          	li	a1,61
    80202364:	00002517          	auipc	a0,0x2
    80202368:	00450513          	addi	a0,a0,4 # 80204368 <digits+0x2d8>
    8020236c:	ffffe097          	auipc	ra,0xffffe
    80202370:	1c0080e7          	jalr	448(ra) # 8020052c <_panic_>
        panic("kernel trap while interrupts enbled");
    80202374:	00002617          	auipc	a2,0x2
    80202378:	03460613          	addi	a2,a2,52 # 802043a8 <digits+0x318>
    8020237c:	04000593          	li	a1,64
    80202380:	00002517          	auipc	a0,0x2
    80202384:	fe850513          	addi	a0,a0,-24 # 80204368 <digits+0x2d8>
    80202388:	ffffe097          	auipc	ra,0xffffe
    8020238c:	1a4080e7          	jalr	420(ra) # 8020052c <_panic_>
        panic("kernel trap");
    80202390:	00002617          	auipc	a2,0x2
    80202394:	04060613          	addi	a2,a2,64 # 802043d0 <digits+0x340>
    80202398:	04500593          	li	a1,69
    8020239c:	00002517          	auipc	a0,0x2
    802023a0:	fcc50513          	addi	a0,a0,-52 # 80204368 <digits+0x2d8>
    802023a4:	ffffe097          	auipc	ra,0xffffe
    802023a8:	188080e7          	jalr	392(ra) # 8020052c <_panic_>
    if (device == TIMER_INTERRUPT && currentProcess[hartId] != NULL &&
    802023ac:	2781                	sext.w	a5,a5
    802023ae:	078e                	slli	a5,a5,0x3
    802023b0:	00114717          	auipc	a4,0x114
    802023b4:	09870713          	addi	a4,a4,152 # 80316448 <currentProcess>
    802023b8:	97ba                	add	a5,a5,a4
    802023ba:	639c                	ld	a5,0(a5)
    802023bc:	d7c1                	beqz	a5,80202344 <kernelTrap+0x44>
    802023be:	1547a703          	lw	a4,340(a5) # 1f861154 <_start-0x6099eeac>
    802023c2:	478d                	li	a5,3
    802023c4:	f8f710e3          	bne	a4,a5,80202344 <kernelTrap+0x44>
        yield();
    802023c8:	00000097          	auipc	ra,0x0
    802023cc:	9cc080e7          	jalr	-1588(ra) # 80201d94 <yield>
    802023d0:	bf95                	j	80202344 <kernelTrap+0x44>

00000000802023d2 <userTrapReturn>:
        }
    }
    userTrapReturn();
}

void userTrapReturn() {
    802023d2:	1141                	addi	sp,sp,-16
    802023d4:	e406                	sd	ra,8(sp)
    802023d6:	e022                	sd	s0,0(sp)
    802023d8:	0800                	addi	s0,sp,16
    extern char trampoline[];
    w_stvec(TRAMPOLINE_BASE + ((u64)userVector - (u64)trampoline));
    802023da:	00001517          	auipc	a0,0x1
    802023de:	c2650513          	addi	a0,a0,-986 # 80203000 <_trampoline>
    802023e2:	040007b7          	lui	a5,0x4000
    802023e6:	17fd                	addi	a5,a5,-1
    802023e8:	07b2                	slli	a5,a5,0xc
    802023ea:	00001717          	auipc	a4,0x1
    802023ee:	c1670713          	addi	a4,a4,-1002 # 80203000 <_trampoline>
    802023f2:	973e                	add	a4,a4,a5
    802023f4:	8f09                	sub	a4,a4,a0
	asm volatile("csrw stvec, %0" : : "r" (x));
    802023f6:	10571073          	csrw	stvec,a4
    asm volatile("mv %0, tp" : "=r" (x) );
    802023fa:	8692                	mv	a3,tp

    extern Process *currentProcess[HART_TOTAL_NUMBER];
    extern char kernelStack[];
    extern Trapframe trapframe[];
    int hartId = r_hartid();
    trapframe->kernelSp = (u64)kernelStack + KERNEL_STACK_SIZE;
    802023fc:	00001717          	auipc	a4,0x1
    80202400:	d2670713          	addi	a4,a4,-730 # 80203122 <trapframe>
    80202404:	00023617          	auipc	a2,0x23
    80202408:	bfc60613          	addi	a2,a2,-1028 # 80225000 <_stack+0x10000>
    8020240c:	e710                	sd	a2,8(a4)
    trapframe->trapHandler = (u64)userTrap;
    8020240e:	00000617          	auipc	a2,0x0
    80202412:	05660613          	addi	a2,a2,86 # 80202464 <userTrap>
    80202416:	eb10                	sd	a2,16(a4)
	asm volatile("mv %0, tp" : "=r" (x) );
    80202418:	8612                	mv	a2,tp
    trapframe->kernelHartId = r_tp();
    8020241a:	f310                	sd	a2,32(a4)
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020241c:	10002673          	csrr	a2,sstatus

    //bcopy(&(currentProcess->trapframe), trapframe, sizeof(Trapframe));

    u64 sstatus = r_sstatus();
    sstatus &= ~SSTATUS_SPP;
    80202420:	eff67613          	andi	a2,a2,-257
    sstatus |= SSTATUS_SPIE;
    80202424:	02066613          	ori	a2,a2,32
    asm volatile("csrw sstatus, %0" : : "r" (x));
    80202428:	10061073          	csrw	sstatus,a2
    w_sstatus(sstatus);
    u64 satp = MAKE_SATP(currentProcess[hartId]->pgdir);
    8020242c:	2681                	sext.w	a3,a3
    8020242e:	068e                	slli	a3,a3,0x3
    80202430:	00114617          	auipc	a2,0x114
    80202434:	01860613          	addi	a2,a2,24 # 80316448 <currentProcess>
    80202438:	96b2                	add	a3,a3,a2
    8020243a:	6294                	ld	a3,0(a3)
    8020243c:	1306b583          	ld	a1,304(a3)
    80202440:	81b1                	srli	a1,a1,0xc
    u64 fn = TRAMPOLINE_BASE + ((u64)userReturn - (u64)trampoline);
    ((void(*)(u64, u64))fn)(TRAMPOLINE_BASE + (u64)trapframe - (u64)trampoline, satp);
    80202442:	973e                	add	a4,a4,a5
    u64 fn = TRAMPOLINE_BASE + ((u64)userReturn - (u64)trampoline);
    80202444:	00001697          	auipc	a3,0x1
    80202448:	c5468693          	addi	a3,a3,-940 # 80203098 <userReturn>
    8020244c:	97b6                	add	a5,a5,a3
    8020244e:	8f89                	sub	a5,a5,a0
    ((void(*)(u64, u64))fn)(TRAMPOLINE_BASE + (u64)trapframe - (u64)trampoline, satp);
    80202450:	56fd                	li	a3,-1
    80202452:	16fe                	slli	a3,a3,0x3f
    80202454:	8dd5                	or	a1,a1,a3
    80202456:	40a70533          	sub	a0,a4,a0
    8020245a:	9782                	jalr	a5
}
    8020245c:	60a2                	ld	ra,8(sp)
    8020245e:	6402                	ld	s0,0(sp)
    80202460:	0141                	addi	sp,sp,16
    80202462:	8082                	ret

0000000080202464 <userTrap>:
void userTrap() {
    80202464:	7179                	addi	sp,sp,-48
    80202466:	f406                	sd	ra,40(sp)
    80202468:	f022                	sd	s0,32(sp)
    8020246a:	ec26                	sd	s1,24(sp)
    8020246c:	1800                	addi	s0,sp,48
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    8020246e:	100027f3          	csrr	a5,sstatus
    if (sstatus & SSTATUS_SPP) {
    80202472:	1007f793          	andi	a5,a5,256
    80202476:	e3bd                	bnez	a5,802024dc <userTrap+0x78>
	asm volatile("csrw stvec, %0" : : "r" (x));
    80202478:	fffff797          	auipc	a5,0xfffff
    8020247c:	2cc78793          	addi	a5,a5,716 # 80201744 <kernelVector>
    80202480:	10579073          	csrw	stvec,a5
    asm volatile("mv %0, tp" : "=r" (x) );
    80202484:	8592                	mv	a1,tp
	asm volatile("csrr %0, scause" : "=r" (x) );
    80202486:	142026f3          	csrr	a3,scause
    if (scause & SCAUSE_INTERRUPT) {
    8020248a:	0606c763          	bltz	a3,802024f8 <userTrap+0x94>
        u64 *pte = NULL;
    8020248e:	fc043c23          	sd	zero,-40(s0)
        switch (scause & SCAUSE_EXCEPTION_CODE)
    80202492:	00169713          	slli	a4,a3,0x1
    80202496:	8305                	srli	a4,a4,0x1
    80202498:	57ed                	li	a5,-5
    8020249a:	8385                	srli	a5,a5,0x1
    8020249c:	8ff5                	and	a5,a5,a3
    8020249e:	4635                	li	a2,13
    802024a0:	06c78563          	beq	a5,a2,8020250a <userTrap+0xa6>
    802024a4:	47a1                	li	a5,8
    802024a6:	0ef71d63          	bne	a4,a5,802025a0 <userTrap+0x13c>
            trapframe->epc += 4;
    802024aa:	00001797          	auipc	a5,0x1
    802024ae:	c7878793          	addi	a5,a5,-904 # 80203122 <trapframe>
    802024b2:	6f98                	ld	a4,24(a5)
    802024b4:	0711                	addi	a4,a4,4
    802024b6:	ef98                	sd	a4,24(a5)
            syscallVector[trapframe->a7]();
    802024b8:	77d8                	ld	a4,168(a5)
    802024ba:	070e                	slli	a4,a4,0x3
    802024bc:	00003797          	auipc	a5,0x3
    802024c0:	b4478793          	addi	a5,a5,-1212 # 80205000 <syscallVector>
    802024c4:	97ba                	add	a5,a5,a4
    802024c6:	639c                	ld	a5,0(a5)
    802024c8:	9782                	jalr	a5
    userTrapReturn();
    802024ca:	00000097          	auipc	ra,0x0
    802024ce:	f08080e7          	jalr	-248(ra) # 802023d2 <userTrapReturn>
}
    802024d2:	70a2                	ld	ra,40(sp)
    802024d4:	7402                	ld	s0,32(sp)
    802024d6:	64e2                	ld	s1,24(sp)
    802024d8:	6145                	addi	sp,sp,48
    802024da:	8082                	ret
        panic("usertrap: not from user mode\n");
    802024dc:	00002617          	auipc	a2,0x2
    802024e0:	f0460613          	addi	a2,a2,-252 # 802043e0 <digits+0x350>
    802024e4:	05400593          	li	a1,84
    802024e8:	00002517          	auipc	a0,0x2
    802024ec:	e8050513          	addi	a0,a0,-384 # 80204368 <digits+0x2d8>
    802024f0:	ffffe097          	auipc	ra,0xffffe
    802024f4:	03c080e7          	jalr	60(ra) # 8020052c <_panic_>
        trapDevice();
    802024f8:	00000097          	auipc	ra,0x0
    802024fc:	d5c080e7          	jalr	-676(ra) # 80202254 <trapDevice>
        yield();
    80202500:	00000097          	auipc	ra,0x0
    80202504:	894080e7          	jalr	-1900(ra) # 80201d94 <yield>
    80202508:	b7c9                	j	802024ca <userTrap+0x66>
    int hartId = r_hartid();
    8020250a:	0005849b          	sext.w	s1,a1
	asm volatile("csrr %0, stval" : "=r" (x) );
    8020250e:	143025f3          	csrr	a1,stval
            pa = pageLookup(currentProcess[hartId]->pgdir, r_stval(), &pte);
    80202512:	00349713          	slli	a4,s1,0x3
    80202516:	00114797          	auipc	a5,0x114
    8020251a:	f3278793          	addi	a5,a5,-206 # 80316448 <currentProcess>
    8020251e:	97ba                	add	a5,a5,a4
    80202520:	639c                	ld	a5,0(a5)
    80202522:	fd840613          	addi	a2,s0,-40
    80202526:	1307b503          	ld	a0,304(a5)
    8020252a:	fffff097          	auipc	ra,0xfffff
    8020252e:	dd8080e7          	jalr	-552(ra) # 80201302 <pageLookup>
            if (pa == 0) {
    80202532:	c905                	beqz	a0,80202562 <userTrap+0xfe>
            } else if (*pte & PTE_COW) {
    80202534:	fd843783          	ld	a5,-40(s0)
    80202538:	639c                	ld	a5,0(a5)
    8020253a:	1007f793          	andi	a5,a5,256
    8020253e:	c3b9                	beqz	a5,80202584 <userTrap+0x120>
    80202540:	143025f3          	csrr	a1,stval
                cowHandler(currentProcess[hartId]->pgdir, r_stval());
    80202544:	00349793          	slli	a5,s1,0x3
    80202548:	00114717          	auipc	a4,0x114
    8020254c:	f0070713          	addi	a4,a4,-256 # 80316448 <currentProcess>
    80202550:	97ba                	add	a5,a5,a4
    80202552:	639c                	ld	a5,0(a5)
    80202554:	1307b503          	ld	a0,304(a5)
    80202558:	fffff097          	auipc	ra,0xfffff
    8020255c:	03c080e7          	jalr	60(ra) # 80201594 <cowHandler>
    80202560:	b7ad                	j	802024ca <userTrap+0x66>
    80202562:	143025f3          	csrr	a1,stval
                pageout(currentProcess[hartId]->pgdir, r_stval());
    80202566:	00349793          	slli	a5,s1,0x3
    8020256a:	00114717          	auipc	a4,0x114
    8020256e:	ede70713          	addi	a4,a4,-290 # 80316448 <currentProcess>
    80202572:	97ba                	add	a5,a5,a4
    80202574:	639c                	ld	a5,0(a5)
    80202576:	1307b503          	ld	a0,304(a5)
    8020257a:	fffff097          	auipc	ra,0xfffff
    8020257e:	f48080e7          	jalr	-184(ra) # 802014c2 <pageout>
    80202582:	b7a1                	j	802024ca <userTrap+0x66>
                panic("unknown");
    80202584:	00002617          	auipc	a2,0x2
    80202588:	e7c60613          	addi	a2,a2,-388 # 80204400 <digits+0x370>
    8020258c:	07000593          	li	a1,112
    80202590:	00002517          	auipc	a0,0x2
    80202594:	dd850513          	addi	a0,a0,-552 # 80204368 <digits+0x2d8>
    80202598:	ffffe097          	auipc	ra,0xffffe
    8020259c:	f94080e7          	jalr	-108(ra) # 8020052c <_panic_>
    802025a0:	14302773          	csrr	a4,stval
            panic("unhandled error %d,  %lx\n", scause, r_stval());
    802025a4:	00002617          	auipc	a2,0x2
    802025a8:	e6460613          	addi	a2,a2,-412 # 80204408 <digits+0x378>
    802025ac:	07400593          	li	a1,116
    802025b0:	00002517          	auipc	a0,0x2
    802025b4:	db850513          	addi	a0,a0,-584 # 80204368 <digits+0x2d8>
    802025b8:	ffffe097          	auipc	ra,0xffffe
    802025bc:	f74080e7          	jalr	-140(ra) # 8020052c <_panic_>

00000000802025c0 <interruptPush>:
#include "Interrupt.h"
#include "Riscv.h"
#include "Cpu.h"
#include "Driver.h"

void interruptPush(void) {
    802025c0:	1101                	addi	sp,sp,-32
    802025c2:	ec06                	sd	ra,24(sp)
    802025c4:	e822                	sd	s0,16(sp)
    802025c6:	e426                	sd	s1,8(sp)
    802025c8:	1000                	addi	s0,sp,32
#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable

static inline u64 r_sstatus() {
    u64 x;
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    802025ca:	100024f3          	csrr	s1,sstatus
    802025ce:	100027f3          	csrr	a5,sstatus
	w_sstatus(r_sstatus() | SSTATUS_SIE);
}

// disable device interrupts
static inline void intr_off() {
	w_sstatus(r_sstatus() & ~SSTATUS_SIE);
    802025d2:	9bf5                	andi	a5,a5,-3
    asm volatile("csrw sstatus, %0" : : "r" (x));
    802025d4:	10079073          	csrw	sstatus,a5
    int oldInterruptEnable = intr_get();
    intr_off();

    struct Cpu* cpu = myCpu();
    802025d8:	00000097          	auipc	ra,0x0
    802025dc:	1a0080e7          	jalr	416(ra) # 80202778 <myCpu>
    if (cpu->interruptLayer == 0)
    802025e0:	411c                	lw	a5,0(a0)
    802025e2:	e781                	bnez	a5,802025ea <interruptPush+0x2a>
}

// are device interrupts enabled?
static inline bool intr_get() {
	u64 x = r_sstatus();
	return (x & SSTATUS_SIE) != 0;
    802025e4:	8085                	srli	s1,s1,0x1
    802025e6:	8885                	andi	s1,s1,1
        cpu->lastInterruptEnable = oldInterruptEnable;
    802025e8:	c144                	sw	s1,4(a0)
    cpu->interruptLayer++;
    802025ea:	2785                	addiw	a5,a5,1
    802025ec:	c11c                	sw	a5,0(a0)
}
    802025ee:	60e2                	ld	ra,24(sp)
    802025f0:	6442                	ld	s0,16(sp)
    802025f2:	64a2                	ld	s1,8(sp)
    802025f4:	6105                	addi	sp,sp,32
    802025f6:	8082                	ret

00000000802025f8 <interruptPop>:

void interruptPop(void) {
    802025f8:	1141                	addi	sp,sp,-16
    802025fa:	e406                	sd	ra,8(sp)
    802025fc:	e022                	sd	s0,0(sp)
    802025fe:	0800                	addi	s0,sp,16
    struct Cpu* cpu = myCpu();
    80202600:	00000097          	auipc	ra,0x0
    80202604:	178080e7          	jalr	376(ra) # 80202778 <myCpu>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    80202608:	100027f3          	csrr	a5,sstatus
	return (x & SSTATUS_SIE) != 0;
    8020260c:	8b89                	andi	a5,a5,2
    if (intr_get()) {
    8020260e:	e78d                	bnez	a5,80202638 <interruptPop+0x40>
        panic("Interrupt bit still have!\n");
    }

    if (cpu->interruptLayer < 0) {
    80202610:	411c                	lw	a5,0(a0)
    80202612:	0407c063          	bltz	a5,80202652 <interruptPop+0x5a>
        panic("Interrupt close error! Not match!\n");
    }

    cpu->interruptLayer--;
    80202616:	37fd                	addiw	a5,a5,-1
    80202618:	0007871b          	sext.w	a4,a5
    8020261c:	c11c                	sw	a5,0(a0)
    if (cpu->interruptLayer == 0 && cpu->lastInterruptEnable)
    8020261e:	eb09                	bnez	a4,80202630 <interruptPop+0x38>
    80202620:	415c                	lw	a5,4(a0)
    80202622:	c799                	beqz	a5,80202630 <interruptPop+0x38>
    asm volatile("csrr %0, sstatus" : "=r" (x) );
    80202624:	100027f3          	csrr	a5,sstatus
	w_sstatus(r_sstatus() | SSTATUS_SIE);
    80202628:	0027e793          	ori	a5,a5,2
    asm volatile("csrw sstatus, %0" : : "r" (x));
    8020262c:	10079073          	csrw	sstatus,a5
        intr_on();
    80202630:	60a2                	ld	ra,8(sp)
    80202632:	6402                	ld	s0,0(sp)
    80202634:	0141                	addi	sp,sp,16
    80202636:	8082                	ret
        panic("Interrupt bit still have!\n");
    80202638:	00002617          	auipc	a2,0x2
    8020263c:	df060613          	addi	a2,a2,-528 # 80204428 <digits+0x398>
    80202640:	45cd                	li	a1,19
    80202642:	00002517          	auipc	a0,0x2
    80202646:	e0650513          	addi	a0,a0,-506 # 80204448 <digits+0x3b8>
    8020264a:	ffffe097          	auipc	ra,0xffffe
    8020264e:	ee2080e7          	jalr	-286(ra) # 8020052c <_panic_>
        panic("Interrupt close error! Not match!\n");
    80202652:	00002617          	auipc	a2,0x2
    80202656:	e0660613          	addi	a2,a2,-506 # 80204458 <digits+0x3c8>
    8020265a:	45dd                	li	a1,23
    8020265c:	00002517          	auipc	a0,0x2
    80202660:	dec50513          	addi	a0,a0,-532 # 80204448 <digits+0x3b8>
    80202664:	ffffe097          	auipc	ra,0xffffe
    80202668:	ec8080e7          	jalr	-312(ra) # 8020052c <_panic_>

000000008020266c <initLock>:
#include "Spinlock.h"
#include "Cpu.h"
#include "Interrupt.h"
#include "Driver.h"

void initLock(struct Spinlock* lock, char* name) {
    8020266c:	1141                	addi	sp,sp,-16
    8020266e:	e422                	sd	s0,8(sp)
    80202670:	0800                	addi	s0,sp,16
    lock->name = name;
    80202672:	e50c                	sd	a1,8(a0)
    lock->locked = 0;
    80202674:	00050023          	sb	zero,0(a0)
    lock->cpu = 0;
    80202678:	00053823          	sd	zero,16(a0)
}
    8020267c:	6422                	ld	s0,8(sp)
    8020267e:	0141                	addi	sp,sp,16
    80202680:	8082                	ret

0000000080202682 <holding>:
    interruptPop();
}

int holding(struct Spinlock* lock) {
    int r;
    r = (lock->locked && lock->cpu == myCpu());
    80202682:	00054783          	lbu	a5,0(a0)
    80202686:	e399                	bnez	a5,8020268c <holding+0xa>
    80202688:	4501                	li	a0,0
    return r;
    8020268a:	8082                	ret
int holding(struct Spinlock* lock) {
    8020268c:	1101                	addi	sp,sp,-32
    8020268e:	ec06                	sd	ra,24(sp)
    80202690:	e822                	sd	s0,16(sp)
    80202692:	e426                	sd	s1,8(sp)
    80202694:	1000                	addi	s0,sp,32
    r = (lock->locked && lock->cpu == myCpu());
    80202696:	6904                	ld	s1,16(a0)
    80202698:	00000097          	auipc	ra,0x0
    8020269c:	0e0080e7          	jalr	224(ra) # 80202778 <myCpu>
    802026a0:	40a48533          	sub	a0,s1,a0
    802026a4:	00153513          	seqz	a0,a0
    802026a8:	60e2                	ld	ra,24(sp)
    802026aa:	6442                	ld	s0,16(sp)
    802026ac:	64a2                	ld	s1,8(sp)
    802026ae:	6105                	addi	sp,sp,32
    802026b0:	8082                	ret

00000000802026b2 <acquireLock>:
void acquireLock(struct Spinlock* lock) {
    802026b2:	1101                	addi	sp,sp,-32
    802026b4:	ec06                	sd	ra,24(sp)
    802026b6:	e822                	sd	s0,16(sp)
    802026b8:	e426                	sd	s1,8(sp)
    802026ba:	1000                	addi	s0,sp,32
    802026bc:	84aa                	mv	s1,a0
    interruptPush();
    802026be:	00000097          	auipc	ra,0x0
    802026c2:	f02080e7          	jalr	-254(ra) # 802025c0 <interruptPush>
    if (holding(lock)) {
    802026c6:	8526                	mv	a0,s1
    802026c8:	00000097          	auipc	ra,0x0
    802026cc:	fba080e7          	jalr	-70(ra) # 80202682 <holding>
    802026d0:	ed0d                	bnez	a0,8020270a <acquireLock+0x58>
    while(__sync_lock_test_and_set(&lock->locked, 1) != 0);
    802026d2:	ffc4f713          	andi	a4,s1,-4
    802026d6:	0034f693          	andi	a3,s1,3
    802026da:	0036969b          	slliw	a3,a3,0x3
    802026de:	4605                	li	a2,1
    802026e0:	00d6163b          	sllw	a2,a2,a3
    802026e4:	44c727af          	amoor.w.aq	a5,a2,(a4)
    802026e8:	00d7d7bb          	srlw	a5,a5,a3
    802026ec:	0ff7f793          	zext.b	a5,a5
    802026f0:	fbf5                	bnez	a5,802026e4 <acquireLock+0x32>
    __sync_synchronize();
    802026f2:	0ff0000f          	fence
    lock->cpu = myCpu();
    802026f6:	00000097          	auipc	ra,0x0
    802026fa:	082080e7          	jalr	130(ra) # 80202778 <myCpu>
    802026fe:	e888                	sd	a0,16(s1)
}
    80202700:	60e2                	ld	ra,24(sp)
    80202702:	6442                	ld	s0,16(sp)
    80202704:	64a2                	ld	s1,8(sp)
    80202706:	6105                	addi	sp,sp,32
    80202708:	8082                	ret
        panic("You have acquire the lock!\n");
    8020270a:	00002617          	auipc	a2,0x2
    8020270e:	d7660613          	addi	a2,a2,-650 # 80204480 <digits+0x3f0>
    80202712:	45bd                	li	a1,15
    80202714:	00002517          	auipc	a0,0x2
    80202718:	d8c50513          	addi	a0,a0,-628 # 802044a0 <digits+0x410>
    8020271c:	ffffe097          	auipc	ra,0xffffe
    80202720:	e10080e7          	jalr	-496(ra) # 8020052c <_panic_>

0000000080202724 <releaseLock>:
void releaseLock(struct Spinlock* lock) {
    80202724:	1101                	addi	sp,sp,-32
    80202726:	ec06                	sd	ra,24(sp)
    80202728:	e822                	sd	s0,16(sp)
    8020272a:	e426                	sd	s1,8(sp)
    8020272c:	1000                	addi	s0,sp,32
    8020272e:	84aa                	mv	s1,a0
    if (!holding(lock)) {
    80202730:	00000097          	auipc	ra,0x0
    80202734:	f52080e7          	jalr	-174(ra) # 80202682 <holding>
    80202738:	c115                	beqz	a0,8020275c <releaseLock+0x38>
    lock->cpu = 0;
    8020273a:	0004b823          	sd	zero,16(s1) # ffffffffffe00010 <bssEnd+0xffffffff7fa92010>
    __sync_synchronize();
    8020273e:	0ff0000f          	fence
    __sync_lock_release(&lock->locked);
    80202742:	0ff0000f          	fence
    80202746:	00048023          	sb	zero,0(s1)
    interruptPop();
    8020274a:	00000097          	auipc	ra,0x0
    8020274e:	eae080e7          	jalr	-338(ra) # 802025f8 <interruptPop>
}
    80202752:	60e2                	ld	ra,24(sp)
    80202754:	6442                	ld	s0,16(sp)
    80202756:	64a2                	ld	s1,8(sp)
    80202758:	6105                	addi	sp,sp,32
    8020275a:	8082                	ret
        panic("You have release the lock!\n");
    8020275c:	00002617          	auipc	a2,0x2
    80202760:	d5460613          	addi	a2,a2,-684 # 802044b0 <digits+0x420>
    80202764:	02300593          	li	a1,35
    80202768:	00002517          	auipc	a0,0x2
    8020276c:	d3850513          	addi	a0,a0,-712 # 802044a0 <digits+0x410>
    80202770:	ffffe097          	auipc	ra,0xffffe
    80202774:	dbc080e7          	jalr	-580(ra) # 8020052c <_panic_>

0000000080202778 <myCpu>:
#include "Cpu.h"
#include "Riscv.h"

struct Cpu cpus[CPU_NUM];

inline struct Cpu* myCpu() {
    80202778:	1141                	addi	sp,sp,-16
    8020277a:	e422                	sd	s0,8(sp)
    8020277c:	0800                	addi	s0,sp,16
#define HART_TOTAL_NUMBER 4

// which hart (core) is this?
static inline u64 r_hartid() {
    u64 x;
    asm volatile("mv %0, tp" : "=r" (x) );
    8020277e:	8792                	mv	a5,tp
    int r = r_hartid();
    return &cpus[r];
    80202780:	2781                	sext.w	a5,a5
    80202782:	078e                	slli	a5,a5,0x3
    80202784:	0016a517          	auipc	a0,0x16a
    80202788:	d0450513          	addi	a0,a0,-764 # 8036c488 <cpus>
    8020278c:	953e                	add	a0,a0,a5
    8020278e:	6422                	ld	s0,8(sp)
    80202790:	0141                	addi	sp,sp,16
    80202792:	8082                	ret
	...

0000000080203000 <_trampoline>:
    80203000:	14051573          	csrrw	a0,sscratch,a0
    80203004:	02153423          	sd	ra,40(a0)
    80203008:	02253823          	sd	sp,48(a0)
    8020300c:	02353c23          	sd	gp,56(a0)
    80203010:	04453023          	sd	tp,64(a0)
    80203014:	04553423          	sd	t0,72(a0)
    80203018:	04653823          	sd	t1,80(a0)
    8020301c:	04753c23          	sd	t2,88(a0)
    80203020:	f120                	sd	s0,96(a0)
    80203022:	f524                	sd	s1,104(a0)
    80203024:	fd2c                	sd	a1,120(a0)
    80203026:	e150                	sd	a2,128(a0)
    80203028:	e554                	sd	a3,136(a0)
    8020302a:	e958                	sd	a4,144(a0)
    8020302c:	ed5c                	sd	a5,152(a0)
    8020302e:	0b053023          	sd	a6,160(a0)
    80203032:	0b153423          	sd	a7,168(a0)
    80203036:	0b253823          	sd	s2,176(a0)
    8020303a:	0b353c23          	sd	s3,184(a0)
    8020303e:	0d453023          	sd	s4,192(a0)
    80203042:	0d553423          	sd	s5,200(a0)
    80203046:	0d653823          	sd	s6,208(a0)
    8020304a:	0d753c23          	sd	s7,216(a0)
    8020304e:	0f853023          	sd	s8,224(a0)
    80203052:	0f953423          	sd	s9,232(a0)
    80203056:	0fa53823          	sd	s10,240(a0)
    8020305a:	0fb53c23          	sd	s11,248(a0)
    8020305e:	11c53023          	sd	t3,256(a0)
    80203062:	11d53423          	sd	t4,264(a0)
    80203066:	11e53823          	sd	t5,272(a0)
    8020306a:	11f53c23          	sd	t6,280(a0)
    8020306e:	140022f3          	csrr	t0,sscratch
    80203072:	06553823          	sd	t0,112(a0)
    80203076:	00853103          	ld	sp,8(a0)
    8020307a:	02053203          	ld	tp,32(a0)
    8020307e:	01053283          	ld	t0,16(a0)
    80203082:	14102373          	csrr	t1,sepc
    80203086:	00653c23          	sd	t1,24(a0)
    8020308a:	00053303          	ld	t1,0(a0)
    8020308e:	18031073          	csrw	satp,t1
    80203092:	12000073          	sfence.vma
    80203096:	8282                	jr	t0

0000000080203098 <userReturn>:
    80203098:	18059073          	csrw	satp,a1
    8020309c:	12000073          	sfence.vma
    802030a0:	07053283          	ld	t0,112(a0)
    802030a4:	14029073          	csrw	sscratch,t0
    802030a8:	01853303          	ld	t1,24(a0)
    802030ac:	14131073          	csrw	sepc,t1
    802030b0:	02853083          	ld	ra,40(a0)
    802030b4:	03053103          	ld	sp,48(a0)
    802030b8:	03853183          	ld	gp,56(a0)
    802030bc:	04053203          	ld	tp,64(a0)
    802030c0:	04853283          	ld	t0,72(a0)
    802030c4:	05053303          	ld	t1,80(a0)
    802030c8:	05853383          	ld	t2,88(a0)
    802030cc:	7120                	ld	s0,96(a0)
    802030ce:	7524                	ld	s1,104(a0)
    802030d0:	7d2c                	ld	a1,120(a0)
    802030d2:	6150                	ld	a2,128(a0)
    802030d4:	6554                	ld	a3,136(a0)
    802030d6:	6958                	ld	a4,144(a0)
    802030d8:	6d5c                	ld	a5,152(a0)
    802030da:	0a053803          	ld	a6,160(a0)
    802030de:	0a853883          	ld	a7,168(a0)
    802030e2:	0b053903          	ld	s2,176(a0)
    802030e6:	0b853983          	ld	s3,184(a0)
    802030ea:	0c053a03          	ld	s4,192(a0)
    802030ee:	0c853a83          	ld	s5,200(a0)
    802030f2:	0d053b03          	ld	s6,208(a0)
    802030f6:	0d853b83          	ld	s7,216(a0)
    802030fa:	0e053c03          	ld	s8,224(a0)
    802030fe:	0e853c83          	ld	s9,232(a0)
    80203102:	0f053d03          	ld	s10,240(a0)
    80203106:	0f853d83          	ld	s11,248(a0)
    8020310a:	10053e03          	ld	t3,256(a0)
    8020310e:	10853e83          	ld	t4,264(a0)
    80203112:	11053f03          	ld	t5,272(a0)
    80203116:	11853f83          	ld	t6,280(a0)
    8020311a:	14051573          	csrrw	a0,sscratch,a0
    8020311e:	10200073          	sret

0000000080203122 <trapframe>:
	...
