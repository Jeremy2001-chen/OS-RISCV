# 信号机制与实现

## 信号机制

信号机制可以用于进程间通信或线程间通信。信号最多有 1024 种。除 SIGKILL 外，用户进程可以自定义这些信号的处理函数。定义的方式是通过系统调用，填入一个用户态函数的地址。如果用户进程没有定义过该信号的处理函数，默认的处理函数是直接忽略。每个线程都有自己的信号掩码。由于定义的处理函数是属于进程的，如果某个线程不想处理该信号，则可以设置信号掩码，可以屏蔽这种信号。被屏蔽的信号需要在屏蔽解除后响应。

在信号处理的过程中，也可能会接收到信号。这时需要信号处理的“重入”机制。在信号处理过程中，要屏蔽正在处理的信号。比如，在处理 SIG_CANCEL 信号时，不再响应 SIG_CANCEL 信号。不会发生同一种信号的“重入”。

在信号处理结束，处理函数能调用 `sig_return` 系统调用返回内核态。

## 具体实现

在我们的设计中，每个线程维护了一个待处理的信号栈。在线程从内核态返回用户态时，需要先看一下这个信号栈。如果栈中有需要处理的信号，则先执行信号处理。由于信号处理过程中可能会遇到各种情况，如系统调用、中断，还会有“重入”的问题，因此现场保护十分重要。

我们设计了一种叫做 `SignalContext`（信号上下文）的资源，用于保存**该信号处理结束后应当恢复的现场**。每次进入信号处理时，将当前的 `trapframe` 复制到该信号对应的 `SignalContext` 中。每次 `sig_return` 系统调用，将 `SignalContext` 中的现场复制到 `trapframe` 中。

这种方式的正确性，依赖于结束信号处理的系统调用只有两种可能，`exit` 和 `sig_return`。前者会直接让线程结束，也就不再需要任何现场了。
