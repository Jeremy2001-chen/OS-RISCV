# 全国大学生系统能力大赛内核实现赛道文档

## 基本情况

我们内核名称为 Too Low Too Simple Kernel，该内核是参考了 MOS、xv6 思路的基础上，重新设计的一个宏内核。该内核支持内存管理、进程和线程管理、中断和异常、Fat32 文件系统、Shell 界面，在决赛第一阶段期间增加了对动态链接、信号和信号量的支持。

## 整体架构

todo

## 相关技术文档

我们的内核有许多组成部分，各部分的设计思路详见下面的文档：

### 初赛阶段

* [内存管理](memory.md)
* [进程管理和线程管理](process.md)
* [异常和系统调用](trap.md)
* [SD 卡驱动](sd.md)
* [UART 驱动](uart.md)
* [文件系统介绍](fat-design.md)
* [文件系统实现](fat-impl.md)
* [文件系统相关系统调用](fat-syscall.md)
* [多核启动](multicore.md)
* [睡眠锁](sleeplock.md)
* [用户程序和 Shell](shell.md)
* [测试程序](test.md)

### 决赛第一阶段

* [动态链接](dynamic.md)
* [信号量](futex.md)
* [信号](signal.md)

## 各阶段分工

### 初赛阶段

陈纪源：SD 卡驱动、多核启动、虚拟文件系统
郭衍培：系统初始架构、虚拟文件系统
邹增禹：FAT32 文件系统、Shell 移植

### 决赛第一阶段

陈纪源：Futex、内核级线程、信号
郭衍培：Socket、信号
邹增禹：动态链接

## 遇到的问题及解决方法

### Sifive Unmatched 开发板 SD 卡驱动问题

四月中旬我们开始开发 Sifive Unmatched 的 SD 卡驱动，当时在 github 上找了一下是否有开源驱动，但是并没有找到一个完整的驱动，（仅有一个启动时的读 SD 卡驱动，没有写驱动）。最终我们决定在这个不完整的驱动上自主开发一个完整的读写驱动，通过搜集资料我们找到了 SPI 总线协议，按照时序图编写了比较简单的单块读的 `CMD17` 命令和单块写的 `CMD23` 命令。在 QEMU 上通过测试后，又在开发板上进行了测试，结果发现驱动非常不稳定，经常出现无法正常读写的情况。并且在评测的开发板上并不支持 `CMD23` 命令，因此我们又编写了多块读写的 `CMD24` 命令。为了解决驱动不稳定问题，我们给驱动增加了超时重读机制，如下所示：

```c
    if (!timeout) {
        goto retry;
    }
    ......
retry:
    writeTimes++;
    if (writeTimes > 10) {
	    panic("[SD Write]There must be some error in sd write");
    }
    sd_cmd_end();
    goto start;
```

当出现读写超时时，会跳转到 `retry` 标签，SPI 协议重新初始化，并跳转到 `start` 标签重新进行读写操作。同时我们设置了超时重读的阈值次数，当超过 10 次后就认为 SD 卡外设有严重问题，需要进行检查。这一方法有效增加了 SD 卡驱动的鲁棒性，提高了驱动的稳定性。在决赛第一阶段的评测时，我们也发现这一方法有效降低了因为驱动而出错的概率。

### QEMU 上通过文件系统测试后开发板上有误

五月上旬我们在 QEMU 上通过了 `ls` 指令输出开发板上文件的内容，但是在开发板上只能显示 `.` 和 `..`，相当于并没有正确读出 SD 卡中内容。后来发现是 QEMU 上实现的 SPI 协议有问题的，具体来说在进行磁盘块的读写前需要指定读写的块号，在 QEMU 上则要求传字节数，这个实现的差异导致同一份代码在两边的结果并不一样，因此最终我们将代码改为：

```c
    #ifdef QEMU
    if (sd_cmd(24 | 0x40, now * 512, 0) != 0) {
    #else
    if (sd_cmd(24 | 0x40, now, 0) != 0) {
    #endif			
```

通过 `QEMU` 这一个宏来区分两个的差异。